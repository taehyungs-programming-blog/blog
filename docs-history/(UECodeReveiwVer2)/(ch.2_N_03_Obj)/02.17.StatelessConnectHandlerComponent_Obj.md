---
layout: default
title: "[Obj] StatelessConnectHandlerComponent"
parent: "([Network] 03. UE Network Object)"
grand_parent: "(UnrealEngine Code-Review Ver.2)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* StatelessConnectHandlerComponentëŠ” UDP ì—°ê²°ì˜ ë³´ì•ˆì„ ê°•í™”í•˜ê¸° ìœ„í•œ í•¸ë“œì…°ì´í¬ í”„ë¡œí† ì½œì„ êµ¬í˜„í•˜ëŠ” ì»´í¬ë„ŒíŠ¸
* ì£¼ìš” ëª©ì 
    * IP ìŠ¤í‘¸í•‘ê³¼ ê°™ì€ DoS ê³µê²©ìœ¼ë¡œë¶€í„° ì„œë²„ë¥¼ ë³´í˜¸

```cpp
// ì„œë²„ëŠ” í•¸ë“œì…°ì´í¬ê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ì—°ê²° ìƒíƒœë¥¼ ì €ì¥í•˜ì§€ ì•ŠìŒ
void UpdateSecret()
{
    if (ActiveSecret == 255)  // ìµœì´ˆ ì´ˆê¸°í™”
    {
        HandshakeSecret[0].AddUninitialized(SECRET_BYTE_SIZE);
        HandshakeSecret[1].AddUninitialized(SECRET_BYTE_SIZE);
        ActiveSecret = 0;
    }
    else 
    {
        ActiveSecret = (uint8)!ActiveSecret;  // 0ê³¼ 1 ì‚¬ì´ í† ê¸€
    }
    
    // ìƒˆë¡œìš´ ì‹œí¬ë¦¿ ìƒì„±
    TArray<uint8>& CurArray = HandshakeSecret[ActiveSecret];
    for (int32 i=0; i<SECRET_BYTE_SIZE; i++)
    {
        CurArray[i] = FMath::Rand() % 255;
    }
}
```

```cpp
// í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸° ì—°ê²° íŒ¨í‚· ì „ì†¡
void SendInitialPacket(EHandshakeVersion HandshakeVersion)
{
    FBitWriter InitialPacket(AdjustedSize + (BaseRandomDataLengthBytes * 8) + 1);
    
    // ê¸°ë³¸ í•¸ë“œì…°ì´í¬ ì •ë³´ ì‘ì„±
    BeginHandshakePacket(InitialPacket, EHandshakePacketType::InitialPacket, 
                        HandshakeVersion, SentHandshakePacketCount, CachedClientID);
    
    // ë³´ì•ˆì„ ìœ„í•œ ì¶”ê°€ ë°ì´í„°
    uint8 SecretIdPad = 0;
    InitialPacket.WriteBit(SecretIdPad);
    
    // ì„œë²„ë¡œ ì „ì†¡
    SendToServer(HandshakeVersion, EHandshakePacketType::InitialPacket, InitialPacket);
}
```

---

## ì´ë¦„ì„ Statelessë¼ í•œ ì´ìœ ?

```cpp
class StatelessHandshake {
    TArray<uint8> ServerSecret;  // ì„œë²„ë§Œ ì•Œê³  ìˆëŠ” ë¹„ë°€í‚¤
    
    FCookie GenerateCookie(const FString& ClientIP) {
        // í´ë¼ì´ì–¸íŠ¸ë³„ ìƒíƒœë¥¼ ì €ì¥í•˜ì§€ ì•Šê³  ì¿ í‚¤ë¡œ ì•”í˜¸í™”
        return HMAC(ServerSecret, ClientIP);  // ğŸ‘ˆ ë©”ëª¨ë¦¬ ì‚¬ìš© ì—†ìŒ
    }
    
    bool ValidateCookie(const FCookie& Cookie, const FString& ClientIP) {
        // ì¿ í‚¤ ê²€ì¦ë„ ìƒíƒœ ì €ì¥ ì—†ì´ ìˆ˜í–‰
        return Cookie == HMAC(ServerSecret, ClientIP);  // ğŸ‘ˆ ì €ì¥ëœ ìƒíƒœ í•„ìš” ì—†ìŒ
    }
};
```