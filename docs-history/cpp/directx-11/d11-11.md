---
layout: default
title: "11. êµ¬ ê·¸ë¦¬ê¸°"
parent: "(DirectX 11 ğŸŒŸ)"
grand_parent: C++
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ì¼ë°˜ì  ë°©ë²•

* [Clone Code ğŸŒ](https://github.com/EasyCoding-7/DirectX11-Examples/tree/12/12_sphere)

```cpp
MeshData GeometryGenerator::MakeSphere(const float radius, const int numSlices,
                                       const int numStacks) {

    // ì°¸ê³ : OpenGL Sphere
    // http://www.songho.ca/opengl/gl_sphere.html
    // Texture ì¢Œí‘œê³„ë•Œë¬¸ì— (numSlices + 1) ê°œì˜ ë²„í…ìŠ¤ ì‚¬ìš© (ë§ˆì§€ë§‰ì— ë‹«ì•„ì£¼ëŠ”
    // ë²„í…ìŠ¤ê°€ ì¤‘ë³µ) Stackì€ y ìœ„ìª½ ë°©í–¥ìœ¼ë¡œ ìŒ“ì•„ê°€ëŠ” ë°©ì‹

    const float dTheta = -XM_2PI / float(numSlices);
    const float dPhi = -XM_PI / float(numStacks);

    MeshData meshData;

    vector<Vertex> &vertices = meshData.vertices;

    for (int j = 0; j <= numStacks; j++) {

        // ìŠ¤íƒì— ìŒ“ì¼ ìˆ˜ë¡ ì‹œì‘ì ì„ x-y í‰ë©´ì—ì„œ íšŒì „ ì‹œì¼œì„œ ìœ„ë¡œ ì˜¬ë¦¬ëŠ” êµ¬ì¡°
        //Vector3 stackStartPoint = Vector3(
        //    radius, -radius + 2.0f * radius / numStacks * j, 0.0f); // ì‹¤ë¦°ë”
        Vector3 stackStartPoint = Vector3::Transform(
            Vector3(0.0f, -radius, 0.0f), Matrix::CreateRotationZ(dPhi * j));

        for (int i = 0; i <= numSlices; i++) {
            Vertex v;

            // ì‹œì‘ì ì„ x-z í‰ë©´ì—ì„œ íšŒì „ì‹œí‚¤ë©´ì„œ ì›ì„ ë§Œë“œëŠ” êµ¬ì¡°
            v.position = Vector3::Transform(
                stackStartPoint, Matrix::CreateRotationY(dTheta * float(i)));

            v.normal = v.position; // ì›ì ì´ êµ¬ì˜ ì¤‘ì‹¬
            v.normal.Normalize();
            v.texcoord =
                Vector2(float(i) / numSlices, 1.0f - float(j) / numStacks);

            vertices.push_back(v);
        }
    }

    // cout << vertices.size() << endl;

    vector<uint16_t> &indices = meshData.indices;

    for (int j = 0; j < numStacks; j++) {

        const int offset = (numSlices + 1) * j;

        for (int i = 0; i < numSlices; i++) {

            indices.push_back(offset + i);
            indices.push_back(offset + i + numSlices + 1);
            indices.push_back(offset + i + 1 + numSlices + 1);

            indices.push_back(offset + i);
            indices.push_back(offset + i + 1 + numSlices + 1);
            indices.push_back(offset + i + 1);
        }
    }

    // cout << indices.size() << endl;
    // for (int i = 0; i < indices.size(); i++) {
    //     cout << indices[i] << " ";
    // }
    // cout << endl;

    return meshData;
}
```

---

## ë‹¤ë¥¸ ë°©ë²• (Subdivision)

* [Clone Code ğŸŒ](https://github.com/EasyCoding-7/DirectX11-Examples/tree/13/13_subdivision)

* ë§ ê·¸ëŒ€ë¡œ divisionì„ ë†’ì´ëŠ” ë°©ë²•ì´ë‹¤.
* Vertexì˜ ìƒì„¸ë„ê°€ ë‚®ì„ê²½ìš° ì‚¬ìš©í•˜ë©´ ì¢‹ë‹¤.

```cpp
MeshData GeometryGenerator::SubdivideToSphere(const float radius,
                                              MeshData meshData) {

    using namespace DirectX;
    using DirectX::SimpleMath::Matrix;
    using DirectX::SimpleMath::Vector3;

    // ì›ì ì´ ì¤‘ì‹¬ì´ë¼ê³  ê°€ì •
    // ì…ë ¥ ë°›ì€ êµ¬ ëª¨ë¸ì˜ ë°˜ì§€ë¦„ ì¡°ì ˆ
    for (auto &v : meshData.vertices) {
        v.position = v.normal * radius;
    }

    // êµ¬ì˜ í‘œë©´ìœ¼ë¡œ ì˜®ê¸°ê³  ë…¸ë©€ ê³„ì‚°
    auto ProjectVertex = [&](Vertex &v) {
        v.normal = v.position;
        v.normal.Normalize();
        v.position = v.normal * radius;

        // ì£¼ì˜: í…ìŠ¤ì¶°ê°€ ì´ìŒë§¤ì—ì„œ ê¹¨ì§‘ë‹ˆë‹¤.
        // atan vs atan2
        // https://stackoverflow.com/questions/283406/what-is-the-difference-between-atan-and-atan2-in-c
        // const float theta = atan2f(v.position.z, v.position.x);
        // const float phi = acosf(v.position.y / radius);
        // v.texcoord.x = theta / XM_2PI;
        // v.texcoord.y = phi / XM_PI;
    };

    // ë²„í…ìŠ¤ê°€ ì¤‘ë³µë˜ëŠ” êµ¬ì¡°ë¡œ êµ¬í˜„
    MeshData newMesh;
    uint16_t count = 0;
    for (size_t i = 0; i < meshData.indices.size(); i += 3) {
        size_t i0 = meshData.indices[i];
        size_t i1 = meshData.indices[i + 1];
        size_t i2 = meshData.indices[i + 2];

        Vertex v0 = meshData.vertices[i0];
        Vertex v1 = meshData.vertices[i1];
        Vertex v2 = meshData.vertices[i2];

        Vertex v3;
        // ìœ„ì¹˜ì™€ í…ìŠ¤ì¶° ì¢Œí‘œ ê²°ì •
        v3.position = (v0.position + v2.position) * 0.5f;
        v3.texcoord = (v0.texcoord + v2.texcoord) * 0.5f;

        Vertex v4;
        // ìœ„ì¹˜ì™€ í…ìŠ¤ì¶° ì¢Œí‘œ ê²°ì •
        v4.position = (v0.position + v1.position) * 0.5f;
        v4.texcoord = (v0.texcoord + v1.texcoord) * 0.5f;

        Vertex v5;
        // ìœ„ì¹˜ì™€ í…ìŠ¤ì¶° ì¢Œí‘œ ê²°ì •
        v5.position = (v1.position + v2.position) * 0.5f;
        v5.texcoord = (v1.texcoord + v2.texcoord) * 0.5f;

        ProjectVertex(v3);
        ProjectVertex(v4);
        ProjectVertex(v5);

        // ëª¨ë“  ë²„í…ìŠ¤ ìƒˆë¡œ ì¶”ê°€
        newMesh.vertices.push_back(v4);
        newMesh.vertices.push_back(v1);
        newMesh.vertices.push_back(v5);

        newMesh.vertices.push_back(v0);
        newMesh.vertices.push_back(v4);
        newMesh.vertices.push_back(v3);

        newMesh.vertices.push_back(v3);
        newMesh.vertices.push_back(v4);
        newMesh.vertices.push_back(v5);

        newMesh.vertices.push_back(v3);
        newMesh.vertices.push_back(v5);
        newMesh.vertices.push_back(v2);

        // ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
         for (uint16_t j = 0; j < 12; j++) {
             newMesh.indices.push_back(j + count);
         }
         count += 12;
    }

    return newMesh;
}
} // namespace hlab

```