---
layout: default
title: "18. Image Filter(Bloom Filter)"
parent: "(DirectX 11 ğŸŒŸ)"
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Clone Code ğŸŒ](https://github.com/EasyCoding-7/DirectX11-Examples/tree/20/20_bloomFilter)

## Filterë§Œë“¤ê¸° ì „ ì£¼ì˜ì‚¬í•­

```cpp
void Initialize(ComPtr<ID3D11Device> &device,
                ComPtr<ID3D11DeviceContext> &context,
                const wstring vertexPrefix, const wstring pixelPrefix,
                int width, int height) {

    // ...

    // Initializeì‹œì— ìì‹ ì´ ì›í•˜ëŠ” Shaderë¥¼ ì„ íƒí•œë‹¤.
    D3D11Utils::CreateVertexShaderAndInputLayout(
        device, vertexPrefix + L"VertexShader.hlsl", basicInputElements,
        m_vertexShader, m_inputLayout);

    D3D11Utils::CreatePixelShader(device, pixelPrefix + L"PixelShader.hlsl",
                                    m_pixelShader);

    // Texture sampler
    D3D11_SAMPLER_DESC sampDesc;
    ZeroMemory(&sampDesc, sizeof(sampDesc));
    sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;

    // Samplerì˜ ê²½ìš° WRAPì´ ì•„ë‹ˆë¼ CRAMPë¥¼ ì‚¬ìš©í•˜ëŠ”ë° ì£¼ì˜
    sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
    sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
    sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
    sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;
    sampDesc.MinLOD = 0;
    sampDesc.MaxLOD = D3D11_FLOAT32_MAX;

    // Create the Sample State
    device->CreateSamplerState(&sampDesc, m_samplerState.GetAddressOf());


    // Create a rasterizer state
    D3D11_RASTERIZER_DESC rastDesc;
    ZeroMemory(&rastDesc, sizeof(D3D11_RASTERIZER_DESC)); // Need this
    rastDesc.FillMode = D3D11_FILL_MODE::D3D11_FILL_SOLID;
    rastDesc.CullMode = D3D11_CULL_MODE::D3D11_CULL_NONE;
    rastDesc.FrontCounterClockwise = false;
    
    // ì´ë¯¸ì§€ í›„ ì²˜ë¦¬ê¸°ì— Depth Bufferë˜í•œ í•„ìš”ì—†ê¸°ì— Enableì„ ëˆë‹¤
    rastDesc.DepthClipEnable = false;

    device->CreateRasterizerState(&rastDesc,
                                m_rasterizerSate.GetAddressOf());

    // Set the viewport
    // ê²½ìš°ì— ë”°ë¼ Viewportë¥¼ ë³€ê²½í•´ ê°€ë©° Filterë¥¼ ê±¸ìˆ˜ ìˆê¸°ì— Viewportë„ ë³„ë„ë¡œ ì§€ì •í•œë‹¤
    ZeroMemory(&m_viewport, sizeof(D3D11_VIEWPORT));
    m_viewport.TopLeftX = 0;
    m_viewport.TopLeftY = 0;
    m_viewport.Width = float(width);
    m_viewport.Height = float(height);
    m_viewport.MinDepth = 0.0f;
    m_viewport.MaxDepth = 1.0f;


    // ì´ë¯¸ì§€ ì²˜ë¦¬ìš© textureë¥¼ ìƒˆë¡œ ìƒì„±í•œë‹¤
    ComPtr<ID3D11Texture2D> texture;

    D3D11_TEXTURE2D_DESC txtDesc;
    ZeroMemory(&txtDesc, sizeof(txtDesc));
    txtDesc.Width = width;
    txtDesc.Height = height;
    txtDesc.MipLevels = txtDesc.ArraySize = 1;

    //  ì´ë¯¸ì§€ ì²˜ë¦¬ìš©ë„, ì¼ë°˜ì  Formatë³´ë‹¤ ì‚¬ì´ì¦ˆê°€ í›¨ì”¬í¬ë‹¤
    txtDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT; 
    txtDesc.SampleDesc.Count = 1;
    txtDesc.Usage = D3D11_USAGE_DEFAULT;

    // ì´ë¯¸ì§€ ì²˜ë¦¬ìš© TextureëŠ” ì½ì–´ì˜¤ê³  ì“°ê³  ëª¨ë‘ê°€ ê°€ëŠ¥í•´ì•¼í•¨
        // D3D11_BIND_SHADER_RESOURCE - ì½ì–´ì˜¬ìˆ˜ ìˆë‹¤
        // D3D11_BIND_RENDER_TARGET - ì“¸ìˆ˜ ìˆë‹¤
        // D3D11_BIND_UNORDERED_ACCESS - ì—°ì‚°ë„ ê°€ëŠ¥
    txtDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE |
                        D3D11_BIND_RENDER_TARGET |
                        D3D11_BIND_UNORDERED_ACCESS;

    // ...

    // Textureë¥¼ ë§Œë“¤ê³ 
    device->CreateTexture2D(&txtDesc, NULL, texture.GetAddressOf());

    // ê·¸ë ¤ì§ˆ Textureë¡œ ì„ ì •
    device->CreateRenderTargetView(texture.Get(), &viewDesc,
                                m_renderTargetView.GetAddressOf());

    // ê·¸ë¦´ Textureë¡œ ì„ ì •(ì˜ë³´ë©´ ê·¸ë ¤ì§ˆ, ê·¸ë¦´ textureëŠ” ëª¨ë‘ ë™ì¼í•¨)
    device->CreateShaderResourceView(texture.Get(), nullptr,
                                    m_shaderResourceView.GetAddressOf());
```

ì‚¬ì§„

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx11/d11-18-1.jpg"/>
</p>

```cpp
void Render(ComPtr<ID3D11DeviceContext> &context) {

        assert(m_shaderResources.size() > 0);
        assert(m_renderTargets.size() > 0);

        // ì–´ë””ì— ë Œë”ë§ í• ì§€ë¥¼ ì§€ì •
        context->OMSetRenderTargets(UINT(m_renderTargets.size()),
                                    m_renderTargets.data(), nullptr);
        //float clearColor[4] = {0.0f, 0.0f, 0.0f, 1.0f};
        //context->ClearRenderTargetView(m_renderTargetView.Get(), clearColor);
        context->RSSetState(m_rasterizerSate.Get());
        context->RSSetViewports(1, &m_viewport);

        UINT stride = sizeof(Vertex);
        UINT offset = 0;

        context->IASetInputLayout(m_inputLayout.Get());
        context->IASetVertexBuffers(0, 1, m_mesh->vertexBuffer.GetAddressOf(),
                                    &stride, &offset);
        context->IASetIndexBuffer(m_mesh->indexBuffer.Get(),
                                  DXGI_FORMAT_R32_UINT, 0);
        context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
        context->VSSetShader(m_vertexShader.Get(), 0, 0);
        context->PSSetShader(m_pixelShader.Get(), 0, 0);
        context->PSSetShaderResources(0, UINT(m_shaderResources.size()),
                                      m_shaderResources.data());
        context->PSSetConstantBuffers(
            0, 1, m_mesh->pixelConstantBuffer.GetAddressOf());
        context->PSSetSamplers(0, 1, m_samplerState.GetAddressOf());
        context->DrawIndexed(m_mesh->m_indexCount, 0, 0);
    }
```

```cpp
bool AppBase::InitDirect3D() {

    // ...

    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferDesc.Width = m_screenWidth;   // set the back buffer width
    sd.BufferDesc.Height = m_screenHeight; // set the back buffer height
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // use 32-bit color
    sd.BufferCount = 2;                                // Double-buffering
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;

    // Swap Chain ë§Œë“¤ì‹œ BackBufferë¥¼ ë‹¤ì‹œ ì…ë ¥ìœ¼ë¡œ ë„£ì–´ì„œ Filterë¥¼ ê±¸ì–´ì¤˜ì•¼í•¨.
        // DXGI_USAGE_SHADER_INPUT ì‰ì´ë”ì— ì…ë ¥ìœ¼ë¡œ ë„£ì–´ì£¼ê¸° ìœ„í•´ í•„ìš”
    sd.BufferUsage = DXGI_USAGE_SHADER_INPUT | DXGI_USAGE_RENDER_TARGET_OUTPUT;
```

```cpp
bool AppBase::CreateRenderTargetView() {

    ComPtr<ID3D11Texture2D> backBuffer;
    m_swapChain->GetBuffer(0, IID_PPV_ARGS(backBuffer.GetAddressOf()));
    if (backBuffer) {

        // ê¸°ì¡´ì—ëŠ” RenderTargetë§Œ ë§Œë“œëŠ”ë°
        m_device->CreateRenderTargetView(backBuffer.Get(), nullptr,
                                         m_renderTargetView.GetAddressOf());

        // m_device->CreateShaderResourceView(backBuffer.Get(), nullptr,
        // m_shaderResourceView.GetAddressOf());

        D3D11_TEXTURE2D_DESC desc;
        backBuffer->GetDesc(&desc);
        // ë””ë²„ê¹…ìš©
        // cout << desc.Width << " " << desc.Height << " " << desc.Format <<
        // endl;
        desc.SampleDesc.Count = 1;
        desc.SampleDesc.Quality = 0;
        desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        desc.MiscFlags = 0;

        if (FAILED(m_device->CreateTexture2D(&desc, nullptr,
                                             m_tempTexture.GetAddressOf()))) {
            cout << "Failed()" << endl;
        }

        // ì´ì   Back Bufferë¥¼ ë‹¤ì‹œ ì¨ì•¼í•˜ê¸°ì— ShaderResourceViewê¹Œì§€ ë‹¤ì‹œ ë§Œë“¦
            // ShaderResourceë¥¼ (backBufferê°€ ì•„ë‹ˆë¼) tempTextureë¡œë¶€í„° ìƒì„±
        m_device->CreateShaderResourceView(m_tempTexture.Get(), nullptr,
                                           m_shaderResourceView.GetAddressOf());
    } else {
        std::cout << "CreateRenderTargetView() failed." << std::endl;
        return false;
    }

    return true;
}
```

---

## ì´ì œ Filterë¥¼ ë§Œë“¤ì–´ë³´ì

### ìì‹ ì„ ë³µì‚¬í•˜ëŠ” Filter

```cpp
void ExampleApp::BuildFilters() {

    m_filters.clear();

    // ìê¸°ìì‹ ì„ ë³µì‚¬í•œëŠ” Filter
    auto copyFilter =
    make_shared<ImageFilter>(m_device, m_context, L"Sampling", L"Sampling",
                                m_screenWidth, m_screenHeight);
    copyFilter->SetShaderResources({m_shaderResourceView});
    m_filters.push_back(copyFilter);

    // ì´ëŸ°ì‹ìœ¼ë¡œ Filterë¥¼ í•˜ë‚˜ë” ê±°ì¹˜ê²Œ í•  ìˆ˜ ìˆìŒ
    auto finalFilter =
        make_shared<ImageFilter>(m_device, m_context, L"Sampling", L"Sampling",
                                 m_screenWidth, m_screenHeight);
    finalFilter->SetShaderResources({m_filters.back()->m_shaderResourceView});

    // ë§ˆì§€ë§‰ì€ í™”ë©´ì˜ renderTargetì— ê·¸ë ¤ë‹¬ë¼
    finalFilter->SetRenderTargets({this->m_renderTargetView});
    m_filters.push_back(finalFilter);
}
```

```cpp
// Sampling Pixel Shader

float4 main(SamplingPixelShaderInput input) : SV_TARGET
{
    // bloom effect
    float3 color = g_texture0.Sample(g_sampler, input.texcoord).rgb;
    float l = (color.x + color.y + color.y) / 3;
    
    if (l > threshold)
    {
        return float4(color, 1.0f);
    }
    else
    {
        return float4(0.0f, 0.0f, 0.0f, 0.0f);
    }
}
```

```cpp
// Sampling Vertex Shader

SamplingPixelShaderInput main(SamplingVertexShaderInput input)
{
    SamplingPixelShaderInput output;
    
    output.position = float4(input.position, 1.0);
    output.texcoord = input.texcoord;

    return output;
}

```

---

### Bloom Filter ë„£ê¸°

```cpp
void ExampleApp::BuildFilters() {

    m_filters.clear();

    // í™”ë©´ì„ í•œ ë²ˆ ë³µì‚¬í•œë‹¤
    auto copyFilter =
        make_shared<ImageFilter>(m_device, m_context, L"Sampling", L"Sampling",
                                 m_screenWidth, m_screenHeight);
    copyFilter->SetShaderResources({m_shaderResourceView});
    m_filters.push_back(copyFilter);

    // down sampling í•œë‹¤(í•´ìƒë„ë¥¼ ì¤„ì¸ì¸ë‹¤)
    auto downFilter = make_shared<ImageFilter>(
        m_device, m_context, L"Sampling", L"Sampling", m_screenWidth / m_down,
        m_screenHeight / m_down);
    downFilter->SetShaderResources({m_shaderResourceView});
    downFilter->m_pixelConstData.threshold = m_threshold;
    downFilter->UpdateConstantBuffers(m_device, m_context);
    m_filters.push_back(downFilter);

    for (int i = 0; i < m_repeat; i++) {
        // x, y gaussian effectì„ ë„£ëŠ”ë‹¤
        auto &prevResource = m_filters.back()->m_shaderResourceView;
        m_filters.push_back(make_shared<ImageFilter>(
            m_device, m_context, L"Sampling", L"BlurX", m_screenWidth / m_down,
            m_screenHeight / m_down));
        m_filters.back()->SetShaderResources({prevResource});

        auto &prevResource2 = m_filters.back()->m_shaderResourceView;
        m_filters.push_back(make_shared<ImageFilter>(
            m_device, m_context, L"Sampling", L"BlurY", m_screenWidth / m_down,
            m_screenHeight / m_down));
        m_filters.back()->SetShaderResources({prevResource2});
    }

    // ë‹¤ì‹œ í•´ìƒë„ë¥¼ ëŒë¦°ë‹¤(Up Sampling)
    auto upFilter =
        make_shared<ImageFilter>(m_device, m_context, L"Sampling", L"Sampling",
                                 m_screenWidth, m_screenHeight);
    upFilter->SetShaderResources({m_filters.back()->m_shaderResourceView});
    m_filters.push_back(upFilter);

    auto combineFilter =
        make_shared<ImageFilter>(m_device, m_context, L"Sampling", L"Combine",
                                 m_screenWidth, m_screenHeight);
    combineFilter->SetShaderResources({copyFilter->m_shaderResourceView,
                                       m_filters.back()->m_shaderResourceView});
    combineFilter->SetRenderTargets(
        {this->m_renderTargetView}); // ë Œë”íƒ€ê²Ÿ êµì²´
    combineFilter->m_pixelConstData.strength = m_strength;
    combineFilter->UpdateConstantBuffers(m_device, m_context);
    m_filters.push_back(combineFilter);
}
```