---
layout: default
title: "10. Material"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/10)


## ì§€ë‚œê°•ì˜ ë²„ê·¸ìˆ˜ì •

ğŸ˜º ìƒê°ë³´ë‹¤ í”„ë ˆì„ì´ ì•ˆë‚˜ì˜¤ëŠ”ë° ì•„ë˜ì˜ ë¬¸ì œë•Œë¬¸ì´ë‹¤.

```cpp
void Input::Update()
{
	// ...

	for (uint32 key = 0; key < KEY_TYPE_COUNT; key++)
	{
		// í”„ë ˆì„ë§ˆë‹¤ GetAsyncKeyStateë¥¼ í˜¸ì¶œí•˜ëŠ”ê²ƒì´ ë¶€ë‹´ì´ë‹¤.
		if (::GetAsyncKeyState(key) & 0x8000)
		{
			//...
```

```cpp
void Input::Update()
{
	// ...

    // keyì˜ ìƒíƒœë¥¼ ë°°ì—´ë¡œ í•œ ë²ˆì— ë°›ì•„ì™€ ì¤€ë‹¤
	BYTE asciiKeys[KEY_TYPE_COUNT] = {};
	if (::GetKeyboardState(asciiKeys) == false)
		return;

    for (uint32 key = 0; key < KEY_TYPE_COUNT; key++)
	{
		if (asciiKeys[key] & 0x80)
		{
            // ...
```

---

## Material í´ë˜ìŠ¤

ğŸ˜¾ Materialì´ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ Mesh, Shader, Textureë¥¼ ê´€ë¦¬í•´ë³´ì

ğŸ˜¾ ì™œ Materialì´ë¼ëŠ” í´ë˜ìŠ¤ê°€ í•„ìš”í•œì§€ ì´í•´ê°€ ì•ˆë ìˆ˜ ìˆëŠ”ë°

```cpp
void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);

	vector<Vertex> vec(4);
	vec[0].pos = Vec3(-0.5f, 0.5f, 0.5f);
	vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);
	vec[0].uv = Vec2(0.f, 0.f);
	// ...

    // (ë¬¸ì œ.1) Initì—ì„œ mesh, shader, textureë¥¼ ìƒì„±
        // ê·¸ëŸ°ë° ì–´ì°¨í”¼ ê°™ì´ ì“°ì¼êº¼ í•˜ë‚˜ë¡œ ë¬¶ì„ìˆœ ì—†ë‚˜?
	mesh->Init(vec, indexVec);
	shader->Init(L"..\\Resources\\Shader\\default.hlsli");
	texture->Init(L"..\\Resources\\Texture\\veigar.jpg");

	GEngine->GetCmdQueue()->WaitSync();
}
```

```cpp
void Game::Update()
{
	GEngine->Update();

	GEngine->RenderBegin();

	shader->Update();

	// ...

		mesh->SetTransform(t);

        // (ë¬¸ì œ.2) 1ê³¼ ë¹„ìŠ·í•œ ë¬¸ì œì¸ë° shader, mesh, textureê°€ ê°™ì´
            // Renderë˜ëŠ”ë° shader->update, mesh->Render ë‘ ê°€ì§€
            // ë°©ë²•ìœ¼ë¡œ Rendering ë˜ê³  ìˆìŒ -> í•˜ë‚˜ë¡œ ë¬¶ì
		mesh->SetTexture(texture);
		mesh->Render();
	}
```

* ê²°êµ­ ì´ë ‡ê²Œ ì“°ê³ ì‹¶ì€ ê²ƒì´ë‹¤.

```cpp
shared_ptr<Material> material = make_shared<Material>();
// ì‰ì´ë”ë¥¼ ì§€ì •í•˜ê³ 
material->SetShader(shader);
// í•„ìš”í•œ íŒŒë¼ë¯¸í„°ë¥¼ ë„˜ê²¨ì„œ
material->SetFloat(0, 0.3f);
material->SetFloat(1, 0.4f);
material->SetFloat(2, 0.3f);
// í…ìŠ¤ì³ ì§€ì •í•´
material->SetTexture(0, texture);

// ë©”ì‰¬ë³„ë¡œ materialì„ ì§€ì •í•˜ë ¤í•œë‹¤.
mesh->SetMaterial(material);
// ë©”ì‰¬ë§Œ ë‹¬ë¼ì§€ë©´ ëª¨ì–‘ì— ë”°ë¼ ì§€ì •ëœ material(ìƒ‰ìƒ, ë¹›ë°˜ì‚¬ë“±ë“±ì´ ì„¤ì •ëœ)ì´ ë‚˜íƒ€ë‚˜ê²Œ ëœë‹¤.
```

* ì•„ì§ì€ Material Paramì— ë­˜ ë„£ì„ì§„ ê²°ì •ì€ ì•ˆë¨.
* ë„£ì„ìˆ˜ ìˆë‹¤ ì •ë„ì„.

---

<br>

ğŸ˜º `Material`í´ë˜ìŠ¤ì— í†µí•©í•´ í•´ê²°ì˜ˆì • ë§Œë“¤ì–´ ë³´ì!

```cpp
#pragma once

class Shader;
class Texture;

enum
{
	MATERIAL_INT_COUNT = 5,			// int 5ê°œ
	MATERIAL_FLOAT_COUNT = 5,		// float 5ê°œ
	MATERIAL_TEXTURE_COUNT = 5,		// texture 5ê°œ ë¥¼ ì“¸ê²ƒì´ë‹¤.
};

struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;

    // (ì°¸ê³  : array)
        // int32 intParams[MATERIAL_INT_COUNT];
        // arrayëŠ” vectorì²˜ëŸ¼ ê¸¸ì´ë¥¼ ëŠ˜ë¦´ìˆ˜ ìˆëŠ”ê²ƒë„ ì•„ë‹ˆê³ 
        // int32 [] ì´ê±°ë‘ ë¬´ìŠ¨ ì°¨ì´ì¸ê°€??
        // -> ë²”ìœ„ ì²´í¬ê°€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.(ì€ê·¼ ìœ ìš©í•¨)
        // intParams[index] = value; ì´ê±¸í• ë•Œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ Crash!!
};

class Material
{
public:
	shared_ptr<Shader> GetShader() { return _shader; }

	void SetShader(shared_ptr<Shader> shader) { _shader = shader; }
	void SetInt(uint8 index, int32 value) { _params.SetInt(index, value); }
	void SetFloat(uint8 index, float value) { _params.SetFloat(index, value); }
	void SetTexture(uint8 index, shared_ptr<Texture> texture) { _textures[index] = texture; }

	void Update();

private:
	shared_ptr<Shader>	_shader;
	MaterialParams		_params;
	array<shared_ptr<Texture>, MATERIAL_TEXTURE_COUNT> _textures;
};
```

```cpp
void Material::Update()
{
	// CBV ì—…ë¡œë“œ
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));

	// SRV ì—…ë¡œë“œ
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetTableDescHeap()->SetSRV(_textures[i]->GetCpuHandle(), reg);
	}

	// íŒŒì´í”„ë¼ì¸ ì„¸íŒ…
	_shader->Update();
}
```

ğŸ˜º ì‹¤ì‚¬ìš©ì€ ì´ë ‡ê²Œ í•  ì˜ˆì •

```cpp
void Game::Init(const WindowInfo& info)
{
	// ...

	mesh->Init(vec, indexVec);

	shared_ptr<Shader> shader = make_shared<Shader>();
	shared_ptr<Texture> texture = make_shared<Texture>();
	shader->Init(L"..\\Resources\\Shader\\default.hlsli");
	texture->Init(L"..\\Resources\\Texture\\veigar.jpg");

	shared_ptr<Material> material = make_shared<Material>();
	material->SetShader(shader);
	material->SetFloat(0, 0.3f);
	material->SetFloat(1, 0.4f);
	material->SetFloat(2, 0.3f);
	material->SetTexture(0, texture);
	mesh->SetMaterial(material);

	GEngine->GetCmdQueue()->WaitSync();
}
```

ğŸ˜º ì•„ë˜ì—ì„œ SetFloat, SetTextureë¥¼ ë”°ë¼ê°€ë©´ì„œ ì„¤ëª…í•˜ê² ë‹¤.

<br>

---

## ConstantBuffer

ğŸ˜º ConstantBuffer ì—­ì‹œ Materialë‹¨ìœ„ë¡œ ë°ì´í„°ë¥¼ ë„˜ê²¨ì£¼ê³  ì‹¶ë‹¤

```
cbuffer TEST_B0 : register(b0)
{
    // ìœ„ì¹˜(Transform)ì •ë³´
    float4 offset0;
};

cbuffer MATERIAL_PARAMS : register(b1)
{
	// Materialì •ë³´ë¥¼ ì—¬ê¸° ë‹´ê² ë‹¤
    int int_0;
    int int_1;
    int int_2;
    int int_3;
    int int_4;
    float float_0;
    float float_1;
    float float_2;
    float float_3;
    float float_4;
};

// Textureë„ 5ê°œ
Texture2D tex_0 : register(t0);
Texture2D tex_1 : register(t1);
Texture2D tex_2 : register(t2);
Texture2D tex_3 : register(t3);
Texture2D tex_4 : register(t4);
```

<br>

ğŸ˜º ConstantBufferë‚´ë¶€ë„ ìˆ˜ì •ì´ í•„ìš”í•´ì§„ë‹¤.

```cpp
enum class CONSTANT_BUFFER_TYPE : uint8
{
	TRANSFORM,		// Transform ìš©ë„ì¸ê°€
	MATERIAL,		// Material ìš©ë„ì¸ê°€
	END
};

enum
{
	CONSTANT_BUFFER_COUNT = static_cast<uint8>(CONSTANT_BUFFER_TYPE::END)
};

class ConstantBuffer
{
public:
	ConstantBuffer();
	~ConstantBuffer();

    // ì´ì œ Initì‹œì— ì–´ë–¤ ë ˆì§€ìŠ¤í„°ë¥¼ ì‚¬ìš©í•  ê²ƒì¸ì§€ ë„˜ê²¨ì•¼í•œë‹¤.
        // Transform(b0), Material(b1)ì— ë”°ë¼ ì‚¬ìš©í•˜ëŠ” ë ˆì§€ìŠ¤í„°ê°€ ë‹¬ë¼ì¡Œë‹¤
	void Init(CBV_REGISTER reg, uint32 size, uint32 count);

	void Clear();
	void PushData(void* buffer, uint32 size);

	D3D12_GPU_VIRTUAL_ADDRESS GetGpuVirtualAddress(uint32 index);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle(uint32 index);

private:
	void CreateBuffer();
	void CreateView();

private:
	ComPtr<ID3D12Resource>	_cbvBuffer;
	BYTE*					_mappedBuffer = nullptr;
	uint32					_elementSize = 0;
	uint32					_elementCount = 0;

	ComPtr<ID3D12DescriptorHeap>		_cbvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE			_cpuHandleBegin = {};
	uint32								_handleIncrementSize = 0;

	uint32					_currentIndex = 0;

	CBV_REGISTER			_reg = {};
};
```

<Br>

ğŸ˜º ë²„í¼ìƒì„±

```cpp
void ConstantBuffer::PushData(void* buffer, uint32 size)
{
	assert(_currentIndex < _elementCount);
	assert(_elementSize == ((size + 255) & ~255));

    // BYTE*	_mappedBuffer = nullptr;
	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

    // mappedëœ ë©”ëª¨ë¦¬ì— ìˆëŠ” ë°ì´í„°ë¥¼ ì˜¬ë ¤ë‹¬ë¼(ì•„ë˜ì°¸ê³ )
	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
	GEngine->GetTableDescHeap()->SetCBV(cpuHandle, _reg);

	_currentIndex++;
}
```

---

### ì ì‹œë³µìŠµ1 (ConstantBuffer)

```cpp
void Engine::Init(const WindowInfo& info)
{
	// ...

    // Engineì´ Initë˜ë©° ConstantBufferë„ ìƒì„±ì´ ëœë‹¤.
	CreateConstantBuffer(CBV_REGISTER::b0, sizeof(Transform), 256);
	CreateConstantBuffer(CBV_REGISTER::b1, sizeof(MaterialParams), 256);
```

```cpp
void Engine::CreateConstantBuffer(CBV_REGISTER reg, uint32 bufferSize, uint32 count)
{
	uint8 typeInt = static_cast<uint8>(reg);
	assert(_constantBuffers.size() == typeInt);

	shared_ptr<ConstantBuffer> buffer = make_shared<ConstantBuffer>();
	buffer->Init(reg, bufferSize, count);
	_constantBuffers.push_back(buffer);
}
```

```cpp
class Engine
{
    // ...

    // ìƒì„±ëœ ConstantBufferì˜ í˜¸ì¶œì€ GetConstantBufferì„ í†µí•´ í•œë‹¤
        // ì¢€ ë” ì •í™•íˆëŠ” ë©”í¬ë¡œë¥¼ í†µí•´ì„œ
        // #define CONST_BUFFER(type)	GEngine->GetConstantBuffer(type)
	shared_ptr<ConstantBuffer> GetConstantBuffer(CONSTANT_BUFFER_TYPE type) { return _constantBuffers[static_cast<uint8>(type)]; }
```

```cpp
void Material::Update()
{
	// ì‚¬ìš©ì€ ì´ë ‡ê²Œ -> CONSTANT_BUFFER_TYPE::MATERIALì— ë°ì´í„° ë„£ì–´ì£¼ì„¸ìš”
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));
```

```cpp
void Mesh::Render()
{
	// ...
		
    // ì‚¬ìš©ì€ ì´ë ‡ê²Œ2 -> CONSTANT_BUFFER_TYPE::TRANSFORMì— ë°ì´í„° ë„£ì–´ì£¼ì„¸ìš”
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::TRANSFORM)->PushData(&_transform, sizeof(_transform));
```

ë‹¤ì‹œ `ConstantBuffer::Init`ìœ¼ë¡œ ëŒì•„ê°€ì„œ

```cpp
void ConstantBuffer::Init(CBV_REGISTER reg, uint32 size, uint32 count)
{
	_reg = reg;

	_elementSize = (size + 255) & ~255;
	_elementCount = count;

    // Bufferì™€ ê·¸ Viewë¥¼ ìƒì„±
	CreateBuffer();
    /*
        void ConstantBuffer::CreateBuffer()
        {
            uint32 bufferSize = _elementSize * _elementCount;
            D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
            D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

            DEVICE->CreateCommittedResource(
                &heapProperty,
                D3D12_HEAP_FLAG_NONE,
                &desc,
                D3D12_RESOURCE_STATE_GENERIC_READ,
                nullptr,
                IID_PPV_ARGS(&_cbvBuffer));

            _cbvBuffer->Map(0, nullptr, reinterpret_cast<void**>(&_mappedBuffer));
    */


	CreateView();
    /*
        void ConstantBuffer::CreateView()
        {
            D3D12_DESCRIPTOR_HEAP_DESC cbvDesc = {};
            cbvDesc.NumDescriptors = _elementCount;
            cbvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
            cbvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
            DEVICE->CreateDescriptorHeap(&cbvDesc, IID_PPV_ARGS(&_cbvHeap));

            _cpuHandleBegin = _cbvHeap->GetCPUDescriptorHandleForHeapStart();
            _handleIncrementSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

            for (uint32 i = 0; i < _elementCount; ++i)
            {
                D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle = GetCpuHandle(i);

                D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = {};
                cbvDesc.BufferLocation = _cbvBuffer->GetGPUVirtualAddress() + static_cast<uint64>(_elementSize) * i;
                cbvDesc.SizeInBytes = _elementSize;   // CB size is required to be 256-byte aligned.

                DEVICE->CreateConstantBufferView(&cbvDesc, cbvHandle);
            }
        }
    */
}
```

ConstantBufferì— PushDataë¥¼ í• ì‹œ

```cpp
void ConstantBuffer::PushData(void* buffer, uint32 size)
{
	assert(_currentIndex < _elementCount);
	assert(_elementSize == ((size + 255) & ~255));

    // CreateBuffer();ì—ì„œ mappedí•œ ë²„í¼ì— ë°ì´í„°ë¥¼ ë„£ê³ 
	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

    // TableDescriptorì— SetCBVë¥¼ í˜¸ì¶œí•˜ëŠ”ë°
	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
	GEngine->GetTableDescHeap()->SetCBV(cpuHandle, _reg);

	_currentIndex++;
}
```

```cpp
// GPUë‚´ì˜ ë ˆì§€ìŠ¤í„° ì˜¬ë¦¬ê¸° ì§ì „ì˜ ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë³µì‚¬í•´ ë‹¬ë¼
void TableDescriptorHeap::SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg)
{
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

	uint32 destRange = 1;
	uint32 srcRange = 1;
	DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}
```

---

```cpp
/*
	CreateConstantBuffer(CBV_REGISTER::b0, sizeof(Transform), 256);
	CreateConstantBuffer(CBV_REGISTER::b1, sizeof(MaterialParams), 256);
*/

void Engine::CreateConstantBuffer(CBV_REGISTER reg, uint32 bufferSize, uint32 count)
{
	// CBV_REGISTERëŠ” b0, b1 ... ìˆœì°¨ì ìœ¼ë¡œ ë§Œë“¤ì–´ì¤˜ì•¼í•¨
	// ì¤‘ê°„ì— ëˆ„ë½ëœê²Œ ìˆì„ê¹Œë´ ê²€ìˆ˜í•˜ëŠ” ê³¼ì •ì„.
	uint8 typeInt = static_cast<uint8>(reg);
	assert(_constantBuffers.size() == typeInt);

	shared_ptr<ConstantBuffer> buffer = make_shared<ConstantBuffer>();
	buffer->Init(reg, bufferSize, count);
	_constantBuffers.push_back(buffer);
}
```

```cpp
// ë²„í¼ ì´ˆê¸°í™”

// CBV_REGISTER regë¥¼ í†µí•´ b0, b1ì¸ì§€ í™•ì¸
void ConstantBuffer::Init(CBV_REGISTER reg, uint32 size, uint32 count)
{
	_reg = reg;

	_elementSize = (size + 255) & ~255;
	_elementCount = count;

	CreateBuffer();
	CreateView();
}
```

```cpp
void ConstantBuffer::PushData(void* buffer, uint32 size)
{
	assert(_currentIndex < _elementCount);
	assert(_elementSize == ((size + 255) & ~255));

	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);

	// Constant Buffer ì—…ë¡œë“œ
	GEngine->GetTableDescHeap()->SetCBV(cpuHandle, _reg);

	/*
		void TableDescriptorHeap::SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg)
		{
			D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

			uint32 destRange = 1;
			uint32 srcRange = 1;
			DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
		}
	*/

	_currentIndex++;
}
```

---

## ë‹¤ì‹œ Setë¶€í„° ë”°ë¼ê°€ë³´ì

ğŸ˜º ì—„ì²­ í—·ê°ˆë¦°ë‹¤. Setë¶€í„° ë”°ë¼ê°€ë³¸ë‹¤

```cpp
void Game::Init(const WindowInfo& info)
{
	// ...

	mesh->Init(vec, indexVec);

	shared_ptr<Shader> shader = make_shared<Shader>();
	shared_ptr<Texture> texture = make_shared<Texture>();
	shader->Init(L"..\\Resources\\Shader\\default.hlsli");
	texture->Init(L"..\\Resources\\Texture\\veigar.jpg");

	shared_ptr<Material> material = make_shared<Material>();
	material->SetShader(shader);
	material->SetFloat(0, 0.3f);
	material->SetFloat(1, 0.4f);
	material->SetFloat(2, 0.3f);
	material->SetTexture(0, texture);
    /*
        class Material
        {
            // Setì„ í• ì‹œ MaterialParamsì— ê° ë°ì´í„°ë¥¼ ë‹´ëŠ”ë‹¤
            void SetShader(shared_ptr<Shader> shader) { _shader = shader; }
            void SetInt(uint8 index, int32 value) { _params.SetInt(index, value); }
            void SetFloat(uint8 index, float value) { _params.SetFloat(index, value); }
            void SetTexture(uint8 index, shared_ptr<Texture> texture) { _textures[index] = texture; }
    */
	mesh->SetMaterial(material);

	GEngine->GetCmdQueue()->WaitSync();
}
```

<Br>

ğŸ˜º `MaterialParams`ì— ë‹´ì€ ë°ì´í„°ë¥¼ Updateë¥¼ í†µí•´ GPUì— ì˜¬ë¦¬ê²Œ ë˜ëŠ”ë°

```cpp
void Material::Update()
{
	// CBV
        // mappedëœ GPUë°ì´í„°ì— ë°ì´í„°ë¥¼ ì˜¬ë¦¬ê³  ë ˆì§€ìŠ¤í„°ì— ì˜¬ë ¤ë‹¬ë¼ ëª…ë ¹
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));

	// SRV
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetTableDescHeap()->SetSRV(_textures[i]->GetCpuHandle(), reg);
        /*
            void TableDescriptorHeap::SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg)
            {
                D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

                uint32 destRange = 1;
                uint32 srcRange = 1;
                DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
            }
        */
	}

    // ì‰ì´ë”©í•´ë‹¬ë¼
	_shader->Update();
}
```