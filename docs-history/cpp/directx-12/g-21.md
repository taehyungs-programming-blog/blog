---
layout: default
title: "21. Normal Mapping"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: (C++)
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/16)

ğŸ˜º Textureë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ [3D Textures](https://3dtextures.me/)ì™€ ê°™ì€ ì‚¬ì´íŠ¸ì—ì„œ Textureë¥¼ ë‹¤ìš´í›„ ì‚¬ìš©í•˜ë©´ ìƒê°ë³´ë‹¤ ë°‹ë°‹í•˜ë‹¤...

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-20-2.png"/>
</p>

ğŸ˜º ì´ìœ ëŠ” Textureì—ëŠ” Lightì •ë³´ê°€ ì—†ì–´ì„œ ì¸ë° Textureë¥¼ í†µí•´ì„œ Normal Vectorì •ë³´ë¥¼ ë„˜ê²¨ ì…ì²´ê°ì„ ì£¼ëŠ” í‘œí˜„ë°©ì‹ì„ **Normal-Mapping(Bump-Mapping)**ì´ë¼í•œë‹¤.

```cpp
shared_ptr<Mesh> Resources::LoadCubeMesh()
{
	//...

	vector<Vertex> vec(24);
    /*
        struct Vertex
        {
            Vertex() {}

            Vertex(Vec3 p, Vec2 u, Vec3 n, Vec3 t)
                : pos(p), uv(u), normal(n), tangent(t)
            {
            }

            Vec3 pos;
            Vec2 uv;
            Vec3 normal;
            Vec3 tangent;
        };
    */

	// ì•ë©´
    // í•œìª½ë©´ì˜ í…ìŠ¤ì³ ë‚´ì— Normal Vectorê°’ì´ ì¼ì •í•˜ë‹ˆ ë¹› ë°˜ì‚¬ë¥¼ ëª¨ë‘ ì¼ì •í•˜ê²Œ í•˜ë©° í‰ë©´ì ìœ¼ë¡œ ë³´ì´ê²Œ ëœë‹¤.
    // ì•„ë˜ì„œ ì„¸ ë²ˆì§¸ ìš”ì†Œê°€ Normal Vectorì´ë‹¤
	vec[0] = Vertex(Vec3(-w2, -h2, -d2),        // position
                    Vec2(0.0f, 1.0f),           // uv
                    Vec3(0.0f, 0.0f, -1.0f),    // normal
                    Vec3(1.0f, 0.0f, 0.0f));    // tangent(ì•„ì§ ì™œì“°ëŠ”ì§€ ì•ˆë‚˜ì˜´.)
	vec[1] = Vertex(Vec3(-w2, +h2, -d2), Vec2(0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[2] = Vertex(Vec3(+w2, +h2, -d2), Vec2(1.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[3] = Vertex(Vec3(+w2, -h2, -d2), Vec2(1.0f, 1.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));

    // ë³´ë©´ ì•ë©´ì˜ Normal-Vectorê°€ ëª¨ë‘ Vec3(0.0f, 0.0f, -1.0f)ë¡œ ë™ì¼í•˜ë‹¤

    // ...
```

ğŸ˜º ë§Œì•½ Cubeê°€ Sphere ì²˜ëŸ¼ Normalì´ ë‹¤ì–‘í•˜ë‹¤ë©´ ì…ì²´ê°ì´ ë‚˜íƒ€ë‚ í…ë°... ê·¸ëŸ¼ ëª¨ë“  Textureì— ë§ì¶°ì„œ Normalì„ ì„¸íŒ…í•´ ì¤˜ì•¼í• ê¹Œ? ì´ëŸ° ë…¸ê°€ë‹¤ê°€ì—†ë‹¤...

ğŸ˜º ì´ ë¬¸ì œì˜ í•´ê²°ì±…ìœ¼ë¡œ Textureìì²´ì— Normalì •ë³´ë¥¼ ì…í˜€ë‘” Textureê°€ ìˆë‹¤.

* (ì°¸ê³ ) Normal-Mappingëœ Textureë¥¼ ì—´ì–´ë³´ë©´ í‘¸ë¥¸ìƒ‰ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚˜ëŠ”ë°, ì™œ ê·¸ëŸ´ê¹Œ?
    * Normal-Mapping TextureëŠ” Localì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ Tagent ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•˜ê²Œ ëœë‹¤.
    * Tagent(ì ‘í•˜ëŠ” í‰ë©´)ì˜ ì¢Œí‘œê³„ë€ ë§ì¸ë°, ë§ ê·¸ëŒ€ë¡œ Objectì˜ í‘œë©´ê³¼ ì ‘í•˜ëŠ” ì¢Œí‘œê³„ì´ë‹¤.

* Tagent ì¢Œí‘œê³„ì˜ ì¢Œí‘œëŠ” x(right), y(look), z(up) (ìˆœì„œëŒ€ë¡œ rgb) ì¸ë° ëŒ€ë¶€ë¶„ z(up)ìœ¼ë¡œ í–¥í•˜ê¸°ì—(ì•„ë¬´ë˜ë„ ìƒ‰ì„ ë°˜ì‚¬í•˜ê¸° ìœ„í•œ ì¢Œí‘œê³„ì´ê¸°ì— upì„±ë¶„ì´ ë§ìŒ right, lookë„ ì•½ê°„ì€ ìˆìœ¼ë‚˜ ìƒ‰ì„ ë¹„ìŠ¤ë“¬íˆ ë°˜ì‚¬ì‹œí‚¤ë ¤ëŠ” ì •ë„?
    * ì–´ë–»ê²Œ ì‚¬ìš©ë ê¹Œ? -> ì¼ë‹¨ í˜„ì¬ Lightë¥¼ ê·¸ë¦¬ëŠ” ì¢Œí‘œê³„ê°€ Viewì¢Œí‘œê³„ì´ê¸°ì— Tagent ì¢Œí‘œê³„ì—ì„œ Viewì¢Œí‘œê³„ë¡œ ë³€í™˜ì„ ì‹œì¼œì£¼ê³  ê·¸ Normal Vectorë¥¼ ì´ìš©í•´ Lightë¥¼ ê·¸ë¦¬ë©´ ëœë‹¤.

* ì—¬ê¸°ë¶€í„´ ì˜¤íˆë ¤ ì½”ë“œë³´ëŠ”ê²Œ í¸í•¨.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-20-1.png"/>
</p>

ğŸ± TangentView -> WorldView ì¢Œí‘œë³€í™˜ì„ ìœ„í•´ì„œ Binormal Vectorë¥¼ ì•Œì•„ì•¼í•˜ëŠ”ë° Normalì´ ì ‘í•œ í‰ë©´ì˜ ìˆ˜ì§ê°ì˜ Vectorë¼ë©´ Tangent Vectorì™€ Normalì˜ ë‚´ì ì´ë¼ ìƒê°í•˜ë©´ ëœë‹¤.

```
// Normal-Mapping Textureì˜ Tangent Space(ì¢Œí‘œê³„)ì—ì„œ View Spaceë¡œ ì˜®ê¸°ë ¤ë©´
// ì•„ë˜ Matrixë¥¼ ì—°ì‚°í•´ì£¼ë©´ëœë‹¤.
Tx Ty Tz    (Tangent x, y, z)
Bx By Bz    (Binormal x, y, z)
Nx Ny Nz    (Normal x, y, z)
```

```cpp
shared_ptr<Scene> SceneManager::LoadTestScene()
{
	// ...

    shared_ptr<Shader> shader = make_shared<Shader>();
    shared_ptr<Texture> texture = make_shared<Texture>();
    shared_ptr<Texture> texture2 = make_shared<Texture>();
    shader->Init(L"..\\Resources\\Shader\\default.hlsli");
    texture->Init(L"..\\Resources\\Texture\\Leather.jpg");
    
    // Normal Textureë¥¼ ë„£ëŠ”ë‹¤
    texture2->Init(L"..\\Resources\\Texture\\Leather_Normal.jpg");
```

```
cbuffer MATERIAL_PARAMS : register(b2)
{
    // ...

    // ì‰ì´ë”ì—ì„œëŠ” Texutreì˜ nullì²´í¬ê°€ ë¶ˆê°€ëŠ¥í•˜ê¸°ì—
    // onì´ë¼ëŠ” ë³€ìˆ˜ë¥¼ ë‘ì–´ nullì¸ì§€ ì•„ë‹Œì§€ í™•ì¸í•œë‹¤.
    int     g_tex_on_0;
    int     g_tex_on_1;

    // ...
};

Texture2D g_tex_0 : register(t0);
Texture2D g_tex_1 : register(t1);       // t1ì— normal textureë¥¼ ë„£ì–´ì¤„ ì˜ˆì •
Texture2D g_tex_2 : register(t2);

// ...
```

```cpp
void SetTexture(uint8 index, shared_ptr<Texture> texture) 
{ 
    _textures[index] = texture;
    // textureê°€ ì—†ë‹¤ë©´ 0 
    // ìˆë‹¤ë©´ 1ë¡œ ë„£ì–´ë‹¬ë¼
    _params.SetTexOn(index, (texture == nullptr ? 0 : 1));
}
```

```
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;

    // vertex shaderì—ì„œ ë„˜ì–´ì˜¨ normal, tagent, binormalì„ ë„£ëŠ”ë‹¤
        // ì°¸ê³ ë¡œ ì—¬ê¸°ì„œ ë„˜ì–´ì˜¨ n, t, bê°’ì€ vertexì˜ ntbê°’ì´ì§€ normaltextureì˜ ntbê°’ì´ ì•„ë‹˜(ì£¼ì˜)
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);
    output.viewTangent = normalize(mul(float4(input.tangent, 0.f), g_matWV).xyz);
    output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));

    return output;
}
```

```
float4 PS_Main(VS_OUT input) : SV_Target
{
    float4 color = float4(1.f, 1.f, 1.f, 1.f);
    if (g_tex_on_0)
        color = g_tex_0.Sample(g_sam_0, input.uv);

    float3 viewNormal = input.viewNormal;
    if (g_tex_on_1)
    {
        // [0,255] ë²”ìœ„ì—ì„œ [0,1]ë¡œ ë³€í™˜
        float3 tangentSpaceNormal = g_tex_1.Sample(g_sam_0, input.uv).xyz;
        // [0,1] ë²”ìœ„ì—ì„œ [-1,1]ë¡œ ë³€í™˜
        tangentSpaceNormal = (tangentSpaceNormal - 0.5f) * 2.f;

        // normal textureë¡œ nbtë¥¼ êµ¬í•´ì„œ ì—°ì‚°
            // TBN ìˆœì„œë¡œ ìƒì„±ëœ Matrixë¥¼ ê³±í•´ì£¼ê²Œ ëœë‹¤.
        float3x3 matTBN = { input.viewTangent, 
                            input.viewBinormal, 
                            input.viewNormal };
                            /*
                                Tx Ty Tz    (Tangent x, y, z)
                                Bx By Bz    (Binormal x, y, z)
                                Nx Ny Nz    (Normal x, y, z)
                            */
        viewNormal = normalize(mul(tangentSpaceNormal, matTBN));
    }

    LightColor totalColor = (LightColor)0.f;

    for (int i = 0; i < g_lightCount; ++i)
    {
         LightColor color = CalculateLightColor(i, viewNormal, input.viewPos);
         totalColor.diffuse += color.diffuse;
         totalColor.ambient += color.ambient;
         totalColor.specular += color.specular;
    }

    color.xyz = (totalColor.diffuse.xyz * color.xyz)
        + totalColor.ambient.xyz * color.xyz
        + totalColor.specular.xyz;

     return color;
}
```
