---
layout: default
title: "17. Resource"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: C++
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/14)

* ìš°ì„  ë³¸ ê°•ì¢Œì—ì„œëŠ” Cubeì™€ Sphereë¥¼ ìƒì„±í•  ì˜ˆì •ì´ê³  Cube, Sphereë¥¼ ìœ„í•´ì„œ Resourceë¥¼ ì–´ë–»ê²Œ ê´€ë¦¬í• ì§€? ê°€ ì‚¬ì‹¤ í•µì‹¬ì´ë‹¤.

## object í´ë˜ìŠ¤

ğŸ˜º ê²Œì„ì— ì‚¬ìš©ë˜ëŠ” ê°ì¢… objectë¥¼ object í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ê´€ë¦¬í•´ ë³´ì.

ğŸ˜º ëª©ì ì€ íŒŒì¼ë¡œ ì €ì¥/ë¡œë“œê°€ ê°€ëŠ¥í•˜ê²Œ í•˜ì—¬ ì¢€ ë” í¸ì•ˆí•˜ê²Œ ê´€ë¦¬ + objectë¼ëŠ” ìƒìœ„ í´ë˜ìŠ¤ë¡œ ê´€ë¦¬í•˜ë©´ ë¯¸ë˜ì— ê´€ë¦¬ê°€ ìˆ˜ì›”í•˜ê¸° ë•Œë¬¸

```cpp
#pragma once

enum class OBJECT_TYPE : uint8
{
    NONE,
    GAMEOBJECT, // PREFAB
    COMPONENT,
    MATERIAL,
    MESH,
    SHADER,
    TEXTURE,
    END
};

enum
{
    OBJECT_TYPE_COUNT = static_cast<uint8>(OBJECT_TYPE::END)
};

class Object
{
public:
    Object(OBJECT_TYPE type);
    virtual ~Object();          // ìµœìƒìœ„ í´ë˜ìŠ¤ì´ê¸°ì— virtualë¡œ ì†Œë©¸ìë¥¼ ê°–ê²Œí•˜ì

    OBJECT_TYPE GetType() { return _objectType; }

    // ì´ë¦„ì„ ì–¸
    void SetName(const wstring& name) { _name = name; }
    const wstring& GetName() { return _name; }

    // TODO : Instantiate(Object ë³µì‚¬ê¸°ëŠ¥, ì´í›„ ì¶”ê°€ í•  ì˜ˆì •)

protected:
    // Resourcesì—ì„œëŠ” Objectì˜ Load, Saveë¥¼ ë§ˆìŒëŒ€ë¡œ í•  ìˆ˜ ìˆë‹¤.
    friend class Resources;

    // íŒŒì¼ì— ì €ì¥/ë¡œë“œê¸°ëŠ¥
    virtual void Load(const wstring& path) { }
    virtual void Save(const wstring& path) { }

protected:
    OBJECT_TYPE _objectType = OBJECT_TYPE::NONE;
    wstring _name;
};
```

ğŸ˜º ì°¸ê³ ë¡œ `object`ë¡œ íŒŒìƒë˜ëŠ” í´ë˜ìŠ¤ëŠ” `GameObject`, `Component`, `Material`, `Shader`, `Texture`

ğŸ™€ ë‹¤ë¥¸ê±´ ì´í•´ê°€ ë˜ëŠ”ë° `GameObject`ë¥¼ í•˜ë‚˜ì˜ Objectë¡œ ë´ì•¼í•˜ë‚˜? `GameObject`ë‚´ì—ëŠ” Textrue, Shaderë“±ì´ í¬í•¨ë í…ë°?? -> ì—¬ëŸ¬ ë¦¬ì†ŒìŠ¤ë¥¼ ë‚˜ë¦„ëŒ€ë¡œ ì»¤ìŠ¤í„°ë§ˆì´ì§•í•œ í•˜ë‚˜ì˜ Objectë¼ ìƒê°í•˜ì(ì–¸ë¦¬ì–¼ì˜ ë¸”ë£¨í”„ë¦°íŠ¸ì™€ ë™ì¼í•œ ê°œë…!)

---

## Resource í´ë˜ìŠ¤

ğŸ˜º object ìì²´ë¥¼ ê´€ë¦¬í•  Resourceë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.

```cpp
class Resources
{
    DECLARE_SINGLE(Resources);

public:
    // objectê°€ ì–´ë–¤ í´ë˜ìŠ¤ì¼ì§€ ëª¨ë¥´ë‹ˆ Templateë¡œ ìƒì„±
    template<typename T>
    shared_ptr<T> Load(const wstring& key, const wstring& path);

    template<typename T>
    bool Add(const wstring& key, shared_ptr<T> object);

    template<typename T>
    shared_ptr<T> Get(const wstring& Key);

    template<typename T>
    OBJECT_TYPE GetObjectType();

    // Cube, Sphere êµ¬í˜„ì€ ì•„ë˜ì„œ ì°¸ì¡°
    shared_ptr<Mesh> LoadCubeMesh();
    shared_ptr<Mesh> LoadSphereMesh();

private:
    // Resourceì˜ ë³´ê´€ì€ Mapì˜ í˜•íƒœë¡œ í•œë‹¤.
    using KeyObjMap = std::map<wstring/*key*/, shared_ptr<Object>>;

    // ê° objectì— ë”°ë¼ ë°°ì—´ì„ ìƒˆë¡œ í• ë‹¹í•˜ì—¬ ê´€ë¦¬
    array<KeyObjMap, OBJECT_TYPE_COUNT> _resources;
    /* ì‚¬ìš©ì€ ì´ë ‡ê²Œ -> _resources[static_cast<uint8>(objectType)] */
};
```

```cpp
// Resources.h

template<typename T>
inline shared_ptr<T> Resources::Load(const wstring& key, const wstring& path)
{
    OBJECT_TYPE objectType = GetObjectType<T>();
    KeyObjMap& keyObjMap = _resources[static_cast<uint8>(objectType)];

    auto findIt = keyObjMap.find(key);
    if (findIt != keyObjMap.end())
        return static_pointer_cast<T>(findIt->second);

    shared_ptr<T> object = make_shared<T>();
    object->Load(path);
    keyObjMap[key] = object;

    return object;
}

template<typename T>
bool Resources::Add(const wstring& key, shared_ptr<T> object)
{
    OBJECT_TYPE objectType = GetObjectType<T>();
    KeyObjMap& keyObjMap = _resources[static_cast<uint8>(objectType)];

    auto findIt = keyObjMap.find(key);
    if (findIt != keyObjMap.end())
        return false;

    keyObjMap[key] = object;
    return true;
}

template<typename T>
shared_ptr<T> Resources::Get(const wstring& key)
{
    OBJECT_TYPE objectType = GetObjectType<T>();
    KeyObjMap& keyObjMap = _resources[static_cast<uint8>(objectType)];

    auto findIt = keyObjMap.find(key);
    if (findIt != keyObjMap.end())
        return static_pointer_cast<T>(findIt->second);

    return nullptr;
}

template<typename T>
inline OBJECT_TYPE Resources::GetObjectType()
{
    // std::is_same_v<T, GameObject> -> C++11 Templateê¸°ë²•
    if (std::is_same_v<T, GameObject>)
        return OBJECT_TYPE::GAMEOBJECT;
    else if (std::is_same_v<T, Material>)
        return OBJECT_TYPE::MATERIAL;
    else if (std::is_same_v<T, Mesh>)
        return OBJECT_TYPE::MESH;
    else if (std::is_same_v<T, Shader>)
        return OBJECT_TYPE::SHADER;
    else if (std::is_same_v<T, Texture>)
        return OBJECT_TYPE::TEXTURE;
    else if (std::is_convertible_v<T, Component>)
        return OBJECT_TYPE::COMPONENT;
    else
        return OBJECT_TYPE::NONE;
}
```

---

## ì •ì ìœ¼ë¡œ Cube, Sphere ë§Œë“œëŠ” ë°©ë²•

ğŸ˜º CubeëŠ” ì‰½ë‹¤

```
               ------------------
              /                 / |
             /                 /  |
            /                 /   |
(-w, h, -d) ------------------- (w, h, -d)
            |                 |   |
            |                 |   |
            |                 |  /
            |                 | /
(-w, -h, -d) ------------------ (w, -h, -d)
```

ğŸ˜º ì›ì ì„ ì¤‘ì‹¬ìœ¼ë¡œ ë†’ì´ë¥¼ h, ë„ˆë¹„ë¥¼ w, ê¹Šì´ë¥¼ dë¼ í–ˆì„ë•Œ ì •ì ì •ë³´ëŠ” ìœ„ ê·¸ë¦¼ê³¼ ê°™ì´ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

ğŸ˜º ë¬¸ì œëŠ” Sphereì¸ë° ... ëŒ€ëµ ì•„ë˜ì™€ ê°™ì€ ë°©ë²•ìœ¼ë¡œ ë§Œë“ ë‹¤ê³  ìƒê°í•˜ê³  ì°¨ë¼ë¦¬ ì½”ë“œë¥¼ ë³´ëŠ”ê²Œ ì‰½ë‹¤

```
     o (ê¼­ì§€ì ) -> ë¶ê·¹
    / \
   o   o
  / \ / \

    ...
  
  \ / \ /
   o   o
    \ /
     o -> ë‚¨ê·¹

* ë¶ê·¹, ë‚¨ê·¹ì„ ë§Œë“¤ê³  í•˜ë‚˜í•˜ë‚˜ ëŠ˜ë ¤ê°€ë©° ê°€ìš´ë°ì„œ ë§Œë‚˜ëŠ” í˜•íƒœë¡œ êµ¬í˜„
```

ğŸ˜º ì½”ë“œì— ë“¤ì–´ê°€ê¸° ì „ `Vertex` êµ¬ì¡°ì²´ë¥¼ ì•½ê°„ ìˆ˜ì •í•˜ê² ìŒ

```cpp
struct Vertex
{
    Vertex() {}
    Vertex(Vec3 p, Vec2 u, Vec3 n, Vec3 t)
        : pos(p), uv(u), normal(n), tangent(t)
    {
    }
    Vec3 pos;
    Vec2 uv;

    // Vec3 color -> ì‚­ì œí•˜ê³ ,

    // Lighting ì— ì‚¬ìš©ë  ì •ë³´ì´ê¸°ì— ì§€ê¸ˆì€ ë¬´ì‹œí•´ë„ ì¢‹ë‹¤
    Vec3 normal;
    Vec3 tangent;
};
```

`Vertex` êµ¬ì¡°ì²´ê°€ ìˆ˜ì •ë˜ë©´ ì‰ì´ë”ë„ ë™ì¼í•˜ê²Œ ìˆ˜ì •ì´ í•„ìš”í•´ì§„ë‹¤.

```cpp
void Shader::Init(const wstring& path)
{
    // ...
    D3D12_INPUT_ELEMENT_DESC desc[] =
    {
        { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
        { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
        { "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 20, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
        { "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 32, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
    };
    // ...
```

```
struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;

    // normal, tangentëŠ” ë‹¹ì¥ì‚¬ìš©í•˜ì§€ ì•Šê¸°ì— ë„£ì§€ëŠ” ì•ŠìŒ
};
```

### Cube SourceCode

```cpp
shared_ptr<Mesh> Resources::LoadCubeMesh()
{
    shared_ptr<Mesh> findMesh = Get<Mesh>(L"Cube");
    if (findMesh)
        return findMesh;

    float w2 = 0.5f;
    float h2 = 0.5f;
    float d2 = 0.5f;
    vector<Vertex> vec(24);

    // ì•ë©´
    vec[0] = Vertex(Vec3(-w2, -h2, -d2), Vec2(0.0f, 1.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
    vec[1] = Vertex(Vec3(-w2, +h2, -d2), Vec2(0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
    vec[2] = Vertex(Vec3(+w2, +h2, -d2), Vec2(1.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
    vec[3] = Vertex(Vec3(+w2, -h2, -d2), Vec2(1.0f, 1.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));

    // ë’·ë©´
    vec[4] = Vertex(Vec3(-w2, -h2, +d2), Vec2(1.0f, 1.0f), Vec3(0.0f, 0.0f, 1.0f), Vec3(-1.0f, 0.0f, 0.0f));
    vec[5] = Vertex(Vec3(+w2, -h2, +d2), Vec2(0.0f, 1.0f), Vec3(0.0f, 0.0f, 1.0f), Vec3(-1.0f, 0.0f, 0.0f));
    vec[6] = Vertex(Vec3(+w2, +h2, +d2), Vec2(0.0f, 0.0f), Vec3(0.0f, 0.0f, 1.0f), Vec3(-1.0f, 0.0f, 0.0f));
    vec[7] = Vertex(Vec3(-w2, +h2, +d2), Vec2(1.0f, 0.0f), Vec3(0.0f, 0.0f, 1.0f), Vec3(-1.0f, 0.0f, 0.0f));

    // ìœ—ë©´
    vec[8] = Vertex(Vec3(-w2, +h2, -d2), Vec2(0.0f, 1.0f), Vec3(0.0f, 1.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f));
    vec[9] = Vertex(Vec3(-w2, +h2, +d2), Vec2(0.0f, 0.0f), Vec3(0.0f, 1.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f));
    vec[10] = Vertex(Vec3(+w2, +h2, +d2), Vec2(1.0f, 0.0f), Vec3(0.0f, 1.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f));
    vec[11] = Vertex(Vec3(+w2, +h2, -d2), Vec2(1.0f, 1.0f), Vec3(0.0f, 1.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f));

    // ì•„ë«ë©´
    vec[12] = Vertex(Vec3(-w2, -h2, -d2), Vec2(1.0f, 1.0f), Vec3(0.0f, -1.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f));
    vec[13] = Vertex(Vec3(+w2, -h2, -d2), Vec2(0.0f, 1.0f), Vec3(0.0f, -1.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f));
    vec[14] = Vertex(Vec3(+w2, -h2, +d2), Vec2(0.0f, 0.0f), Vec3(0.0f, -1.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f));
    vec[15] = Vertex(Vec3(-w2, -h2, +d2), Vec2(1.0f, 0.0f), Vec3(0.0f, -1.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f));

    // ì™¼ìª½ë©´
    vec[16] = Vertex(Vec3(-w2, -h2, +d2), Vec2(0.0f, 1.0f), Vec3(-1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f));
    vec[17] = Vertex(Vec3(-w2, +h2, +d2), Vec2(0.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f));
    vec[18] = Vertex(Vec3(-w2, +h2, -d2), Vec2(1.0f, 0.0f), Vec3(-1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f));
    vec[19] = Vertex(Vec3(-w2, -h2, -d2), Vec2(1.0f, 1.0f), Vec3(-1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f));

    // ì˜¤ë¥¸ìª½ë©´
    vec[20] = Vertex(Vec3(+w2, -h2, -d2), Vec2(0.0f, 1.0f), Vec3(1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, 1.0f));
    vec[21] = Vertex(Vec3(+w2, +h2, -d2), Vec2(0.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, 1.0f));
    vec[22] = Vertex(Vec3(+w2, +h2, +d2), Vec2(1.0f, 0.0f), Vec3(1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, 1.0f));
    vec[23] = Vertex(Vec3(+w2, -h2, +d2), Vec2(1.0f, 1.0f), Vec3(1.0f, 0.0f, 0.0f), Vec3(0.0f, 0.0f, 1.0f));

    vector<uint32> idx(36);
    // ì•ë©´
    idx[0] = 0; idx[1] = 1; idx[2] = 2;
    idx[3] = 0; idx[4] = 2; idx[5] = 3;
    // ë’·ë©´
    idx[6] = 4; idx[7] = 5; idx[8] = 6;
    idx[9] = 4; idx[10] = 6; idx[11] = 7;
    // ìœ—ë©´
    idx[12] = 8; idx[13] = 9; idx[14] = 10;
    idx[15] = 8; idx[16] = 10; idx[17] = 11;
    // ì•„ë«ë©´
    idx[18] = 12; idx[19] = 13; idx[20] = 14;
    idx[21] = 12; idx[22] = 14; idx[23] = 15;
    // ì™¼ìª½ë©´
    idx[24] = 16; idx[25] = 17; idx[26] = 18;
    idx[27] = 16; idx[28] = 18; idx[29] = 19;
    // ì˜¤ë¥¸ìª½ë©´
    idx[30] = 20; idx[31] = 21; idx[32] = 22;
    idx[33] = 20; idx[34] = 22; idx[35] = 23;
    shared_ptr<Mesh> mesh = make_shared<Mesh>();
    mesh->Init(vec, idx);
    Add(L"Cube", mesh);
    return mesh;
}
```

### Sphere SourceCode

```cpp
shared_ptr<Mesh> Resources::LoadSphereMesh()
{
    shared_ptr<Mesh> findMesh = Get<Mesh>(L"Sphere");
    if (findMesh)
        return findMesh;
    float radius = 0.5f; // êµ¬ì˜ ë°˜ì§€ë¦„
    uint32 stackCount = 20; // ê°€ë¡œ ë¶„í• 
    uint32 sliceCount = 20; // ì„¸ë¡œ ë¶„í• 
    vector<Vertex> vec;
    Vertex v;

    // ë¶ê·¹
    v.pos = Vec3(0.0f, radius, 0.0f);
    v.uv = Vec2(0.5f, 0.0f);
    v.normal = v.pos;

    // normal, tangentëŠ” ìš°ì„  ë¬´ì‹œ
    v.normal.Normalize();
    v.tangent = Vec3(1.0f, 0.0f, 1.0f);
    vec.push_back(v);
    float stackAngle = XM_PI / stackCount;
    float sliceAngle = XM_2PI / sliceCount;
    float deltaU = 1.f / static_cast<float>(sliceCount);
    float deltaV = 1.f / static_cast<float>(stackCount);

    // ê³ ë¦¬ë§ˆë‹¤ ëŒë©´ì„œ ì •ì ì„ ê³„ì‚°í•œë‹¤ (ë¶ê·¹/ë‚¨ê·¹ ë‹¨ì¼ì ì€ ê³ ë¦¬ê°€ X)
    for (uint32 y = 1; y <= stackCount - 1; ++y)
    {
        float phi = y * stackAngle;
        // ê³ ë¦¬ì— ìœ„ì¹˜í•œ ì •ì 
        for (uint32 x = 0; x <= sliceCount; ++x)
        {
            float theta = x * sliceAngle;
            v.pos.x = radius * sinf(phi) * cosf(theta);
            v.pos.y = radius * cosf(phi);
            v.pos.z = radius * sinf(phi) * sinf(theta);
            v.uv = Vec2(deltaU * x, deltaV * y);
            // normal, tangentëŠ” ìš°ì„  ë¬´ì‹œ
            v.normal = v.pos;
            v.normal.Normalize();
            v.tangent.x = -radius * sinf(phi) * sinf(theta);
            v.tangent.y = 0.0f;
            v.tangent.z = radius * sinf(phi) * cosf(theta);
            v.tangent.Normalize();
            vec.push_back(v);
        }
    }

    // ë‚¨ê·¹
    v.pos = Vec3(0.0f, -radius, 0.0f);
    v.uv = Vec2(0.5f, 1.0f);
    v.normal = v.pos;
    v.normal.Normalize();
    v.tangent = Vec3(1.0f, 0.0f, 0.0f);
    vec.push_back(v);
    vector<uint32> idx(36);

    // ë¶ê·¹ ì¸ë±ìŠ¤
    for (uint32 i = 0; i <= sliceCount; ++i)
    {
        //  [0]
        //   |  \
        //  [i+1]-[i+2]
        idx.push_back(0);
        idx.push_back(i + 2);
        idx.push_back(i + 1);
    }

    // ëª¸í†µ ì¸ë±ìŠ¤
    uint32 ringVertexCount = sliceCount + 1;
    for (uint32 y = 0; y < stackCount - 2; ++y)
    {
        for (uint32 x = 0; x < sliceCount; ++x)
        {
            //  [y, x]-[y, x+1]
            //  |       /
            //  [y+1, x]
            idx.push_back(1 + (y) * ringVertexCount + (x));
            idx.push_back(1 + (y) * ringVertexCount + (x + 1));
            idx.push_back(1 + (y + 1) * ringVertexCount + (x));
            //       [y, x+1]
            //       /    |
            //  [y+1, x]-[y+1, x+1]
            idx.push_back(1 + (y + 1) * ringVertexCount + (x));
            idx.push_back(1 + (y) * ringVertexCount + (x + 1));
            idx.push_back(1 + (y + 1) * ringVertexCount + (x + 1));
        }
    }

    // ë‚¨ê·¹ ì¸ë±ìŠ¤
    uint32 bottomIndex = static_cast<uint32>(vec.size()) - 1;
    uint32 lastRingStartIndex = bottomIndex - ringVertexCount;
    for (uint32 i = 0; i < sliceCount; ++i)
    {
        //  [last+i]-[last+i+1]
        //  |      /
        //  [bottom]
        idx.push_back(bottomIndex);
        idx.push_back(lastRingStartIndex + i);
        idx.push_back(lastRingStartIndex + i + 1);
    }

    shared_ptr<Mesh> mesh = make_shared<Mesh>();
    mesh->Init(vec, idx);
    Add(L"Sphere", mesh);
    return mesh;
}
```

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-16-1.png"/>
</p>
