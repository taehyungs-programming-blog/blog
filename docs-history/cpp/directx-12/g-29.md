---
layout: default
title: "29. Particle System"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/23)


## ì´ë¡ 

### 1. Particleì€ í•˜ë‚˜í•˜ë‚˜ ë§Œë“¤ì–´ì•¼ í• ê¹Œ?

ğŸ˜º ì•„ë˜ê·¸ë¦¼ê³¼ ê°™ì´ ìƒì„±ëœ Sphereì£¼ì˜ì— Particleì„ ë„£ìœ¼ë ¤í•œë‹¤. ì–´ë–»ê²Œ êµ¬í˜„í•˜ë©´ ë ê¹Œ?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-29-1.png"/>
</p>

ğŸ˜º Materialì„ í•˜ë‚˜í•˜ë‚˜ ë§Œë“¤ì–´ì„œ ë„£ìœ¼ë©´ ë ê¹Œ?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-29-2.png"/>
</p>

ğŸ˜º ë§¤ë²ˆ ì´ ë§ì€ Pipelineì„ ëŒë©´ì„œ?? ì´ê±´ ë„ˆë¬´ ë¹„íš¨ìœ¨ì ì´ë‹¤ ğŸ‘‰ DirectXì—ì„œ íš¨ìœ¨ì ì¸ ë°©ë²•ì„ ì¤€ë¹„í–ˆë‹¤.

```cpp
// Instancingì´ë¼ëŠ” ê¸°ë²•ìœ¼ë¡œ ì—¬ëŸ¬ Particleì„ í‘œí˜„í•  ì˜ˆì •ì´ë‹¤.
// Instancingì´ë€ ë­ëƒí•˜ë©´ ê¸°ì¡´ì—ëŠ” í•˜ë‚˜ì˜ Object(Material)ë¥¼ 
// Pipelineìœ¼ë¡œ ë³´ëƒˆë‹¤ê³  í•œë‹¤ë©´

// Instancingìœ¼ë¡œ Pipelineìœ¼ë¡œ í•˜ë‚˜ì˜ Objectë¥¼ ë³´ë‚´ê³ 
// ì¶œë ¥ì€ ì—¬ëŸ¬ê°œë¥¼ ë½‘ëŠ” ë°©ë²•ì´ë‹¤.

void Mesh::Render()
{
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

    // DrawIndexedInstancedì—ì„œ ëª‡ê°œì˜ Instanceë¥¼ ê·¸ë¦´ì§€ ì§€ì •
	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, 1/* í˜„ì¬ëŠ” ë¬´ì¡°ê±´ í•œ ê°œë¡œ ê·¸ë¦°ë‹¤ */, 0, 0, 0);

    // ì•„ë‹ˆ ì´ê²ƒë„ ê²°êµ­ Renderingí•´ë‹¬ë¼ëŠ”ê±° ì•„ë‹Œê°€?
        // ì•½ê°„ ë‹¤ë¥¸ê²Œ ì •ì ì •ë³´(IA)ë¥¼ í•œ ë²ˆë§Œ ë„˜ê²¨ì¤˜ë„ ëœë‹¤ëŠ” ì ì—ì„œ ë‹¤ë¥´ë‹¤.
        // ì •ì ì´ ê°„ë‹¨í•˜ë©´ ëª¨ë¥´ì§€ë§Œ ë³µì¡í•´ì§„ë‹¤ë©´ ì—°ì‚°ì— í° ì°¨ì´ë¥¼ ë³´ì¸ë‹¤.
}
```

* `DrawIndexedInstanced`ë¥¼ ì‚¬ìš©ì‹œ DirectXì—ì„œ IA(Input Assembler Stage)ë¥¼ ì œì™¸í•˜ê³  ë‚˜ë¨¸ì§€ Pipelineì„ ëŒì•„ì¤€ë‹¤

---

### 2. ê° Particleì˜ ìœ„ì¹˜, ì†ë„, í¬ê¸° ë“±ì€ ì–´ë””ì„œ ì§€ì •í•˜ë‚˜?

```cpp
// params.fx

// Particleì„ Constant Bufferë¡œ ë„˜ê¸°ë©´ë ê¹Œ?
    // Constant Bufferë¡œ ë„˜ê¸°ëŠ” ê°€ì¥ ëŒ€í‘œì ì¸ Lightë¥¼ ë³´ìë©´

cbuffer GLOBAL_PARAMS : register(b0)
{
    int         g_lightCount;
    float3      g_lightPadding;
    LightInfo   g_light[50];        
    // ë”± 50ê°œë§Œ ë„˜ê¸¸ìˆ˜ ìˆê²Œ ë§Œë“¤ì—ˆëŠ”ë° 
    // ì‚¬ì‹¤ Particleì´ ëª‡ê°œ ì¼ê±°ë€ ë³´ì¥ì´ ì—†ë‹¤.
        // ì´ê±¸ 1000ê°œë¡œ ë°”ê¿”ì„œ ë§Œë“¤ì–´ ë³¼ê¹Œ?
        // ë‚˜ì¤‘ì— 2000ê°œê°€ í•„ìš”í•˜ë©´?? 3000ê°œë©´??? -> ë‹¤ë¥¸ ë°©ë²•ì„ ê³ ë ¤í•´ë³´ì
}
```

ğŸ™€ ë˜ ë‹¤ë¥¸ ë¬¸ì œ1) Constant Bufferì´ìš©ì‹œ ë§¤ë²ˆ CPUë©”ëª¨ë¦¬ë¥¼ GPUë¡œ ì˜®ê²¨ì•¼ í•˜ëŠ”ë° ê·¸ ì†ë„ ë˜í•œ ë§¤ìš° ëŠë¦¬ë‹¤. Particleì´ ì»¤ì§€ë©´ ì»¤ì§ˆìˆ˜ë¡ ë¶€ë‹´ë„ ê°™ì´ ì»¤ì§€ê²Œ ëœë‹¤.

ğŸ˜º GPUë¡œ Particleì˜ ìœ„ì¹˜, ì†ë„, í¬ê¸°ë“±ì„ CPUì—ì„œ ë„˜ê¸°ëŠ”ê²Œ ì•„ë‹ˆë¼ í•„ìš”í•œ ì •ë³´ë¥¼ GPUìì²´ì—ì„œ ì—°ì‚°(Compute Shader)ì„ í•´ì„œ ì“°ê²Œ ë§Œë“¤ì–´ ì¤˜ì•¼í•œë‹¤.

ğŸ˜º (ì¶”ê°€ ì„¤ëª…) Constant Bufferë¥¼ GPUì—ì„œ ì“¸ ìˆ˜ ì—†ìŒ(ì´ë¦„ê·¸ëŒ€ë¡œ ìƒìˆ˜) ë”°ë¼ì„œ Constant Bufferì— ê°’ì— ì—°ì‚°ì´ í•„ìš”í•  ê²½ìš° ë˜ ìƒˆë¡œìš´ ë©”ëª¨ë¦¬ë¥¼ ì¡ì•„ì•¼ í•œë‹¤.

ğŸ± ë˜ ë‹¤ë¥¸ ë¬¸ì œ2) ìƒì„±ëœ Particleì„ ë§¤ë²ˆ ê°–ê³  ìˆì–´ì•¼ í• ê¹Œ ë©”ëª¨ë¦¬ ë¶€ë‹´ì´ ìƒë‹¹í• êº¼ ê°™ì€ë°?? 

ğŸ‘‰ ê·¸ë ¤ì§€ë©´ ì•ˆëœë‹¤ì˜ íŒë³„ê¸°ì¤€ì´ í•„ìš”í•´ì§„ë‹¤. (Geometry Shaderë¥¼ ì´ìš©í•˜ê²Œ ë˜ëŠ”ë°, ìì„¸í•œê±´ ì•„ë˜ì„œ ì°¸ì¡°)

- ê²°ë¡ ì€ Particle Systemì˜ ê²½ìš° ì–´ë”” ê·¸ë ¤ì§ˆì§€, ì–´ë–¤í¬ê¸°ë¡œ ê·¸ë ¤ì§ˆì§€, ì–¸ì œ ê·¸ë ¤ì§ˆì§€ ë“±ì€ GPUë‚´ì—ì„œ ë³„ë„ë¡œ ê²°ì •í•˜ê²Œ í•´ì•¼í•œë‹¤ëŠ” ê²ƒ!
- ì´ë ‡ê²Œ ìƒê°í•˜ë©´ í¸í• ë“¯ Compute Shaderì—ì„œ Particleì´ ì–´ë””,í¬ê¸°,ì–¸ì œ ê·¸ë ¤ì§ˆì§€ ê²°ì • í›„ Pipelineìœ¼ë¡œ ë³´ë‚´ê²Œ ëœë‹¤. Pipelineì„ ëŒë©° ê·¸ë ¤ì§€ë©° íŠ¹íˆ Geometry Shaderì—ì„œ ê·¸ë ¤ì§ˆì§€ ë§ì§€ ê²°ì •ë¨ì„ ì£¼ì˜í•´ì„œ ë³´ì

---

## êµ¬í˜„

### ì‰ì´ë” ë¶„ì„

```cpp
// particle.fx

struct Particle
{
    float3  worldPos;
    float   curTime;
    float3  worldDir;
    float   lifeTime;
    int     alive;
    float3  padding;
};

// ...

struct ComputeShared
{
    int addCount;
    float3 padding;
};

// RWStructuredBuffer : ì•„ì§ì€ ì´í•´ê°€ ì˜ ë˜ì§€ ì•Šê² ì§€ë§Œ ë°°ì—´ì´ë¼ ìƒê°í•˜ê³ 
// u0ì— ë°°ì—´ì˜ ì£¼ì†Œë¥¼ ë„£ì–´ë†¨ë‹¤ê³  ìƒê°í•˜ë©´ëœë‹¤.
RWStructuredBuffer<Particle> g_particle : register(u0);

// GPU Threadì—ì„œ ê³µìš©ìœ¼ë¡œ ì‚¬ìš©í•  ë©”ëª¨ë¦¬(ë³€ìˆ˜)
RWStructuredBuffer<ComputeShared> g_shared : register(u1);
```

```cpp
// Compute Shaderê°€ ë¨¼ì € ì‚¬ìš©ì´ ë˜ê¸°ì— ë¨¼ì € ë¶„ì„í•´ ë³´ìë©´

// CS_Main
// g_vec2_1 : DeltaTime / AccTime
// g_int_0  : Particle Max Count
// g_int_1  : AddCount
// g_vec4_0 : MinLifeTime / MaxLifeTime / MinSpeed / MaxSpeed
[numthreads(1024, 1, 1)]
void CS_Main(int3 threadIndex : SV_DispatchThreadID)
{
    /*
        // Compute Shader ì‚¬ìš©ì‹œ ì ˆëŒ€ ì£¼ì˜ì‚¬í•­!
        g_particle[threadIndex.x - 1] = XXX;
        * ë‚˜ ë§ê³  ë‹¤ë¥¸ Indexì˜ Threadë¥¼ ê±´ë“œë¦¬ë©´ ì ˆëŒ€ ì•ˆëœë‹¤.
        * ë³‘ë ¬ë¡œ ì²˜ë¦¬ë˜ê³  ìˆê¸°ì— ì—°ì‚°ì´ ëë‚¬ëŠ”ì§€ ì•ˆëë‚¬ëŠ”ì§€ ì•Œ ìˆ˜ì—†ìŒ.

        * ê³µìœ ìì›(g_shared)ë¥¼ ì‚¬ìš©í• ì‹œì— ì£¼ì˜í•´ì•¼í•œë‹¤. *
    */

    if (threadIndex.x >= g_int_0)
        return;

    int maxCount = g_int_0;
    int addCount = g_int_1;
    int frameNumber = g_int_2;
    float deltaTime = g_vec2_1.x;
    float accTime = g_vec2_1.y;
    float minLifeTime = g_vec4_0.x;
    float maxLifeTime = g_vec4_0.y;
    float minSpeed = g_vec4_0.z;
    float maxSpeed = g_vec4_0.w;

    // ì´ê±° ë„ˆë¬´ ìœ„í—˜í•˜ì§€ ì•Šë‚˜?
    // g_sharedëŠ” ëª¨ë“  threadì—ì„œ ì ‘ê·¼í•˜ëŠ” ë³€ìˆ˜ì¸ë° ì´ë ‡ê²Œ ê°’ì„ ì„¸íŒ…??
    // ì•„ë˜ì„œ ë³´ì™„ì½”ë“œë¥¼ ë„£ìŒ.
    g_shared[0].addCount = addCount;

    // GroupMemoryBarrierWithGroupSync();ê°€ ì‹ í˜¸ë“±ì´ ëœë‹¤.
    // ë‚˜ë¨¸ì§€ ThreadëŠ” ê¸°ë‹¤ë ¤!
    GroupMemoryBarrierWithGroupSync();

    // ê¸°ì¡´ì— ê·¸ë¦¬ì§€ ì•Šê³  ìˆì—ˆë‹¤ë©´ ( alive == 0 )
    if (g_particle[threadIndex.x].alive == 0)
    {
        // ê³µìœ ìì› ì ‘ê·¼ì„ ìœ„í•œ ì½”ë“œ
        while (true)
        {
           // ë¶€í™œì´ ê°€ëŠ¥í•œì§€ ì²´í¬í•œë‹¤. remainingì´ 0ì´ë©´ ë¶€í™œë¶ˆê°€ëŠ¥.
            int remaining = g_shared[0].addCount;
            if (remaining <= 0)
                break;

            int expected = remaining;
            int desired = remaining - 1;
            int originalValue;
            InterlockedCompareExchange(g_shared[0].addCount, expected, desired, originalValue);

            if (originalValue == expected)
            {
                g_particle[threadIndex.x].alive = 1;
                break;
            }
        }

        // ì•„ë˜ ì—°ì‚°ì€ Particleì„ ëŒ€ëµì  ê³„ì‚°(í¬ê²Œ ì¤‘ìš”í•˜ì§„ ì•ŠìŒ.)

        if (g_particle[threadIndex.x].alive == 1)
        {
            float x = ((float)threadIndex.x / (float)maxCount) + accTime;

            float r1 = Rand(float2(x, accTime));
            float r2 = Rand(float2(x * accTime, accTime));
            float r3 = Rand(float2(x * accTime * accTime, accTime * accTime));

            // [0.5~1] -> [0~1]
            float3 noise =
            {
                2 * r1 - 1,
                2 * r2 - 1,
                2 * r3 - 1
            };

            // [0~1] -> [-1~1]
            float3 dir = (noise - 0.5f) * 2.f;

            g_particle[threadIndex.x].worldDir = normalize(dir);
            g_particle[threadIndex.x].worldPos = (noise.xyz - 0.5f) * 25;
            g_particle[threadIndex.x].lifeTime = ((maxLifeTime - minLifeTime) * noise.x) + minLifeTime;
            g_particle[threadIndex.x].curTime = 0.f;
        }
    }
    else
    {
        g_particle[threadIndex.x].curTime += deltaTime;
        if (g_particle[threadIndex.x].lifeTime < g_particle[threadIndex.x].curTime)
        {
            g_particle[threadIndex.x].alive = 0;
            return;
        }

        float ratio = g_particle[threadIndex.x].curTime / g_particle[threadIndex.x].lifeTime;
        float speed = (maxSpeed - minSpeed) * ratio + minSpeed;
        g_particle[threadIndex.x].worldPos += g_particle[threadIndex.x].worldDir * speed * deltaTime;
    }
}
```

```cpp
// ëœë¤ì„ ë§Œë“¤ê¸° ìœ„í•œ í•¨ìˆ˜
// ì¼ë°˜ì ìœ¼ë¡œ ì´ë ‡ê²Œ ì“°ë‹ˆ ë„ˆë¬´ ê³ ë¯¼ ë§ê³  ê·¸ëƒ¥ ì“°ì.
	// í˜¹ì€ ë…¸ì´ì¦ˆ í…ìŠ¤ì³ë¡œ ëœë¤í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ”ë° ê·¸ëƒ¥ ì•Œì•„ë§Œ ë‘ì.
float Rand(float2 co)
{
    return 0.5 + (frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 0.5;
}
```

ğŸ˜º Compute Shaderì˜ ì—°ì‚°ì„ ë§ˆì¹œ í›„

```cpp
// Compute Shaderì— ì˜í•´ ì—°ì‚°ëœ ê²°ê³¼ê°€ 
// Vertex Shaderì— ë“¤ì–´ê°€ê²Œ ëœë‹¤.
    // (t9ì¸ê±¸ë¡œ ë´ì„  Textureë¡œ ë“¤ì–´ê°)
StructuredBuffer<Particle> g_data : register(t9);

struct VS_OUT
{
    float4 viewPos : POSITION;
    float2 uv : TEXCOORD;
    float id : ID;
};

// VS_MAIN
// g_float_0    : Start Scale
// g_float_1    : End Scale
// g_tex_0      : Particle Texture

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0.f;

    float3 worldPos = mul(float4(input.pos, 1.f), g_matWorld).xyz;

    // indexë¡œ particleì„ ì°¾ì•„ì„œ ìœ„ì¹˜ë¥¼ ë³€í™˜í•´ ì¤€ë‹¤
    worldPos += g_data[input.id].worldPos;

    output.viewPos = mul(float4(worldPos, 1.f), g_matView);
    output.uv = input.uv;
    output.id = input.id;

    return output;
}
```

ğŸ˜º ë§ˆì§€ë§‰ìœ¼ë¡œ Geometry Shaderì—ì„œ ê·¸ë ¤ì¤„ì§€ ë§ì§€ ê²°ì •

```cpp
struct GS_OUT
{
    float4 position : SV_Position;
    float2 uv : TEXCOORD;
    uint id : SV_InstanceID;
};

[maxvertexcount(6)]
void GS_Main(point/*ì  í•˜ë‚˜ë§Œ ë„˜ì–´ê°‘ë‹ˆë‹¤.*/ VS_OUT input[1], 
inout TriangleStream<GS_OUT> outputStream)
{
    // Vertex Shaderì˜ ê²°ê³¼(input)ê°€ Geometry Shaderë¡œ ë“¤ì–´ê°€ê²Œ ë˜ê³ 
    // 

    GS_OUT output[4] =
    {
        (GS_OUT)0.f, (GS_OUT)0.f, (GS_OUT)0.f, (GS_OUT)0.f
    };

    VS_OUT vtx = input[0];
    uint id = (uint)vtx.id;
    if (0 == g_data[id].alive)
        // ê·¸ë¦´ í•„ìš”ê°€ ì—†ëŠ”ê²½ìš° ê·¸ëƒ¥ return í•´ë²„ë¦¬ì.
        return;

    float ratio = g_data[id].curTime / g_data[id].lifeTime;
    float scale = ((g_float_1 - g_float_0) * ratio + g_float_0) / 2.f;

    // View Space
    output[0].position = vtx.viewPos + float4(-scale, scale, 0.f, 0.f);
    output[1].position = vtx.viewPos + float4(scale, scale, 0.f, 0.f);
    output[2].position = vtx.viewPos + float4(scale, -scale, 0.f, 0.f);
    output[3].position = vtx.viewPos + float4(-scale, -scale, 0.f, 0.f);

    // Projection Space
    output[0].position = mul(output[0].position, g_matProjection);
    output[1].position = mul(output[1].position, g_matProjection);
    output[2].position = mul(output[2].position, g_matProjection);
    output[3].position = mul(output[3].position, g_matProjection);

    output[0].uv = float2(0.f, 0.f);
    output[1].uv = float2(1.f, 0.f);
    output[2].uv = float2(1.f, 1.f);
    output[3].uv = float2(0.f, 1.f);

    output[0].id = id;
    output[1].id = id;
    output[2].id = id;
    output[3].id = id;

    outputStream.Append(output[0]);
    outputStream.Append(output[1]);
    outputStream.Append(output[2]);
    outputStream.RestartStrip();

    outputStream.Append(output[0]);
    outputStream.Append(output[2]);
    outputStream.Append(output[3]);
    outputStream.RestartStrip();
}
```

---

### C++ ë¶„ì„

```cpp
class StructuredBuffer
{
public:
	StructuredBuffer();
	~StructuredBuffer();

	void Init(uint32 elementSize, uint32 elementCount);

	void PushGraphicsData(SRV_REGISTER reg);
	void PushComputeSRVData(SRV_REGISTER reg);
	void PushComputeUAVData(UAV_REGISTER reg);

	ComPtr<ID3D12DescriptorHeap> GetSRV() { return _srvHeap; }
	ComPtr<ID3D12DescriptorHeap> GetUAV() { return _uavHeap; }

	void SetResourceState(D3D12_RESOURCE_STATES state) { _resourceState = state; }
	D3D12_RESOURCE_STATES GetResourceState() { return _resourceState; }
	ComPtr<ID3D12Resource> GetBuffer() { return _buffer; }

private:
	ComPtr<ID3D12Resource>			_buffer;
	ComPtr<ID3D12DescriptorHeap>	_srvHeap;
	ComPtr<ID3D12DescriptorHeap>	_uavHeap;

	uint32						_elementSize = 0;
	uint32						_elementCount = 0;
	D3D12_RESOURCE_STATES		_resourceState = {};

private:
	D3D12_CPU_DESCRIPTOR_HANDLE _srvHeapBegin = {};
	D3D12_CPU_DESCRIPTOR_HANDLE _uavHeapBegin = {};
};
```

```cpp
struct ParticleInfo
{
	Vec3	worldPos;
	float	curTime;
	Vec3	worldDir;
	float	lifeTime;
	int32	alive;
	int32	padding[3];
};

struct ComputeSharedInfo
{
	int32 addCount;
	int32 padding[3];
};

class ParticleSystem : public Component
{
public:
	ParticleSystem();
	virtual ~ParticleSystem();

public:
	virtual void FinalUpdate();
	void Render();

public:
	virtual void Load(const wstring& path) override { }
	virtual void Save(const wstring& path) override { }

private:
	shared_ptr<StructuredBuffer>	_particleBuffer;
	shared_ptr<StructuredBuffer>	_computeSharedBuffer;
	uint32							_maxParticle = 1000;

	shared_ptr<Material>		_computeMaterial;
	shared_ptr<Material>		_material;
	shared_ptr<Mesh>			_mesh;

	float				_createInterval = 0.005f;
	float				_accTime = 0.f;

	float				_minLifeTime = 0.5f;
	float				_maxLifeTime = 1.f;
	float				_minSpeed = 100;
	float				_maxSpeed = 50;
	float				_startScale = 10.f;
	float				_endScale = 5.f;
};
```

```cpp
ParticleSystem::ParticleSystem() : Component(COMPONENT_TYPE::PARTICLE_SYSTEM)
{
	_particleBuffer = make_shared<StructuredBuffer>();
	_particleBuffer->Init(sizeof(ParticleInfo), _maxParticle);

	_computeSharedBuffer = make_shared<StructuredBuffer>();
	_computeSharedBuffer->Init(sizeof(ComputeSharedInfo), 1);

	_mesh = GET_SINGLE(Resources)->LoadPointMesh();
	_material = GET_SINGLE(Resources)->Get<Material>(L"Particle");
	shared_ptr<Texture> tex = GET_SINGLE(Resources)->Load<Texture>(
		L"Bubbles", L"..\\Resources\\Texture\\Particle\\bubble.png");

	_material->SetTexture(0, tex);

	_computeMaterial = GET_SINGLE(Resources)->Get<Material>(L"ComputeParticle");
}

ParticleSystem::~ParticleSystem()
{
}

void ParticleSystem::FinalUpdate()
{
	_accTime += DELTA_TIME;

	int32 add = 0;
	if (_createInterval < _accTime)
	{
		_accTime = _accTime - _createInterval;
		add = 1;
	}

	_particleBuffer->PushComputeUAVData(UAV_REGISTER::u0);
	_computeSharedBuffer->PushComputeUAVData(UAV_REGISTER::u1);

	_computeMaterial->SetInt(0, _maxParticle);
	_computeMaterial->SetInt(1, add);

	_computeMaterial->SetVec2(1, Vec2(DELTA_TIME, _accTime));
	_computeMaterial->SetVec4(0, Vec4(_minLifeTime, _maxLifeTime, _minSpeed, _maxSpeed));

	_computeMaterial->Dispatch(1, 1, 1);
}

void ParticleSystem::Render()
{
	GetTransform()->PushData();

	_particleBuffer->PushGraphicsData(SRV_REGISTER::t9);
	_material->SetFloat(0, _startScale);
	_material->SetFloat(1, _endScale);
	_material->PushGraphicsData();

	_mesh->Render(_maxParticle);
}
```
