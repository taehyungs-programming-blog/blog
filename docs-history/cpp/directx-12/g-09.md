---
layout: default
title: "09. Keyboard Input & Timer"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/9)

ğŸ˜º ê·¸ë¦¬ ì–´ë µì§€ ì•Šê¸°ì— ì„¤ëª…ì€ ì£¼ì„ìœ¼ë¡œ ì²˜ë¦¬

## Input

```cpp
// í‚¤ë³´ë“œ ì…ë ¥ì„ ë°›ì•„ì„œ ì´ë™ì‹œí‚¤ê¸°

void Game::Update()
{
	GEngine->Update();

	GEngine->RenderBegin();

	shader->Update();

	{
		static Transform t = {};
		
        // Keyboard inputì„ ë°›ì•„ì„œ ë„¤ëª¨ë¥¼ ì•½ê°„ì”© ì´ë™í•˜ê³ ì í•œë‹¤.
		if (INPUT->GetButton(KEY_TYPE::W))
			t.offset.y += 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::S))
			t.offset.y -= 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::A))
			t.offset.x -= 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::D))
			t.offset.x += 1.f * DELTA_TIME;

		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	}
```

```cpp
#pragma once

enum class KEY_TYPE
{
	UP = VK_UP,
	DOWN = VK_DOWN,
	LEFT = VK_LEFT,
	RIGHT = VK_RIGHT,

	W = 'W',
	A = 'A',
	S = 'S',
	D = 'D',
};

enum class KEY_STATE
{
	NONE,
	PRESS,
	DOWN,
	UP,
	END
};

enum
{
	KEY_TYPE_COUNT = static_cast<int32>(UINT8_MAX),
	KEY_STATE_COUNT = static_cast<int32>(KEY_STATE::END),
};

class Input
{
public:
	void Init(HWND hwnd);
	void Update();

	// ëˆ„ë¥´ê³  ìˆì„ ë•Œ
	bool GetButton(KEY_TYPE key) { return GetState(key) == KEY_STATE::PRESS; }
	// ë§¨ ì²˜ìŒ ëˆŒë €ì„ ë•Œ
	bool GetButtonDown(KEY_TYPE key) { return GetState(key) == KEY_STATE::DOWN; }
	// ë§¨ ì²˜ìŒ ëˆŒë €ë‹¤ ë—ì„ ë•Œ
	bool GetButtonUp(KEY_TYPE key) { return GetState(key) == KEY_STATE::UP; }

private:
	inline KEY_STATE GetState(KEY_TYPE key) { return _states[static_cast<uint8>(key)]; }

private:
	HWND _hwnd;     // êµ³ì´ í•¸ë“¤ì„ ë°›ëŠ” ì´ìœ ëŠ” í˜„ì¬ ê²Œì„ì—ì„œë§Œ Inputì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ì„œì´ë‹¤
	vector<KEY_STATE> _states;
};
```

```cpp
#include "pch.h"
#include "Input.h"


void Input::Init(HWND hwnd)
{
	_hwnd = hwnd;
	_states.resize(KEY_TYPE_COUNT, KEY_STATE::NONE);
}

void Input::Update()
{
	HWND hwnd = ::GetActiveWindow();
	if (_hwnd != hwnd)
	{
		for (uint32 key = 0; key < KEY_TYPE_COUNT; key++)
			_states[key] = KEY_STATE::NONE;

		return;
	}

	for (uint32 key = 0; key < KEY_TYPE_COUNT; key++)
	{
		// í‚¤ê°€ ëˆŒë ¤ ìˆìœ¼ë©´ true
		if (::GetAsyncKeyState(key) & 0x8000)
		{
			KEY_STATE& state = _states[key];

			// ì´ì „ í”„ë ˆì„ì— í‚¤ë¥¼ ëˆ„ë¥¸ ìƒíƒœë¼ë©´ PRESS
			if (state == KEY_STATE::PRESS || state == KEY_STATE::DOWN)
				state = KEY_STATE::PRESS;
			else
				state = KEY_STATE::DOWN;
		}
		else
		{
			KEY_STATE& state = _states[key];

			// ì´ì „ í”„ë ˆì„ì— í‚¤ë¥¼ ëˆ„ë¥¸ ìƒíƒœë¼ë©´ UP
			if (state == KEY_STATE::PRESS || state == KEY_STATE::DOWN)
				state = KEY_STATE::UP;
			else
				state = KEY_STATE::NONE;
		}
	}
}
```

---

## Timer

```cpp
#pragma once


class Timer
{
public:
	void Init();
	void Update();

	uint32 GetFps() { return _fps; }
	float GetDeltaTime() { return _deltaTime; }

private:
	uint64	_frequency = 0;
	uint64	_prevCount = 0;
	float	_deltaTime = 0.f;

private:
	uint32	_frameCount = 0;
	float	_frameTime = 0.f;
	uint32	_fps = 0;
};
```

```cpp
#include "pch.h"
#include "Timer.h"

void Timer::Init()
{
	// GetTickCount64()ë¥¼ ì•ˆì“°ëŠ” ì´ìœ ?? -> ì •ë°€ë„ê°€ ë¶€ì¡±í•¨.
	::QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&_frequency));
	::QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&_prevCount)); // CPU í´ëŸ­
}

void Timer::Update()
{
	uint64 currentCount;
	::QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&currentCount));

	_deltaTime = (currentCount - _prevCount) / static_cast<float>(_frequency);
	_prevCount = currentCount;

	_frameCount++;
	_frameTime += _deltaTime;

	// 1ì´ˆë§ˆë‹¤ ê°±ì‹ í•´ì£¼ì„¸ìš”
	if (_frameTime > 1.f)
	{
		_fps = static_cast<uint32>(_frameCount / _frameTime);

		_frameTime = 0.f;
		_frameCount = 0;
	}
}
```

---

## ë³µìŠµ

```cpp
void Game::Update()
{
	GEngine->Update();
    /*
        // ì—…ë°ì´íŠ¸
        void Engine::Update()
        {
            _input->Update();
            _timer->Update();

            ShowFps();
        }
    */

	GEngine->RenderBegin();
    /*
        void Engine::RenderBegin()
        {
            _cmdQueue->RenderBegin(&_viewport, &_scissorRect);
        }
    */

	shader->Update();

	{
		static Transform t = {};
		
        // transform offsetì„ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•?
		if (INPUT->GetButton(KEY_TYPE::W))
			t.offset.y += 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::S))
			t.offset.y -= 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::A))
			t.offset.x -= 1.f * DELTA_TIME;
		if (INPUT->GetButton(KEY_TYPE::D))
			t.offset.x += 1.f * DELTA_TIME;

		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	}
```

```cpp
void Mesh::Render()
{
    // CommandQueueë¥¼ í†µí•´ InputAssembleì— vertext, index bufferë¥¼ ë„˜ê¸´ë‹¤.
	CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
	CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	{
        // GPUë©”ëª¨ë¦¬ì— transformì„ ë„˜ê¸°ê³ 
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
        /*
            D3D12_CPU_DESCRIPTOR_HANDLE ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size)
            {
                assert(_currentIndex < _elementSize);

                ::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

                D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
                
                _currentIndex++;

                return cpuHandle;
            }
        */
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);
		GEngine->GetTableDescHeap()->SetSRV(_tex->GetCpuHandle(), SRV_REGISTER::t0);
	}

    // ë ˆì§€ìŠ¤í„°ì— ì˜¬ë ¤ë‹¬ë¼ê³  ëª…ë ¹
	GEngine->GetTableDescHeap()->CommitTable();

	CMD_LIST->DrawIndexedInstanced(_indexCount, 1, 0, 0, 0);
}
```