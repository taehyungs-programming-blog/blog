---
layout: default
title: "03. ì‚¼ê°í˜• ë ˆìŠ¤í„°í™”"
parent: "(Graphics Rasterize ğŸ’¥)"
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Git Clone ğŸŒ](https://github.com/EasyCoding-7/Directx11_Rasterization/tree/1/1_Triangle)

## ì´ë¡ 

* ì—¬ê¸°ì„œ í•  ê²ƒì€ ë‚´ê°€ ê·¸ë¦´ Pixelì˜ ê°’ì´ ì‚¼ê°í˜•ì•ˆì— ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ƒì¸ë°
* ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ???
    * ì‚¬ì‹¤ ì´ì „ì‹œê°„ì— ë°°ìš´ **ë¬´ê²Œ ì¤‘ì‹¬ ì¢Œí‘œê³„**ë¥¼ ì´ìš©í•˜ë©´ ëœë‹¤.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/d11/d11-3-1.jpg"/>
</p>

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/d11/d11-3-2.jpg"/>
</p>

* ì„¸ Edgeì— ëŒ€í•´ ëª¨ë‘ Edge Functionì„ ëŒë¦¬ë©´ ë˜ê² êµ°??

---

## êµ¬í˜„

```cpp
float Rasterization::EdgeFunction(const vec2 &v0, const vec2 &v1,
                                  const vec2 &point) {

    // ì–´ë–¤ 3ì°¨ì› ë²¡í„° a = (ax, ay, az)ì™€ b = (bx, by, bz)ê°€ ìˆì„ ë•Œ,
    // a x b = (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx) ì´ë‹¤.
    // ì•ì—ì„œëŠ” glm::cross()ë¡œ ê°„ë‹¨íˆ ê³„ì‚°
    // ì—¬ê¸°ì„œëŠ” 3ì°¨ì› ì •ì ë“¤ì„ 2ì°¨ì› í‰ë©´ìœ¼ë¡œ íˆ¬ì˜í–ˆê¸° ë•Œë¬¸ì—
    // azì™€ bzê°€ ë‘˜ ë‹¤ 0ì´ë¼ê³  ë†“ê³  ê³„ì‚°í•˜ë©´
    // a x b = (0, 0, ax*by - ay*bx)
    // ì—¬ê¸°ì„œ ax*by - ay*bx ë°˜í™˜

    const vec2 a = v1 - v0;
    const vec2 b = point - v0;
    return a.x * b.y - a.y * b.x;
}
```

```cpp
void Rasterization::Render(vector<vec4> &pixels) {

    // DirectXì—ì„œ ìë™ìœ¼ë¡œ ì²˜ë¦¬í•´ì£¼ëŠ” ë¶€ë¶„ë“¤ì´ê¸° ë•Œë¬¸ì— íë¦„ë§Œ ë´ë‘ì…”ë„
    // ì¶©ë¶„í•©ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ ë‚´ë¶€ì ìœ¼ë¡œ í•˜ë“œì›¨ì–´ ì œì¡°ì‚¬ì—ì„œ ê°œë°œí•œ ë“œë¼ì´ë²„ë¥¼
    // ì‚¬ìš©í•©ë‹ˆë‹¤.
    // https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage

    // ì‚¼ê°í˜•ì„ í•˜ë‚˜ë§Œ ê·¸ë¦¬ëŠ” ê²½ìš°ì…ë‹ˆë‹¤.
    // ë’¤ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ì‚¼ê°í˜•ìœ¼ë¡œ í™•ì¥í•´ë´…ì‹œë‹¤.

    // World ì¢Œí‘œê³„ì— ì •ì˜ëœ ì •ì ì˜ ì¢Œí‘œë“¤ì„ Screen Raster ì¢Œí‘œê³„ë¡œ ë³€í™˜
    // ë³€ìˆ˜ ì´ë¦„ì„ ê°„ë‹¨íˆ í•˜ê¸° ìœ„í•´ì„œ v0, v1, v2ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ ì¢Œí‘œê³„ê°€
    // ë‹¤ë¦…ë‹ˆë‹¤.
    const auto v0 = ProjectWorldToRaster(triangle.v0.pos);
    const auto v1 = ProjectWorldToRaster(triangle.v1.pos);
    const auto v2 = ProjectWorldToRaster(triangle.v2.pos);

    // Bounding box ì°¾ê¸° (xMin, yMin, xMax, yMax)

    // min(), max(), clamp()ê°€ std::ì™€ glm::ì— ëª¨ë‘ ì •ì˜ë˜ì–´ ìˆì–´ì„œ
    // glm::min()ê³¼ ê°™ì´ êµ¬ì²´ì ìœ¼ë¡œ ì ì–´ì¤¬ìŠµë‹ˆë‹¤.
    // glm::min(), std::min() ì¤‘ ì–´ë–¤ ê²ƒì„ ì‚¬ìš©í•´ë„ ìƒê´€ ì—†ìŠµë‹ˆë‹¤.
    // std::min({a, b, c})ëŠ” a, b, c ì¤‘ì—ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ë°˜í™˜í•´ì¤ë‹ˆë‹¤.

    const auto xMin = size_t(glm::clamp(
        glm::floor(std::min({v0.x, v1.x, v2.x})), 0.0f, float(width - 1)));
    const auto yMin = size_t(glm::clamp(
        glm::floor(std::min({v0.y, v1.y, v2.y})), 0.0f, float(height - 1)));
    const auto xMax = size_t(glm::clamp(glm::ceil(std::max({v0.x, v1.x, v2.x})),
                                        0.0f, float(width - 1)));
    const auto yMax = size_t(glm::clamp(glm::ceil(std::max({v0.y, v1.y, v2.y})),
                                        0.0f, float(height - 1)));

    // Bounding boxì— í¬í•¨ë˜ëŠ” í”½ì…€ë“¤ì˜ ìƒ‰ ê²°ì •
    for (size_t j = yMin; j <= yMax; j++) {
        for (size_t i = xMin; i <= xMax; i++) {

            // Rasterizing a triangle
            // 1. í”½ì…€ì´ ì‚¼ê°í˜•ì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸
            // 2. í”½ì…€ì˜ ìƒ‰ ê²°ì •
            // ì°¸ê³ : A Parallel Algorithm for Polygon Rasterization

            // 3Dì—ì„œ bary centric coordinates êµ¬í•˜ë˜ ê²ƒê³¼ ë™ì¼í•œë°
            // 2Dë¼ì„œ zê°’ì„ 0ìœ¼ë¡œ ê³ ì •í•˜ë©´ ê°„ë‹¨í•´ì§

            const vec2 point = vec2(float(i), float(j));

            const float alpha0 = EdgeFunction(v1, v2, point);
            const float alpha1 = EdgeFunction(v2, v0, point);
            const float alpha2 = EdgeFunction(v0, v1, point);

            if (alpha0 >= 0.0f && alpha1 >= 0.0f && alpha2 >= 0.0f) {
                // ì—¬ê¸°ì— ë“¤ì–´ì™”ë‹¤ëŠ” ê²ƒì€ ì‚¼ê°í˜• ë‚´ì— ì†í•œë‹¤ëŠ” ë§.
                
                const float area = alpha0 + alpha1 + alpha2;

                // í”½ì…€ì˜ ìƒ‰ ê²°ì •
                // ì£¼ì˜: ì›ê·¼íˆ¬ì˜(perspective projection)ì—ì„œëŠ”
                // depth ê°’ì„ ê³ ë ¤í•´ì„œ ë³´ì •í•´ì¤˜ì•¼ í•©ë‹ˆë‹¤.

                // ë„“ì´ë¡œ ë‚˜ëˆ ì¤ë‹ˆë‹¤.
                const float w0 = alpha0 / area;
                const float w1 = alpha1 / area;
                const float w2 = alpha2 / area;


                // Bary-centric coordinatesë¥¼ ì´ìš©í•´ì„œ color interpolation
                const vec3 color =
                    (w0 * triangle.v0.color + w1 * triangle.v1.color +
                     w2 * triangle.v2.color);

                pixels[i + width * j] = vec4(color, 1.0f);
            }
        }
    }
}
```