---
layout: default
title: "05. 2μ°¨μ› λ³€ν™"
parent: "(Graphics Rasterize π’¥)"
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Git Clone π](https://github.com/EasyCoding-7/Directx11_Rasterization/tree/3/3_Transformations)

## μ΄λ΅ 

* x, y Scale / νμ „(Translation) λ“±μ„ κµ¬ν„ν•΄λ³΄μ

```
* νμ „μ‹λ§ μ λ„ν•΄ λ³΄μλ©΄ ...
x = r * cos(a)
y = r * sin(a)

// bλ§νΌ νμ „ν•΄ λ³΄μ
x' = r * cos(a + b)
y' = r * sin(a + b)

x' = r * cos(a + b)
   = r * cos(a)cos(b) - r * sin(a)sin(b)
   = x * cos(b) - y * sin(b)
y' = r * sin(a + b)
   = r * cos(a)sin(b) + r * sin(a)cos(b)
   = x * sin(b) + y * cos(b)
```

---

## κµ¬ν„

```cpp
vec3 RotateAboutZ(const vec3 &v, const float &theta) { 
    return vec3(v.x * cos(theta) - v.y * sin(theta),
                v.x * sin(theta) + v.y * cos(theta), v.z);
}

void Rasterization::Update() {
    // μ• λ‹λ©”μ΄μ… κµ¬ν„

    // GUI μ…λ ¥μ— λ€ν•΄μ„ vertexBuffer μ—…λ°μ΄νΈ
    // μ΄ μμ μ—μ„λ” this->vertexBufferλ§ μ—…λ°μ΄νΈν•κ³ 
    // colorBufferμ™€ indexBufferλ” λ³€ν™” μ—†μ

    for (size_t i = 0; i < circle.vertices.size(); i++) {
        auto temp = RotateAboutZ(circle.vertices[i], this->rotation1);
        temp = temp * vec3(scaleX, scaleY, 1.0f);
        temp = temp + this->translation1;
        temp = RotateAboutZ(temp, this->rotation2);
        temp = temp + this->translation2;
        this->vertexBuffer[i] = temp;
    }

    // μ¤‘μ”: λ²„ν…μ¤ μ‰μ΄λ”(Vertex shader)κ°€ ν•λ” μΌλ“¤μ…λ‹λ‹¤.
}
```

---

## 2μ°¨μ› μ• λ‹λ©”μ΄μ…

* μ‰½κΈ°μ— λ³„λ„ μ •λ¦¬μ•ν•¨

* [Git Clone π](https://github.com/EasyCoding-7/Directx11_Rasterization/tree/4/4_animation)