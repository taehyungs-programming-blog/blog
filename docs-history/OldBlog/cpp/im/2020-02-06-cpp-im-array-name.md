---
title: "(C++) 배열의 이름은 배열의 주소일까?"
date: 2020-02-06 00:00:00 -0000
---

```cpp
int main()
{
  int x[3] = { 1, 2, 3 };
  
  int *p = x;   // 배열의 이름은 배열의 주소일까???
}
```

```cpp
int main()
{
  // 자료형의 포인터 변수는 아래와 같이 만든다.
  int n;    // 변수 이름 : n, 타입 : int
  int *p1 = &n;
  double d;   // 변수 이름 : d, 타입 : double
  double *p2 = &d;
  
  // 그럼 배열의 포인터 변수는??
  int x[3] = { 1, 2, 3 };   // 변수이름 : x, 타입 : int[3]
  
  // 배열 x의 주소..
  int (*p3)[3] = &x;
  // (*p3)괄호를 붙이는 이유는 컴파일러에게 포인터의 주소를 알려달라고, 배열로 보지말고 알려주는 선언이다.
  
  int * p4 = x;   // 이것은 배열의 주소가 아니다!
}
```

```cpp
int main()
{
  // 모든 변수는 자신과 동일한 타입의 변수로 초기화(복사) 될 수 있다.
  int n1 = 10;
  int n2 = n1;
  double d1 = 3.4;
  double d2 = d1;
  
  // 배열의 경우??
  int x1[3] = { 1, 2, 3 };    // x1의 타입 : int[3]
  int x2[3] = x1;   // 가능한가? -> Nope, 배열은 자신과 동일한 타입의 배열로 복사가 안됨.
  
  int * p1 = x1;    // 배열의 이름은 첫 번째 요소의 주소로 암시적 형변환된다.
}
```

```cpp
// 배열의 주소와 배열의 요소의 주소는 뭐가 다른가???
#include <stdio.h>

int main()
{
  int x[3] = { 1, 2, 3 };
  
  int (*p1)[3] = &x;    // 배열의 주소
  int *p2 = x;          // 배열의 이름이 배열의 첫 번째 요소의 주소로 암시적 형 변환
  
  printf("%p\n", p1);
  printf("%p\n", p2);
  // 컴파일 해보면 같은 값이 나옴
  // 엥??? 그럼 결국 같은거 아니냐?
  // 아니다!!
  // 모든 컴파일러는 +1을 할경우 자신이 갖는 자료형의 size만큼 커진다.
  // 거기서 차이가 발생
  p1 = p1 + 1;    // 12 바이트 올라감
  p2 = p2 + 1;    // 4 바이트 올라감
}
```

```cpp
#include <stdio.h>

int main()
{
  int x[3] = { 1, 2, 3 };
  
  int (*p1)[3] = &x;
  int *p2 = x;
  
  printf("%p, %p\n", p1, p1+1);
  printf("%p, %p\n", p2, p2+1);
  
  // p1은 배열의 주소, *p1 : 배열이 나온다.
  (*p1)[0] = 10; // 첫 번째 요소를 10으로
  *p2 = 10;      // 역시 첫 번째 요소를 10으로
}
```