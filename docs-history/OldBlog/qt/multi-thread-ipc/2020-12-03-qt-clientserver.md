---
title: "(Qt) ClientServer"
permalink: qt/mthread-ipc/clientserver/                # link 직접 지정
#toc: true                       # for Sub-title (On this page)
comments: true                  # for disqus Comments
categories:                     # for categories
date: 2020-12-02 00:00:00 -0000
last_modified_at: 2020-12-02 00:00:00 -0000
sidebar:
  title: "Qt 목차"
  nav: Qt
tag:
  - Qt
  - Multi Thread
category:
  - ClientServer
excerpt: ""
classes: wide
header:
  teaser: /file/image/nodejs-page-teaser.gif
---

* [Get Code](https://github.com/EasyCoding-7/Qt-MultiThread-IPC-Example/tree/master/DBus)

DBus를 통한 IPC

---

## Client

widget.h

```cpp
/*
 *          This example is the client side of our example of dbus, exposing
 *          a calculator in the server part and using it in the client.
 *
 *              . The client uses the interface exposed from the server to call
 *                stuff on the server object.
 *
 *              . Interface class is generated from xml interface descriptor file,
 *                see info in comments in server widget.h.
 *
 *
 *              . We instantiate the interface in the constructor and give it clear
 *                information on the , service, path and dbus connection.
 *
 *              . For the rest, make sure you just explain the concepts of dbus in
 *                the slides you're going to put together.
 *
 * */

#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>
#include <calculatorInterface.h>

namespace Ui {
class Widget;
}

class Widget : public QWidget
{
    Q_OBJECT

public:
    explicit Widget(QWidget *parent = nullptr);
    ~Widget();



private slots:
    void on_multiplyButton_clicked();

    void on_divideButton_clicked();

private:
    Ui::Widget *ui;
    com::blikoon::CalculatorInterface * calculatorHandle;
};

#endif // WIDGET_H
```

widget.cpp

```cpp
#include "widget.h"
#include "ui_widget.h"
#include <QDebug>


Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
{
    ui->setupUi(this);


    calculatorHandle = new com::blikoon::CalculatorInterface("com.blikoon.CalculatorService",
                                                             "/CalcServicePath",
                                                             QDBusConnection::sessionBus());
}

Widget::~Widget()
{
    delete ui;
}



void Widget::on_multiplyButton_clicked()
{
    if(calculatorHandle->isValid()){
        double result = calculatorHandle->multiply(ui->number1SpinBox->value(),ui->number2SpinBox->value());
        ui->resultLineEdit->setText(QString::number(result));
    }else{
        qCritical() << "Calculator Interface is not valid";
    }

}

void Widget::on_divideButton_clicked()
{
    if(calculatorHandle->isValid()){
        double result = calculatorHandle->divide(ui->number1SpinBox->value(),ui->number2SpinBox->value());
        ui->resultLineEdit->setText(QString::number(result));
    }else{
        qCritical() << "Calculator Interface is not valid";
    }
}
```

calculatorInterface.h

```cpp
/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -p calculatorInterface slavecalculator.xml
 *
 * qdbusxml2cpp is Copyright (C) 2019 The Qt Company Ltd.
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef CALCULATORINTERFACE_H
#define CALCULATORINTERFACE_H

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

/*
 * Proxy class for interface com.blikoon.CalculatorInterface
 */
class ComBlikoonCalculatorInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "com.blikoon.CalculatorInterface"; }

public:
    ComBlikoonCalculatorInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = nullptr);

    ~ComBlikoonCalculatorInterfaceInterface();

public Q_SLOTS: // METHODS
    inline QDBusPendingReply<double> divide(double divident, double divisor)
    {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(divident) << QVariant::fromValue(divisor);
        return asyncCallWithArgumentList(QStringLiteral("divide"), argumentList);
    }

    inline QDBusPendingReply<double> multiply(double factor1, double factor2)
    {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(factor1) << QVariant::fromValue(factor2);
        return asyncCallWithArgumentList(QStringLiteral("multiply"), argumentList);
    }

Q_SIGNALS: // SIGNALS
};

namespace com {
  namespace blikoon {
    typedef ::ComBlikoonCalculatorInterfaceInterface CalculatorInterface;
  }
}
#endif
```

---

## Server

```cpp

```