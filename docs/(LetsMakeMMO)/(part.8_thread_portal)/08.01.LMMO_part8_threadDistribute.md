---
layout: default
title: "08-01. Thread ë¶„ë¦¬"
parent: "(08. Threadë¶„ë¦¬ì™€ Portal ë§Œë“¤ê¸°)"
grand_parent: "(MMORPG ë§Œë“¤ì–´ ë³´ê¸° ğŸ¤©)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒŸ](https://github.com/Arthur880708/LetMakeMMO/tree/8)

---

```csharp
class Program
{
    static Listener _listener = new Listener();
    static Connector _connector = new Connector();

    static void Main(string[] args)
    {
        ConfigManager.LoadConfig();
        DataManager.LoadData();

        IPAddress ipAddr = IPAddress.Parse(ConfigManager.Config.ip);			
        IPEndPoint endPoint = new IPEndPoint(ipAddr, ConfigManager.Config.port);
        _listener.Init(endPoint, () => { return SessionManager.Instance.Generate(); });
        
        Console.WriteLine("Listening...");

        // GameLogic
            // ì—¬ê¸°ë¥¼ ë³´ë©´ ë˜ê² ì§€?
        const int GameThreadCount = 2;
        GameLogic.LaunchGameThreads(GameThreadCount);

        // DB
        const int DbThreadCount = 2;
        DBManager.LaunchDBThreads(DbThreadCount);

        // MainThread
        GameLogic.FlushMainThreadJobs();
    }
}
```

```csharp
static public void LaunchGameThreads(int threadCount)
{
    _threadCount = threadCount;

    for (int i = 0; i < threadCount; i++)
    {
        Thread t = new Thread(new ParameterizedThreadStart(GameThreadJob_1));
        t.Name = $"GameLogic_{i}";
        t.Start(i);
    }
}
```

```csharp
static public void GameThreadJob_1(object arg)
{
    int threadId = (int)arg;
    int idx = threadId % _threadCount;

    // ì“°ë ˆë“œê°€ ë‹´ë‹¹í•˜ëŠ” ë°© ì°¾ê¸°.
    List<GameRoom> rooms = _rooms
        .Where(r => r.Key % _threadCount == idx)
        .Select(r => r.Value)
        .ToList();

    while (true)
    {
        foreach (GameRoom room in rooms)
            room.Update();

        Thread.Sleep(0);
    }
}
```

* ìœ„ ë°©ì‹ì˜ ë¬¸ì œ?
    * íŠ¹ì • Threadì— Jobì´ ëª°ë¦¬ê²Œ ëœë‹¤ë©´?
    * í•˜ë“œì½”ë”©ìœ¼ë¡œ ì²˜ë¦¬í•´ ì¤˜ì•¼í• ê¹Œ?

```csharp
// ê°œì„ ì•ˆ.
    // Multi-Thread Safe Queueë¥¼ í™œìš©
    // static ConcurrentQueue<GameRoom> _updateQueue;
static public void GameThreadJob_2(object arg)
{
    int threadId = (int)arg;

    while (true)
    {
        if (_updateQueue.TryDequeue(out GameRoom room) == false)
            continue;

        room.Flush();				

        _updateQueue.Enqueue(room);

        Thread.Sleep(0);
    }
}
```

* ThreadPoolì„ í™œìš©í•˜ëŠ” ë°©ë²•ë„ ìˆë‹¤.
* ì¥ì ì€ ë­˜ê¹Œ?
    * Threadì˜ ê°œìˆ˜ë¥¼ ê°œë°œìê°€ ì§ì ‘ ì§€ì •í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
    * OSë‹¨ì—ì„œ Threadê°œìˆ˜ë¥¼ ì ì ˆíˆ ë°°ë¶„í•´ì¤€ë‹¤.

```csharp
static public void LaunchRoomUpdateTasks()
{
    foreach (GameRoom room in _rooms.Values)
    {
        StartRoomUpdateTask(room);
    }
}
```

```csharp
static public void StartRoomUpdateTask(GameRoom room)
{
    Task.Run(() =>
    {
        room.Update();
        StartRoomUpdateTask(room);
    });
}
```

* ê·¸ëŸ°ë° ìš°ë¦¬ ê²Œì„ì€ Roomê¸°ë°˜ì˜ ê²Œì„ì´ë¼ Threadë‚˜ëˆ„ê¸°ê°€ ì¢‹ì€ë°, ì‹¬ë¦¬ìŠ¤ê²Œì„ì—ì„  ì–´ë–»ê²Œ Threadë¥¼ ë‚˜ëˆ ì•¼ í• ê¹Œ?
    * ì´ê±´ ë‹µì´ ì—†ëŠ” ë¬¸ì œ, ê° Actorë³„ë¡œ Threadë¥¼ ì£¼ê±°ë‚˜ ì¼ì • ì§€ì—­ì„ ë‹¨ìœ„ë¡œ Threadë¥¼ ë°°ë¶„í•´ ë§ˆì¹˜ Room ì²˜ëŸ¼ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤.
    * ë‹¨, ê° Actorë³„ë¡œ Threadë¥¼ ë‚˜ëˆ„ëŠ”ê²ƒì€ êµ¬í˜„ì˜ ì–´ë ¤ì›€ì´ ë”°ë¦„...


