---
layout: default
title: "04-01. CheckAddressResolution"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** check the state of address resolution, and kicks off next stage if applicable - returning the result/action taken or current status update */

// CheckAddressResolution() is resides in IpNetConnection::Tick() and periodically check AddressResolution's current state and update its state if necessary

// CheckAddressResolution()ì€ IpNetConnection::Tick() ë‚´ì— ìˆìœ¼ë©° ì£¼ê¸°ì ìœ¼ë¡œ AddressResolutionì˜ í˜„ì¬ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  í•„ìš”í•œ ê²½ìš° ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
ECheckAddressResolutionResult CheckAddressResolution()
{
    // NOTE that ECheckAddressResolutionResult is different from EAddressResolutionState (but it is similar)
    // - see ECheckAddressResolutionResult briefly

    // ECheckAddressResolutionResultëŠ” EAddressResolutionStateì™€ ë‹¤ë¦…ë‹ˆë‹¤ (í•˜ì§€ë§Œ ë¹„ìŠ·í•©ë‹ˆë‹¤)
    // - ECheckAddressResolutionResultë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
    ECheckAddressResolutionResult Result = ECheckAddressResolutionResult::None;

    // ResolutionState is lastly updated as 'TryNextAddress' by calling GetAddressInfoAsync() in NetDriverAddressResolution::InitConnect()
    // - we also updated "ResolverResults" from NetDriverAddressResolution
    // - "CurrentAddressIndex" starts from '0'

    // ResolutionStateëŠ” NetDriverAddressResolution::InitConnect()ì—ì„œ GetAddressInfoAsync()ë¥¼ í˜¸ì¶œí•˜ì—¬ ë§ˆì§€ë§‰ìœ¼ë¡œ 'TryNextAddress'ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤
    // - ë˜í•œ NetDriverAddressResolutionì—ì„œ "ResolverResults"ë¥¼ ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤
    // - "CurrentAddressIndex"ëŠ” '0'ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤
    if (ResolutionState == EAddressResolutionState::TryNextAddress)
    {
        RemoteAddr = ResolverResults[CurrentAddressIndex];

        // BindSockets are passed through NetDriverAddressResolution by calling GetAddressInfoAsync() in NetDriverAddressResolution::InitConnect()
        // - as we covered, BindSockets usually has only one socket
        // - Protocol is whether IPv4 or IPv6, in usual case, they are always same:
        //   - RemoteAddr is server's address!
        
        // BindSocketsëŠ” NetDriverAddressResolution::InitConnect()ì—ì„œ GetAddressInfoAsync()ë¥¼ í˜¸ì¶œí•˜ì—¬ NetDriverAddressResolutionì„ í†µí•´ ì „ë‹¬ë©ë‹ˆë‹¤
        // - ì•ì„œ ë‹¤ë¤˜ë“¯ì´, BindSocketsëŠ” ë³´í†µ í•˜ë‚˜ì˜ ì†Œì¼“ë§Œ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤
        // - í”„ë¡œí† ì½œì€ IPv4 ë˜ëŠ” IPv6ì´ë©°, ì¼ë°˜ì ì¸ ê²½ìš° í•­ìƒ ë™ì¼í•©ë‹ˆë‹¤:
        //   - RemoteAddrì€ ì„œë²„ì˜ ì£¼ì†Œì…ë‹ˆë‹¤!
        ResolutionSocket.Reset();
        for (const TSharedPtr<FSocket>& BindSocket : BindSockets)
        {
            if (BindSocket->GetProtocol() == RemoteAddr->GetProtocolType())
            {
                ResolutionSocket = BindSocket;
                break;
            }
        }

        // now finally we update NetConnectionAddressResolution's ResolutionSocket
        // - we need to pass it through to IpConnection's SocketPrivate
        // - first, we update ResolutionState as 'Connecting' and return 'ECheckAddressResolutionResult::TryFirstAddress'
        // ì´ì œ ë§ˆì§€ë§‰ìœ¼ë¡œ NetConnectionAddressResolutionì˜ ResolutionSocketì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        // - ì´ê²ƒì„ IpConnectionì˜ SocketPrivateë¡œ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤
        // - ë¨¼ì €, ResolutionStateë¥¼ 'Connecting'ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³  'ECheckAddressResolutionResult::TryFirstAddress'ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤
        if (ResolutionSocket.IsValid())
        {
            ResolutionState = EAddressResolutionState::Connecting;
            if (CurrentAddressIndex == 0)
            {
                Result = ECheckAddressResolutionResult::TryFirstAddress;
            }
            else
            {
                Result = ECheckAddressResolutionResult::TryNextAddress;
            }
            ++CurrentAddressIndex;
        }
    }
    else if (ResolutionState == EAddressResolutionState::Connected)
    {
        ResolutionState = EAddressResolutionState::Done;
        Result = ECheckAddressResolutionResult::Connected;
        CleanupResolutionSockets(ECleanupResolutionSocketsFlags::CleanInactive);
    }
}
```