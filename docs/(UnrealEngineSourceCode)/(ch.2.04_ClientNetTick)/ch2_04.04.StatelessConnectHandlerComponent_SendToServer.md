---
layout: default
title: "04-04. StatelessConnectHandlerComponent::SendToServer"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** send a packet from the client to the server */
/** í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤ */

// finally, we'll send initial packet to the server!
// ë§ˆì¹¨ë‚´ ì´ˆê¸° íŒ¨í‚·ì„ ì„œë²„ë¡œ ì „ì†¡í•©ë‹ˆë‹¤!

void SendToServer(EHandshakeVersion HandshakeVersion, EHandshakePacketType PacketType, FBitWriter& Packet)
{
    if (UNetConnection* ServerConn = (Driver != nullptr ? Driver->ServerConnection : nullptr))
    {
        // CapHandshakePacket generates RandomData at the end of packets
        // CapHandshakePacketì´ íŒ¨í‚· ëì— ëœë¤ ë°ì´í„°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤

        CapHandshakePacket(Packet, HandshakeVersion);

        // disable PacketHandler parsing, and send the raw packet
        // we call UNetConnection::LowLevelSend here:
        // - in UNetConnection::LowLevelSend, it also calls PacketHandler::Incoming method, which cause stackoverflow (infinite-recursive call)
        // - to prevent stackoverflow, mark it as bRawSend as true, it doesn't enter PacketHandler's method

        // PacketHandler íŒŒì‹±ì„ ë¹„í™œì„±í™”í•˜ê³  ì›ì‹œ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤
        // ì—¬ê¸°ì„œ UNetConnection::LowLevelSendë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤:
        // - UNetConnection::LowLevelSendì—ì„œ PacketHandler::Incoming ë©”ì„œë“œë„ í˜¸ì¶œí•˜ëŠ”ë°, ì´ëŠ” ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤(ë¬´í•œ ì¬ê·€ í˜¸ì¶œ)
        // - ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ bRawSendë¥¼ trueë¡œ ì„¤ì •í•˜ì—¬ PacketHandlerì˜ ë©”ì„œë“œë¡œ ì§„ì…í•˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤

        Handler->SetRawSend(true);
        {
            // do you remember IpConnection's socket is ready? (UIpConnection's SocketPrivate is null!)
            // - we failed to call UNetConnection::LowLevelSend()!!
            // - we need to call it again to try to connect(handshake) to the server: when does it happens?
            //   *** first where ServerConnection's socket is initialized?
            //       - UNetConnection::Tick() -> PacketHandler::Tick() -> StatelessConnectHandlerComponent::Tick()
            // *** now we need to see where client's ServerConnection's Tick() is called!

            // IpConnectionì˜ ì†Œì¼“ì´ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ ê¸°ì–µí•˜ì‹œë‚˜ìš”? (UIpConnectionì˜ SocketPrivateì´ nullì…ë‹ˆë‹¤!)
            // - UNetConnection::LowLevelSend() í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤!!
            // - ì„œë²„ì— ì—°ê²°(í•¸ë“œì…°ì´í¬)ì„ ì‹œë„í•˜ê¸° ìœ„í•´ ë‹¤ì‹œ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤: ì´ëŠ” ì–¸ì œ ë°œìƒí• ê¹Œìš”?
            //   *** ë¨¼ì € ServerConnectionì˜ ì†Œì¼“ì€ ì–´ë””ì„œ ì´ˆê¸°í™”ë ê¹Œìš”?
            //       - UNetConnection::Tick() -> PacketHandler::Tick() -> StatelessConnectHandlerComponent::Tick()
            // *** ì´ì œ í´ë¼ì´ì–¸íŠ¸ì˜ ServerConnectionì˜ Tick()ì´ ì–´ë””ì„œ í˜¸ì¶œë˜ëŠ”ì§€ ë´ì•¼ í•©ë‹ˆë‹¤!

            // we finally can pass UIpNetDriver::IsNetResourceValid()
            // ë§ˆì¹¨ë‚´ UIpNetDriver::IsNetResourceValid()ë¥¼ í†µê³¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

            if (Driver->IsNetResourceValid())
            {
                FOutPacketTraits Traits;
                Driver->ServerConnection->LowLevelSend(Packet.GetData(), Packet.GetNumBits(), Traits);
            }
        }
        Handler->SetRawSend(false);

        // regardless of sending actual InitialPacket, update LastClientSendTimestamp
        // ì‹¤ì œ InitialPacket ì „ì†¡ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ LastClientSendTimestampë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤

        LastClientSendTimestamp = FPlatformTime::Seconds();
    }
}
```