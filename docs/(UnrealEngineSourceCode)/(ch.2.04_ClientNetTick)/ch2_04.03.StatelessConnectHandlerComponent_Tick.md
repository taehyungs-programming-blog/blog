---
layout: default
title: "04-03. StatelessConnectHandlerComponent::Tick"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# StatelessConnectHandlerComponent ê°œìš”

StatelessConnectHandlerComponentëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ ê´€ë¦¬í•˜ëŠ” ì¤‘ìš”í•œ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤. ì£¼ìš” íŠ¹ì§•ê³¼ ì—­í• ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

## 1. ê¸°ë³¸ ê¸°ëŠ¥
- í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ ê°„ì˜ ë¬´ìƒíƒœ(Stateless) ì—°ê²° ì²˜ë¦¬
- ì—°ê²° í•¸ë“œì…°ì´í¬ í”„ë¡œí† ì½œ ê´€ë¦¬
- íŒ¨í‚· ì¸ì¦ ë° ë³´ì•ˆ ì²˜ë¦¬

## 2. Tick í•¨ìˆ˜ì˜ ì—­í• 
StatelessConnectHandlerComponentì˜ Tick í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤:
- ì—°ê²° ìƒíƒœ ì£¼ê¸°ì  í™•ì¸
- íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬
- ì¬ì—°ê²° ì‹œë„ ê´€ë¦¬
- íŒ¨í‚· í ì²˜ë¦¬

## 3. ì£¼ìš” ë©¤ë²„ ë³€ìˆ˜
```cpp
class StatelessConnectHandlerComponent
{
    // í˜„ì¬ ì—°ê²° ìƒíƒœ
    EConnectStatus ConnectStatus;
    
    // ì—°ê²° ì‹œë„ íšŸìˆ˜
    int32 ConnectAttempts;
    
    // ë§ˆì§€ë§‰ ì—°ê²° ì‹œë„ ì‹œê°„
    double LastConnectAttemptTime;
    
    // íŒ¨í‚· í
    TArray<FPacketQueueEntry> PacketQueue;
};
```

## 4. ë™ì‘ ë°©ì‹
1. í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì— ì—°ê²° ìš”ì²­
2. í•¸ë“œì…°ì´í¬ í”„ë¡œí† ì½œ ì‹œì‘
3. ì¸ì¦ ê³¼ì • ìˆ˜í–‰
4. ì—°ê²° ì„¤ì • ì™„ë£Œ

## 5. ì¥ì 
- ì„œë²„ ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì  ê´€ë¦¬
- DOS ê³µê²© ë°©ì§€
- ì•ˆì •ì ì¸ ì—°ê²° ê´€ë¦¬

ì´ ì»´í¬ë„ŒíŠ¸ëŠ” íŠ¹íˆ ëŒ€ê·œëª¨ ë©€í‹°í”Œë ˆì´ì–´ ê²Œì„ì—ì„œ ì¤‘ìš”í•œ ì—­í• ì„ í•˜ë©°, í´ë¼ì´ì–¸íŠ¸ì™€ ì„œë²„ ê°„ì˜ ì•ˆì •ì ì¸ ì—°ê²°ì„ ë³´ì¥í•©ë‹ˆë‹¤.

---

```cpp
class StatelessConnectHandlerComponent : public HandlerComponent
{
    // ...

virtual void Tick(float DeltaTime) override;
{
    // the mode is for 'client'
    // í´ë¼ì´ì–¸íŠ¸ ëª¨ë“œì¼ ê²½ìš°ì—ë§Œ ì‹¤í–‰
    if (Handler->Mode == UE::Handler::Mode::Client)
    {
        // focus on 'LastClientSendTimestamp'
        // - using LastClientSendTimestamp, we calculate diff-time, 'LastSendTimeDiff'
        // - UE::Net::HandshakeResendInterval is 1.0 (== 1 second)
        // - handshake process is not allowed to execute every frame, only in periodic time (currently by default, 1 second)
        //   - in our case, after we failed to 'SendInitialPacket', next-try is done after 1 second, NOT in next-frame(tick)
        // - LastClientSendTimestamp is updated in StatelessConnectHandlerComponent::SendToServer()

        // LastClientSendTimestampì— ì£¼ëª©
        // - LastClientSendTimestampë¥¼ ì‚¬ìš©í•´ì„œ ê²½ê³¼ ì‹œê°„ì¸ 'LastSendTimeDiff'ë¥¼ ê³„ì‚°
        // - UE::Net::HandshakeResendIntervalì€ 1.0(1ì´ˆ)ì„
        // - í•¸ë“œì‰ì´í¬ í”„ë¡œì„¸ìŠ¤ëŠ” ë§¤ í”„ë ˆì„ë§ˆë‹¤ ì‹¤í–‰ë˜ì§€ ì•Šê³ , ì£¼ê¸°ì ìœ¼ë¡œë§Œ ì‹¤í–‰ë¨(í˜„ì¬ ê¸°ë³¸ê°’ 1ì´ˆ)
        //   - ìš°ë¦¬ì˜ ê²½ìš°, 'SendInitialPacket' ì‹¤íŒ¨ í›„ ë‹¤ìŒ ì‹œë„ëŠ” ë‹¤ìŒ í”„ë ˆì„ì´ ì•„ë‹Œ 1ì´ˆ í›„ì— ì‹¤í–‰ë¨
        // - LastClientSendTimestampëŠ” StatelessConnectHandlerComponent::SendToServer()ì—ì„œ ì—…ë°ì´íŠ¸ë¨
        if (State != UE::Handler::Component::State::Initialized && LastClientSendTimestamp != 0.0)
        {
            double LastSendTimeDiff = FPlatformTime::Seconds() - LastClientSendTimestamp;
            if (LastSendTimeDiff > UE::Net::HandshakeResendInterval)
            {
                // we are not dealing with 'Challenge' in handshake for now
                // - but it is worth to know 'challenge' is the follow-up process in handshake
                // - today, we cover what the 'ChallengePacket' is, so reviewing what we covered helps you to understand bRestartChallenge means here
                //   - why we set State as 'Uninitialized' ans start SendInitialPacket again (starting from the scratch)
                // *** for explanation clarity, I eliminate the possibility to packet loss, but handshake is unreliable! keep in mind!

                // í˜„ì¬ëŠ” í•¸ë“œì‰ì´í¬ì˜ 'Challenge' ë¶€ë¶„ì„ ë‹¤ë£¨ì§€ ì•ŠìŒ
                // - í•˜ì§€ë§Œ 'challenge'ê°€ í•¸ë“œì‰ì´í¬ì˜ í›„ì† í”„ë¡œì„¸ìŠ¤ë¼ëŠ” ê²ƒì„ ì•Œì•„ë‘ë©´ ì¢‹ìŒ
                // - ì˜¤ëŠ˜ì€ 'ChallengePacket'ì´ ë¬´ì—‡ì¸ì§€ ë‹¤ë£¨ë¯€ë¡œ, ì§€ê¸ˆê¹Œì§€ ë°°ìš´ ë‚´ìš©ì„ ë³µìŠµí•˜ë©´ bRestartChallengeì˜ ì˜ë¯¸ë¥¼ ì´í•´í•˜ëŠ”ë° ë„ì›€ì´ ë¨
                //   - ì™œ Stateë¥¼ 'Uninitialized'ë¡œ ì„¤ì •í•˜ê³  SendInitialPacketì„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ëŠ”ì§€
                // *** ì„¤ëª…ì˜ ëª…í™•ì„±ì„ ìœ„í•´ íŒ¨í‚· ì†ì‹¤ì˜ ê°€ëŠ¥ì„±ì€ ì œì™¸í–ˆì§€ë§Œ, í•¸ë“œì‰ì´í¬ëŠ” ì‹ ë¢°í•  ìˆ˜ ì—†ë‹¤ëŠ” ì ì„ ëª…ì‹¬í•  ê²ƒ!
                const bool bRestartChallenge = Driver != nullptr && ((Driver->GetElapsedTime() - LastChallengeTimestamp) > MIN_COOKIE_LIFETIME);
                if (bRestartChallenge)
                {
                    SetState(UE::Handler::Component::State::Uninitialized);
                }

                if (State == UE::Handler::Component::State::Uninitialized)
                {
                    // now we are ready to call and succeeed 'SendInitialPacket()'
                    // - see StatelessConnectHandlerComponent::SendInitialPacket (we already covered this)
                    // *** StatelessConnectHandlerComponent::SendInitialPacket

                    // ì´ì œ 'SendInitialPacket()'ì„ í˜¸ì¶œí•˜ê³  ì„±ê³µí•  ì¤€ë¹„ê°€ ë¨
                    // - StatelessConnectHandlerComponent::SendInitialPacket ì°¸ê³  (ì´ë¯¸ ë‹¤ë£¬ ë‚´ìš©)
                    // *** StatelessConnectHandlerComponent::SendInitialPacket
                    EHandshakeVersion ResendVersion = static_cast<EHandshakeVersion>(CurrentHandshakeVersion);
                    SendInitialPacket(ResendVersion);
                }
            }
        }
    }
}
```