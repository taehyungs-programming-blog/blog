---
layout: default
title: "([Network] 04. ClientNetTick)"
parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
has_children: true
nav_order: 3
---

```cpp
/** poll the connection, if it is timed out, close it 
 * ì—°ê²°ì„ í´ë§í•˜ê³ , ì‹œê°„ ì´ˆê³¼ë˜ë©´ ë‹«ìŠµë‹ˆë‹¤
*/
// before getting into PacketHandler::Tick, we firstly see how connection tick rate is managed
    // PacketHandler::Tickìœ¼ë¡œ ë“¤ì–´ê°€ê¸° ì „ì—, ë¨¼ì € connection tick rateê°€ ì–´ë–»ê²Œ ê´€ë¦¬ë˜ëŠ”ì§€ ë´…ë‹ˆë‹¤
virtual void Tick(float DeltaSeconds)
{
    // get frame time
    // as seconds, we calculate current time to manage tick rates (in 120Hz)
        // í”„ë ˆì„ ì‹œê°„ ê°€ì ¸ì˜¤ê¸°
        // ì´ˆ ë‹¨ìœ„ë¡œ, í‹± ì†ë„ë¥¼ ê´€ë¦¬í•˜ê¸° ìœ„í•´ í˜„ì¬ ì‹œê°„ì„ ê³„ì‚°í•©ë‹ˆë‹¤ (120Hzì—ì„œ)
    const double CurrentRealtimeSeconds = FPlatformTime::Seconds();

    // if this is 0, it's our first tick since init, so start our real-time tracking from here
    // "LastTime == 0" means since NetConnection is constructed, the instance tick is not executed yet
        // ì´ê²ƒì´ 0ì´ë©´, ì´ˆê¸°í™” ì´í›„ ì²« ë²ˆì§¸ í‹±ì´ë¯€ë¡œ ì—¬ê¸°ì„œë¶€í„° ì‹¤ì‹œê°„ ì¶”ì ì„ ì‹œì‘í•©ë‹ˆë‹¤
        // "LastTime == 0"ì€ NetConnectionì´ ìƒì„±ëœ ì´í›„ ì¸ìŠ¤í„´ìŠ¤ í‹±ì´ ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤
    if (LastTime == 0.0)
    {
        LastTime = CurrentRealtimeSeconds;
        LastReceiveRealTime = CurrentRealtimeSeconds;
    }

    // 'FrameTime' means the interval time between previous-tick and current-tick
        // 'FrameTime'ì€ ì´ì „ í‹±ê³¼ í˜„ì¬ í‹± ì‚¬ì´ì˜ ê°„ê²© ì‹œê°„ì„ ì˜ë¯¸í•©ë‹ˆë‹¤
    FrameTime = CurrentRealtimeSeconds - LastTime;

    // MaxNetTickRate is '120'
    // - you can find 'MaxNetTickRate' is 120 in BaseEngine.ini
    // - the UE netcode is not allowed to ticking more than 120fps
        // MaxNetTickRateëŠ” '120'ì…ë‹ˆë‹¤
        // - BaseEngine.iniì—ì„œ 'MaxNetTickRate'ê°€ 120ì¸ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
        // - UE ë„¤íŠ¸ì›Œí¬ ì½”ë“œëŠ” 120fps ì´ìƒì˜ í‹±ì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
    const int32 MaxNetTickRate = Driver->MaxNetTickRate;
    float EngineTickRate = GEngine->GetMaxTickRate(0.0f, false);
    const float MaxNetTickRateFloat = MaxNetTickRate > 0 ? float(MaxNetTickRate) : MAX_flt;
    const float DesiredTickRate = FMath::Clamp(EngineTickRate, 0.0f, MaxNetTickRateFloat);

    // apply net tick rate limiting if the desired net tick rate is strictly less than the engine tick rate
        // ì›í•˜ëŠ” ë„¤íŠ¸ì›Œí¬ í‹± ì†ë„ê°€ ì—”ì§„ í‹± ì†ë„ë³´ë‹¤ ì—„ê²©íˆ ë‚®ì€ ê²½ìš° ë„¤íŠ¸ì›Œí¬ í‹± ì†ë„ ì œí•œì„ ì ìš©í•©ë‹ˆë‹¤
    if (!IsInternalTick() && MaxNetTickRateFloat < EngineTickRate && DesiredTickRate > 0.0f)
    {
        // MinNetFrameTime is 0.008 (120 fps: 0.016 == 60fps)
        // - if NetConnection' tick is called within 0.008f, we skip ticking (by calling "return")
            // MinNetFrameTimeì€ 0.008ì…ë‹ˆë‹¤ (120 fps: 0.016 == 60fps)
            // - NetConnectionì˜ í‹±ì´ 0.008f ì´ë‚´ì— í˜¸ì¶œë˜ë©´, í‹±í‚¹ì„ ê±´ë„ˆëœë‹ˆë‹¤ ("return" í˜¸ì¶œë¡œ)
        const float MinNetFrameTime = 1.0f / DesiredTickRate;
        if (FrameTime < MinNetFrameTime)
        {
            return;
        }
    }

    // update 'LastTime' to reserve the variable, calculating FrameTime in next-tick
        // ë‹¤ìŒ í‹±ì—ì„œ FrameTimeì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ 'LastTime'ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    LastTime = CurrentRealtimeSeconds;

    // handle time-outs
    // if no timeout is set, Timeout value is +INF
        // ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬
    // ì‹œê°„ ì´ˆê³¼ê°€ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš°, Timeout ê°’ì€ +INFì…ë‹ˆë‹¤
    const float Timeout = GetTimeoutValue();

    // where LastReceiveRealTime is updated? UNetConnection::ReceivedPacket()
        // LastReceiveRealTimeì€ ì–´ë””ì„œ ì—…ë°ì´íŠ¸ë ê¹Œìš”? UNetConnection::ReceivedPacket()
    if ((CurrentRealtimeSeconds - LastReceiveRealtime) > Timeout)
    {
        HandleConnectionTimeout(Error);
        if (Driver == NULL)
        {
            return;
        }
    }

    // tick handler
    // do you remember 'StatelessConnectHandlerComponent::SendInitialPacket' is failed to call 'SendToServer' because of UIpConnection's SocketPrivate?
    // - now it's time to send handshake's initial packet!
        // í•¸ë“¤ëŸ¬ í‹±
        // UIpConnectionì˜ SocketPrivate ë•Œë¬¸ì— 'StatelessConnectHandlerComponent::SendInitialPacket'ì´ 'SendToServer'ë¥¼ í˜¸ì¶œí•˜ì§€ ëª»í•œ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
        // - ì´ì œ í•¸ë“œì…°ì´í¬ì˜ ì´ˆê¸° íŒ¨í‚·ì„ ë³´ë‚¼ ì‹œê°„ì…ë‹ˆë‹¤!
    if (Handler.IsValid())
    {
        Handler->Tick(FrameTime);
    }
}
```

```cpp
/** handle a packet we just received */
virtual void ReceivedPacket(FBitReader& Reader, bool bIsReinjectedPacket=false, bool bDispatchPacket=true)
{
    //...

    // record the packet time to the histogram
        // íˆìŠ¤í† ê·¸ë¨ì— íŒ¨í‚· ì‹œê°„ì„ ê¸°ë¡í•©ë‹ˆë‹¤
    // whenever we received any packet for this NetConnection, update 'LastReceiveRealtime'
        // ì´ NetConnectionì— ëŒ€í•´ íŒ¨í‚·ì„ ë°›ì„ ë•Œë§ˆë‹¤ 'LastReceiveRealtime'ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    const double CurrentReceiveTimeInS = FPlatformTime::Seconds();
    if (!bIsReinjectedPacket)
    {
        LastReceiveRealtime = CurrentReceiveTimeInS;
    }
}
```