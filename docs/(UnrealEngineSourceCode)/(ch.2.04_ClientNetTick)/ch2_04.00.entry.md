---
layout: default
title: "([Network] 04. ClientNetTick)"
parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
has_children: true
nav_order: 3
---

```cpp
class UEditorEngine : public UEngine
{

// ...
virtual void Tick(float DeltaSeconds, bool bIdleMode) override
{
    // ...

        for (; PieContext.PIEAccumulatedTickSeconds >= TickDeltaSeconds; PieContext.PIEAccumulatedTickSeconds -= TickDeltaSeconds)
        {
            // tick all travel and pending NetGames (Seamless, server, client)
            // all travelê³¼ pending NetGames(Seamless, server, client)ì— ëŒ€í•´ í‹±ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤
            
            // client still doesn't have any UWorld, but it has UPendingNetGame instead
            // where is UPendingNetGame's tick() executed?
            
            // í´ë¼ì´ì–¸íŠ¸ëŠ” ì•„ì§ UWorldê°€ ì—†ê³ , ëŒ€ì‹  UPendingNetGameì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤
            // UPendingNetGameì˜ tick()ì€ ì–´ë””ì„œ ì‹¤í–‰ë ê¹Œìš”?
            TickWorldTravel(PieContext, TickDeltaSeconds);

            // update the level
            // ë ˆë²¨ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
            {
                // tick the level
                
                // ë ˆë²¨ì— ëŒ€í•´ í‹±ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤
                PieContext.World()->Tick(LEVELTICK_All, TickDeltaSeconds);
            }
        }
    }
}
```

```cpp
virtual void TickWorldTravel(FWorldContext& Context, float DeltaSeconds)
{
    //...

    // here we can see UPendingNetGame::Tick() is called!
    if (Context.PendingNetGame)
    {
        Context.PendingNetGame->Tick(DeltaSeconds);
    }
} 
```

```cpp
class UPendingNetGame : public UObject, FNetworkNotify
{
    // ...

/** update the pending level's status */
/** ëŒ€ê¸° ì¤‘ì¸ ë ˆë²¨ì˜ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤ */

// we can see NetDriver's ticking here:
// - ServerConnection is in IpNetDriver
// - ServerConnection will be ticked in TickFlush()!
//   - 'TickDispatch' is for receving packet and dispatching receive events
//   - 'TickFlush' is for ticking connections and sending accumulated packets

// ì—¬ê¸°ì„œ NetDriverì˜ í‹±í‚¹ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤:
// - ServerConnectionì€ IpNetDriver ì•ˆì— ìˆìŠµë‹ˆë‹¤
// - ServerConnectionì€ TickFlush()ì—ì„œ í‹± ì²˜ë¦¬ë©ë‹ˆë‹¤!
//   - 'TickDispatch'ëŠ” íŒ¨í‚·ì„ ìˆ˜ì‹ í•˜ê³  ìˆ˜ì‹  ì´ë²¤íŠ¸ë¥¼ ë””ìŠ¤íŒ¨ì¹˜í•˜ëŠ” ìš©ë„ì…ë‹ˆë‹¤
//   - 'TickFlush'ëŠ” ì»¤ë„¥ì…˜ë“¤ì„ í‹± ì²˜ë¦¬í•˜ê³  ëˆ„ì ëœ íŒ¨í‚·ë“¤ì„ ì „ì†¡í•˜ëŠ” ìš©ë„ì…ë‹ˆë‹¤
virtual void Tick(float DeltaTime)
{
    // update the network driver
    // ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë²„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    NetDriver->TickDispatch(DeltaTime);

    // may NULL itself via CancelPending if a disconnect/error occurs
    // ì—°ê²° í•´ì œë‚˜ ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ CancelPendingì„ í†µí•´ NULLì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤
    if (NetDriver)
    {
        NetDriver->PostTickDispatch();
    }

    if (NetDriver)
    {
        // we are going to see the TickFlush first
        
        // ë¨¼ì € TickFlushë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤
        NetDriver->TickFlush(DeltaTime);
    }

    if (NetDriver)
    {
        NetDriver->PostTickFlush();
    }
}
```

```cpp
/** ReplicateActors and flush */
virtual void TickFlush(float DeltaSeconds)
{
    // poll all sockets
    // this TickFlush is very big function, for now we focus on UIpConnection::Tick to find where IpConnection's SocketPrivate is set

    if (ServerConnection)
    {
        ServerConnection->Tick(DeltaSeconds);
    }
}
```

```cpp
class UIpConnection : public UNetConnection
{
    // ...

virtual void Tick(float DeltaSeconds) override
{
    ECheckAddressResolutionResult CheckResult = Resolver->CheckAddressResolution();

    // CheckResult is 'TryFirstAddress':
    // - we finally update IpConnection's SocketPrivate to Resolver's ResolutionSocket
    // - we also update RemoteAddr
    // - and re-init SendBuffer again, see InitSendBuffer() briefly
    
    // CheckResultê°€ 'TryFirstAddress'ì¸ ê²½ìš°:
    // - ë§ˆì¹¨ë‚´ IpConnectionì˜ SocketPrivateì„ Resolverì˜ ResolutionSocketìœ¼ë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    // - RemoteAddrë„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    // - ê·¸ë¦¬ê³  SendBufferë¥¼ ë‹¤ì‹œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤, InitSendBuffer()ë¥¼ ê°„ë‹¨íˆ í™•ì¸í•˜ì„¸ìš”
    if (CheckResult == ECheckAddressResolutionResult::TryFirstAddress || CheckResult == ECheckAddressResolutionResult::TryNextAddress)
    {
        SetSocket_Local(Resolver->GetResolutionSocket());
        RemoteAddr = Resolver->GetRemoveAddr();

        // reset any timers
        // ëª¨ë“  íƒ€ì´ë¨¸ë¥¼ ë¦¬ì…‹í•©ë‹ˆë‹¤
        LastReceiveRealtime = FPlatformTime::Seconds();

        // reinit the buffer
        // ë²„í¼ë¥¼ ë‹¤ì‹œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤
        InitSendBuffer();
    }

    // finally we update IpConnection's socket, we are ready to call StatelessConnectHanderComponent::SendInitialPacket()
    // - where is this function called again?
    //   - UNetConnection::Tick() -> PacketHandler::Tick() -> StatelessConnectHandlerComponent::Tick()
    
    // ë§ˆì¹¨ë‚´ IpConnectionì˜ ì†Œì¼“ì„ ì—…ë°ì´íŠ¸í–ˆê³ , StatelessConnectHanderComponent::SendInitialPacket()ì„ í˜¸ì¶œí•  ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤
    // - ì´ í•¨ìˆ˜ëŠ” ì–´ë””ì„œ ë‹¤ì‹œ í˜¸ì¶œë˜ë‚˜ìš”?
    //   - UNetConnection::Tick() -> PacketHandler::Tick() -> StatelessConnectHandlerComponent::Tick()
    UNetConnection::Tick(DeltaSeconds);
}
```

### `UIpConnection` í´ë˜ìŠ¤ ì„¤ëª…

* ì½”ë“œì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´, í´ë¼ì´ì–¸íŠ¸ì˜ ë„¤íŠ¸ì›Œí¬ í‹± ì²˜ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤:
    * UEditorEngine::Tick() â†’ TickWorldTravel() â†’ UPendingNetGame::Tick()ì˜ í˜¸ì¶œ ìˆœì„œë¡œ ì§„í–‰ë©ë‹ˆë‹¤.
    * UPendingNetGame::Tick()ì—ì„œëŠ” NetDriverì˜ ì£¼ìš” í‹± í•¨ìˆ˜ë“¤ì´ í˜¸ì¶œë©ë‹ˆë‹¤:
        * TickDispatch(): íŒ¨í‚· ìˆ˜ì‹  ë° ì´ë²¤íŠ¸ ì²˜ë¦¬
        * TickFlush(): ì—°ê²° í‹± ì²˜ë¦¬ ë° ëˆ„ì ëœ íŒ¨í‚· ì „ì†¡
    * UIpConnectionì—ì„œëŠ” íŒ¨í‚· ìˆ˜ì‹  ì‹œ ReceivedPacket()ì„ í†µí•´ ì²˜ë¦¬í•˜ë©°, LastReceiveRealtimeì„ ì—…ë°ì´íŠ¸í•˜ì—¬ ìµœê·¼ íŒ¨í‚· ìˆ˜ì‹  ì‹œê°„ì„ ì¶”ì í•©ë‹ˆë‹¤.
* ì£¼ìš” ë³€ê²½ì‚¬í•­ì´ë‚˜ ì¶”ê°€ê°€ í•„ìš”í•œ ë¶€ë¶„ì€ ë³´ì´ì§€ ì•ŠìŠµë‹ˆë‹¤ë§Œ, ì½”ë“œì˜ í•µì‹¬ í¬ì¸íŠ¸ëŠ”:
    * í´ë¼ì´ì–¸íŠ¸ëŠ” ì´ˆê¸°ì— UWorld ëŒ€ì‹  UPendingNetGameì„ ì‚¬ìš©í•©ë‹ˆë‹¤
    * ë„¤íŠ¸ì›Œí¬ ì²˜ë¦¬ëŠ” TickDispatchì™€ TickFlushë¥¼ í†µí•´ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤
    * íŒ¨í‚· ìˆ˜ì‹  ì‹œê°„ ì¶”ì ì„ í†µí•´ ì—°ê²° ìƒíƒœë¥¼ ëª¨ë‹ˆí„°ë§í•©ë‹ˆë‹¤
* ì´ëŸ¬í•œ êµ¬ì¡°ë¥¼ í†µí•´ ì–¸ë¦¬ì–¼ ì—”ì§„ì€ íš¨ìœ¨ì ì¸ ë„¤íŠ¸ì›Œí¬ í†µì‹ ì„ êµ¬í˜„í•˜ê³  ìˆìŠµë‹ˆë‹¤.


---

```cpp
/** handle a packet we just received */
virtual void ReceivedPacket(FBitReader& Reader, bool bIsReinjectedPacket=false, bool bDispatchPacket=true)
{
    //...

    // record the packet time to the histogram
        // íˆìŠ¤í† ê·¸ë¨ì— íŒ¨í‚· ì‹œê°„ì„ ê¸°ë¡í•©ë‹ˆë‹¤
    // whenever we received any packet for this NetConnection, update 'LastReceiveRealtime'
        // ì´ NetConnectionì— ëŒ€í•´ íŒ¨í‚·ì„ ë°›ì„ ë•Œë§ˆë‹¤ 'LastReceiveRealtime'ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    const double CurrentReceiveTimeInS = FPlatformTime::Seconds();
    if (!bIsReinjectedPacket)
    {
        LastReceiveRealtime = CurrentReceiveTimeInS;
    }
}
```