---
layout: default
title: "04-01. Tick"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
void Tick(float DeltaTime)
{
    // as we saw the only handler-component, 'StatelessConnectHandlerComponent::Tick' is called
    // - see StatelessConnectHandlerComponent::Tick(goto 011: ClientNetTick)
        // ìš°ë¦¬ê°€ ë³¸ ìœ ì¼í•œ í•¸ë“¤ëŸ¬ ì»´í¬ë„ŒíŠ¸ì¸ 'StatelessConnectHandlerComponent::Tick'ì´ í˜¸ì¶œë©ë‹ˆë‹¤
        // - StatelessConnectHandlerComponent::Tick ì°¸ì¡°
    for (const TSharedPtr<HandlerComponent>& Component : HandlerComponents)
    {
        if (Component.IsValid())
        {
            Component->Tick(DeltaTime);
        }
    }
}
```

```cpp
virtual void Tick(float DeltaTime) override;
{
    // the mode is for 'client'
        // ì´ ëª¨ë“œëŠ” 'í´ë¼ì´ì–¸íŠ¸'ìš©ì…ë‹ˆë‹¤
    if (Handler->Mode == UE::Handler::Mode::Client)
    {
        // focus on 'LastClientSendTimestamp'
        // - using LastClientSendTimestamp, we calculate diff-time, 'LastSendTimeDiff'
        // - UE::Net::HandshakeResendInterval is 1.0 (== 1 second)
        // - handshake process is not allowed to execute every frame, only in periodic time (currently by default, 1 second)
        //   - in our case, after we failed to 'SendInitialPacket', next-try is done after 1 second, NOT in next-frame(tick)
        // - LastClientSendTimestamp is updated in StatelessConnectHandlerComponent::SendToServer()

            // 'LastClientSendTimestamp'ì— ì§‘ì¤‘í•˜ì„¸ìš”
            // - LastClientSendTimestampë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹œê°„ ì°¨ì´ì¸ 'LastSendTimeDiff'ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤
            // - UE::Net::HandshakeResendIntervalì€ 1.0 (== 1ì´ˆ)ì…ë‹ˆë‹¤
            // - í•¸ë“œì…°ì´í¬ í”„ë¡œì„¸ìŠ¤ëŠ” ë§¤ í”„ë ˆì„ë§ˆë‹¤ ì‹¤í–‰ë˜ì§€ ì•Šê³ , ì£¼ê¸°ì ì¸ ì‹œê°„(í˜„ì¬ ê¸°ë³¸ê°’ìœ¼ë¡œ 1ì´ˆ)ì—ë§Œ ì‹¤í–‰ë©ë‹ˆë‹¤
            //   - ìš°ë¦¬ì˜ ê²½ìš°, 'SendInitialPacket' ì‹¤íŒ¨ í›„ ë‹¤ìŒ ì‹œë„ëŠ” ë‹¤ìŒ í”„ë ˆì„(í‹±)ì´ ì•„ë‹Œ 1ì´ˆ í›„ì— ì´ë£¨ì–´ì§‘ë‹ˆë‹¤
            // - LastClientSendTimestampëŠ” StatelessConnectHandlerComponent::SendToServer()ì—ì„œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤
        if (State != UE::Handler::Component::State::Initialized && LastClientSendTimestamp != 0.0)
        {
            double LastSendTimeDiff = FPlatformTime::Seconds() - LastClientSendTimestamp;
            if (LastSendTimeDiff > UE::Net::HandshakeResendInterval)
            {
                // we are not dealing with 'Challenge' in handshake for now
                // - but it is worth to know 'challenge' is the follow-up process in handshake
                // - today, we cover what the 'ChallengePacket' is, so reviewing what we covered helps you to understand bRestartChallenge means here
                //   - why we set State as 'Uninitialized' ans start SendInitialPacket again (starting from the scratch)
                // *** for explanation clarity, I eliminate the possibility to packet loss, but handshake is unreliable! keep in mind!

                    // í˜„ì¬ í•¸ë“œì…°ì´í¬ì—ì„œ 'Challenge'ë¥¼ ë‹¤ë£¨ì§€ ì•ŠìŠµë‹ˆë‹¤
                    // - í•˜ì§€ë§Œ 'challenge'ê°€ í•¸ë“œì…°ì´í¬ì˜ í›„ì† í”„ë¡œì„¸ìŠ¤ë¼ëŠ” ê²ƒì„ ì•Œì•„ë‘ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤
                    // - ì˜¤ëŠ˜ ìš°ë¦¬ëŠ” 'ChallengePacket'ì´ ë¬´ì—‡ì¸ì§€ ë‹¤ë£¨ë¯€ë¡œ, ìš°ë¦¬ê°€ ë‹¤ë£¬ ë‚´ìš©ì„ ê²€í† í•˜ë©´ bRestartChallengeì˜ ì˜ë¯¸ë¥¼ ì´í•´í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤
                    //   - ì™œ Stateë¥¼ 'Uninitialized'ë¡œ ì„¤ì •í•˜ê³  SendInitialPacketì„ ë‹¤ì‹œ ì‹œì‘í•˜ëŠ”ì§€ (ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘)
                    // *** ì„¤ëª…ì˜ ëª…í™•ì„±ì„ ìœ„í•´ íŒ¨í‚· ì†ì‹¤ ê°€ëŠ¥ì„±ì„ ì œê±°í–ˆì§€ë§Œ, í•¸ë“œì…°ì´í¬ëŠ” ì‹ ë¢°í•  ìˆ˜ ì—†ë‹¤ëŠ” ì ì„ ëª…ì‹¬í•˜ì„¸ìš”!
                const bool bRestartChallenge = Driver != nullptr && ((Driver->GetElapsedTime() - LastChallengeTimestamp) > MIN_COOKIE_LIFETIME);
                if (bRestartChallenge)
                {
                    SetState(UE::Handler::Component::State::Uninitialized);
                }

                if (State == UE::Handler::Component::State::Uninitialized)
                {
                    // now we are ready to call and succeeed 'SendInitialPacket()'
                    // - see StatelessConnectHandlerComponent::SendInitialPacket (we already covered this)
                    // *** StatelessConnectHandlerComponent::SendInitialPacket

                        // ì´ì œ 'SendInitialPacket()'ì„ í˜¸ì¶œí•˜ê³  ì„±ê³µí•  ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤
                        // - StatelessConnectHandlerComponent::SendInitialPacketì„ ì°¸ì¡°í•˜ì„¸ìš” (ì´ë¯¸ ë‹¤ë£¨ì—ˆìŠµë‹ˆë‹¤)
                        // *** StatelessConnectHandlerComponent::SendInitialPacket
                    EHandshakeVersion ResendVersion = static_cast<EHandshakeVersion>(CurrentHandshakeVersion);
                    SendInitialPacket(ResendVersion);
                }
            }
        }
    }
}
```

```cpp
/** send a packet from the client to the server */
    /** í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ íŒ¨í‚·ì„ ë³´ëƒ…ë‹ˆë‹¤ */
// finally, we'll send initial packet to the server!
    // ë§ˆì¹¨ë‚´ ì„œë²„ë¡œ ì´ˆê¸° íŒ¨í‚·ì„ ë³´ëƒ…ë‹ˆë‹¤!
void SendToServer(EHandshakeVersion HandshakeVersion, EHandshakePacketType PacketType, FBitWriter& Packet)
{
    if (UNetConnection* ServerConn = (Driver != nullptr ? Driver->ServerConnection : nullptr))
    {
        // CapHandshakePacket generates RandomData at the end of packets
        // - see StatelessConnectHandlerComponent::CapHandshakePacket
            // CapHandshakePacketì€ íŒ¨í‚· ëì— RandomDataë¥¼ ìƒì„±í•©ë‹ˆë‹¤
            // - StatelessConnectHandlerComponent::CapHandshakePacket ì°¸ì¡°
        CapHandshakePacket(Packet, HandshakeVersion);

        // disable PacketHandler parsing, and send the raw packet
        // we call UNetConnection::LowLevelSend here:
        // - in UNetConnection::LowLevelSend, it also calls PacketHandler::Incoming method, which cause stackoverflow (infinite-recursive call)
        // - to prevent stackoverflow, mark it as bRawSend as true, it doesn't enter PacketHandler's method
        // *** see briefly SetRawSend() method
            
            // PacketHandler íŒŒì‹±ì„ ë¹„í™œì„±í™”í•˜ê³  ì›ì‹œ íŒ¨í‚·ì„ ë³´ëƒ…ë‹ˆë‹¤
            // ì—¬ê¸°ì„œ UNetConnection::LowLevelSendë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤:
            // - UNetConnection::LowLevelSendì—ì„œ PacketHandler::Incoming ë©”ì„œë“œë„ í˜¸ì¶œí•˜ëŠ”ë°, ì´ëŠ” ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ì¼ìœ¼í‚µë‹ˆë‹¤ (ë¬´í•œ ì¬ê·€ í˜¸ì¶œ)
            // - ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ bRawSendë¥¼ trueë¡œ ì„¤ì •í•˜ì—¬ PacketHandlerì˜ ë©”ì„œë“œì— ì§„ì…í•˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤
            // *** SetRawSend() ë©”ì„œë“œë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
        Handler->SetRawSend(true);
        {
            // do you remember IpConnection's socket is ready? (UIpConnection's SocketPrivate is null!)
            // - see UIpNetDriver::IsNetResourceValid (goto 048: ClientConnect)
            // - we failed to call UNetConnection::LowLevelSend()!!
            // - we need to call it again to try to connect(handshake) to the server: when does it happens?
            //   *** first where ServerConnection's socket is initialized?
            //       - UNetConnection::Tick() -> PacketHandler::Tick() -> StatelessConnectHandlerComponent::Tick()
            // *** now we need to see where client's ServerConnection's Tick() is called!

                // IpConnectionì˜ ì†Œì¼“ì´ ì¤€ë¹„ë˜ì—ˆëŠ”ì§€ ê¸°ì–µí•˜ì‹œë‚˜ìš”? (UIpConnectionì˜ SocketPrivateê°€ nullì…ë‹ˆë‹¤!)
                // - UIpNetDriver::IsNetResourceValid ì°¸ì¡°
                // - UNetConnection::LowLevelSend() í˜¸ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤!!
                // - ì„œë²„ì— ì—°ê²°(í•¸ë“œì…°ì´í¬)ì„ ì‹œë„í•˜ê¸° ìœ„í•´ ë‹¤ì‹œ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤: ì–¸ì œ ì´ë£¨ì–´ì§ˆê¹Œìš”?
                //   *** ë¨¼ì € ServerConnectionì˜ ì†Œì¼“ì€ ì–´ë””ì„œ ì´ˆê¸°í™”ë˜ë‚˜ìš”?

            //       - UNetConnection::Tick() -> PacketHandler::Tick() -> StatelessConnectHandlerComponent::Tick()
                // *** ì´ì œ í´ë¼ì´ì–¸íŠ¸ì˜ ServerConnectionì˜ Tick()ì´ ì–´ë””ì„œ í˜¸ì¶œë˜ëŠ”ì§€ ë´ì•¼ í•©ë‹ˆë‹¤!

            // [ClientNetTick]
            // 
            // - we finally can pass UIpNetDriver::IsNetResourceValid()
            // *** see FOutPacketTraits briefly
            // *** see UIpConnection::LowLevelSend

                // [ClientNetTick]
                // 
                // - ë§ˆì¹¨ë‚´ UIpNetDriver::IsNetResourceValid()ë¥¼ í†µê³¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
                // *** FOutPacketTraitsë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
                // *** UIpConnection::LowLevelSendë¥¼ ì°¸ì¡°í•˜ì„¸ìš”
            if (Driver->IsNetResourceValid())
            {
                FOutPacketTraits Traits;
                Driver->ServerConnection->LowLevelSend(Packet.GetData(), Packet.GetNumBits(), Traits);
            }
        }
        Handler->SetRawSend(false);

        // [ClientNetTick]
        // regardless of sending actual InitialPacket, update LastClientSendTimestamp
            // [ClientNetTick]
            // ì‹¤ì œ InitialPacket ì „ì†¡ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ LastClientSendTimestampë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        LastClientSendTimestamp = FPlatformTime::Seconds();
    }
}
```

```cpp
virtual void LowLevelSend(void* Data, int32 CountBits, FOutPacketTraits& Traits) override
{
    const uint8* DataToSend = reinterpret_cast<uint8*>(Data);

    // process any packet modifiers
    // note that we SetRawSend(true), so we are not get into this if-statement
    // - in general case, we are into this statement, but for now skip and defer in near-future

        // íŒ¨í‚· ìˆ˜ì •ì ì²˜ë¦¬
        // SetRawSend(true)ë¡œ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì´ ifë¬¸ì— ë“¤ì–´ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤
        // - ì¼ë°˜ì ì¸ ê²½ìš°ì—ëŠ” ì´ êµ¬ë¬¸ì— ë“¤ì–´ê°€ì§€ë§Œ, ì§€ê¸ˆì€ ê±´ë„ˆë›°ê³  ë‚˜ì¤‘ì— ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤
    if (Handler.IsValid() && !Handler->GetRawSend())
    {
        // @todo
    }

    // finally call FSocket::SendTo!
    // - see FSocketSendResult briefly
    // - note that calling FSocketBSD::SendTo with 'RemoteAddr(server address)'
        // ë§ˆì¹¨ë‚´ FSocket::SendToë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤!
        // - FSocketSendResultë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
        // - 'RemoteAddr(ì„œë²„ ì£¼ì†Œ)'ì™€ í•¨ê»˜ FSocketBSD::SendToë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì— ì£¼ëª©í•˜ì„¸ìš”
    FSocketSendResult SendResult;
    int32 CountBytes = FMath::DivideAndRoundUp(CountBits, 8);
    if (CountBytes > 0)
    {
        FSocket* CurSocket = GetSocket();
        bool bWasSuccessful = CurSocket->SendTo(DataToSend, CountBytes, SendResult.BytesSent, *RemoteAddr);
        if (!bWasSuccessful)
        {
            ISocketSubsystem* const SocketSubsystem = Driver->GetSocketSubsystem();
            SendResult.Error = SocketSubsystem->GetLastErrorCode();
        }
    }

    // [ClientNetTick]
    // *** finally we send the packet, it is time to see how Unreal receive packets and dispatch it!
        // [ClientNetTick]
        // *** ë§ˆì¹¨ë‚´ íŒ¨í‚·ì„ ë³´ëƒˆìŠµë‹ˆë‹¤. ì´ì œ ì–¸ë¦¬ì–¼ì´ ì–´ë–»ê²Œ íŒ¨í‚·ì„ ë°›ê³  ì²˜ë¦¬í•˜ëŠ”ì§€ ì‚´í´ë³¼ ì°¨ë¡€ì…ë‹ˆë‹¤!
}
```