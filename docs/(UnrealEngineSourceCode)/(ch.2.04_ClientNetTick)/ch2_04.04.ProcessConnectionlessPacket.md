---
layout: default
title: "04-04. ProcessConnectionlessPacket"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** process packets not associated with a NetConnection, performing handshaking and NetConnection creation or remapped as necessary */
/** NetConnectionê³¼ ì—°ê´€ë˜ì§€ ì•Šì€ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ë©°, í•„ìš”ì— ë”°ë¼ í•¸ë“œì…°ì´í‚¹ ë° NetConnection ìƒì„± ë˜ëŠ” ì¬ë§¤í•‘ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤ */

// this function is only called in server-side
// ì´ í•¨ìˆ˜ëŠ” ì„œë²„ ì¸¡ì—ì„œë§Œ í˜¸ì¶œë©ë‹ˆë‹¤

UNetConnection* ProcessConnectionlessPacket(FReceivedPacketView& PacketRef, const FPacketBufferView& WorkingBuffer)
{
    UNetConnection* ReturnVal = nullptr;
    TSharedPtr<StatelessConnectHandlerComponent> StatelessConnect;

    // in this course, we are NOT dealing with 'RestartHandshake'
    // ì´ ê³¼ì •ì—ì„œëŠ” 'RestartHandshake'ë¥¼ ë‹¤ë£¨ì§€ ì•ŠìŠµë‹ˆë‹¤
    bool bRestartedHandshake = false;

    // focus on these two variables
    // ì´ ë‘ ë³€ìˆ˜ì— ì§‘ì¤‘í•˜ì„¸ìš”
    bool bPassedChallenge = false;
    bool bIgnorePacket = true;

    // for handling "initialpacket" for requesting connection to the server, it will get into this statement
    // ì„œë²„ì— ì—°ê²°ì„ ìš”ì²­í•˜ëŠ” "initialpacket"ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì´ êµ¬ë¬¸ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤
    if (Notify != nullptr && ConnectionlessHandler.IsValid() && StatelessConnectComponent.IsValid())
    {
        // ConnectionlessHandler is 'PacketHandler'
        // ConnectionlessHandlerëŠ” 'PacketHandler'ì…ë‹ˆë‹¤
        StatelessConnect = ConnectionlessHandler.Pin();
        EIncomingResult Result = ConnectionlessHandler->IncomingConnectionless(PacketRef);
        if (Result == EIncomingResult::Success)
        {
            // we just send 'ConnectChanllenge' packet
            // - for now, we failed to pass 'challenge' yet
                // 'ConnectChallenge' íŒ¨í‚·ì„ ë°©ê¸ˆ ë³´ëƒˆìŠµë‹ˆë‹¤
                // - í˜„ì¬ë¡œì„œëŠ” ì•„ì§ 'challenge'ë¥¼ í†µê³¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
            bPassedChallenge = StatelessConnect->HasPassedChallenge(Address, bRestartedHandshake);
            if (bPassedChallenge)
            {
                int32 NewCountBytes = PacketRef.DataView.NumBytes();
                uint8* WorkingData = WorkingBuffer.Buffer.GetData();
                if (NewCountBytes > 0)
                {
                    // NewCountBytes == 0
                }
                PacketRef.DataView = {WorkingData, NewCountBytes, ECountUnits::Bytes};
            }
        }
    }

    if (bPassedChallenge)
    {
        if (!bRestartedHandshake)
        {
            ReturnVal = NewObject<UIpConnection>(GetTransientPackage(), NewConnectionClass);

            // we pass IpNetDriver's SocketPrivate
            ReturnVal->InitRemoteConnection(this, SocketPrivate.Get(), World ? World->URL : FURL(), *Address, USOCK_Open);

            // set the initial packet sequence from the handshake data
            if (StatelessConnect.IsValid())
            {
                int32 ServerSequence = 0;
                int32 ClientSequence = 0;
                StatelessConnect->GetChallengeSequence(ServerSequence, ClientSequence);

                // ì—¬ê¸° ì¤‘ìš”í•˜ë‹ˆ ìŠ¤í‚µí•˜ì§€ ë§ì! (UNetConnection::InitSequence)
                ReturnVal->InitSequence(ClientSequence, ServerSequence);
            }

            // PacketHandlerì˜ ModeëŠ” ì—¬ê¸°ì„œ Serverì„!
            // - ì°¸ê³ ë¡œ ì„œë²„ëŠ” StatelessConnectHandlerComponentëŠ” Initializedëœ ìƒíƒœ!
            if (ReturnVal->Handler.IsValid())
            {
                ReturnVal->Handler->BeginHandshaking();
            }

            // UNetDriver::AddClientConnection()
            AddClientConnection(ReturnVal);
        }

        if (StatelessConnect.IsValid())
        {
            StatelessConnect->ResetChallengeData();
        }
    }

    if (bIgnorePacket)
    {
        PacketRef.DataView = {PacketRef.DataView.GetData(), 0, ECountUnits::Bits};
    }

    return ReturnVal;
}
```
