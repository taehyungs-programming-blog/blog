---
layout: default
title: "04-02. ServerInitalSendPacket"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
class UNetDriver : public UObject, public FExec
{
public:
    void InternalTickDispatch(float DeltaSeconds)
    {
        TickDispatch(DeltaSeconds);
    }
```

```cpp
/** handle time update; read and process packets */
// [ClientChallengeResponse]
// most of code to process received packets are same, for now what we are interested in is "ChallengeResponse"
// - see partial code one by one:
//   - first focus on "Connection" variable on client-side

/** ì‹œê°„ ì—…ë°ì´íŠ¸ ì²˜ë¦¬; íŒ¨í‚· ì½ê¸° ë° ì²˜ë¦¬ */
// [ClientChallengeResponse]
// ìˆ˜ì‹ ëœ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ì½”ë“œëŠ” ë™ì¼í•˜ë©°, í˜„ì¬ ìš°ë¦¬ê°€ ê´€ì‹¬ ìˆëŠ” ê²ƒì€ "ChallengeResponse"ì…ë‹ˆë‹¤.
// - ë¶€ë¶„ ì½”ë“œë¥¼ í•˜ë‚˜ì”© ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:
//   - ë¨¼ì € í´ë¼ì´ì–¸íŠ¸ ì¸¡ì˜ "Connection" ë³€ìˆ˜ì— ì§‘ì¤‘í•©ë‹ˆë‹¤ 
virtual void TickDispatch(float DeltaTime) override
{
    //...

    // process all incoming packets
    // finally we can have a change to see how unreal networking engine receive packets
    
    // ëª¨ë“  ìˆ˜ì‹  íŒ¨í‚· ì²˜ë¦¬
    // ë§ˆì¹¨ë‚´ ì–¸ë¦¬ì–¼ ë„¤íŠ¸ì›Œí‚¹ ì—”ì§„ì´ íŒ¨í‚·ì„ ì–´ë–»ê²Œ ìˆ˜ì‹ í•˜ëŠ”ì§€ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
    for (FPacketIterator It(this); It; ++It)
    {
        // if we are in this scope, we successfully get a single packet from the socket
        // - by calling FPacketIterator::GetCurrentPacket(), we can retrieve packet data into FReceivedPacketView

            // ì´ ë²”ìœ„ì— ìˆë‹¤ë©´, ì†Œì¼“ì—ì„œ ë‹¨ì¼ íŒ¨í‚·ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì˜¨ ê²ƒì…ë‹ˆë‹¤
            // - FPacketIterator::GetCurrentPacket()ì„ í˜¸ì¶œí•˜ì—¬ íŒ¨í‚· ë°ì´í„°ë¥¼ FReceivedPacketViewë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
        FReceivedPacketView ReceivedPacket;
        FInPacketTraits& ReceivedTraits = ReceivedPacket.Traits;
        bool bOk = It.GetCurrentPacket(ReceivedPacket);

        // retrieve 'FromAddr(client address)' or 'FromAddr(server address)'
        // 'FromAddr(í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œ)' ë˜ëŠ” 'FromAddr(ì„œë²„ ì£¼ì†Œ)' ê²€ìƒ‰
        const TSharedRef<const FInternetAddr> FromAddr = ReceivedPacket.Address.ToSharedRef();

        UNetConnection* Connection = nullptr;
        UIpConnection* const MyServerConnection = GetServerConnection();

        // figure out which socket the received data came from
        // ìˆ˜ì‹ ëœ ë°ì´í„°ê°€ ì–´ëŠ ì†Œì¼“ì—ì„œ ì™”ëŠ”ì§€ íŒŒì•…

        // [ServerInitialSendPacket]
        // if we have valid ServerConnection, the current TickDispatch is for client-side
        // - as client-side connection, we just try to only receive any packet from the 'server'
        // - so, we compare the received packet's address and RemoteAddr(server address)
        // - and if it is matched, we set our connection as 'MyServerConnection'
        // - but, for now server-side, ServerConnection is null!
            // [ì„œë²„ ì´ˆê¸° ì „ì†¡ íŒ¨í‚·]
            // ìœ íš¨í•œ ServerConnectionì´ ìˆë‹¤ë©´, í˜„ì¬ TickDispatchëŠ” í´ë¼ì´ì–¸íŠ¸ ì¸¡ì…ë‹ˆë‹¤
            // - í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì—°ê²°ë¡œì„œ, ìš°ë¦¬ëŠ” 'ì„œë²„'ë¡œë¶€í„° ì˜¤ëŠ” íŒ¨í‚·ë§Œ ìˆ˜ì‹ í•˜ë ¤ê³  í•©ë‹ˆë‹¤
            // - ë”°ë¼ì„œ ìˆ˜ì‹ ëœ íŒ¨í‚·ì˜ ì£¼ì†Œì™€ RemoteAddr(ì„œë²„ ì£¼ì†Œ)ë¥¼ ë¹„êµí•©ë‹ˆë‹¤
            // - ì¼ì¹˜í•˜ë©´ ìš°ë¦¬ì˜ ì—°ê²°ì„ 'MyServerConnection'ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤
            // - í•˜ì§€ë§Œ í˜„ì¬ ì„œë²„ ì¸¡ì—ì„œëŠ” ServerConnectionì´ nullì…ë‹ˆë‹¤!
        if (MyServerConnection)
        {
            // [ClientChallengeResponse]
            // do we have valid "MyServerConnection"?
            // - YES: for client-side, we already construct IpConnection successfully and we are ready to send/receive packet by ServerConnection
            // - we also meet the condition, 'MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr)'
            // - now we set "Connection" with "MyServerConnection" successfully in **client-side**
            // - we'll go straight to the code line

            // [ClientChallengeResponse]
            // ìœ íš¨í•œ "MyServerConnection"ì´ ìˆìŠµë‹ˆê¹Œ?
            // - ì˜ˆ: í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œëŠ” ì´ë¯¸ IpConnectionì„ ì„±ê³µì ìœ¼ë¡œ êµ¬ì„±í–ˆê³  ServerConnectionìœ¼ë¡œ íŒ¨í‚·ì„ ì†¡ìˆ˜ì‹ í•  ì¤€ë¹„ê°€ ë˜ì–´ ìˆìŠµë‹ˆë‹¤
            // - ë˜í•œ 'MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr)' ì¡°ê±´ë„ ì¶©ì¡±í•©ë‹ˆë‹¤
            // - ì´ì œ **í´ë¼ì´ì–¸íŠ¸ ì¸¡**ì—ì„œ "Connection"ì„ "MyServerConnection"ìœ¼ë¡œ ì„±ê³µì ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤
            // - ë°”ë¡œ ì½”ë“œ ë¼ì¸ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤
            if (MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr))
            {
                Connection = MyServerConnection;
            }
        }

        if (Connection == nullptr)
        {
            // [ServerInitialSendPacket]
            // server-side logic: try to find constructed connections from 'MappedClientConnections'
            // - note that server has connected client-connections
            // - the server distinguish client connection by 'FromAddr'

            // [ServerInitialSendPacket]
            // ì„œë²„ ì¸¡ ë¡œì§: 'MappedClientConnections'ì—ì„œ êµ¬ì„±ëœ ì—°ê²°ì„ ì°¾ìœ¼ë ¤ê³  ì‹œë„
            // - ì„œë²„ê°€ ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ê°€ì§€ê³  ìˆìŒì— ì£¼ëª©
            // - ì„œë²„ëŠ” 'FromAddr'ë¡œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ êµ¬ë¶„
            auto* Result = MappedClientConnections.Find(FromAddr);
            if (Result)
            {
                UNetConnection* ConnVal = *Result;
                if (ConnVal)
                {
                    Connection = ConnVal;
                }
            }
            // [ServerInitialSendPacket]
            // it is natural to match client-connection's RemoteAddr is client-address!
            // - server's NetConnection's RemoteAddr has client's address
            // - from the server point of view, remote means client's address and local means server address~ :)

            // [ServerInitialSendPacket]
            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì˜ RemoteAddrì´ í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œì™€ ì¼ì¹˜í•˜ëŠ” ê²ƒì€ ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤!
            // - ì„œë²„ì˜ NetConnectionì˜ RemoteAddrì€ í´ë¼ì´ì–¸íŠ¸ì˜ ì£¼ì†Œë¥¼ ê°€ì§‘ë‹ˆë‹¤
            // - ì„œë²„ ê´€ì ì—ì„œ remoteëŠ” í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œë¥¼ ì˜ë¯¸í•˜ê³  localì€ ì„œë²„ ì£¼ì†Œë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤~ :)
            check(Connection == nullptr || CastChecked<UIpConnection>(Connection)->RemoteAddr->CompareEndpoints(*FromAddr));
        }

        if (bOk == false)
        {
            // ERROR
        }
        else
        {
            // if we didn't find a client connection, maybe create new one
            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ì°¾ì§€ ëª»í–ˆë‹¤ë©´ ìƒˆë¡œ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

            // [ServerInitialSendPacket]
            // the server get the packet from not-mapped clients
            // - it is very high possibility to be the packet for connection
            // - to construct complete-client-UNetConnection, first as we saw, need to succeed on handshake
            // - see FPacketBufferView 
            // - see FPacketIterator::GetWorkingBuffer 
            // - finally see how connectionless-packet(not mapped NetConnection), see UIpNetDriver::ProcessConnectionlessPacket

            // [ì„œë²„ ì´ˆê¸° ì „ì†¡ íŒ¨í‚·]
            // ì„œë²„ê°€ ë§¤í•‘ë˜ì§€ ì•Šì€ í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° íŒ¨í‚·ì„ ë°›ìŠµë‹ˆë‹¤
            // - ì—°ê²°ì„ ìœ„í•œ íŒ¨í‚·ì¼ ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤
            // - ì™„ì „í•œ í´ë¼ì´ì–¸íŠ¸ UNetConnectionì„ êµ¬ì„±í•˜ë ¤ë©´, ë¨¼ì € ìš°ë¦¬ê°€ ë³¸ ëŒ€ë¡œ í•¸ë“œì…°ì´í¬ì— ì„±ê³µí•´ì•¼ í•©ë‹ˆë‹¤
            // - FPacketBufferView ì°¸ì¡° 
            // - FPacketIterator::GetWorkingBuffer ì°¸ì¡° 
            // - ë§ˆì§€ë§‰ìœ¼ë¡œ ì—°ê²° ì—†ëŠ” íŒ¨í‚·(ë§¤í•‘ë˜ì§€ ì•Šì€ NetConnection)ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ëŠ”ì§€ UIpNetDriver::ProcessConnectionlessPacket ì°¸ì¡° (012: ì„œë²„ ì´ˆê¸° ì „ì†¡ íŒ¨í‚·ìœ¼ë¡œ ì´ë™)
            if (Connection == nullptr)
            {
                FPacketBufferView WorkingBuffer = It.GetWorkingBuffer();
                Connection = ProcessConnectionlessPacket(ReceivedPacket, WorkingBuffer);

                // for now, 'bIngorePacket' is TRUE:
                // - ReceivedPacket.DataView.NumBytes() == 0, cuz we consume all data in the packet of handshake
                // í˜„ì¬ 'bIngorePacket'ì€ TRUEì…ë‹ˆë‹¤:
                // - ReceivedPacket.DataView.NumBytes() == 0, í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì†Œë¹„í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤
                bIgnorePacket = ReceivedPacket.DataView.NumBytes() == 0;
            }

            // send the packet to the connection for processing
            // it is the first time for client to be handled by FPacketIterator
            // - see UIpConnection::ReceivedRawPacket

            // ì²˜ë¦¬ë¥¼ ìœ„í•´ íŒ¨í‚·ì„ ì—°ê²°ë¡œ ë³´ëƒ…ë‹ˆë‹¤
            // í´ë¼ì´ì–¸íŠ¸ê°€ FPacketIteratorì— ì˜í•´ ì²˜ë¦¬ë˜ëŠ” ì²« ë²ˆì§¸ ì‹œê°„ì…ë‹ˆë‹¤
            // - UIpConnection::ReceivedRawPacket ì°¸ì¡°
            if (Connection != nullptr && !bIgnorePacket)
            {
                Connection->ReceivedRawPacket((uint8*)ReceivedPacket.DataView.GetData(), ReceivedPacket.DataView.NumBytes());
            }
        }
    }
}
```