---
layout: default
title: "04-02. UNetConnection::Tick"
parent: "([Network] 04. ClientNetTick)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
class UNetConnection : public UPlayer
{
    // ...

/** poll the connection, if it is timed out, close it */
/** ì—°ê²°ì´ íƒ€ì„ì•„ì›ƒë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê³ , íƒ€ì„ì•„ì›ƒëœ ê²½ìš° ì—°ê²°ì„ ì¢…ë£Œí•©ë‹ˆë‹¤ */
virtual void Tick(float DeltaSeconds)
{
    // get frame time
    // as seconds, we calculate current time to manage tick rates (in 120Hz)
    
    // í”„ë ˆì„ ì‹œê°„ì„ ê°€ì ¸ì˜µë‹ˆë‹¤
    // ì´ˆ ë‹¨ìœ„ë¡œ, í‹± ë ˆì´íŠ¸(120Hz)ë¥¼ ê´€ë¦¬í•˜ê¸° ìœ„í•´ í˜„ì¬ ì‹œê°„ì„ ê³„ì‚°í•©ë‹ˆë‹¤
    const double CurrentRealtimeSeconds = FPlatformTime::Seconds();

    // if this is 0, it's our first tick since init, so start our real-time tracking from here
    // "LastTime == 0" means since NetConnection is constructed, the instance tick is not executed yet
    
    // ë§Œì•½ 0ì´ë©´, ì´ˆê¸°í™” ì´í›„ ì²« ë²ˆì§¸ í‹±ì´ë¯€ë¡œ ì—¬ê¸°ì„œë¶€í„° ì‹¤ì‹œê°„ ì¶”ì ì„ ì‹œì‘í•©ë‹ˆë‹¤
    // "LastTime == 0"ì€ NetConnectionì´ ìƒì„±ëœ ì´í›„ ì¸ìŠ¤í„´ìŠ¤ í‹±ì´ ì•„ì§ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤
    if (LastTime == 0.0)
    {
        LastTime = CurrentRealtimeSeconds;
        LastReceiveRealTime = CurrentRealtimeSeconds;
    }

    // 'FrameTime' means the interval time between previous-tick and current-tick
    // - the word, 'FrameTime' is confusing, but by codes, it is straight-forward, right?
    
    // 'FrameTime'ì€ ì´ì „ í‹±ê³¼ í˜„ì¬ í‹± ì‚¬ì´ì˜ ì‹œê°„ ê°„ê²©ì„ ì˜ë¯¸í•©ë‹ˆë‹¤
    // - 'FrameTime'ì´ë¼ëŠ” ë‹¨ì–´ëŠ” í˜¼ë€ìŠ¤ëŸ¬ìš¸ ìˆ˜ ìˆì§€ë§Œ, ì½”ë“œìƒìœ¼ë¡œëŠ” ë§¤ìš° ì§ê´€ì ì…ë‹ˆë‹¤
    FrameTime = CurrentRealtimeSeconds - LastTime;

    // MaxNetTickRate is '120'
    // - you can find 'MaxNetTickRate' is 120 in BaseEngine.ini
    // - the UE netcode is not allowed to ticking more than 120fps
    
    // MaxNetTickRateëŠ” '120'ì…ë‹ˆë‹¤
    // - BaseEngine.iniì—ì„œ 'MaxNetTickRate'ê°€ 120ìœ¼ë¡œ ì„¤ì •ëœ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
    // - UE ë„¤íŠ¸ì›Œí¬ ì½”ë“œëŠ” 120fps ì´ìƒì˜ í‹±ì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
    const int32 MaxNetTickRate = Driver->MaxNetTickRate;
    float EngineTickRate = GEngine->GetMaxTickRate(0.0f, false);
    const float MaxNetTickRateFloat = MaxNetTickRate > 0 ? float(MaxNetTickRate) : MAX_flt;
    const float DesiredTickRate = FMath::Clamp(EngineTickRate, 0.0f, MaxNetTickRateFloat);

    // apply net tick rate limiting if the desired net tick rate is strictly less than the engine tick rate
    // MinNetFrameTime is 0.008 (120 fps: 0.016 == 60fps)
    // - if NetConnection' tick is called within 0.008f, we skip ticking (by calling "return")
    
    // ì›í•˜ëŠ” ë„¤íŠ¸ì›Œí¬ í‹± ë ˆì´íŠ¸ê°€ ì—”ì§„ í‹± ë ˆì´íŠ¸ë³´ë‹¤ ì—„ê²©í•˜ê²Œ ë‚®ì€ ê²½ìš° ë„¤íŠ¸ì›Œí¬ í‹± ë ˆì´íŠ¸ ì œí•œì„ ì ìš©í•©ë‹ˆë‹¤
    // MinNetFrameTimeì€ 0.008ì…ë‹ˆë‹¤ (120 fps: 0.016 == 60fps)
    // - NetConnectionì˜ í‹±ì´ 0.008f ì´ë‚´ì— í˜¸ì¶œë˜ë©´ í‹±ì„ ê±´ë„ˆëœë‹ˆë‹¤ ("return" í˜¸ì¶œ)
    if (!IsInternalTick() && MaxNetTickRateFloat < EngineTickRate && DesiredTickRate > 0.0f)
    {
        const float MinNetFrameTime = 1.0f / DesiredTickRate;
        if (FrameTime < MinNetFrameTime)
        {
            return;
        }
    }

    // update 'LastTime' to reserve the variable, calculating FrameTime in next-tick
    
    // ë‹¤ìŒ í‹±ì—ì„œ FrameTimeì„ ê³„ì‚°í•˜ê¸° ìœ„í•´ 'LastTime' ë³€ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    LastTime = CurrentRealtimeSeconds;

    // handle time-outs
    // if no timeout is set, Timeout value is +INF
    
    // íƒ€ì„ì•„ì›ƒì„ ì²˜ë¦¬í•©ë‹ˆë‹¤
    // íƒ€ì„ì•„ì›ƒì´ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš° Timeout ê°’ì€ +INFì…ë‹ˆë‹¤
    const float Timeout = GetTimeoutValue();

    // where LastReceiveRealTime is updated? UNetConnection::ReceivedPacket()
    // - we are NOT going to see 'HandleConnectionTimeout()'
    
    // LastReceiveRealTimeì€ ì–´ë””ì„œ ì—…ë°ì´íŠ¸ë ê¹Œìš”? UNetConnection::ReceivedPacket()ì—ì„œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤
    // - 'HandleConnectionTimeout()'ëŠ” ì‚´í´ë³´ì§€ ì•Šì„ ì˜ˆì •ì…ë‹ˆë‹¤
    if ((CurrentRealtimeSeconds - LastReceiveRealtime) > Timeout)
    {
        HandleConnectionTimeout(Error);
        if (Driver == NULL)
        {
            return;
        }
    }

    // tick handler
    // do you remember 'StatelessConnectHandlerComponent::SendInitialPacket' is failed to call 'SendToServer' because of UIpConnection's SocketPrivate?
    // - now it's time to send handshake's initial packet!
    
    // í•¸ë“¤ëŸ¬ë¥¼ í‹±í•©ë‹ˆë‹¤
    // UIpConnectionì˜ SocketPrivate ë•Œë¬¸ì— 'StatelessConnectHandlerComponent::SendInitialPacket'ì´ 'SendToServer' í˜¸ì¶œì— ì‹¤íŒ¨í–ˆë˜ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    // - ì´ì œ í•¸ë“œì‰ì´í¬ì˜ ì´ˆê¸° íŒ¨í‚·ì„ ë³´ë‚¼ ì‹œê°„ì…ë‹ˆë‹¤!
    if (Handler.IsValid())
    {
        Handler->Tick(FrameTime);
    }
}
```

---

## PacketHandler ì ê¹ ë³µìŠµ

### ê¸°ë³¸ ê°œë…

* PacketHandlerëŠ” ë„¤íŠ¸ì›Œí¬ íŒ¨í‚·ì˜ ì „ì²˜ë¦¬/í›„ì²˜ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤
* ì£¼ë¡œ íŒ¨í‚·ì˜ ì•”í˜¸í™”, ì••ì¶•, ì¸ì¦ ë“±ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤

### ì£¼ìš” ì»´í¬ë„ŒíŠ¸ë“¤

* `StatelessConnectHandlerComponent`: ì´ˆê¸° ì—°ê²° í•¸ë“œì‰ì´í¬ ì²˜ë¦¬
* `ReliabilityHandlerComponent`: íŒ¨í‚· ì‹ ë¢°ì„± ë³´ì¥
* `EncryptionComponent`: íŒ¨í‚· ì•”í˜¸í™”/ë³µí˜¸í™”

```cpp
class PacketHandler
{
    // ...

void Tick(float DeltaTime)
{
    // as we saw the only handler-component, 'StatelessConnectHandlerComponent::Tick' is called

    // ìš°ë¦¬ê°€ ë³¸ ìœ ì¼í•œ í•¸ë“¤ëŸ¬ ì»´í¬ë„ŒíŠ¸ì¸ 'StatelessConnectHandlerComponent::Tick'ì´ í˜¸ì¶œë©ë‹ˆë‹¤
    for (const TSharedPtr<HandlerComponent>& Component : HandlerComponents)
    {
        if (Component.IsValid())
        {
            Component->Tick(DeltaTime);
        }
    }
}
```

---

## HandlerComponent ì ê¹ ë³µìŠµ

### ê¸°ë³¸ íŠ¹ì§•

* HandlerComponentëŠ” íŒ¨í‚· ì²˜ë¦¬ë¥¼ ìœ„í•œ ê¸°ë³¸ ì»´í¬ë„ŒíŠ¸ í´ë˜ìŠ¤ì…ë‹ˆë‹¤
* PacketHandlerì— ì˜í•´ ê´€ë¦¬ë˜ë©° ë„¤íŠ¸ì›Œí¬ íŒ¨í‚·ì˜ ì „/í›„ì²˜ë¦¬ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤

```cpp
class HandlerComponent 
{
    // ìˆ˜ì‹ ëœ íŒ¨í‚· ì²˜ë¦¬
    virtual bool IncomingPacket(FBitReader& Packet) = 0;
    
    // ì†¡ì‹ í•  íŒ¨í‚· ì²˜ë¦¬
    virtual bool OutgoingPacket(FBitWriter& Packet) = 0;
}
```

```cpp
class HandlerComponent
{
    // ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”
    virtual void Initialize() = 0;
    
    // ì£¼ê¸°ì ì¸ ìƒíƒœ ì—…ë°ì´íŠ¸
    virtual void Tick(float DeltaTime) = 0;
}
```

### ì£¼ìš” êµ¬í˜„ í´ë˜ìŠ¤ë“¤

* `StatelessConnectHandlerComponent`: 
    * ì—°ê²° ì´ˆê¸°í™” ë° í•¸ë“œì‰ì´í¬ ì²˜ë¦¬
    * í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ê°„ ì´ˆê¸° ì—°ê²° ì„¤ì •
* `ReliabilityHandlerComponent`: 
    * íŒ¨í‚· ì „ì†¡ì˜ ì‹ ë¢°ì„± ë³´ì¥
    * íŒ¨í‚· ì†ì‹¤ ë³µêµ¬ ë° ì¬ì „ì†¡ ê´€ë¦¬
* `EncryptionHandlerComponent`: 
    * íŒ¨í‚· ë°ì´í„° ì•”í˜¸í™”/ë³µí˜¸í™”
    * ë³´ì•ˆ í†µì‹  ì§€ì›

---

## PacketHandlerì™€ HandlerComponentì˜ ê´€ê³„

### êµ¬ì¡°ì  ê´€ê³„

```cpp
class PacketHandler
{
private:
    // HandlerComponentë“¤ì„ ë°°ì—´ë¡œ ê´€ë¦¬
    TArray<TSharedPtr<HandlerComponent>> HandlerComponents;
    
    // í˜„ì¬ í™œì„±í™”ëœ HandlerComponent
    TSharedPtr<HandlerComponent> ActiveHandler;
}
```

### ì£¼ìš” íŠ¹ì§•

* ê³„ì¸µì  êµ¬ì¡°
    * PacketHandlerëŠ” ìƒìœ„ ê´€ë¦¬ì ì—­í• 
    * HandlerComponentëŠ” ì‹¤ì œ íŒ¨í‚· ì²˜ë¦¬ ë‹´ë‹¹
    * ê° ì»´í¬ë„ŒíŠ¸ëŠ” ë…ë¦½ì ìœ¼ë¡œ ë™ì‘í•˜ë©´ì„œë„ ìˆœì°¨ì ìœ¼ë¡œ ì—°ê²°ë¨
* ì±…ì„ ë¶„ë¦¬
    * PacketHandler: ì „ì²´ íŒ¨í‚· ì²˜ë¦¬ íë¦„ ê´€ë¦¬
    * HandlerComponent: íŠ¹ì • ê¸°ëŠ¥(ì•”í˜¸í™”, ì‹ ë¢°ì„± ë“±) êµ¬í˜„
* í™•ì¥ì„±
    * ìƒˆë¡œìš´ HandlerComponent ì¶”ê°€ê°€ ìš©ì´
    * ê¸°ì¡´ ì‹œìŠ¤í…œ ìˆ˜ì • ì—†ì´ ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ ê°€ëŠ¥

---

```cpp
class PacketHandler
{
    // ...

void Tick(float DeltaTime)
{
    // as we saw the only handler-component, 'StatelessConnectHandlerComponent::Tick' is called

    // ìš°ë¦¬ê°€ ë³¸ ìœ ì¼í•œ í•¸ë“¤ëŸ¬ ì»´í¬ë„ŒíŠ¸ì¸ 'StatelessConnectHandlerComponent::Tick'ì´ í˜¸ì¶œë©ë‹ˆë‹¤
    for (const TSharedPtr<HandlerComponent>& Component : HandlerComponents)
    {
        if (Component.IsValid())
        {
            Component->Tick(DeltaTime);
        }
    }
}
```