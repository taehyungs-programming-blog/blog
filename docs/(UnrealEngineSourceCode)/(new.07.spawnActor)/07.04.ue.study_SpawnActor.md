---
layout: default
title: "07-04. SpawnActor"
parent: "(07. SpawnActor)"
grand_parent: "(UE SourceCode ë¶„ì„ ðŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/**
* spawns the appropriate PlayerController for the given options: split out from Login() for easier overriding
* override this to conditionally spawn specialized PlayerControllers, for instance 
*/
virtual APlayerController* SpawnPlayerController(ENetRole InRemoteRole, const FString& Options)
{
    // I remove wrapper function calls
    FActorSpawnParameters SpawnInfo;
    SpawnInfo.Instigator = GetInstigator();
    SpawnInfo.bDeferConstruction = true;

    // we never want to save player controllers into a map
    SpawnInfo.ObjectFlags |= RF_Transient;

    APlayerController* NewPC = GetWorld()->SpawnActor<APlayerController>(PlayerControllerClass, FVector::ZeroVector, FRotator::ZeroRotator, SpawnInfo);

    if (NewPC)
    {
        if (InRemoteRole == ROLE_SimulatedProxy)
        {
            // this is a local player because it has no authority/autonomous remote role
            NewPC->SetAsLocalPlayerController();
        }

        NewPC->FinishSpawning(FTransform(FVector::ZeroVector, FRotator::ZeroRotator), false, nullptr, ESpawnActorScaleMethod::MultiplyWithRoot);
    }

    return NewPC;
}
```

```cpp
/** spawn Actors with given transform and SpawnParameters */
AActor* SpawnActor(UClass* Class, FTransform const* UserTransformPtr, const FActorSpawnParameters& SpawnParameters = FActorSpawnParameters())
{
    //  when we spawn Actor in world, Actor's outer will be persistent-level
    // - as you guess, persistent level's outer is world, so we can see Actor's outer as world
    ULevel* CurrentLevel = PersistentLevel;

    // I abbreviate condition checks for clarity to see codes
#pragma region SpawnActor_Condition Check
    if (!Class->IsChildOf(AActor::StaticClass()))
    {
        return NULL;
    }
    if (Class->HasAnyClassFlags(CLASS_Deprecated))
    {
        return NULL;
    }
#pragma endregion

    // determine where a new actor is spawned: to ULevel
    ULevel* LevelToSpawnIn = SpawnParameters.OverrideLevel;
    if (LevelToSpawnIn == NULL)
    {
        // spawn in the same level as the owner if we have one
        // note that what level is set to CurrentLevel
        LevelToSpawnIn = (SpawnParameters.Owner != NULL) ? SpawnParameters.Owner->GetLevel() : ToRawPtr(CurrentLevel);
    }

    // use class's default actor as a template if none provided
    // if SpawnParameter.Template is not provided, we use Class's CDO
    AActor* Template = SpawnParameters.Template ? SpawnParameters.Template : Class->GetDefaultObject<AActor>();
    check(Template);

    bool bNeedGloballyUniqueName = false;
    FName NewActorName = SpawnParameters.Name;
    if (NewActorName.IsNone())
    {
        // if we are using a template object and haven't specified a name, create a name relative to the template, otherwise let the default object naming behavior in Stat
        // depending on Template, choose the base name of Actor's name:
        // - if Template is from CDO, use Class's name
        // - otherwise (Template is specified), use Template's name
        const FName BaseName = Template->HasAnyFlags(RF_ClassDefaultObject) ? Class->GetFName() : *Template->GetFName().GetPlainNameString();

        // - we use bNeedGloballyUniqueName as 'false'
        NewActorName = FActorSpawnUtils::MakeUniqueActorName(LevelToSpawnIn, Template->GetClass(), BaseName, bNeedGloballyUniqueName);
    }
    else if (StaticFindObjectFast(nullptr, LevelToSpawnIn, NewActorName) 
        || (bNeedGloballyUniqueName != FActorSpawnUtils::IsGloballyUniqueName(NewActorName))
    {
        // if the name of actor is overlapped, create new name
        NewActorName = FActorSpawnUtils::MakeUniqueActorName(LevelToSpawnIn, Template->GetClass(), FActorSpawnutils::GetBaseName(NewActorName), bNeedGloballyUniqueName);
    }

#if WITH_EDITOR || 1
    UPackage* ExternalPackage = nullptr;
    if (bNeedGloballyUniqueName && !ExternalPackage)
    {
        TStringBuilderWithBuffer<TCHAR, NAME_SIZE> ActorPath;
        ActorPath += LevelToSpawnIn->GetPathName();
        ActorPath += TEXT(".");
        ActorPath += NewActorName.ToString();

        // note that Actor is stored separate package file for supporting the OFPA(One File Per Actor)
        // Diagram:
        //                                                          
        //  [Level-Actor]                   [External Actor Files]  
        //                        â”Œâ”€â”                               
        //                        â”‚ â”‚                               
        //      Level0            â”‚ â”‚                               
        //       â”‚                â”‚ â”‚                               
        //       â”œâ”€â”€Actor0 â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â–º External_Actor0       
        //       â”‚                â”‚ â”‚                               
        //       â”œâ”€â”€Actor1 â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â–º External_Actor1       
        //       â”‚                â”‚ â”‚                               
        //       â””â”€â”€Actor2 â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â–º External_Actor2       
        //                        â”‚ â”‚                               
        //                        â”‚ â”‚                               
        //                        â”‚ â”‚                               
        //                        â”‚ â”‚                               
        //      Level1            â”‚ â”‚                               
        //       â”‚                â”‚ â”‚                               
        //       â”œâ”€â”€Actor3 â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â–º External_Actor3       
        //       â”‚                â”‚ â”‚                               
        //       â”œâ”€â”€Actor4 â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â–º External_Actor4       
        //       â”‚                â”‚ â”‚                               
        //       â””â”€â”€Actor5 â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â–º External_Actor5       
        //                        â”‚ â”‚                               
        //                        â””â”€â”˜                               
        //                 OFPA(One-File-Per-Actor)                 
        //   
        // Why do we need the OFPA?
        // - it can break dependencies between level and actors
        // - by separating actors and levels, multiple users can modify same level at the same time
        // - see the diagram:
        //                                                                                                                                                   
        //  [Previous]                                                              [Current]                                                                
        //                                                                                                                                                   
        //    â”Œâ”€Level0â”€â”€â”€â”€â”€â”€â”                                                          â”Œâ”€Level0â”€â”€â”€â”€â”€â”€â”                                                       
        //    â”‚             â”‚                                                          â”‚             â”‚                                                       
        //    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚                                                          â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  
        //    â”‚ â”‚Actor0â”‚ â—„â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ User0                                        â”‚ â”‚Actor0â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤External Actor0â”‚â—„â”€â”€â”€â”€â”€â”€â”€User0                     
        //    â”‚ â””â”€â”€â”€â”€â”€â”€â”˜    â”‚                                                          â”‚ â””â”€â”€â”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  
        //    â”‚             â”‚                                                          â”‚             â”‚                                                       
        //    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚                                                          â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  
        //    â”‚ â”‚Actor1â”‚ â—„â”€â”€â”¼â”€â”€â”€[X]â”€â”€â”€â”€â”€â”€ User1                                        â”‚ â”‚Actor1â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤External Actor1â”‚â—„â”€â”€â”€â”€â”€â”€â”€User1                     
        //    â”‚ â””â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚                                                     â”‚ â””â”€â”€â”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  
        //    â”‚             â”‚    â”‚                                                     â”‚             â”‚                                                       
        //    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            ***Using OFPA, User0 and User1 can modify  
        //                     User1 can NOT modify Level0                                                                                                   
        //                                                                                                                                                   
        //                                                                                                                                                   
        //                   â”‚                                                                                                                               
        //                   â”‚                                                                                                                               
        //   To modify Actor0 and Actor1 by separate users (User0 and User1)                                                                                 
        //                   â”‚                                                                                                                               
        //                   â”‚                                                                                                                               
        //                   â–¼                                                                                                                               
        //                                                                                                                                                   
        //    â”Œâ”€Level0â”€â”€â”€â”€â”€â”€â”                                                                                                                                
        //    â”‚             â”‚                                                                                                                                
        //    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚                                                                                                                                
        //    â”‚ â”‚Actor0â”‚â—„â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ User0                                                                                                               
        //    â”‚ â””â”€â”€â”€â”€â”€â”€â”˜    â”‚                                                                                                                                
        //    â”‚             â”‚                                                                                                                                
        //    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                                                                                
        //                               ***Now User0 and User1 can modify Actor0 and Actor1                                                                 
        //    â”Œâ”€Level1â”€â”€â”€â”€â”€â”€â”                by separting Actors to Level0 and Level1                                                                        
        //    â”‚             â”‚                                                                                                                                
        //    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”    â”‚                                                                                                                                
        //    â”‚ â”‚Actor1â”‚â—„â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ User1                                                                                                               
        //    â”‚ â””â”€â”€â”€â”€â”€â”€â”˜    â”‚                                                                                                                                
        //    â”‚             â”‚                                                                                                                                
        //    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                                                                                
        //                                                                                                                                                               
        ExternalPackage = ULevel::CreateActorPackage(LevelToSpawnIn->GetPackage(), LevelToSpawnIn->GetActorPackagingScheme(), *ActorPath);
    }
#endif

    FTransform const UserTransform = UserTransformPtr ? *UserTransformPtr : FTransform::Identity;

    // do you remember ESpawnActorCollisionHandlingMethod?
    ESpawnActorCollisionHandlingMethod CollisionHandlingOverride = SpawnParameters.SpawnCollisionHandlingOverride;

    // use override if set, else fall back to actor's preference
    // if CollisionHandlingOverride is 'Undefined', try to use Template's SpawnCollisionHandlingMethod
    ESpawnActorCollisionHandlingMethod const CollisionHandlingMethod = (CollisionHandlingOverride == ESpawnActorCollisionHandlingMethod::Undefined) ? Template->SpawnCollisionHandlingMethod : CollisionHandlingOverride;

    // see if we can avoid spawning altogether by checking native components
    // note: we can't handle all cases here, since we don't know the full component hiearchy until after the actor is spawned
    if (CollisionHandlingMethod == ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding)
    {
        // skip the detail
        //...
    }

    // as we saw it in ExecutConstruction(), with CDO, we use NewObject, not StaticDuplicateObject()
    EObjectFLags ActorFlags = SpawnParameters.ObjectFlags;
    AActor* const Actor = NewObject<AActor>(LevelToSpawnIn, Class, NewActorName, ActorFlags, Template, false/*bCopyTransientsFromClassDefaults*/, nullptr/*InInstanceGraph*/, ExternalPackage);
    check(Actor);
    check(Actor->GetLevel() == LevelToSpawnIn);

    // Actor is belonged to ULevel and also mark it as GCed object by inserting ActorsForGC
    LevelToSpawnIn->Actors.Add(Actor);
    LevelToSpawnIn->ActorsForGC.Add(Actor);

    // tell the actor what method to use, in case it was overriden
    Actor->SpawnCollisionHandlingMethod = CollisionHandlingMethod;

    Actor->PostSpawnInitialize(UserTransform, SpawnParameters.Owner, SpawnParameter.Instigator, SpawnParameters.IsRemoteOwned(), SpawnParameters.bNoFail, SpawnParameters.bDeferConstruction, SpawnParameters.TransformScaleMethod);

    // if we are spawning an external actor, mark this package dirty
    if (ExternalPackage)
    {
        ExternalPackage->MarkPackageDirty();
    }

    // broadcast notification of spawn
    OnActorsSpawned.Broadcast(Actor);

    // add this newly spawned actor to the network actor list: 
    // - do this after PostSpawnInitialize so that actor has "finished" spawning
    AddNetworkActor(Actor);

    return Actor;
}
```