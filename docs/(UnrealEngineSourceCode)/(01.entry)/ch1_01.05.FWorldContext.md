---
layout: default
title: "01-05. FWorldContext"
parent: "(01. UEì˜ Mainì€ ì–´ë””ì¼ê¹Œ?)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/**
 * FWorldContext
 * a context for dealing with UWorlds at the engine level. as the engine brings up and destroys world, we need a way to keep straight
 * what world belongs to what
 * 
 * WorldContexts can be throught of as a track. by default, we have 1 track that we load and unload levels on. adding a second context
 * is adding a second track; another track of progression for worlds to live on.
 * 
 * for the GameEngine, there will be one WorldContext until we decide to support multiple simultaneous worlds.
 * for the EditorEngine, there may be one WorldContext for EditorWorld and one for the PIE World.
 * 
 * FWorldContext provides both a way to manage 'the current PIE UWorld*' as well as state that goes along with connecting/travelling to
 * new worlds
 * 
 * FWorldContext should remain internal to the UEngine classes. outside code should not keep pointers or try to manage FWorldContexts directly.
 * outside code can still deal with UWorld*, and pass UWorld*s into Engine level functions. the Engine code can look up the relevant context
 * for a given UWorld*
 * 
 * for convenience, FWorldContext can maintain outside pointers to UWorld*s. for example, PIE can tie UWorld* UEditorEngine::PlayWorld to the PIE
 * world context. if the PIE UWorld changes, the UEditorEngine::PlayWorld pointer will be automatically updated. this is done with AddRef() and 
 * SetCurrentWorld()
 */

// ì—”ì§„ ë ˆë²¨ì—ì„œ UWorldë¥¼ ë‹¤ë£¨ê¸° ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤. ì—”ì§„ì´ ì›”ë“œë¥¼ ìƒì„±í•˜ê³  íŒŒê´´í•  ë•Œ, ì–´ë–¤ ì›”ë“œê°€ ì–´ë””ì— ì†í•˜ëŠ”ì§€ ëª…í™•íˆ êµ¬ë¶„í•  ë°©ë²•ì´ í•„ìš”í•©ë‹ˆë‹¤.
//
// WorldContextëŠ” íŠ¸ë™ìœ¼ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ìš°ë¦¬ëŠ” ë ˆë²¨ì„ ë¡œë“œí•˜ê³  ì–¸ë¡œë“œí•˜ëŠ” 1ê°œì˜ íŠ¸ë™ì„ ê°€ì§‘ë‹ˆë‹¤. ë‘ ë²ˆì§¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì€
// ë‘ ë²ˆì§¸ íŠ¸ë™ì„ ì¶”ê°€í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤; ì›”ë“œê°€ ì¡´ì¬í•  ìˆ˜ ìˆëŠ” ë˜ ë‹¤ë¥¸ ì§„í–‰ íŠ¸ë™ì…ë‹ˆë‹¤.
//
// GameEngineì˜ ê²½ìš°, ìš°ë¦¬ê°€ ì—¬ëŸ¬ ê°œì˜ ë™ì‹œ ì›”ë“œë¥¼ ì§€ì›í•˜ê¸°ë¡œ ê²°ì •í•  ë•Œê¹Œì§€ í•˜ë‚˜ì˜ WorldContextë§Œ ìˆì„ ê²ƒì…ë‹ˆë‹¤.
// EditorEngineì˜ ê²½ìš°, EditorWorldìš© WorldContext í•˜ë‚˜ì™€ PIE Worldìš© WorldContext í•˜ë‚˜ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
//
// FWorldContextëŠ” 'í˜„ì¬ PIE UWorld*'ë¥¼ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ê³¼ ìƒˆë¡œìš´ ì›”ë“œë¡œ ì—°ê²°/ì´ë™í•˜ëŠ” ê²ƒê³¼ ê´€ë ¨ëœ ìƒíƒœë¥¼ ì œê³µí•©ë‹ˆë‹¤.
//
// FWorldContextëŠ” UEngine í´ë˜ìŠ¤ ë‚´ë¶€ì— ìœ ì§€ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì™¸ë¶€ ì½”ë“œëŠ” FWorldContextì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ìœ ì§€í•˜ê±°ë‚˜ ì§ì ‘ ê´€ë¦¬í•˜ë ¤ê³  í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.
// ì™¸ë¶€ ì½”ë“œëŠ” ì—¬ì „íˆ UWorld*ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìœ¼ë©°, UWorld*ë¥¼ Engine ë ˆë²¨ í•¨ìˆ˜ì— ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Engine ì½”ë“œëŠ” ì£¼ì–´ì§„ UWorld*ì— ëŒ€í•œ ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸ë¥¼
// ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
//
// í¸ì˜ë¥¼ ìœ„í•´ FWorldContextëŠ” UWorld*ì— ëŒ€í•œ ì™¸ë¶€ í¬ì¸í„°ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, PIEëŠ” UWorld* UEditorEngine::PlayWorldë¥¼ PIE ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ì—
// ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. PIE UWorldê°€ ë³€ê²½ë˜ë©´ UEditorEngine::PlayWorld í¬ì¸í„°ê°€ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤. ì´ëŠ” AddRef()ì™€ SetCurrentWorld()ë¥¼ í†µí•´ ìˆ˜í–‰ë©ë‹ˆë‹¤.

// 
// - the context for world used in engine level (UEngine, UEditorEngine, etc)
//   - you can think of FWorldContext as descriptor for loosing dependency between engine and world
// - for GameEngine:
//   - usually one WorldContext, when switching worlds like lobby to in-game world, there is the moment when two world contexts exist
// - for EditorEngine:
//   - when we editing the world with level viewport, we normally face one world context
//   - when we execute the PIE, the new world context is generated and simultaneously, two world contexts exists
//   - when you try to run multiplay game in PIE, multiple world contexts can exist
// - as I said, the world context is for engine, so do NOT maintain FWorldContext elsewhere

// - ì—”ì§„ ë ˆë²¨(UEngine, UEditorEngine ë“±)ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì›”ë“œì˜ ì»¨í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤.
//   - FWorldContextë¥¼ ì—”ì§„ê³¼ ì›”ë“œ ì‚¬ì´ì˜ ì˜ì¡´ì„±ì„ ëŠìŠ¨í•˜ê²Œ í•˜ëŠ” ë””ìŠ¤í¬ë¦½í„°ë¡œ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
// - GameEngineì˜ ê²½ìš°:
//   - ë³´í†µ í•˜ë‚˜ì˜ WorldContextê°€ ìˆì§€ë§Œ, ë¡œë¹„ì—ì„œ ì¸ê²Œì„ ì›”ë“œë¡œ ì „í™˜í•  ë•Œì™€ ê°™ì´ ì›”ë“œë¥¼ ì „í™˜í•  ë•Œ ë‘ ê°œì˜ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•˜ëŠ” ìˆœê°„ì´ ìˆìŠµë‹ˆë‹¤.
// - EditorEngineì˜ ê²½ìš°:
//   - ë ˆë²¨ ë·°í¬íŠ¸ë¡œ ì›”ë“œë¥¼ í¸ì§‘í•  ë•Œ ì¼ë°˜ì ìœ¼ë¡œ í•˜ë‚˜ì˜ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.
//   - PIEë¥¼ ì‹¤í–‰í•  ë•Œ ìƒˆë¡œìš´ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ê°€ ìƒì„±ë˜ì–´ ë™ì‹œì— ë‘ ê°œì˜ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.
//   - PIEì—ì„œ ë©€í‹°í”Œë ˆì´ ê²Œì„ì„ ì‹¤í–‰í•˜ë ¤ê³  í•  ë•Œ ì—¬ëŸ¬ ê°œì˜ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ê°€ ì¡´ì¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
// - ì•ì„œ ë§í–ˆë“¯ì´ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ëŠ” ì—”ì§„ì„ ìœ„í•œ ê²ƒì´ë¯€ë¡œ ë‹¤ë¥¸ ê³³ì—ì„œ FWorldContextë¥¼ ìœ ì§€í•˜ì§€ ë§ˆì„¸ìš”.

struct FWorldContext
{
    void SetCurrentWorld(UWorld* World)
    {
        UWorld* OldWorld = ThisCurrentWorld;
        ThisCurrentWorld = World;

        if (OwningGameInstance)
        {
            OwningGameInstance->OnWorldChanged(OldWorld, ThisCurrentWorld);
        }
    }

    TEnumAsByte<EWorldType::Type> WorldType;
    
    // assign separate name to context different from UWorld's name
    // UWorldì˜ ì´ë¦„ê³¼ ë‹¤ë¥¸ ë³„ë„ì˜ ì´ë¦„ì„ ì»¨í…ìŠ¤íŠ¸ì— í• ë‹¹í•©ë‹ˆë‹¤.
    FName ContextHandle;

    // GameInstance owns ONE world context
    // GameInstanceëŠ” í•˜ë‚˜ì˜ ì›”ë“œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì†Œìœ í•©ë‹ˆë‹¤.
    TObjectPtr<class UGameInstance> OwningGameInstance;

    // the world which the context is referencing
    // ì»¨í…ìŠ¤íŠ¸ê°€ ì°¸ì¡°í•˜ê³  ìˆëŠ” ì›”ë“œì…ë‹ˆë‹¤.
    TObjectPtr<UWorld> ThisCurrentWorld;
};
```