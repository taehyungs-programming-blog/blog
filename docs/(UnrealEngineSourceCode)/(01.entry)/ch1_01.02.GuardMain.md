---
layout: default
title: "01-02. GuardMain"
parent: "(01. UEì˜ Mainì€ ì–´ë””ì¼ê¹Œ?)"
grand_parent: "(UE SourceCode ë¶„ì„ ðŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/**
 * static guarded main function; rolled into own function so we can have error handling for debug/release builds depending on
 * whether a debugger is attached or not
 */
// ì •ì  ë³´í˜¸ëœ ë©”ì¸ í•¨ìˆ˜; ë””ë²„ê±° ì—°ê²° ì—¬ë¶€ì— ë”°ë¼ ë””ë²„ê·¸/ë¦´ë¦¬ìŠ¤ ë¹Œë“œì— ëŒ€í•œ ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìžˆë„ë¡ ë³„ë„ì˜ í•¨ìˆ˜ë¡œ ë¶„ë¦¬ë¨
int32 GuardMain(const TCHAR* CmdLine)
{
    //...

#if !(UE_BUILD_SHIPPING)
    // passing command arguments with "waitforattach" is useful when you want to debug at the starting of the engine
    // "waitforattach" ëª…ë ¹ ì¸ìžë¥¼ ì „ë‹¬í•˜ëŠ” ê²ƒì€ ì—”ì§„ ì‹œìž‘ ì‹œ ë””ë²„ê¹…í•˜ê³  ì‹¶ì„ ë•Œ ìœ ìš©í•¨

    if (FParse::Param(CmdLine, TEXT("waitforattach")))
    {
        // when debugger is attached, it will be out of inf-loop
        // ë””ë²„ê±°ê°€ ì—°ê²°ë˜ë©´ ë¬´í•œ ë£¨í”„ì—ì„œ ë¹ ì ¸ë‚˜ì˜´

        while (!FPlatformMisc::IsDebuggerPresent())
        {
            FPlatformProcess::Sleep(0.1f);
        }
        // it stops here:
        // - it is VERY useful to debugging the VERY starting point

        // ì—¬ê¸°ì„œ ë©ˆì¶¤:
        // - ë§¤ìš° ì´ˆê¸° ì‹œìž‘ì ì„ ë””ë²„ê¹…í•˜ëŠ” ë° ë§¤ìš° ìœ ìš©í•¨
        UE_DEBUG_BREAK();
    }
#endif

    // super early init code: DO NOT MOVE THIS ANYWHERE ELSE:
    // 
    // - CoreDelegates, CoreUObjectDelegates, WorldDelegates, ... 
    // - these delegate classes are good to remember
    // - the unreal engine gives a way to inject the code in a form of provding delegate class like above
    // - here, you **can inject the code very starting point of the unreal engine**

    // ë§¤ìš° ì´ˆê¸° ì´ˆê¸°í™” ì½”ë“œ: ì´ ì½”ë“œë¥¼ ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ì˜®ê¸°ì§€ ë§ˆì„¸ìš”:
    // - CoreDelegates, CoreUObjectDelegates, WorldDelegates, ...
    // - ì´ëŸ¬í•œ ë¸ë¦¬ê²Œì´íŠ¸ í´ëž˜ìŠ¤ë“¤ì„ ê¸°ì–µí•´ë‘ë©´ ì¢‹ìŒ
    // - ì–¸ë¦¬ì–¼ ì—”ì§„ì€ ìœ„ì™€ ê°™ì€ ë¸ë¦¬ê²Œì´íŠ¸ í´ëž˜ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” í˜•íƒœë¡œ ì½”ë“œë¥¼ ì£¼ìž…í•  ìˆ˜ ìžˆëŠ” ë°©ë²•ì„ ì œê³µí•¨
    // - ì—¬ê¸°ì„œ ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ë§¤ìš° ì´ˆê¸° ì‹œìž‘ì ì— ì½”ë“œë¥¼ ì£¼ìž…í•  ìˆ˜ ìžˆìŒ

    FCoreDelegates::GetPreMainInitDelegate().Broadcast();

    // make sure GEngineLoop::Exit() is always called:
    // this pattern is frequently used in unreal engine

    // GEngineLoop::Exit()ê°€ í•­ìƒ í˜¸ì¶œë˜ë„ë¡ ë³´ìž¥:
    // ì´ íŒ¨í„´ì€ ì–¸ë¦¬ì–¼ ì—”ì§„ì—ì„œ ìžì£¼ ì‚¬ìš©ë¨

    struct EngineLoopCleanupGuard
    {
        ~EngineLoopCleanupGuard()
        {
            EngineExit();
        }
    } CleanupGuard;

    // EnginePreInit (1) ì°¸ì¡°
    int32 ErrorLevel = EnginePreInit(CmdLine);

    {
#if WITH_EDITOR || 1
        if (GIsEditor)
        {
            // 
            // - what we are focusing on is the editor build to analyze engine code
            // ìš°ë¦¬ê°€ ì§‘ì¤‘í•˜ëŠ” ê²ƒì€ ì—”ì§„ ì½”ë“œë¥¼ ë¶„ì„í•˜ê¸° ìœ„í•œ ì—ë””í„° ë¹Œë“œìž„

            ErrorLevel = EditorInit(GEngineLoop);
        }
        else
#endif
        {
            ErrorLevel = EngineInit();
        }
    }

    // the pattern to calculate the elapsed time:
    // ê²½ê³¼ ì‹œê°„ì„ ê³„ì‚°í•˜ëŠ” íŒ¨í„´:

    double EngineInitializationTime = FPlatformTime::Seconds() - GStartTime;

    // IsEngineExitRequested() == GIsRequestingExit
    // - here is main loop of the engine

    // IsEngineExitRequested() == GIsRequestingExit
    // - ì—¬ê¸°ê°€ ì—”ì§„ì˜ ë©”ì¸ ë£¨í”„ìž„

    while (!IsEngineExitRequested())
    {
        // before diving into huge code of EngineTick, let's finished reading rest of code in GuardMain() briefly
        // EngineTickì˜ ë°©ëŒ€í•œ ì½”ë“œë¡œ ë“¤ì–´ê°€ê¸° ì „ì—, GuardMain()ì˜ ë‚˜ë¨¸ì§€ ì½”ë“œë¥¼ ê°„ë‹¨ížˆ ì½ì–´ë³´ìž

        EngineTick();

        /*
            void EngineTick()
            {
                GEngineLoop.Tick();
            }
        */
    }

#if WITH_EDITOR || 1
    if (GIsEditor)
    {
        EditorExit();
    }
#endif

    return ErrorLevel;
}
```

---

## (1) EnginePreInit

```cpp
/** preinit the engine loop */
int32 EnginePreInit(const TCHAR* CmdLine)
{
    int32 ErrorLevel = GEngineLoop.PreInit(CmdLine);
    return ErrorLevel;
}
```

```cpp
/** implements the main engine loop */
// ë©”ì¸ ì—”ì§„ ë£¨í”„ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤
class FEngineLoop : public IEngineLoop
{
public:
    /** pre-initialize the main loop - parse command line, sets up GIsEditor, etc */
    // ë©”ì¸ ë£¨í”„ë¥¼ ì‚¬ì „ ì´ˆê¸°í™”í•©ë‹ˆë‹¤ - ëª…ë ¹ì¤„ êµ¬ë¬¸ ë¶„ì„, GIsEditor ì„¤ì • ë“±
    int32 PreInit(const TCHAR* CmdLine)
    {
        //...
    }

    virtual void Tick() override
    {
        // set FApp::CurrentTime, FApp::DeltaTime and potentially wait to enforce max tick rate
        // FApp::CurrentTime, FApp::DeltaTimeì„ ì„¤ì •í•˜ê³  ìµœëŒ€ í‹± ì†ë„ë¥¼ ê°•ì œí•˜ê¸° ìœ„í•´ ìž ìž¬ì ìœ¼ë¡œ ëŒ€ê¸°í•©ë‹ˆë‹¤
        {
            //  as the comments say, it provides CurrentTime, DeltaTime:
            // - however, the most important thing is that this function syncs the GameThread and RenderTherad including RHIThread
            // - these threads are running in parallel:
            //   - to prevent one of these threads running pass over GameThread, the variables like FrameNumber are used to sync each other

            //  ì£¼ì„ì—ì„œ ë§í•œ ëŒ€ë¡œ CurrentTime, DeltaTimeì„ ì œê³µí•©ë‹ˆë‹¤:
            // - í•˜ì§€ë§Œ ê°€ìž¥ ì¤‘ìš”í•œ ì ì€ ì´ í•¨ìˆ˜ê°€ GameThreadì™€ RHIThreadë¥¼ í¬í•¨í•œ RenderThreadë¥¼ ë™ê¸°í™”í•œë‹¤ëŠ” ê²ƒìž…ë‹ˆë‹¤
            // - ì´ ìŠ¤ë ˆë“œë“¤ì€ ë³‘ë ¬ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤:
            //   - GameThreadë¥¼ ë„˜ì–´ì„œ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ FrameNumberì™€ ê°™ì€ ë³€ìˆ˜ë“¤ì´ ì„œë¡œ ë™ê¸°í™”í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤

            GEngine->UpdateTimeAndHandleMaxTickRate();
        }

        // main game engine tick (world, game objects, etc)
        // ë©”ì¸ ê²Œìž„ ì—”ì§„ í‹± (ì›”ë“œ, ê²Œìž„ ì˜¤ë¸Œì íŠ¸ ë“±)
        // 
        // - in editor (lyra project), call the following order: ULyraEditorEngine -> UUnrealEdEngine -> UEditorEngine
        // - we get into UEditorEngine directly
        // 
        // - ì—ë””í„°ì—ì„œ (lyra í”„ë¡œì íŠ¸), ë‹¤ìŒ ìˆœì„œë¡œ í˜¸ì¶œë©ë‹ˆë‹¤: ULyraEditorEngine -> UUnrealEdEngine -> UEditorEngine
        // - ìš°ë¦¬ëŠ” UEditorEngineìœ¼ë¡œ ì§ì ‘ ë“¤ì–´ê°‘ë‹ˆë‹¤

        // EidtorEngine::Tick (2) ì°¸ì¡°
        GEngine->Tick(FApp::GetDeltaTime(), bIdleMode);
    }
};
```

---

## (2) EidtorEngine::Tick

```cpp
virtual void Tick(float DeltaSeconds, bool bIdleMode) override
{
    UWorld* CurrentGWorld = GWorld;

    FWorldContext& EditorContext = GetEditorWorldContext();
}
```