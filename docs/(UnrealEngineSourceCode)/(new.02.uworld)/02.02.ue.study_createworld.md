---
layout: default
title: "02-02. CreateWorld"
parent: "(02. CreateWorld)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ì´ë¡  Levelê³¼ Worldì˜ ì •ì˜

* **Level**
    * Levelì€ ê²Œì„ ë‚´ì˜ ê°œë³„ì ì¸ êµ¬íšì´ë‚˜ ì¥ë©´ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ëŠ” ê²Œì„ì˜ íŠ¹ì • ë§µ, ìŠ¤í…Œì´ì§€, ë˜ëŠ” ì±•í„°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
    * ë³´í†µ `L_` íŒŒì¼ì˜ Prefix
* **World**
    * WorldëŠ” ê²Œì„ì˜ ì „ì²´ì ì¸ í™˜ê²½ì„ ì˜ë¯¸í•˜ë©°, ëª¨ë“  Levelì„ í¬í•¨í•˜ëŠ” ìƒìœ„ ê°œë…ì…ë‹ˆë‹¤. WorldëŠ” ê²Œì„ì˜ ì „ì—­ ì„¤ì •ê³¼ ë™ì  ë ˆë²¨ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤.
    * Settings -> World Settingsì—ì„œ Worldì— ëŒ€í•œ ì „ì—­ ì„¤ì •ì„ ì¡°ì •.
    * World Settings: ì „ì—­ ê²Œì„ ì„¤ì •(ì˜ˆ: ì¤‘ë ¥, ì‹œê°„ íë¦„, ê¸°ë³¸ ê²Œì„ ëª¨ë“œ).

---

```cpp
/** 
 * the world is the top level object representing a map or a sandbox in which Actors and Components will exist and be rendered 
 * 
 * a world can be a single persistent level with an optional list of streaming levels that are loaded and unloaded via volumes and blueprint functions
 * or it can be a collection of levels organized with a World Composition (->haker: OLD COMMENT...)
 * 
 * in a standalone game, generally only a single World exists except during seamless area transition when both a destination and current world exists
 * in the editor many Worlds exist: 
 * - the level being edited
 * - each PIE instance
 * - each editor tool which has an interactive rendered viewport, and many more
 */
class UWorld final : public UObject, public FNetworkNotify
{
    using InitializationValues = FWorldInitializationValues;

    /** static function that creates a new UWorld and returns a pointer to it */
    static UWorld* CreateWorld(
        const EWorldType::Type InWorldType, 
        bool bInformEngineOfWorld, 
        FName WorldName = NAME_None, 
        UPackage* InWorldPackage = NULL, 
        bool bAddToRoot = true, 
        ERHIFeatureLevel::Type InFeatureLevel = ERHIFeatureLevel::Num, 
        const InitializationValues* InIVS = nullptr, 
        bool bInSkipInitWorld = false
    )
    {
        // UPackageë€ íŒŒì¼ì„ ì €ì¥í•˜ëŠ” í´ë˜ìŠ¤ ì…ë‹ˆë‹¤
        UPackage* WorldPackage = InWorldPackage;
        if (!WorldPackage)
        {
            WorldPackage = CreatePackage(nullptr);
        }

        if (InWorldType == EWorldType::PIE)
        {
            WorldPackage->SetPackageFlags(PKG_PlayInEditor);
        }

        if (WorldPackage != GetTransientPackage())
        {
            WorldPackage->ThisContainsMap();
        }

        const FString WorldNameString = (WorldName != NAME_None) ? WorldName.ToString() : TEXT("Untitled");

        UWorld* NewWorld = NewObject<UWorld>(WorldPackage, *WorldNameString);

        NewWorld->SetFlags(RF_Transactional);
        NewWorld->WorldType = InWorldType;
        NewWorld->SetFeatureLevel(InFeatureLevel);

        // ...

        NewWorld->InitializeNewWorld( // ì•„ë˜ì„œ ë‚´ë¶€ ì„¤ëª…
```

```cpp
/** initializes a newly created world */
void InitializeNewWorld(const InitializationValues IVS = InitializationValues(), bool bInSkipInitWorld = false)
{
    if (!IVS.bTransactional)
    {
        ClearFlags(RF_Transactional);
    }

    // create default persistent level for new world
    PersistentLevel = NewObject<ULevel>(this, TEXT("PersistentLevel"));
    PersistentLevel->OwningWorld = this;

#if WITH_EDITORONLY_DATA || 1
    CurrentLevel = PersistentLevel;
#endif

    // create the WorldInfo actor
    // we are NOT looking into AWorldSettings in detail, but try to understand it with the example
    // [ ] explain AWorldSettings in the editor
    AWorldSettings* WorldSettings = nullptr;
    {
        // haker: when you spawn an Actor, you need to pass FActorSpawnParameters
        FActorSpawnParameters SpawnInfo;
        SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

        // set constant name for WorldSettings to make a network replication work between new worlds on host and client
        // you can override WorldSettings' class using UEngine's WorldSettingClass
        SpawnInfo.Name = GEngine->WorldSettingsClass->GetFName();

        WorldSettings = SpawnActor<AWorldSettings>(GEngine->WorldSettingsClass, SpawnInfo);
    }
    
    // allow the world creator to override the default game mode in case they do not plan to load a level
    if (IVS.DefaultGameMode)
    {
        WorldSettings->DefaultGameMode = IVS.DefaultGameMode;
    }

    // persistent level creates AWorldSettings which contain world info like GameMode
    PersistentLevel->SetWorldSettings(WorldSettings);

#if WITH_EDITOR || 1
    WorldSettings->SetIsTemporaryHiddenInEditor(true);

    if (IVS.bCreateWorldParitition)
    {
        // we skip world partition for now
        // - BUT, lyra is based on World-Partition
    }
#endif

    if (!bInSkipInitWorld)
    {
        // ë‹¤ìŒì¥ì—ì„œ ì„¤ëª…
        InitWorld(IVS);

        const bool bRerunConstructionScripts = !FPlatformProperties::RequiresCookedData();
        UpdateWorldComponents(bRerunConstructionScripts, false);
    }
}
```

---

## UWorldì—ì„œ ì‚¬ìš©ë˜ëŠ” ë³€ìˆ˜

```cpp
    /** the URL that was used when loading this World */
    // think of the URL as package path:
    // - e.g. Game\Map\Seoul\Seoul.umap
    FURL URL;

    /** the type of world this is. Describes the context in which it is being used (Editor, Game, Preview etc.) */
    // we already seen EWorldType
    // - TEnumAsByte is helper wrapper class to support bit operation on enum type
    // - I recommend to read it how it is implemented
    // ADVICE: as C++ programmer, it is VERY important **to manipulate bit operations freely!**
    TEnumAsByte<EWorldType::Type> WorldType;

    /** persistent level containing the world info, default brush and actors pawned during gameplay among other things */
    // short explanation about world info
    TObjectPtr<class ULevel> PersistentLevel;

#if WITH_EDITORONLY_DATA || 1
    /** pointer to the current level being edited; level has to be in the levels array and == PersistentLevel in the game */
    TObjectPtr<class ULevel> CurrentLevel;
#endif

    /** array of levels currently in this world; NOT serialized to disk to avoid hard references */
    // for now, skip how UWorld contains sub-levels
    UPROPERTY(Transient)
    TArray<TObjectPtr<class ULevel>> Levels;

    /** array of level collections currently in this world */
    // UWorld has the classified collections of level we have covered in ULevel
    TArray<FLevelCollection> LevelCollections;

    /** index of the level collection that's currently ticking */
    int32 ActiveLevelCollectionIndex;

    /** DefaultPhysicsVolume used for whole game */
    // you can think of physics volume as 3d range of physics engine works (== physics world covers)
    TObjectPtr<APhysicsVolume> DefaultPhysicsVolume;

    /** physics scene for this world */
    FPhysScene* PhysicsScene;

    // see UWorldSubsystem (goto 21)
    FObjectSubsystemCollection<UWorldSubsystem> SubsystemCollection;

    /** line batchers: */
    // debug lines
    // - ULineBatchComponents are resided in UWorld's subobjects
    TObjectPtr<class ULineBatchComponent> LineBatcher;
    TObjectPtr<class ULineBatchComponent> PersistentLineBatcher;
    TObjectPtr<class ULineBatchComponent> ForegroundLineBatcher;

    // haker: let's wrap up what we have looked through classes:
    //                                                                                â”Œâ”€â”€â”€WorldSubsystem0       
    //                                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                         
    //                                                 Worldâ”€â”€â”¤SubsystemCollectionsâ”œâ”€â”€â”¼â”€â”€â”€WorldSubsystem1       
    //                                                   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                         
    //                                                   â”‚                            â””â”€â”€â”€WorldSubsystem2       
    //             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                                 
    //             â”‚                                          â”‚                                                 
    //           Level0                                     Level1                                              
    //             â”‚                                          â”‚                                                 
    //         â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”                                 â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”                                            
    //         â”‚ Actor0 â”œâ”€â”€â”€â”€Component0(RootComponent)    â”‚ Actor0 â”œâ”€â”€â”€â”€â”€Component0(RootComponent)              
    //         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚                                     
    //         â”‚ Actor1 â”‚     â”œâ”€Component1                â”‚ Actor1 â”‚      â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”                          
    //         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”‚                           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤      â””â”€â”€â”€â”¤Actor2â”œâ”€â”€RootComponent           
    //         â”‚ Actor2 â”‚     â””â”€Component2                â”‚ Actor2 â”‚          â””â”€â”€â”€â”€â”€â”€â”˜   â”‚                      
    //         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤                                 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”œâ”€â”€Component0          
    //         â”‚ Actor3 â”‚                                 â”‚ Actor3 â”‚                     â”‚                      
    //         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”œâ”€â”€Component1          
    //                                                                                   â”‚   â”‚                  
    //                                                                                   â”‚   â””â”€â”€Component2      
    //                                                                                   â”‚                      
    //                                                                                   â””â”€â”€Component3          
};
```

---

## Tips) ULevelì—ì„œ ì‚¬ìš©ë˜ëŠ” ë³€ìˆ˜

```cpp

    /** array of all actors in this level, used by FActorIteratorBase and derived classes */
    // this is the member variable which contains a list of AActor
    TArray<TObjectPtr<AActor>> Actors;

    /** cached level collection that this level is contained in */
    FLevelCollection* CachedLevelCollection;

    /**
     * the world that has this level in its Levels array
     * this is not the same as GetOuter(), because GetOuter() for a streaming level is a vestigial world that is not used
     * it should not be accessed during BeginDestroy(), just like any other UObject references, since GC may occur in any order
     */
    // let's understand OwningWorld vs. OuterPrivate
    // - note that my explanation is based on WorldComposition's level streaming or LevelBlueprint's level load/unload manipulation
    //   - World Partition has different concept which usually OwningWorld and OuterPrivate is same
    // - Diagram:                                                                                                        
    //      World0(OwningWorld)â”€â”€[OuterPrivate]â”€â”€â–ºPackage0(World.umap)                                          
    //       â–²                                                                                                  
    //       â”‚                                                                                                  
    // [OuterPrivate]                                                                                           
    //       â”‚                                                                                                  
    //       â”‚                                                                                                  
    //      Level0(PersistentLevel)                                                                             
    //       â”‚                                                                                                  
    //       â”‚                                                                                                  
    //       â”œâ”€â”€â”€â”€Level1â”€â”€[OuterPrivate]â”€â”€â–ºWorld1â”€â”€â”€[OuterPrivate]â”€â”€â”€â–ºPackage1(Level1.umap)                     
    //       â”‚                                                                                                  
    //       â””â”€â”€â”€â”€Level2â”€â”€â”€â”€â”€â”€â”€â–ºWorld2â”€â”€â”€â”€â”€â”€â”€â–ºPackage2(Level2.umap)                                               
    TObjectPtr<UWorld> OwningWorld;

    enum class EIncrementalComponentState : uint8
    {
        Init,
        RegisterInitialComponents,
#if WITH_EDITOR || 1
        RunConstructionScripts,
#endif
        Finalize,
    };

    /** the current stage for incrementally updating actor components in the level */
    // we already covered AActor's initialization steps
    EIncrementalComponentState IncrementalComponentState;

    /** whether the actor referenced by CurrentActorIndexForUpdateComponents has called PreRegisterAllComponents */
    uint8 bHasCurrentActorCalledPreRegister : 1;

    /** whether components are currently registered or not */
    uint8 bAreComponentsCurrentlyRegistered : 1;

    /** current index into actors array for updating components */
    // tracking actor index in ULevel's ActorList to support incremental update
    int32 CurrentActorIndexForIncrementalUpdate;

    /** data structures for holding the tick functions */
    // for now, member variables related to tick function are skipped
    FTickTaskLevel* TickTaskLevel;

};
```