---
layout: default
title: "02-02. CreateWorld"
parent: "(02. UWorldÎì§Ïñ¥Í∞ÄÍ∏∞)"
grand_parent: "(UE SourceCode Î∂ÑÏÑù ü§ñ)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Ïù¥Î°† LevelÍ≥º WorldÏùò Ï†ïÏùò

* **Level**
    * LevelÏùÄ Í≤åÏûÑ ÎÇ¥Ïùò Í∞úÎ≥ÑÏ†ÅÏù∏ Íµ¨ÌöçÏù¥ÎÇò Ïû•Î©¥ÏùÑ ÏùòÎØ∏Ìï©ÎãàÎã§. Ïù¥Îäî Í≤åÏûÑÏùò ÌäπÏ†ï Îßµ, Ïä§ÌÖåÏù¥ÏßÄ, ÎòêÎäî Ï±ïÌÑ∞Î•º ÎÇòÌÉÄÎÉÖÎãàÎã§.
    * Î≥¥ÌÜµ `L_` ÌååÏùºÏùò Prefix
* **World**
    * WorldÎäî Í≤åÏûÑÏùò Ï†ÑÏ≤¥Ï†ÅÏù∏ ÌôòÍ≤ΩÏùÑ ÏùòÎØ∏ÌïòÎ©∞, Î™®Îì† LevelÏùÑ Ìè¨Ìï®ÌïòÎäî ÏÉÅÏúÑ Í∞úÎÖêÏûÖÎãàÎã§. WorldÎäî Í≤åÏûÑÏùò Ï†ÑÏó≠ ÏÑ§Ï†ïÍ≥º ÎèôÏ†Å Î†àÎ≤® Í¥ÄÎ¶¨Î•º Îã¥ÎãπÌï©ÎãàÎã§.
    * Settings -> World SettingsÏóêÏÑú WorldÏóê ÎåÄÌïú Ï†ÑÏó≠ ÏÑ§Ï†ïÏùÑ Ï°∞Ï†ï.
    * World Settings: Ï†ÑÏó≠ Í≤åÏûÑ ÏÑ§Ï†ï(Ïòà: Ï§ëÎ†•, ÏãúÍ∞Ñ ÌùêÎ¶Ñ, Í∏∞Î≥∏ Í≤åÏûÑ Î™®Îìú).

---

```cpp
/** 
 * the world is the top level object representing a map or a sandbox in which Actors and Components will exist and be rendered 
 * 
 * a world can be a single persistent level with an optional list of streaming levels that are loaded and unloaded via volumes and blueprint functions
 * or it can be a collection of levels organized with a World Composition (->haker: OLD COMMENT...)
 * 
 * in a standalone game, generally only a single World exists except during seamless area transition when both a destination and current world exists
 * in the editor many Worlds exist: 
 * - the level being edited
 * - each PIE instance
 * - each editor tool which has an interactive rendered viewport, and many more
 */
class UWorld final : public UObject, public FNetworkNotify
{
    using InitializationValues = FWorldInitializationValues;

    /** static function that creates a new UWorld and returns a pointer to it */
    static UWorld* CreateWorld(
        const EWorldType::Type InWorldType, 
        bool bInformEngineOfWorld, 
        FName WorldName = NAME_None, 
        UPackage* InWorldPackage = NULL, 
        bool bAddToRoot = true, 
        ERHIFeatureLevel::Type InFeatureLevel = ERHIFeatureLevel::Num, 
        const InitializationValues* InIVS = nullptr, 
        bool bInSkipInitWorld = false
    )
    {
        // UPackageÎûÄ ÌååÏùºÏùÑ Ï†ÄÏû•ÌïòÎäî ÌÅ¥ÎûòÏä§ ÏûÖÎãàÎã§
        UPackage* WorldPackage = InWorldPackage;
        if (!WorldPackage)
        {
            WorldPackage = CreatePackage(nullptr);
        }

        if (InWorldType == EWorldType::PIE)
        {
            WorldPackage->SetPackageFlags(PKG_PlayInEditor);
        }

        if (WorldPackage != GetTransientPackage())
        {
            WorldPackage->ThisContainsMap();
        }

        const FString WorldNameString = (WorldName != NAME_None) ? WorldName.ToString() : TEXT("Untitled");

        UWorld* NewWorld = NewObject<UWorld>(WorldPackage, *WorldNameString);

        NewWorld->SetFlags(RF_Transactional);
        NewWorld->WorldType = InWorldType;
        NewWorld->SetFeatureLevel(InFeatureLevel);

        // ...

        NewWorld->InitializeNewWorld( // ÏïÑÎûòÏÑú ÎÇ¥Î∂Ä ÏÑ§Î™Ö
```

```cpp
/** initializes a newly created world */
void InitializeNewWorld(const InitializationValues IVS = InitializationValues(), bool bInSkipInitWorld = false)
{
    if (!IVS.bTransactional)
    {
        ClearFlags(RF_Transactional);
    }

    // create default persistent level for new world
    PersistentLevel = NewObject<ULevel>(this, TEXT("PersistentLevel"));
    PersistentLevel->OwningWorld = this;

#if WITH_EDITORONLY_DATA || 1
    CurrentLevel = PersistentLevel;
#endif

    // create the WorldInfo actor
    // we are NOT looking into AWorldSettings in detail, but try to understand it with the example
    // [ ] explain AWorldSettings in the editor
    AWorldSettings* WorldSettings = nullptr;
    {
        // haker: when you spawn an Actor, you need to pass FActorSpawnParameters
        FActorSpawnParameters SpawnInfo;
        SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

        // set constant name for WorldSettings to make a network replication work between new worlds on host and client
        // you can override WorldSettings' class using UEngine's WorldSettingClass
        SpawnInfo.Name = GEngine->WorldSettingsClass->GetFName();

        WorldSettings = SpawnActor<AWorldSettings>(GEngine->WorldSettingsClass, SpawnInfo);
    }
    
    // allow the world creator to override the default game mode in case they do not plan to load a level
    if (IVS.DefaultGameMode)
    {
        WorldSettings->DefaultGameMode = IVS.DefaultGameMode;
    }

    // persistent level creates AWorldSettings which contain world info like GameMode
    PersistentLevel->SetWorldSettings(WorldSettings);

#if WITH_EDITOR || 1
    WorldSettings->SetIsTemporaryHiddenInEditor(true);

    if (IVS.bCreateWorldParitition)
    {
        // we skip world partition for now
        // - BUT, lyra is based on World-Partition
    }
#endif

    if (!bInSkipInitWorld)
    {
        // Îã§ÏùåÏû•ÏóêÏÑú ÏÑ§Î™Ö
        InitWorld(IVS);

        const bool bRerunConstructionScripts = !FPlatformProperties::RequiresCookedData();
        UpdateWorldComponents(bRerunConstructionScripts, false);
    }
}
```