---
layout: default
title: "(04. TickTaskManager)"
parent: "(UE SourceCode ë¶„ì„ ðŸ¤–)"
has_children: true
nav_order: 2
---

```cpp
// ì‹œìž‘ì€ ì—¬ê¸°ì„œ
virtual void Tick(float DeltaSeconds, bool bIdleMode) override
{
    UWorld* CurrentGWorld = GWorld;

    FWorldContext& EditorContext = GetEditorWorldContext();
    
    // by default we tick the editor world
    bool bShouldTickEditorWorld = true;

    ELevelTick TickType = IsRealTime ? LEVELTICK_ViewportOnly : LEVELTICK_TimeOnly;
    if (bShouldTickEditorWorld)
    {
        // NOTE: still allowing the FX system to tick so particle systems don't restart after entering/leaving responsive mode
        // FX(niagara) system should be running even in level-viewport mode
        {
            // here is EditorWorld for level-viewport ticking:
            // - level-viewport's world is ticking in very limited allowance
            // - so, we look into world's tick with PIE Context
            EditorContext.World()->Tick(TickType, DeltaSeconds);
        }
    }

    // ...
```

```cpp
/**
* update the level after a variable amount of time, DeltaSeconds, has passed
* all child actors are ticked after their owners have been ticked 
*/
void Tick(ELevelTick TickType, float DeltaSeconds)
{
    FWorldDelegates::OnWorldTickStart.Broadcast(this, TickType, DeltaSeconds);

    bool bDoingActorTicks = 
        (TickType != LEVELTICK_TimeOnly);

    // if only the DynamicLevel collection has entries, we can skip the validation and tick all levels
    // it just minor optimization to skip the code: Levels.Contains(CollectionLevel)
    // DynamicLevelë§Œ ì»¬ë ‰ì…˜ì— ì¡´ìž¬í•  ê²½ìš° Tickì— ëŒ€í•œ ìœ íš¨ì„± ì²´í¬ê°€ í•„ìš” ì—†ê¸° ë•Œë¬¸ì— ê°„ë‹¨í•œ ìµœì í™”ë¥¼ ìœ„í•´ ë¯¸ë¦¬ ì²´í¬í•˜ëŠ” ë¡œì§ ìž…ë‹ˆë‹¤.
    bool bValidateLevelList = false;
    for (const FLevelCollection& LevelCollection : LevelCollections)
    {
        if (LevelCollection.GetType() != ELevelCollectionType::DynamicSourceLevels)
        {
            const int32 NumLevels = LevelCollection.GetLevels().Num();
            if (NumLevels != 0)
            {
                bValidateLevelList = true;
                break;
            }
        }
    }

/*
ìœ„ì—ì„œ ì§„í–‰í•œ ìµœì í™”ì— ëŒ€í•œ ì´ìœ ìž…ë‹ˆë‹¤. 

WorldLevelì€ ì „ì— í•™ìŠµí–ˆë“¯ì´ Dynamic , Staticìœ¼ë¡œ ë¶„ë¥˜ê°€ ë©ë‹ˆë‹¤. 
Staticì˜ ê²½ìš° Tickì„ ì‹¤í–‰í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìžˆê¸° ë•Œë¬¸ì— Tickì— ëŒ€í•œ ì²´í¬ë¥¼ ë§¤
ë²ˆ ì§„í–‰í•´ì•¼í•˜ì§€ë§Œ Dynamicë§Œ ì¡´ìž¬ í•  ê²½ìš° Tickì— ëŒ€í•œ ì‹¤í–‰ì´ ë°˜ë“œì‹œ í•„ìš”í•©ë‹ˆë‹¤. 

ìœ„ì˜ ë¡œì§ì—ì„œ ëª¨ë“  Levelì´ Dynamicì¼ ê²½ìš° bValidateLevelListê°€ falseì´ê¸° ë•Œë¬¸ì— 
Level.Containsë¥¼ ì§„í–‰í•˜ì§€ ì•Šê³  bAddtoTickListì˜ ê²°ê³¼ë¥¼ ì–»ì–´ ì˜¬ ìˆ˜ ìžˆìœ¼ë¯€ë¡œ ì„±ëŠ¥ìƒì˜ 
ì´ì ì„ ì–»ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ìµœì¢…ì ìœ¼ë¡œ Tickì´ í•„ìš”í•œ Levelë“¤ë§Œ LevelsToTickì— ë¶„ë¥˜í•©ë‹ˆë‹¤.
*/
    // we can understand what FLevelCollection for:
    // - object can be categorized into static/dynamic
    // - dynamic or static objects are into different category (LevelCollection)
    // - each level collection ticks on different moment (dynamic -> static)
    for (int32 i = 0; i < LevelCollections.Num(); ++i)
    {
        // build a list of levels from the collection that are also in the world's level array
        // collections may contain levels that aren't loaded in the world at the moment
        TArray<ULevel*> LevelsToTick;
        for (ULevel* CollectionLevel : LevelCollections[i].GetLevels())
        {
            const bool bAddToTickList = (bValidateLevelList == false) || Levels.Contains(CollectionLevel);
            if (bAddToTickList && CollectionLevel)
            {
                LevelsToTick.Add(CollectionLevel);
            }
        }

        // update active level collection by level collection's index
        FScopedLevelCollectionContextSwitch LevelContext(i, this);

        // if caller wants time update only, or we are paused, skip the rest
        const bool bShouldSkipTick = (LevelsToTick.Num() == 0);
        if (bDoingActorTicks && !bShouldSkipTick)
        {
            // actually tick actors now that context is set up
            // understand what SetupPhysicsTickFunctions() does for us:
            SetupPhysicsTickFunctions(DeltaSeconds);

            TickGroup = TG_PrePhysics; // reset this to the start tick group

            FTickTaskManagerInterface::Get().StartFrame(this, DeltaSeconds, TickType, LevelsToTick);

            {
                RunTickGroup(TG_PrePhysics);
            }
            {
                RunTickGroup(TG_StartPhysics);
            }
            {
                // no wait here, we should run until idle though
                // we don't care if all of the async ticks are done before we start running post-phys stuff
                // note that bBlockUntilComplete == false
                RunTickGroup(TG_DuringPhysics, false);
            }
            {
                // set this here so the current tick group is correct during collision notifies, though I am not sure it matters 
                // 'cause of the false up there'
                TickGroup = TG_EndPhysics;
                RunTickGroup(TG_EndPhysics);
            }
            {
                RunTickGroup(TG_PostPhysics);
            }
        }

        // various ticks:
        // 1. LatentActionManager
        // 2. TimerManager
        // 3. TickableGameObjects
        // 4. CameraManager
        // 5. streaming volume

        if (bDoingActorTicks)
        {
            RunTickGroup(TG_PostUpdateWork);
            RunTickGroup(TG_LastDemotable);
        }

        FTickTaskManagerInterface::Get().EndFrame();
    }

    FWorldDelegates::OnWorldTickEnd.Broadcast(this, TickType, DeltaSeconds);
}
```

```cpp
/**
 * a helper RAII class to set the relevant context on a UWorld for a particular FLevelCollection within a scope
 * the constructor will set the PersistentLevel, GameState, NetDriver, and DemoNetDriver on the world and the destructor will restore the original values 
 */
// RAII (Resource Acquisition is initialization) pattern:
// - change ActiveLevelCollection in UWorld
// - see constructor
// - see destructor
class FScopedLevelCollectionContextSwitch
{
public:
    /**
     * constructor that will save the current relevant values of InWorld
     * and set the collection's context values for InWorld 
     */
    FScopedLevelCollectionContextSwitch(int32 InLevelCollectionIndex, UWorld* const InWorld)
        : World(InWorld)
        , SavedTickingCollectionIndex(InWorld ? InWorld->GetActiveLevelCollectionIndex() : INDEX_NONE)
    {
        if (World)
        {
            World->SetActiveLevelCollection(InLevelCollectionIndex);
        }
    }

    /** the destructor restores the context on the world that was saved in the constructor */
    ~FScopedLevelCollectionContextSwitch()
    {
        if (World)
        {
            World->SetActiveLevelCollection(SavedTickingCollectionIndex);
        }
    }

private:
    class UWorld* World;
    int32 SavedTickingCollectionIndex;
};
```