---
layout: default
title: "02-02. CreateWorld"
parent: "(02. CreateWorld)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
class UEngine : public UObject, public FExec
{
    // ...

    virtual void Init(IEngineLoop* InEngineLoop)
    {
        if (GIsEditor)
        {
            FWorldConext& InitialWorldContext = CreateNewWorldContext(EWorldType::Editor);

            // UWorld::CreateWorld
            InitialWorldContext.SetCurrentWorld(UWorld::CreateWorld(EWorldType::Editor, true));
            GWorld = InitialWorldContext.World();
        }
    }
```

```cpp
/** static function that creates a new UWorld and returns a pointer to it */
// ìƒˆë¡œìš´ UWorldë¥¼ ìƒì„±í•˜ê³  ê·¸ í¬ì¸í„°ë¥¼ ë°˜í™˜í•˜ëŠ” ì •ì  í•¨ìˆ˜

// note that this function is static function
// - when you look through parameters in a function, care about their types
// - when we use UWorld::CreateWorld(), we only pass two parameters, so rest of parameters is not necessary to care

// ì´ í•¨ìˆ˜ëŠ” ì •ì  í•¨ìˆ˜ì„
// í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚´í´ë³¼ ë•Œ ê·¸ íƒ€ì…ì— ì£¼ì˜í•´ì•¼ í•¨
// UWorld::CreateWorld()ë¥¼ ì‚¬ìš©í•  ë•Œ ìš°ë¦¬ëŠ” ì˜¤ì§ ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ë§Œ ì „ë‹¬í•˜ë¯€ë¡œ, ë‚˜ë¨¸ì§€ ë§¤ê°œë³€ìˆ˜ë“¤ì€ ì‹ ê²½ ì“¸ í•„ìš”ê°€ ì—†ìŒ
static UWorld* CreateWorld(
    const EWorldType::Type InWorldType, 
    bool bInformEngineOfWorld, 
    FName WorldName = NAME_None, 
    UPackage* InWorldPackage = NULL, 
    bool bAddToRoot = true, 
    ERHIFeatureLevel::Type InFeatureLevel = ERHIFeatureLevel::Num,
    const InitializationValues* InIVS = nullptr, 
    bool bInSkipInitWorld = false
)
{
    // UPackage will be covered in the future, dealing with AsyncLoading
    // - for now, just think of it as describing file format for UWorld
    // - one thing to remember is that each world has 1:1 mapping on separate package
    //   - it is natural that all data in world needs to be serialized as file
    //   - in unreal engine, saving file means 'package', UPackage
    // - another thing is that UObject has OuterPrivate:
    //   - OuterPrivate infers where object is resides in
    //   - normally OuterPrivate is set as UPackage: 
    //     - where object is resides in == what file object resides in
    // - I'd like to explain what I understand about UPackage, don't memorize it, just say 'ah' is enough!

    // UPackageëŠ” ë‚˜ì¤‘ì— ë¹„ë™ê¸° ë¡œë”©ì„ ë‹¤ë£° ë•Œ ë‹¤ë£° ì˜ˆì •
    // ì§€ê¸ˆì€ UWorldì˜ íŒŒì¼ í˜•ì‹ì„ ì„¤ëª…í•˜ëŠ” ê²ƒìœ¼ë¡œ ìƒê°í•˜ë©´ ë¨
    // ê¸°ì–µí•´ì•¼ í•  í•œ ê°€ì§€ëŠ” ê° ì›”ë“œê°€ ë³„ë„ì˜ íŒ¨í‚¤ì§€ì™€ 1:1 ë§¤í•‘ì„ ê°€ì§„ë‹¤ëŠ” ê²ƒ
    // ì›”ë“œì˜ ëª¨ë“  ë°ì´í„°ê°€ íŒŒì¼ë¡œ ì§ë ¬í™”ë˜ì–´ì•¼ í•˜ëŠ” ê²ƒì€ ìì—°ìŠ¤ëŸ¬ìš´ ì¼
    // ì–¸ë¦¬ì–¼ ì—”ì§„ì—ì„œ íŒŒì¼ ì €ì¥ì€ 'íŒ¨í‚¤ì§€', ì¦‰ UPackageë¥¼ ì˜ë¯¸í•¨
    // ë˜ ë‹¤ë¥¸ ì ì€ UObjectê°€ OuterPrivateë¥¼ ê°€ì§„ë‹¤ëŠ” ê²ƒ:
    // OuterPrivateëŠ” ê°ì²´ê°€ ì–´ë””ì— ìœ„ì¹˜í•˜ëŠ”ì§€ë¥¼ ì¶”ë¡ í•¨
    // ë³´í†µ OuterPrivateëŠ” UPackageë¡œ ì„¤ì •ë¨:
    // ê°ì²´ê°€ ìœ„ì¹˜í•œ ê³³ == ê°ì²´ê°€ ìœ„ì¹˜í•œ íŒŒì¼
    // UPackageì— ëŒ€í•´ ë‚´ê°€ ì´í•´í•œ ë°”ë¥¼ ì„¤ëª…í•˜ê³  ì‹¶ì§€ë§Œ, ì™¸ìš¸ í•„ìš”ëŠ” ì—†ê³  ê·¸ëƒ¥ 'ì•„' í•˜ê³  ë„˜ì–´ê°€ë©´ ì¶©ë¶„í•¨!

    UPackage* WorldPackage = InWorldPackage;
    if (!WorldPackage)
    {
        // UWorld needs package as its OuterPrivate and need to be serialized
        // UWorldëŠ” OuterPrivateë¡œ íŒ¨í‚¤ì§€ê°€ í•„ìš”í•˜ê³  ì§ë ¬í™”ë˜ì–´ì•¼ í•¨
        WorldPackage = CreatePackage(nullptr);
    }

    if (InWorldType == EWorldType::PIE)
    {
        // like ObjectFlags in UObjectBase, UPackage's attribute can be set by flags in similar manner
        // - we are not going to read it in detail, later we could have chance to meet again

        // UObjectBaseì˜ ObjectFlagsì²˜ëŸ¼ UPackageì˜ ì†ì„±ë„ ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œ í”Œë˜ê·¸ë¡œ ì„¤ì •í•  ìˆ˜ ìˆìŒ
        // ìì„¸íˆ ì½ì§€ëŠ” ì•Šì„ ê²ƒì´ë©°, ë‚˜ì¤‘ì— ë‹¤ì‹œ ë§Œë‚  ê¸°íšŒê°€ ìˆì„ ìˆ˜ ìˆìŒ
        WorldPackage->SetPackageFlags(PKG_PlayInEditor);
    }

    // mark the package as containing a world
    // what is 'Transient' in Unreal Engine?
    // - if you have property or asset which is not serialized, we mark it as 'Transient'
    // - Transient == (meta data to mark it as not-to-be-serialize)

    // íŒ¨í‚¤ì§€ê°€ ì›”ë“œë¥¼ í¬í•¨í•˜ê³  ìˆë‹¤ê³  í‘œì‹œ
    // ì–¸ë¦¬ì–¼ ì—”ì§„ì—ì„œ 'Transient'ë€ ë¬´ì—‡ì¸ê°€?
    // ì§ë ¬í™”ë˜ì§€ ì•ŠëŠ” ì†ì„±ì´ë‚˜ ì—ì…‹ì´ ìˆë‹¤ë©´, ê·¸ê²ƒì„ 'Transient'ë¡œ í‘œì‹œí•¨
    // Transient == (ì§ë ¬í™”í•˜ì§€ ì•Šì„ ê²ƒì´ë¼ê³  í‘œì‹œí•˜ëŠ” ë©”íƒ€ ë°ì´í„°)
    if (WorldPackage != GetTransientPackage())
    {
        WorldPackage->ThisContainsMap();
    }

    const FString WorldNameString = (WorldName != NAME_None) ? WorldName.ToString() : TEXT("Untitled");

    // we set NewWorld's outer as WorldPackage:
    // - normally, when you look into outer object, it will finally end-up-with package(asset file containing this UObject)

    // NewWorldì˜ outerë¥¼ WorldPackageë¡œ ì„¤ì •:
    // ë³´í†µ outer ê°ì²´ë¥¼ ì‚´í´ë³´ë©´ ê²°êµ­ íŒ¨í‚¤ì§€(ì´ UObjectë¥¼ í¬í•¨í•˜ëŠ” ì—ì…‹ íŒŒì¼)ë¡œ ëë‚˜ê²Œ ë¨
    UWorld* NewWorld = NewObject<UWorld>(WorldPackage, *WorldNameString);

    // UObject::SetFlags -> set unreal object's attribute with flag by bit operator (AND(&), OR(|), SHIFT(>>, <<) etc...)
    // - refer to EObjectFlags and UObject::ObjectFlags

    // UObject::SetFlags -> ë¹„íŠ¸ ì—°ì‚°ì(AND(&), OR(|), SHIFT(>>, <<) ë“±)ë¡œ ì–¸ë¦¬ì–¼ ê°ì²´ì˜ ì†ì„±ì„ ì„¤ì •
    // EObjectFlagsì™€ UObject::ObjectFlags ì°¸ì¡°
    NewWorld->SetFlags(RF_Transactional);
    NewWorld->WorldType = InWorldType;
    NewWorld->SetFeatureLevel(InFeatureLevel);

    NewWorld->InitializeNewWorld(
        InIVS ? *InIVS : UWorld::InitializationValues()
            // as we saw FWorldInitializationValues, the below member functions mark the flag to refer when we create new world
            // FWorldInitializationValuesì—ì„œ ë´¤ë“¯ì´, ì•„ë˜ ë©¤ë²„ í•¨ìˆ˜ë“¤ì€ ìƒˆ ì›”ë“œë¥¼ ìƒì„±í•  ë•Œ ì°¸ì¡°í•  í”Œë˜ê·¸ë¥¼ í‘œì‹œí•¨
            .CreatePhysicsScene(InWorldType != EWorldType::Inactive)
            .ShouldSimulatePhysics(false)
            .EnableTraceCollision(true)
            .CreateNavigation(InWorldType == EWorldType::Editor)
            .CreateAISystem(InWorldType == EWorldType::Editor)
        , bInSkipInitWorld);
    
    // clear the dirty flags set during SpawnActor and UpdateLevelComponents
    // SpawnActorì™€ UpdateLevelComponents ë™ì•ˆ ì„¤ì •ëœ ë”í‹° í”Œë˜ê·¸ë¥¼ ì§€ì›€
    WorldPackage->SetDirtyFlag(false);

    if (bAddToRoot)
    {
        // add to root set so it doesn't get GC'd
        // GCë˜ì§€ ì•Šë„ë¡ ë£¨íŠ¸ ì„¸íŠ¸ì— ì¶”ê°€
        NewWorld->AddToRoot();
    }

    // tell the engine we are adding a world (unless we are asked not to)
    // ì—”ì§„ì— ì›”ë“œë¥¼ ì¶”ê°€í•œë‹¤ê³  ì•Œë¦¼ (ê·¸ë ‡ê²Œ í•˜ì§€ ë§ë¼ê³  ìš”ì²­ë°›ì§€ ì•ŠëŠ” í•œ)
    if ((GEngine) && (bInformEngineOfWorld == true))
    {
        GEngine->WorldAdded(NewWorld);
    }

    return NewWorld;
}
```

