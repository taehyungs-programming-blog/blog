---
layout: default
title: "02-07. InitializeSubsystems"
parent: "(02. CreateWorld)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
class UWorld final : public UObject, public FNetworkNotify
{
    // ...

    void InitializeSubsystems()
    {
        SubsystemCollection.Initialize(this);
    }
}
```

```cpp
/** initialize the collection of systems; systems will be created and initialized */
void Initialize(UObject* NewOuter)
{
    // already initialized
    if (Outer)
    {
        return;
    }

    // we set NewOuter as UWorld
    // SubSystemì˜ ì†Œìœ ì£¼ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤
    Outer = NewOuter;
    
    // Initialize í•¨ìˆ˜ëŠ” Worldê°€ ìƒì„±ëœ ì´ˆì°½ê¸°ì— í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜ì´ê¸° ë•Œë¬¸ì— SubSystemì´ ë‹¨ 1ê°œ ë¼ë„ ë¯¸ë¦¬ ì¡´ì¬í•œë‹¤ë©´ ë¡œì§ì— ë¬¸ì œê°€ ìˆëŠ” ìƒíƒœì…ë‹ˆë‹¤.
    if (ensure(BaseType) && ensure(SubSystemMap.Num() == 0))
    {
        check(IsInGameThread());

        // I eliminate UDynamicsSubsystem handling codes for simplicity
        // - the below code is about non-UDynamicSubsystem e.g. UWorldSubsystem
        {
            // BaseType is UWorldSubsystem for UWorld::SubsystemCollection
            // - calling GetDerivedClasses() collects all classes derived from UWorldSubsystem
            TArray<UClass*> SubsystemClasses;
            GetDerivedClasses(BaseType, SubsystemClasses, true);

            // looping subsystem's classes derived from UWorldSubsystem
            for (UClass* SubsystemClass : SubsystemClasses)
            {
                // ì•„ë˜ì„œ ì„¤ëª…
                AddAndInitializeSubsystem(SubsystemClass);
            }
        }

        // update internal arrays without emptying it so that existing refs remain valid
        for (auto& Pair : SubsystemArrayMap)
        {
            // note that we clear the array!
            Pair.Value.Empty();

            // SubsystemMapArray persist 1:1 mapping on Subsystem, but UDynamicSubsystem could allow multiple instance
            UpdateSubsystemArrayInternal(Pair.Key, Pair.Value);
        }

        // see the definition of GlobalSubsystemCollections
        GlobalSubsystemCollections.Add(this);
    }
}
```

```cpp
USubsystem* AddAndInitializeSubsystem(UClass* SubsystemClass)
{
    // note that it only allow ONE instance per class type
    if (!SubsystemMap.Contains(SubsystemClass))
    {
        // only add instances for non abstract Subsystems
        // - UClass::ClassFlags has class information
        if (SubsystemClass && !SubsystemClass->HasAllClassFlags(CLASS_Abstract))
        {
            // subsystem class should be derived from base type
            check(SubsystemClass->IsChildOf(BaseType));

            // SubSystemì„ ìƒì„± í›„ SubSystem Mapì— ë“±ë¡í•˜ëŠ” ê³¼ì • ì…ë‹ˆë‹¤. InternalOwningSubSystem ì„ í†µí•´ Worldì™€ ì—°ê²°í•˜ëŠ” ê²ƒë„ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            // - ShouldCreateSubsystem() determines whether we create subsystem or not
            //    - override this method to control the flow of subsystem creation
            // - CDO is sufficient to call ShouldCreateSubsystem()
            const USubsystem* CDO = SubsystemClass->GetDefaultObject<USubsystem>();
            // see USubsystem::ShouldCreateSubsystem (goto 32)
            if (CDO->ShouldCreateSubsystem(Outer))
            {
                // create new USubsystem by SubsystemClass (in our case, the class is UWorldSubsystem)
                USubsystem* Subsystem = NewObject<USubsystem>(Outer, SubsystemClass);
                SubsystemMap.Add(SubsystemClass, Subsystem);
                Subsystem->InternalOwningSubsystem = this;
                Subsystem->Initialize(*this);
                return Subsystem;
            }
        }
        return nullptr;
    }
    // if we already have SubsystemClass, find an existing instance from SubsystemMap
    return SubsystemMap.FindRef(SubsystemClass);
}
```