---
layout: default
title: "02-03. UObjectì— ê´€í•˜ì—¬"
parent: "(02. CreateWorld)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/**
 * the base class of all UE objects. the type of an object is defined by its UClass
 * this provides support functions for creating and using objects, and virtual functions that should be overriden in child classes
 */

// ëª¨ë“  UE ê°ì²´ì˜ ê¸°ë³¸ í´ë˜ìŠ¤. ê°ì²´ì˜ íƒ€ì…ì€ UClassì— ì˜í•´ ì •ì˜ë¨
// ê°ì²´ ìƒì„± ë° ì‚¬ìš©ì„ ìœ„í•œ ì§€ì› í•¨ìˆ˜ì™€ ìì‹ í´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œí•´ì•¼ í•˜ëŠ” ê°€ìƒ í•¨ìˆ˜ë¥¼ ì œê³µí•¨
class UObject : public UObjectBaseUtility
{
    
};
```

```cpp
/** provides utility function for UObject, this class should not be used directly */
// UObjectë¥¼ ìœ„í•œ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¥¼ ì œê³µí•¨, ì´ í´ë˜ìŠ¤ëŠ” ì§ì ‘ ì‚¬ìš©í•´ì„œëŠ” ì•ˆ ë¨

//  later we'll cover UObjectBaseUtility's member functions below
// ë‚˜ì¤‘ì— UObjectBaseUtilityì˜ ë©¤ë²„ í•¨ìˆ˜ë“¤ì„ ì•„ë˜ì—ì„œ ë‹¤ë£° ê²ƒì„
class UObjectBaseUtility : public UObjectBase
{
    UObject* GetTypedOuter(UClass* Target) const
    {
        UObject* Result = NULL;
        for (UObject* NextOuter = GetOuter(); Result == NULL && NextOuter != NULL; NextOuter = NextOuter->GetOuter())
        {
            //  we are not getting into IsA(), which is out-of-scope cuz it is related to Reflection System
            // IsA()ì— ëŒ€í•´ì„œëŠ” ë‹¤ë£¨ì§€ ì•Šì„ ê²ƒì„, ë¦¬í”Œë ‰ì…˜ ì‹œìŠ¤í…œê³¼ ê´€ë ¨ë˜ì–´ ìˆì–´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ê¸° ë•Œë¬¸
            if (NextOuter->IsA(Target))
            {
                Result = NextOuter;
            }
        }
        return Result;
    }

    /** traverses the outer chain searching for the next object of a certain type (T must be derived from UObject) */
    // íŠ¹ì • íƒ€ì…ì˜ ë‹¤ìŒ ê°ì²´ë¥¼ ì°¾ê¸° ìœ„í•´ ì™¸ë¶€ ì²´ì¸ì„ ìˆœíšŒí•¨ (TëŠ” UObjectì—ì„œ íŒŒìƒë˜ì–´ì•¼ í•¨)
    template <typename T>
    T* GetTypedOuter() const
    {
        return (T*)GetTypedOuter(T::StaticClass());
    }

    /** determine whether this object is a template object */
    // ì´ ê°ì²´ê°€ í…œí”Œë¦¿ ê°ì²´ì¸ì§€ íŒë‹¨í•¨
    
    // - I have been look through the unreal engine source code for long time, but I still can't explain what is archetype object with specific example
    // - you just think of it as CDO, class default object
    //   - for CDO, what I understand is like **initialization list** as default UObject instance
    // - ì˜¤ë«ë™ì•ˆ ì–¸ë¦¬ì–¼ ì—”ì§„ ì†ŒìŠ¤ ì½”ë“œë¥¼ ì‚´í´ë´¤ì§€ë§Œ, ì•„ì§ë„ ì•„í‚¤íƒ€ì… ê°ì²´ê°€ ë¬´ì—‡ì¸ì§€ êµ¬ì²´ì ì¸ ì˜ˆì‹œë¡œ ì„¤ëª…í•˜ê¸° ì–´ë ¤ì›€
    // - CDO(í´ë˜ìŠ¤ ê¸°ë³¸ ê°ì²´)ë¼ê³  ìƒê°í•˜ë©´ ë¨
    //   - CDOì— ëŒ€í•´ ì´í•´í•œ ë°”ë¡œëŠ” ê¸°ë³¸ UObject ì¸ìŠ¤í„´ìŠ¤ì˜ **ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸**ì™€ ê°™ì€ ê²ƒì„
    bool IsTemplate(EObjectFlags TemplateTypes = RF_ArchetypeObject|RF_ClassDefaultObject) const
    {
        //  note that if one of outer is template, the object is template
        // ì™¸ë¶€ ê°ì²´ ì¤‘ í•˜ë‚˜ê°€ í…œí”Œë¦¿ì´ë©´ ì´ ê°ì²´ë„ í…œí”Œë¦¿ì„
        for (const UObjectBaseUtility* TestOuter = this; TestOuter; TestOuter = TestOuter->GetOuter())
        {
            if (TestOuter->HasAnyFlags(TemplateTypes))
                return true;
        }
        return false;
    }
};
```

```cpp
/** flags describing an object instance */
// ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì„¤ëª…í•˜ëŠ” í”Œë˜ê·¸
enum EObjectFlags
{
    RF_Transactional			=0x00000008,	///< Object is transactional.
    // ê°ì²´ê°€ íŠ¸ëœì­ì…˜ ê°€ëŠ¥í•¨
};

/** low level implementation of UObject, should not be used directly in game code */
// UObjectì˜ ì €ìˆ˜ì¤€ êµ¬í˜„, ê²Œì„ ì½”ë“œì—ì„œ ì§ì ‘ ì‚¬ìš©í•´ì„œëŠ” ì•ˆ ë¨

//  this class is the most base class for UObject
// - look through its member variables
// ì´ í´ë˜ìŠ¤ëŠ” UObjectì˜ ê°€ì¥ ê¸°ë³¸ í´ë˜ìŠ¤ì„
// - ë©¤ë²„ ë³€ìˆ˜ë“¤ì„ ì‚´í´ë³´ì„¸ìš”
class UObjectBase
{
    /**
     * Flags used to track and report various object states
     * this needs to be 8 byte aligned on 32-bit platforms to reduce memory waste 
     */
    // ë‹¤ì–‘í•œ ê°ì²´ ìƒíƒœë¥¼ ì¶”ì í•˜ê³  ë³´ê³ í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í”Œë˜ê·¸
    // 32ë¹„íŠ¸ í”Œë«í¼ì—ì„œ ë©”ëª¨ë¦¬ ë‚­ë¹„ë¥¼ ì¤„ì´ê¸° ìœ„í•´ 8ë°”ì´íŠ¸ ì •ë ¬ì´ í•„ìš”í•¨

    //  bit flags to define UObject's behavior or attribute as meta-data format
    // UObjectì˜ ë™ì‘ì´ë‚˜ ì†ì„±ì„ ë©”íƒ€ë°ì´í„° í˜•ì‹ìœ¼ë¡œ ì •ì˜í•˜ëŠ” ë¹„íŠ¸ í”Œë˜ê·¸
    EObjectFlags ObjectFlags;

    /** object this object resides in */
    // ì´ ê°ì²´ê°€ ì†í•œ ê°ì²´
    //  as we said previously, it is written as UPackage
    // - note that as times went by, the unreal supports lots of features to support reduce dependency on assets:
    //   - OFPA (One File Per Actor) is one of representative example
    //   - in the past, AActor resides in ULevel and its UPackage is just level asset file, which is straight-forward
    //   - but, after introducing OFPA, an indirection is added, no more each AActor is stored in ULevel file, it is stored in separate file Exteral path
    // - I'd like to say that overall pattern is maintained, but as engine evolves, it adds indirection and complexity to understand its actual behavior
    // - anyway for now, you just try to understand OuterPrivate will be set as UPackage normally, it is enought for now!

    // ì´ì „ì— ë§í–ˆë“¯ì´, ì´ê²ƒì€ UPackageë¡œ ì‘ì„±ë¨
    // - ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ì–¸ë¦¬ì–¼ì€ ì—ì…‹ ì˜ì¡´ì„±ì„ ì¤„ì´ê¸° ìœ„í•œ ë§ì€ ê¸°ëŠ¥ì„ ì§€ì›í•¨:
    //   - OFPA(One File Per Actor)ê°€ ëŒ€í‘œì ì¸ ì˜ˆì‹œì„
    //   - ê³¼ê±°ì—ëŠ” AActorê°€ ULevelì— ìˆì—ˆê³  UPackageëŠ” ë‹¨ìˆœíˆ ë ˆë²¨ ì—ì…‹ íŒŒì¼ì´ì—ˆìŒ
    //   - í•˜ì§€ë§Œ OFPA ë„ì… í›„, ê°„ì ‘ ì°¸ì¡°ê°€ ì¶”ê°€ë˜ì–´ ë” ì´ìƒ ê° AActorê°€ ULevel íŒŒì¼ì— ì €ì¥ë˜ì§€ ì•Šê³  ë³„ë„ì˜ ì™¸ë¶€ ê²½ë¡œ íŒŒì¼ì— ì €ì¥ë¨
    // - ì „ë°˜ì ì¸ íŒ¨í„´ì€ ìœ ì§€ë˜ì§€ë§Œ, ì—”ì§„ì´ ë°œì „í•¨ì— ë”°ë¼ ì‹¤ì œ ë™ì‘ì„ ì´í•´í•˜ê¸° ìœ„í•œ ê°„ì ‘ ì°¸ì¡°ì™€ ë³µì¡ì„±ì´ ì¶”ê°€ë¨
    // - ì§€ê¸ˆì€ OuterPrivateê°€ ë³´í†µ UPackageë¡œ ì„¤ì •ëœë‹¤ëŠ” ê²ƒë§Œ ì´í•´í•˜ë©´ ì¶©ë¶„í•¨
    
    UObject* OuterPrivate;
};
```