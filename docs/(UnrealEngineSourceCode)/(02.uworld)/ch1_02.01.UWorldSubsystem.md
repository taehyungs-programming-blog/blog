---
layout: default
title: "02-01. UWorldSubsystem"
parent: "(02. CreateWorld)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## SubSystem

* SubSystemì€ ì–¸ë¦¬ì–¼ì—”ì§„ì˜ êµ¬ì„± ìš”ì†Œì˜ ìˆ˜ëª…(ìƒì„±/íŒŒê´´)ë¥¼ ë”°ë¥´ëŠ” ì‹œìŠ¤í…œ ì…ë‹ˆë‹¤.
* ì—”ì§„ì˜ ì‹œìŠ¤í…œì˜ ìˆ˜ëª…ì— ë§ì¶°ì„œ ë§¤ë‹ˆì € ì‹œìŠ¤í…œì„ êµ¬ì„±í•˜ëŠ” ê²ƒì´ ë³µì¡í•˜ì§€ë§Œ SubSystemì„ ì´ìš©í•˜ë©´ ê°„ë‹¨í•˜ê²Œ ê°œë°œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
* ì‹œìŠ¤í…œì˜ ì¢…ë¥˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
    * UEngineSubsystem
    * UEditorSubsystem
    * UGameInstanceSubsystem
    * UWorldSubsystem
    * ULocalPlayerSubsystem 

```cpp
/**
 * subsystems are auto instanced classes that share the lifetime of certain engine constructs
 * 
 * currently supported subsystem lifetimes are:
 *  Engine		 -> inherit UEngineSubsystem
 *	Editor		 -> inherit UEditorSubsystem
 *	GameInstance -> inherit UGameInstanceSubsystem
 *	World		 -> inherit UWorldSubsystem
 *	LocalPlayer	 -> inherit ULocalPlayerSubsystem
 * 
 * normal example:
 *  class UMySystem : public UGameInstanceSubsystem
 * which can be accessed by:
 *  UGameInstance* GameInstance = ...;
 *  UMySystem* MySystem = GameInstance->GetSubsystem<UMySystem>();
 * 
 * or the following if you need protection from a null GameInstance
 *  UGameInstance* GameInstance = ...;
 *  UMyGameSubsystem* MySubsystem = UGameInstance::GetSubsystem<MyGameSubsystem>(GameInstance);
 * 
 *	You can get also define interfaces that can have multiple implementations.
 *	Interface Example :
 *      MySystemInterface
 *    With 2 concrete derivative classes:
 *      MyA : public MySystemInterface
 *      MyB : public MySystemInterface
 *
 *	Which can be accessed by:
 *		UGameInstance* GameInstance = ...;
 *		const TArray<UMyGameSubsystem*>& MySubsystems = GameInstance->GetSubsystemArray<MyGameSubsystem>();
 */

// ì„œë¸Œì‹œìŠ¤í…œì€ íŠ¹ì • ì—”ì§„ êµ¬ì„±ìš”ì†Œì˜ ìˆ˜ëª…ì„ ê³µìœ í•˜ëŠ” ìë™ìœ¼ë¡œ ì¸ìŠ¤í„´ìŠ¤í™”ë˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
// 
// í˜„ì¬ ì§€ì›ë˜ëŠ” ì„œë¸Œì‹œìŠ¤í…œ ìˆ˜ëª…ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:
//  ì—”ì§„        -> UEngineSubsystem ìƒì†
//  ì—ë””í„°      -> UEditorSubsystem ìƒì†
//  ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ -> UGameInstanceSubsystem ìƒì†
//  ì›”ë“œ        -> UWorldSubsystem ìƒì†
//  ë¡œì»¬ í”Œë ˆì´ì–´ -> ULocalPlayerSubsystem ìƒì†
// 
// ì¼ë°˜ì ì¸ ì˜ˆì‹œ:
//  class UMySystem : public UGameInstanceSubsystem
// ë‹¤ìŒê³¼ ê°™ì´ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
//  UGameInstance* GameInstance = ...;
//  UMySystem* MySystem = GameInstance->GetSubsystem<UMySystem>();
// 
// ë˜ëŠ” GameInstanceê°€ nullì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
//  UGameInstance* GameInstance = ...;
//  UMyGameSubsystem* MySubsystem = UGameInstance::GetSubsystem<MyGameSubsystem>(GameInstance);
// 
// ì—¬ëŸ¬ êµ¬í˜„ì„ ê°€ì§„ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
// ì¸í„°í˜ì´ìŠ¤ ì˜ˆì‹œ:
//      MySystemInterface
//    ë‘ ê°œì˜ êµ¬ì²´ì ì¸ íŒŒìƒ í´ë˜ìŠ¤:
//      MyA : public MySystemInterface
//      MyB : public MySystemInterface
//
// ë‹¤ìŒê³¼ ê°™ì´ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:
//      UGameInstance* GameInstance = ...;
//      const TArray<UMyGameSubsystem*>& MySubsystems = GameInstance->GetSubsystemArray<MyGameSubsystem>();

// USubsystemì€ ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ êµ¬ì„±ìš”ì†Œì˜ ìˆ˜ëª…ì£¼ê¸°(ìƒì„±/ì†Œë©¸)ë¥¼ ë”°ë¥´ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤:
// ì„œë¸Œì‹œìŠ¤í…œì˜ ì¢…ë¥˜:
//   1. ì—”ì§„        -> UEngineSubsystem ìƒì†
//   2. ì—ë””í„°      -> UEditorSubsystem ìƒì†
//   3. ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ -> UGameInstanceSubsystem ìƒì†
//   4. ì›”ë“œ        -> UWorldSubsystem ìƒì†
//   5. ë¡œì»¬ í”Œë ˆì´ì–´ -> ULocalPlayerSubsystem ìƒì†
// UWorldì™€ ê°™ì€ ì—”ì§„ êµ¬ì„±ìš”ì†Œì˜ ìˆ˜ëª…ì£¼ê¸° ê´€ë¦¬ëŠ” ë³µì¡í•˜ì§€ë§Œ:
// ì„œë¸Œì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ë©´ ë§¤ìš° ì‰½ê³  í¸ë¦¬í•©ë‹ˆë‹¤!
// ì„œë¸Œì‹œìŠ¤í…œ ì ‘ê·¼ ë°©ë²•ì— ëŒ€í•œ ì˜ˆì‹œë¥¼ ì½ì–´ë³´ì„¸ìš”

class USubsystem : public UObject
{
    /**
     * override to control if the Subsystem should be created
     * for example you could only have your system created on servers
     * it is important to note that if using this is becomes very important to null check whenever getting the Subsystem
     * 
     * NOTE: this function is called on the CDO prior to instances being created!!! 
     */
    // ì„œë¸Œì‹œìŠ¤í…œ ìƒì„± ì—¬ë¶€ë¥¼ ì œì–´í•˜ê¸° ìœ„í•´ ì˜¤ë²„ë¼ì´ë“œí•©ë‹ˆë‹¤
    // ì˜ˆë¥¼ ë“¤ì–´, ì„œë²„ì—ì„œë§Œ ì‹œìŠ¤í…œì„ ìƒì„±í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
    // ì´ë¥¼ ì‚¬ìš©í•  ê²½ìš° ì„œë¸Œì‹œìŠ¤í…œì„ ê°€ì ¸ì˜¬ ë•Œë§ˆë‹¤ null ì²´í¬ë¥¼ í•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤
    // 
    // ì£¼ì˜: ì´ í•¨ìˆ˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ê¸° ì „ì— CDOì—ì„œ í˜¸ì¶œë©ë‹ˆë‹¤!!!
    
    // ì„¤ëª…ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´, ì´ ë©¤ë²„ í•¨ìˆ˜ëŠ” CDO(ClassDefaultObject)ë¥¼ í†µí•´ í˜¸ì¶œë©ë‹ˆë‹¤
    virtual bool ShouldCreateSubsystem(UObject* Outer) const { return true; }

    /** implement this for init/deinit of instances of the system */
    // ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ì˜ ì´ˆê¸°í™”/í•´ì œë¥¼ ìœ„í•´ ì´ê²ƒì„ êµ¬í˜„í•˜ì„¸ìš”
    virtual void Initialize(FSubsystemCollectionBase& Collection) {}
    virtual void Deinitialize() {}

    // ìš°ë¦¬ëŠ” UWorldì˜ [FObjectSubsystemCollection<UWorldSubsystem>]ì— ê´€ì‹¬ì´ ìˆìŠµë‹ˆë‹¤
    // ê° ì„œë¸Œì‹œìŠ¤í…œì€ ì´ì™€ ê°™ì€ ì†Œìœ ìë¥¼ ê°€ì§‘ë‹ˆë‹¤
    FSubsystemCollectionBase* InternalOwningSubsystem;
};
```

```cpp
class FSubsystemCollectionBase
{
    // ...

    UObject* Outer;         // is UWorld

    // SubSystemì˜ íƒ€ì… ì…ë‹ˆë‹¤. ë‹¤ì–‘í•œ SubSystemì„ ê´€ë¦¬í•˜ê¸° ìœ„í•´ ì¡´ì¬í•©ë‹ˆë‹¤.
    UClass* BaseType;       // is UWorldSubsystem

    /*
    SubSystemì„ A B Cë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ë©´ ê° í´ë˜ìŠ¤ëŠ” ê³ ìœ ì„±ì´ ë³´ì¥ë©ë‹ˆë‹¤. 
    ê·¸ê²ƒì„ ì´ìš©í•´ ì„œ 1:1ë¡œ ë§¤í•‘í•œ í•¨ìˆ˜ ì…ë‹ˆë‹¤. 
    Key : A ClassType Value : Instance A
    */
    TMap<TObjectPtr<UClass>, TObjectPtr<USubsystem>> SubsystemMap;

    /*
    SubSystemì€ ë™ì ìœ¼ë¡œ ìƒì„±ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì—”ì§„ì˜ êµ¬ì„±ë‹¨ê³„ì—ì„œ ê²°ì •ë˜ëŠ”ë°
    DynamicSubSystemì„ ì´ìš©í•˜ë©´ ë™ì ìœ¼ë¡œ ì—¬ëŸ¬ê°œê°€ ìƒì„±ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. 
    ê·¸ê²ƒì„ ê´€ë¦¬í•˜ê¸° ìœ„í•´ì„œ ë³„ë„ë¡œ ë§Œë“  Map ì…ë‹ˆë‹¤.
    */
    mutable TMap<UClass*, TArray<USubsystem*>> SubsystemArrayMap;
};
```