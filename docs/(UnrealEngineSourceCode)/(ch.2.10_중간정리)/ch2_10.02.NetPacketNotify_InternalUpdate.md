---
layout: default
title: "10-02. NetPacketNotify::InternalUpdate"
parent: "([Network] 10. 중간정리)"
grand_parent: "(UE SourceCode 분석 🤖)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* NetPacketNotify는 언리얼 엔진의 네트워크 패킷 신뢰성과 순서 보장을 관리하는 중요한 클래스입니다. 

```cpp
class FNetPacketNotify
{
    // 시퀀스 번호 관리
    private:
        FSequenceNumber::TSequenceNumber LastReceivedSequence;  // 마지막으로 받은 패킷 번호
        FSequenceNumber::TSequenceNumber LastSentSequence;      // 마지막으로 보낸 패킷 번호
        
    // 패킷 추적
    private:
        TStaticBitArray<MAX_PACKET_HISTORY> ReceivedPackets;    // 수신된 패킷 기록
        TStaticBitArray<MAX_PACKET_HISTORY> DeliveredPackets;   // 전달 완료된 패킷 기록
```

* 주요 역할
    * 패킷 시퀀스 관리
        * 각 패킷에 고유한 시퀀스 번호 부여
        * 패킷의 순서 보장
        * 누락된 패킷 감지
    * 신뢰성 보장
        * 패킷 수신 확인(ACK) 처리
        * 손실된 패킷 재전송 요청
        * 중복 패킷 필터링

```cpp
class UChannel 
{
    private:
        FNetPacketNotify PacketNotify;  // 채널별 패킷 관리

    public:
        // 패킷 전송 시
        void SendPacket() 
        {
            // PacketNotify를 통해 시퀀스 번호 할당 및 추적
        }
};
```

```cpp
class UNetConnection 
{
    private:
        FNetPacketNotify PacketNotify;  // 연결별 패킷 관리

    public:
        // 패킷 수신 처리
        void ProcessReceivedPacket(const FPacket& Packet)
        {
            // PacketNotify를 통해 수신 확인 및 순서 검증
        }
};
```

---

* `InternalUpdate`의 역할
    * 클라이언트와 서버 간의 패킷 전송 상태를 추적
    * 패킷 손실을 감지하고 재전송을 처리
    * 시퀀스 번호를 관리하여 패킷의 순서를 보장

* 시퀀스 히스토리 오버플로우 상황
    * 클라이언트의 시퀀스 번호와 현재 처리된 마지막 시퀀스 번호의 차이가 256(HistorySize)를 초과할 때 발생
    * 이는 주로 심각한 패킷 손실이나 네트워크 스파이크가 있을 때 발생
* 두 가지 케이스의 처리 방법:
    * a) 모든 시퀀스 히스토리가 무효한 경우:
        * 히스토리의 모든 항목이 false(배달되지 않음)인 상태
        * 이 경우 InAckSeqAck를 새로운 시퀀스 번호로 조용히 업데이트
        * 누락된 패킷들은 NAK로 처리되어 클라이언트가 재전송
    * b) 유효한 항목이 있는 경우:
        * 히스토리에 하나라도 true(배달됨) 항목이 있는 상태
        * 남은 공간(256 - 현재 히스토리 길이)만큼만 새로운 NAK 항목 추가 가능
        * 기존 항목들은 보존하면서 새로운 시퀀스 번호로 이동

* 이 메커니즘은 특히 다음 상황에서 중요합니다:
    * 심각한 패킷 손실 발생 시
    * 네트워크 트래픽이 매우 높을 때
    * 클라이언트와 서버 간의 동기화가 깨질 위험이 있을 때

* 이를 통해 신뢰성 있는 네트워크 통신을 보장하고, 패킷 손실이 발생하더라도 데이터의 정확한 전달을 보장할 수 있습니다.

```cpp
// 우리는 발신 ack-window가 오버플로우되는지 확인해야 합니다. 만약 오버플로우가 발생하고 처리된 데이터가 있다면 
// ack-시퀀스 히스토리의 재동기화를 시작해야 합니다.
// 이는 동기화가 다시 이루어질 때까지 새로운 패킷들을 무시함으로써 수행됩니다.
// 이는 일반적으로 큰 패킷 손실이나 수신 측의 스파이크가 있는 상황에서만 발생합니다.

// "시퀀스 히스토리를 플러시하기를 기다리고 있는지 아닌지" 결정
// - 만약 (NotificationData.Seq(클라이언트) - InAckSeqAck) > 256(HistorySize)이면, 두 가지 경우가 있습니다:
//   *** 우리는 특이한 상황에 있습니다!
//
//   1. 시퀀스 히스토리의 모든 요소가 유효하지 않은 전달 상태(== false)일 때:
//                                                                                                                            
//           ┌──1.시퀀스 히스토리의 모든 전달 상태가 0                                                                  
//           │                                                                                                                
//      │◄───┴─────────────────►│                                                                                             
//      │                       │                                                                                             
//      ├───┬───┬───┬───┬───┬───┤                                                                                             
//      │ 0 │ 0 │...│ 0 │ 0 │ 0 │                                                                                             
//      └───┴───┴───┴───┴───┴─▲─┘                                                                                             
//                            │                                                                                               
//                            │                                                                                               
//                         2.새로운 InSeq를 추가하기 전에, InSeq로 'InAckSeqAck'를 조용히 업데이트합니다:                              
//                           ┌─────────────────────────────────────────────────────────────────────────────────────────────┐  
//                           │ Count = (InAckSeqAck - InSeq)                                                               │  
//                           │                                                                                             │  
//                           │ [InSeq - Count, InSeq]는 상대방 측(현재 우리 케이스에서는 클라이언트)에서 'Nak'로 처리될 것입니다 │  
//                           │                        ──────────────────────────────────────────────────────────────────── │  
//                           │                                 *** 클라이언트는 번치들을 다시 전송할 것입니다               │  
//                           └─────────────────────────────────────────────────────────────────────────────────────────────┘  
//   
//
//
//   2. 시퀀스 히스토리에 유효한 전달 상태(== true)가 있을 때:
//      
//                      1.시퀀스 히스토리에 일부 전달 상태가 1입니다                                                                                                                  
//                            │                                                                                                                                                        
//                        ┌───┴───┐                                                                                                                                                    
//      │               │ │       │ │                                                                                                                                                  
//      │               │ │       │ │                                                                                                                                                  
//      ├───┬───┬───┬───┼─▼─┬───┬─▼─┤                                                                                                                                                  
//      │ 0 │ 0 │ 0 │...│ 1 │ 0 │ 1 │                                                                                                                                                  
//      ├───┴───┴───┴───┼───┴───┴───┤                                                                                                                                                  
//      │               │           │                                                                                                                                                  
//      │◄────┬────────►│◄────┬────►│                                                                                                                                                  
//      │     │         │     │     │                                                                                                                                                  
//            │               │                                                                                                                                                        
//            │               └─────────2.CurrentSequenceHistoryLength() == 3                                                                                                          
//            │                                                                                                                                                                        
//        3. HistorySize(256) - CurrentSequenceHistoryLength(3) == 253                                                                                                                 
//                                                                ─────                                                                                                                
//                                                                *** InSeqHistory에 총 253개의 항목을 'Nak'로 추가할 수 있습니다                                                            
//                                                                    ────────┬─────────────────────────────────────────────                                                           
//                                        │                                   │                                                                                                        
//                                        │                                   ▼                                                                                                        
//                                        │  4.NewInSeqToAck = InAckSeqAck + 253                                                                                                       
//                                        │                                                                                                                                            
//                                        │  5.FNetPacketNotify::AckSeq(NewInSeqToAck) 호출                                                                                            
//                                        │    ─────────────────────────────┬─────────────                                                                                             
//                                        │                                 │                                                                                                          
//                                        ▼                                 │                                                                                                          
//                               ┌───────────┐   ┌───────────┐              │                                                                                                          
//                               ├───┬───┬───┼───┼───┬───┬───┤              │                                                                                                          
//                               │ 0 │ 0 │ 0 │...│ 1 │ 0 │ 1 │              │                                                                                                          
//                               ├───┴───┴───┼───┼───┴───┴───┤              │                                                                                                          
//                               └───▲───────┘   └───┬───────┘              │                                                                                                          
//                                   │               │                      │                                                                                                          
//                                   └────────▲──────┘                      │                                                                                                          
//                                            │                             │                                                                                                          
//                                            └─────────────────────────────┘                                                                                                          
//                               ┌───────────┐   ┌───────────┐    *** 세 개의 항목 [0,2]가 [253,255]로 이동되고                                                                         
//                               ├───┬───┬───┼───┼───┬───┬───┤        총 253개의 항목이 '0'으로 채워집니다                                                                        
//                               │ 1 │ 0 │ 1 │...│ 0 │ 0 │ 0 │         │                                                                                                               
//                               ├───┴───┴───┼───┼───┴───┴───┤         └───6. 전달 상태가 '0'인 모든 시퀀스 번호는 'Nak'로 처리되고 상대방 측에서 재전송될 것입니다     
//                               └───────────┘   └───────────┘                                                                                                                         
//                                                                                                                                                                                                                                                                                                           
//
// - 언제 이런 일이 발생하나요?
//   *** 큰 패킷 손실이나 심한 네트워크 트래픽이 있을 때
```


