---
layout: default
title: "01. AttachToComponent"
parent: "(06.USceneComponent::OnRegister ë¶„ì„)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## FAttachmentTransformRules

* ë“¤ì–´ê°€ê¸° ì „ `FAttachmentTransformRules`ì— ëŒ€í•œ ì„¤ëª…

```cpp
// ì–´ë–¤ì‹ìœ¼ë¡œ ë¶™ì¼ê»€ì§€ì— ëŒ€í•œ ì„¤ëª…
    // Location, Rotation, Scaleì´ ëŒ€í‘œì ì´ê² ì§€?
struct FAttachmentTransformRules
{
    /** the rule to apply to location when attaching */
    EAttachmentRule LocationRule;

    /** the rule to apply to rotation when attaching */
    EAttachmentRule RotationRule;

    /** the rule to apply to scale when attaching */
    EAttachmentRule ScaleRule;

    // ìš©ì–´ì •ë¦¬ 
        // weld - ìš©ì ‘
        // íŠ¹ì • ë¶€ìœ„ì— ë¶™ì¼ë•Œ ì‚¬ìš©
    
    //                                                  
    //   RigidBody                                      
    //   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            
    //   â”‚                                 â”‚            
    //   â”‚      Shape0                     â”‚            
    //   â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚            
    //   â”‚      â”‚           â”‚              â”‚            
    //   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤              â”‚            
    //   â”‚              â”‚   â”‚    Shape2    â”‚            
    //   â”‚              â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚            
    //   â”‚              â”‚   â”‚         â”‚    â”‚            
    //   â”‚              â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚            
    //   â”‚              â”‚   â”‚              â”‚            
    //   â”‚              â””â”€â”€â”€â”˜              â”‚            
    //   â”‚               Shape1            â”‚            
    //   â”‚                                 â”‚            
    //   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            
    //                                                  
    //   - RigidBody is the unit of physics simulation  
    //   - Shape is the unit of physics properties:     
    //      1. ShapeType(Sphere,Box,Capsule,...)        
    //      2. Mass                                     
    //      3. ...etc.                                  
    //
    // - secondly, understand what is the simulation unit(rigid-body) is:
    //                                                                                                         
    //   Case 1) Each Shape has its own Rigid-Body               Case 2) All shapes owned by one Rigid-Body     
    //                                                                                                          
    //        Shape0:RigidBody0                                       RigidBody                                 
    //        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       
    //        â”‚           â”‚                                           â”‚      Shape0                     â”‚       
    //        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤                                           â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚       
    //                â”‚   â”‚    Shape2:RigidBody2                      â”‚      â”‚           â”‚              â”‚       
    //                â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                 â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤              â”‚       
    //                â”‚   â”‚         â”‚                                 â”‚              â”‚   â”‚    Shape2    â”‚       
    //                â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                 â”‚              â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚       
    //                â”‚   â”‚                                           â”‚              â”‚   â”‚         â”‚    â”‚       
    //                â””â”€â”€â”€â”˜                                           â”‚              â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚       
    //                 Shape1:RigidBody1                              â”‚              â”‚   â”‚              â”‚       
    //                                                                â”‚              â””â”€â”€â”€â”˜              â”‚       
    //                  â”‚                                             â”‚               Shape1            â”‚       
    //                  â”‚                                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       
    //                  â”‚ Gravity is applied                                                                    
    //                  â”‚                                                              â”‚                        
    //                  â”‚                                                              â”‚                        
    //                  â–¼                                                              â”‚ Gravity is applied     
    //                                                                                 â”‚                        
    //                                                                                 â”‚                        
    //               Shape1:RigidBody1                                                 â–¼                        
    //                     â”Œâ”€â”€â”€â”                                                                                
    //                     â”‚   â”‚                                              Shape0                            
    //                     â”‚   â”‚                                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     
    //    Shape0:RigidBody0â”‚   â”‚ Shape2:RigidBody2                            â”‚           â”‚                     
    //    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤                     
    //    â”‚           â”‚    â”‚   â”‚ â”‚         â”‚                                          â”‚   â”‚    Shape2           
    // â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€                                         â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           
    //                                                                                â”‚   â”‚         â”‚           
    //                                                                                â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           
    //                                                                                â”‚   â”‚                     
    //                                                                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    
    //                                                                                 Shape1                                                        
    //

    //   - Diagram:
    //                                                                                                                                    
    //     Component0:BodyInstance0                                                    Component0:BodyInstance0                                  
    //     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                             
    //     â”‚           â”‚                                                               â”‚           â”‚                                             
    //     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤                                                               â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¤                                             
    //             â”‚   â”‚    Component2:BodyInstance2                                           â”‚   â”‚    Component2:WeldParent=BodyInstance0      
    //             â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                             â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   
    //             â”‚   â”‚         â”‚                   Conceptually,                             â”‚   â”‚         â”‚                                   
    //             â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    Merge AllComponent's RididBodies         â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   
    //             â”‚   â”‚                              into Component0(RootComponent)           â”‚   â”‚                                             
    //             â””â”€â”€â”€â”˜                             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º            â””â”€â”€â”€â”˜                                             
    //              Component1:BodyInstance1                                                    Component1:WeldParent=BodyInstance0              
    //                                                                                                                                           
    //                                                                                                                                           
    //                                                                                                                                           
    //            Component0:AttachChildren[Component1]                                       Component0:AttachChildren[Component1]              
    //                â–²                                                                           â–²      WeldChildren[Component1,Component2]     
    //                â”‚                                                                           â”‚                                              
    //            Component1:AttachChildren[Component2]                                       Component1:AttachChildren[Component2]              
    //                â–²                                                                           â–²                                              
    //                â”‚                                                                           â”‚                                              
    //            Component2                                                                  Component2                                         
    //                                                                                                                                           
    bool bWeldSimulatedBodies;
};
```

---

## FUObjectThreadContext

* ë“¤ì–´ê°€ê¸° ì „ `FUObjectThreadContext`

```cpp
// TThreadSingleton - TLSë¥¼ ì“°ê¸°ìœ„í•œ ë¶€ëª¨.
class FUObjectThreadContext : public TThreadSingleton<FUObjectThreadContext>
{
    // ...

    /** Global flag so that FObjectFinders know if they are called from inside the UObject constructors or not */
    int32 IsInConstructor;
};
```

---

## AttachToComponent

```cpp
bool AttachToComponent(USceneComponent* Parent, const FAttachmentTransformRules& AttachmentRules, FName InSocketName=NAME_None)
{
    FUObjectThreadContext& ThreadContext = FUObjectThreadContext::Get();
    if (ThreadContext.IsInConstructor > 0)
    {
        check(!AttachmentRules.bWeldSimulatedBodies);
        check(AttachmentRules.LocationRule == EAttachmentRule::KeepRelative);
        
        // ThreadContext.IsInConstructorì´ ì¼œì§„ê²½ìš°
        // Setupë§Œí•˜ê³  ë„˜ì–´ê°„ë‹¤

        SetupAttachment(Parent, SocketName);
        //...
        return true;
    }

    if (Parent != nullptr)
    {
        // ì•„ë˜ëŠ” í”¼í•´ì•¼í•  ì˜ˆì™¸ì‚¬í•­ì˜ ì²˜ë¦¬ì´ë‹¤.
        const int32 LastAttachIndex = Parent->AttachChildren.Find(TObjectPtr<USceneComponent>(this));
        const bool bSameAttachParentAndSocket = (Parent == GetAttachParent() && SocketName == GetAttachSocketName());
        if (bSameAttachParentAndSocket && LastAttachIndex != INDEX_NONE)
        {
            // already attached!
            return true;
        }

        if (Parent == this)
        {
            return false;
        }

        AActor* MyActor = GetOwner();
        AActor* TheirActor = Parent->GetOwner();

        if (MyActor == TheirActor && MyActor && MyActor->GetRootComponent() == this)
        {
            return false;
        }

        if (Parent->IsAttachedTo(this))
        {
            // AttachCycleWarning: would for cycle!
            return false;
        }

        if (!Parent->CanAttachAsChild(this, SocketName))
        {
            return false;
        }

        if (!IsOwnerRunningUserConstructionScript() && Mobility == EComponentMobility::Static && Parent->Mobility != EComponentMobility::Static)
        {
            // NoStaticToDynamicWarning
            return false;
        }

        if (Parent->IsTemplate() != IsTemplate())
        {
            return false;
        }

        const bool bSavedDisableDetachmentUpdateOverlaps = bDisableDetachmentUpdateOverlaps;
        bDisableDetachmentUpdateOverlaps = true;

        if (!ShouldSkipUpdateOverlaps())
        {
            Parent->ClearSkipUpdateOverlaps();
        }

        // haker: see FDetachmentTransformRules (goto 009: AttachToComponent)
        FDetachmentTransformRules DetachmentRules(AttachmentRules, true);

        // make sure we are detached
        if (bSameAttachParentAndSocket 
            && !IsRegistered() 
            && AttachmentRules.LocationRule == EAttachmentRule::KeepRelative 
            && AttachmentRules.RotationRule == EAttachmentRule::KeepRelative 
            && AttachmentRules.ScaleRule == EAttachmentRule::KeepRelative 
            && LastAttachIndex == INDEX_NONE)
        {
            // Detachë¥¼ í•˜ì§€ ì•Šì„ ì¡°ê±´ì„ ì²´í¬
        }
        else
        {
            // DetachFromComponent! 2ì¥ ì°¸ì¡°!
            DetachFromComponent(DetachmentRules);
        }

        // restore detachment update overlaps flag
        bDisableDetachmentUpdateOverlaps = bSavedDisableDetachmentUpdateOverlaps;

        {
            UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(this);
            FBodyInstance* BI = PrimitiveComponent ? PrimitiveComponent->GetBodyInstance() : nullptr;
            if (BI && BI->bSimulatePhysics && !AttachmentRules.bWeldSimualtedBodies)
            {
                //...
            }
        }

        PrimaryComponentTick.AddPrerequisite(Parent, Parent->PrimaryComponentTick); // force us to tick after the parent does

        // save pointer from child to parent
        SetAttachParent(Parent);
        SetAttachSocketName(SocketName);

        OnAttachmentChanged();


        
        if (LastAttachIndex != INDEX_NONE && !bNetUpdateAttachment)
        {
            Parent->AttachChildren.Insert(this, LastAttachIndex);
        }
        else
        {
            Parent->AttachChildren.Add(this);
        }

        Parent->ModifiedAttachChildren();

        AddToCluster(Parent, true);

        if (Parent->IsNetSimulating() && !IsNetSimulating())
        {
            Parent->ClientAttachedChildren.AddUnique(this);
        }

        FTransform SocketTransform = GetAttachParent()->GetSocketTransform(GetAttachSocketName());

        // - Diagram:
        //                                                                                                                                                             
        //                                                                                                                                                             
        //           A                                                                    A                                                                            
        //          â”Œâ”€â”€â”€â”€â”€â”€â”                                                             â”Œâ”€â”€â”€â”€â”€â”€â”                                                                      
        //          â”‚      â”‚                                                             â”‚      â”‚                                                                      
        //          â”‚  x   â”‚                                                             â”‚  x   â”‚       Y                                                              
        //          â”‚      â”‚                                                             â”‚      â”‚        â–²                                                             
        //          â””â”€â”€â”€â”€â”€â”€â”˜     B                 Apply Inv(BoneTransform(B))           â””â”€â”€â”€â”€â”€â”€â”˜     B  â”‚                                                             
        //    Y                  â”Œâ”€â”€â”€â”€â”€â”€â”                                                             â”Œâ”€â”€â”¼â”€â”€â”€â”                                                         
        //     â–²                 â”‚      â”‚          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                            â”‚  â”‚   â”‚                                                         
        //     â”‚                 â”‚  x   â”‚                                                             â”‚  xâ”€â”€â”€â”¼â”€â”€â–ºX                                                     
        //     â”‚                 â”‚      â”‚                                                             â”‚      â”‚                                                         
        //     â”‚                 â””â”€â”€â”€â”€â”€â”€â”˜                                                             â””â”€â”€â”€â”€â”€â”€â”˜                                                         
        //     â””â”€â”€â”€â”€â”€â”€â–ºX                                                                                                                                               
        //                                                                               A: ComponentToWorld x Inv(BoneTransform(B))                                   
        //     'x' is the origin (or pivot)                                              B: Identity Matrix = BoneTransform(B) x Inv(BoneTransform(B))                 
        //                                                                                                                                                             
        //                                                                               *** A: ComponentToWorld x Inv(BoneTransform(B) == RelativeTransform(A) on B  
        //                                                                                   
        //                                                                                                                                                             
                                                                                                                                                    
        FTransform RelativeTM = GetComponentTransform().GetRelativeTransform(SocketTransform);

        switch (AttachmentRules.LocationRule)
        {
        case EAttachmentRule::KeepRelative:
            // dont do anything, keep relative position the same
            break;
        case EAttachmentRule::KeepWorld:
            if (IsUsingAbsoluteLocation())
            {
                SetRelativeLocation_Direct(GetComponentTransform().GetTranslation());
            }
            else
            {
                SetRelativeLocation_Direct(RelativeTM.GetTranslation());
            }
            break;
        case EAttachmentRule::SnapToTarget:
            SetRelativeLocation_Direct(FVector::ZeroVector);
            break;
        }

        switch (AttachmentRules.RotationRule)
        {
        case EAttachmentRule::KeepRelative:
            // dont do anything, keep relative rotation the same
            break;
        case EAttachmentRule::KeepWorld:
            if (IsUsingAbsoluteRotation())
            {
                SetRelativeRotation_Direct(GetComponentRotation());
            }
            else
            {
                SetRelativeRotation_Direct(RelativeRotationCache.QuatToRotator(RelativeTM.GetRotation()));
            }
            break;
        case EAttachmentRule::SnapToTarget:
            SetRelativeRotation_Direct(FRotator::ZeroRotator);
            break;
        }

        switch (AttachmentRules.ScaleRule)
        {
        case EAttachmentRule::KeepRelative:
            // dont do anything, keep relative scale the same
            break;
        case EAttachmentRule::KeepWorld:
            if (IsUsingAbsoluteScale())
            {
                SetRelativeScale3D_Direct(GetComponentTransform().GetScale3D());
            }
            else
            {
                SetRelativeScale3D_Direct(RelativeTM.GetScale3D());
            }
            break;
        case EAttachmentRule::SnapToTarget:
            SetRelativeScale3D_Direct(FVector(1.0f, 1.0f, 1.0f));
            break;
        }

        GetAttachParent()->OnChildAttached(this);

        UpdateComponentToWorld(EUpdateTransformFlags::None, ETeleportType::TeleportPhysics);

        if (AttachmentRules.bWeldSimulatedBodies)
        {
            if (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(this))
            {
                if (FBodyInstance* BI = PrimitiveComponent->GetBodyInstance())
                {
                    PrimitiveComponent->WeldToImplementation(GetAttachParent(), GetAttachSocketName(), AttachmentRules.bWeldSimulatedBodies);
                }
            }
        }

        if (IsRegistered())
        {
            UpdateOverlaps();
        }

        return true;
    }

    return false;
}
```