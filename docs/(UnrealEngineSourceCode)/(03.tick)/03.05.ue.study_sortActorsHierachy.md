---
layout: default
title: "03-05. SortActorsHierarchy"
parent: "(03. Tickë“¤ì–´ê°€ê¸°)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/**
 * sorts actors such that parent actors will appear before children actors in the list:
 * Stable Sort 
 */
static void SortActorsHierarchy(TArray<TObjectPtr<AActor>>& Actors, ULevel* Level)
{
    // we covered conceptually how child-actor works in AActor-UActorComponent structure
    // - this function sorts actor's depth considering AActor-AActor parent-child relationships
    TMap<AActor*, int32> DepthMap;
    TArray<AActor*, TInlineAllocator<10>> VistedActors;

    DepthMap.Reserve(Actors.Num());

    bool bFoundWorldSettings = false;

    // we need to understand how child actor's root-component is attached its parent-actor:
    // - in the last time, I just simply mention how child actor works in unreal
    // - the actual way is related to SceneComponent's AttachParent and AttachChildren:
    //                                                                                                                                              
    //       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                
    //       â”‚  Actor0  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Actor1  â”‚                                                
    //       â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                               â””â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                
    //          â”‚                                                                         â”‚                                                         
    //       â”Œâ”€RootComponentâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”Œâ”€RootComponentâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            
    //       â”‚ AttachParent: NULL                            â”‚                         â”‚ AttachParent: Actor0's Component1             â”‚            
    //       â”‚ Children: [Component1, Component3]            â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ Children: [Component1, Component2]            â”‚            
    //       â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚         â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            
    //          â”‚                                                       Actor0â”€â”€Actor1    â”‚                                                         
    //          â”‚ â”Œâ”€Component1â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚            â”‚ â”Œâ”€Component1â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       
    //          â”œâ”€â”¤ AttachParent: RootComponent                   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”œâ”€â”¤ AttachParent: RootComponent                   â”‚       
    //          â”‚ â”‚ Children: [Actor1's RootComponent,Component2] â”‚                       â”‚ â”‚ Children: []                                  â”‚       
    //          â”‚ â””â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       
    //          â”‚   â”‚                                                                     â”‚                                                         
    //          â”‚   â”‚  â”Œâ”€Component2â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚ â”Œâ”€Component2â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       
    //          â”‚   â””â”€â”€â”¤ AttachParent: Component1                      â”‚                  â””â”€â”¤ AttachParent: RootComponent                   â”‚       
    //          â”‚      â”‚ Children: []                                  â”‚                    â”‚ Children: []                                  â”‚       
    //          â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       
    //          â”‚                                                                                                                                   
    //          â”‚   â”Œâ”€Component3â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                                               
    //          â””â”€â”€â”€â”¤ AttachParent: RootComponent                   â”‚                                                                               
    //              â”‚ Children: []                                  â”‚                                                                               
    //              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                               
    //                                                                                                                                              
    TFunction<int32(AActor*)> CalcAttachDepth = [
        &DepthMap, 
        &VisitedActors, 
        // we capture TFunction CalcAttachDepth to call lambda recursively
        &CalcAttachDepth, 
        &bFoundWorldSettings]
        (AActor* Actor)
    {
        int32 Depth = 0;
        // not need to do it again if we found the depth of Actor
        // DepthMapì— ì´ë¯¸ Depthê°€ ê³„ì‚°ì´ ë˜ì–´ ìˆë‹¤ë©´ í•´ë‹¹ Depthë¥¼ ì„¤ì •í•˜ê³  ë§ˆë¬´ë¦¬ í•©ë‹ˆë‹¤.
        if (int32* FoundDepth = DepthMap.Find(Actor))
        {
            Depth = *FoundDepth;
        }
        else
        {
            // DepthMapì— ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ì´ì œ íƒìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤.

            // WorldSettings is expected to be the first element in the sorted Actors array
            // to accomodate for the known issue where two world settings can exist, we only sort the
            // first one we find to the 0 index

            // as we saw previously, AWorldSettings is the first Actor added when we create UWorld
            // - we need to make sure AWorldSetting is in index-0
                // UWorldë¥¼ ì„¸íŒ…í•  ë•Œ ê°€ì¥ ì²˜ìŒ ë§Œë“¤ì–´ì§„ ActorëŠ” WorldSetting ì…ë‹ˆë‹¤. í•´ë‹¹ Actorê°€
                // WorldSettingì´ë¼ë©´ 0ì´ë¼ëŠ” ê°’ì„ ë¶€ì—¬í•´ì„œ WorldSettingì€ í•­ìƒ ì¸ë±ìŠ¤ 0ë²ˆì— ìˆìŒì„ ë³´ì¥í•©ë‹ˆë‹¤
            if (Actor->IsA<AWorldSettings>())
            {

                if (!bFoundWorldSettings)
                {
                    // by setting AWorldSetting's depth as lowest value in int32, we can guarantee that AWorldSetting is in index-0
                    Depth = TNumericLimits<int32>::Lowest();
                    bFoundWorldSettings = true;
                }
                else
                {
                    UE_LOG(LogLevel, Warning, TEXT("Detected duplicate WorldSettings actor - UE-62934"));
                }
            }
            else if (AActor* ParentActor = Actor->GetAttachParentActor())
            {
                // WorldSettingì´ ì•„ë‹ˆë¼ë©´ ì¼ë°˜ Actorì´ë¯€ë¡œ ChildActorê°€ ì•„ë‹Œ ParentActorë¥¼ ë¨¼ì € ë“±ë¡ì„ ì§„í–‰í•©ë‹ˆë‹¤.
                if (!VisitedActors.Contains(ParentActor))
                {
                    VisitedActors.Add(Actor);

                    // Actors attached to a ChildActor have to be registered first or else
                    // they will become detached due to the AttachChildren not yet being populated
                    // and thus not recorded in the ComponentInstanceDataCache
                    if (ParentActor->IsChildActor())
                    {
                        // this case is kind of exception handling... BUT, still can't come up with proper scenario...
                        // *** I need to experiment how it works ?!
                        Depth = CalcAttachDepth(ParentActor) - 1;
                    }
                    else
                    {
                        //       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                                           
                        //       â”‚                                                          â”‚                                                                           
                        //       â”‚      Actor0 â—„â”€â”€â”€  Depth = 0                              â”‚                                                                           
                        //       â”‚       â”‚                                                  â”‚                                                                           
                        //       â”‚       â””â”€RootComponent                                    â”‚                                                                           
                        //       â”‚          â”‚                                               â”‚                                                                           
                        //       â”‚          â””â”€Component1                                    â”‚                                                                           
                        //       â”‚             â”‚                                            â”‚                                                                           
                        //       â”‚             â””â”€Actor1 â—„â”€â”€â”€  Depth = 1                     â”‚                                                                           
                        //       â”‚                â”‚                                         â”‚                                                                           
                        //       â”‚                â””â”€RootComponent                           â”‚                                                                           
                        //       â”‚                   â”‚                                      â”‚                                                                           
                        //       â”‚                   â””â”€Actor2 â—„â”€â”€â”€â”€  Depth = 2              â”‚                                                                           
                        //       â”‚                                                          â”‚                                                                           
                        //       â”‚                                                          â”‚                                                                           
                        //       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                           
                        Depth = CalcAttachDepth(ParentActor) + 1;
                    }
                }
            }
            DepthMap.Add(Actor, Depth);
        }
        return Depth;
    };

    // iterating Actors in ULevel, calculate depth with respect to AActor (not ActorComponent!)
    for (AActor* Actor : Actors)
    {
        if (Actor)
        {
            CalcAttachDepth(Actor);
            VisitedActors.Reset();
        }
    }

    auto DepthSorter = [&DepthMap](AActor* A, AActor* B)
    {
        const int32 DepthA = A ? DepthMap.FindRef(A) : MAX_int32;
        const int32 DepthB = B ? DepthMap.FindRef(B) : MAX_int32;
        return DepthA < DepthB;
    };

    // merge sort:
    StableSortInternal(Actors.GetData(), Actors.Num(), DepthSorter);

    // since all the null entries got sorted to the end, loop them off right now
    // after sorting, there are remaining entries in Actors array, so remove them
    int32 RemoveAtIndex = Actors.Num();
    while (RemoveAtIndex > 0 && Actors[RemoveAtIndex - 1] == nullptr)
    {
        --RemoveAtIndex;
    }
    if (RemoveAtIndex < Actors.Num())
    {
        Actors.RemoveAt(RemoveAtIndex, Actors.Num() - RemoveAtIndex);
    }
}
```