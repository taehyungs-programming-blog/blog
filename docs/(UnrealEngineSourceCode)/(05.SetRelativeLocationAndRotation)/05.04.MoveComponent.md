---
layout: default
title: "04. MoveComponent"
parent: "(05.SetRelativeLocationAndRotation ë¶„ì„)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
bool MoveComponent
(
    const FVector& Delta, 
    const FQuat& NewRotation, 
    bool bSweep, 
    FHitResult* Hit, 
    EMoveComponentFlags MoveFlags, 
    ETeleportType Teleport
)
{
    return MoveComponentImpl(Delta, NewRotation, bSweep, Hit, MoveFlags, Teleport);
}
```

```cpp
virtual bool MoveComponentImpl
(
    const FVector& Delta, 
    const FQuat& NewRotation, 
    bool bSweep, 
    FHitResult* Hit = NULL, 
    EMoveComponentFlags MoveFlags = MOVECOMP_NoFlags, 
    ETeleportType Teleport = ETeleportType::None
)
{
    if (OutHit)
    {
        *OutHit = FHitResult(1.f);
    }

    ConditionalUpdateComponentToWorld();

    if (Delta.IsZero())
    {
        if (NewRotation.Equals(GetComponentTransform().GetRotation(), SCENECOMPONENT_QUAT_TOLERANCE))
        {
            return true;
        }
    }

    const bool bMoved = InternalSetWorldLocationAndRotation(GetComponentLocation() + Delta, NewRotation, false, Teleport);


    if (bMoved && !IsDeferringMovementUpdates())
    {
        // (Tips) Overlaps - ë‘ ê°ì²´ê°€ ì„œë¡œì˜ ê³µê°„ì„ ê³µìœ í•  ë•Œ ë°œìƒí•˜ëŠ” ìƒí™©ì„ ë§í•©ë‹ˆë‹¤. 
        // ì´ëŠ” ì£¼ë¡œ ê²Œì„ ê°œë°œì—ì„œ ì¤‘ìš”í•œ ê°œë…ìœ¼ë¡œ, ë¬¼ë¦¬ì ì¸ ì¶©ëŒì´ ì¼ì–´ë‚˜ì§€ ì•Šê³ ë„ ê°ì²´ë“¤ì´ ì–´ë–»ê²Œ ì„œë¡œì˜ ê³µê°„ì— ë“¤ì–´ì™€ ìˆëŠ”ì§€ë¥¼ ê°ì§€í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. 
        // ì˜ˆë¥¼ ë“¤ì–´, ê²Œì„ ìºë¦­í„°ê°€ íŠ¹ì • ì˜ì—­ì— ë“¤ì–´ê°”ì„ ë•Œ íŠ¹ì • ì´ë²¤íŠ¸ë¥¼ ë°œë™ì‹œí‚¤ëŠ” ê²ƒê³¼ ê°™ì€ ìƒí™©ì—ì„œ ì´ìš©ë©ë‹ˆë‹¤.
        UpdateOverlaps();
    }

    return true;
}
```

```cpp
bool UpdateOverlaps(const TOverlapArrayView* PendingOverlaps=nullptr, bool bDoNotifies=true, const TOverlapArrayView* OverlapsAtEndLocation=nullptr)
{
    if (IsDeferringMovementUpdates())
    {
        GetCurrentScopedMovement()->ForceOverlapUpdate();
    }
    else if (!ShouldSkipUpdateOverlaps())
    {
        bSkipUpdateOverlaps = UpdateOverlapsImpl(PendingOverlaps, bDoNotifies, OverlapsAtEndLocation);
    }
    return bSkipUpdateOverlaps;
}
```

```cpp
virtual bool UpdateOverlapsImpl(const TOverlapArrayView* PendingOverlaps=nullptr, bool bDoNotifies=true, const TOverlapArrayView* OverlapsAtEndLocation=nullptr)
{
    bool bCanSkipUpdateOverlaps = true;


    TInlineComponentArray<USceneComponent*> AttachedChildren;
    AttachedChildren.Append(GetAttachChildren());


    for (USceneComponent* ChildComponent : AttachedChildren)
    {
        if (ChildComponent)
        {
            // Childë¥¼ ìˆœíšŒí•˜ë©° UpdateOverlapsí˜¸ì¶œ
            bCanSkipUpdateOverlaps &= ChildComponent->UpdateOverlaps(nullptr, bDoNotifies);
        }
    }

    if (bShouldUpdatePhysicsVolume)
    {
        // (Tips) ê²Œì„ í™˜ê²½ ë‚´ì—ì„œ íŠ¹ì • ë¬¼ë¦¬ì  ì†ì„±ì´ë‚˜ ê·œì¹™ì„ ì ìš©í•  ìˆ˜ ìˆëŠ” ì˜ì—­ì„ ì •ì˜í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. 
        // ì´ ë³¼ë¥¨ì€ ê²Œì„ ë‚´ì—ì„œ ë¬¼ë¦¬ì ì¸ ìƒí˜¸ì‘ìš©ì„ ê´€ë¦¬í•˜ëŠ” ë° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. 
        // ì˜ˆë¥¼ ë“¤ì–´, ë¬¼ ì†ì—ì„œì˜ ì›€ì§ì„, ë‹¤ë¥¸ ì¤‘ë ¥ ì„¤ì •, ë˜ëŠ” íŠ¹ì • ì˜ì—­ì—ì„œì˜ ê³µê¸° ì €í•­ê³¼ ê°™ì€ íŠ¹ë³„í•œ ë¬¼ë¦¬ì  ì¡°ê±´ì„ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        UpdatePhysicsVolume(bDoNotifies);

        bCanSkipUpdateOverlaps = false;
    }

    return bCanSkipUpdateOverlaps;
}
```