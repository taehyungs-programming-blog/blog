---
layout: default
title: "09-04. ReceivedAck"
parent: "([Network] 09. ServerChallengeControlMessage)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** packet was acknowledged as delivered */
// íŒ¨í‚·ì´ ì „ë‹¬ë˜ì—ˆìŒì„ í™•ì¸í–ˆì„ ë•Œ í˜¸ì¶œë¨
void ReceivedAck(int32 AckPacketId, FChannelsToClose& OutChannelsToClose)
{
    // advance OutAckPacketId
    // OutAckPacketIdë¥¼ ì—…ë°ì´íŠ¸
    OutAckPacketId = AckPacketId;

    // when we are going to deal with ActorChannel, we'll cover it~
    // ActorChannelì„ ë‹¤ë£° ë•Œ ì´ ë¶€ë¶„ì„ ë‹¤ë£° ì˜ˆì •
    if (PackageMap != NULL)
    {
        //@todo
    }

    // this lambda is called by FChannelRecordImpl::ConsumeChannelRecordsForPacket
    // ì´ ëŒë‹¤ëŠ” FChannelRecordImpl::ConsumeChannelRecordsForPacketì— ì˜í•´ í˜¸ì¶œë¨
    auto AckChannelFunc = [this, &OutChannelsToClose](int32 AckedPacketId, uint32 ChannelIndex)
    {
        // per-channel, process all bunches which has same AckedPacketId
        // ì±„ë„ë³„ë¡œ ë™ì¼í•œ AckedPacketIdë¥¼ ê°€ì§„ ëª¨ë“  ë²ˆì¹˜ë“¤ì„ ì²˜ë¦¬
        UChannel* const Channel = Channels[ChannelIndex];
        if (Channel)
        {
            // we can easily understand what this logic is for:
            // ì´ ë¡œì§ì´ ë¬´ì—‡ì„ ìœ„í•œ ê²ƒì¸ì§€ ì‰½ê²Œ ì´í•´í•  ìˆ˜ ìˆìŒ:
            //                                                                                                                        
            //                 AckedPacketId==246                           1.when(OpenPacketId.Last==AckedPacketId), bOpenAcked=TRUE 
            //                 OpenPacketId.Last==246                            â”‚                                                    
            //                                                                   â”‚                                                    
            //                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”                                           
            // Channel->OutRec:â”‚   PacketId:244 â”œâ”€â”€â”€â”¼   PacketId:245 â”œâ”€â”€â”€â”¼   PacketId:246 â”‚                                           
            //                 â”‚ ReceiveAck:1   â”‚   â”‚ ReceiveAck:0   â”‚   â”‚ ReceiveAck:1   â”‚                                           
            //                 â”‚      bOpen:0   â”‚   â”‚      bOpen:1   â”‚   â”‚      bOpen:0   â”‚                                           
            //                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                           
            //                                                   â”‚                                                                    
            //                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º                                           
            //                   iterating 'OutRec' and FOutBunchâ”‚:bOpen is true, marking bOpenAcked=FALSE                            
            //                                         â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                     
            //                                              â”‚    â”‚                                                                    
            //                                              â”‚    â”‚                                                                    
            //                                              â””â”€â”€â”€â”€â”˜                                                                    
            //                                                                                                                        
            if (Channel->OpenPacketId.Last == AckedPacketId) // necessary for unreliable "bNetTemporary" channels
                                                            // ì‹ ë¢°í•  ìˆ˜ ì—†ëŠ” "bNetTemporary" ì±„ë„ì— í•„ìš”í•¨
            {
                Channel->OpenAcked = 1;
            }

            for (FOutBunch* OutBunch = Channel->OutRec; OutBunch; OutBunch = OutBunch->Next)
            {
                if (OutBunch->bOpen)
                {
                    // we have a reliable open bunch, don't let the above code set the OpenAcked state,
                    // it must be set in UChannel::ReceivedAcks to verify all open bunches were received
                    // ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” open ë²ˆì¹˜ê°€ ìˆìœ¼ë¯€ë¡œ, ìœ„ì˜ ì½”ë“œê°€ OpenAcked ìƒíƒœë¥¼ ì„¤ì •í•˜ì§€ ëª»í•˜ê²Œ í•¨
                    // ëª¨ë“  open ë²ˆì¹˜ë“¤ì´ ìˆ˜ì‹ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´ UChannel::ReceivedAcksì—ì„œ ì„¤ì •ë˜ì–´ì•¼ í•¨
                    Channel->OpenAcked = 0;
                }

                // ReceiveAck()'s main job is marking ReceiveAck as TRUE for the bunch matching PacketId
                // ReceiveAck()ì˜ ì£¼ìš” ì‘ì—…ì€ PacketIdì™€ ì¼ì¹˜í•˜ëŠ” ë²ˆì¹˜ì— ëŒ€í•´ ReceiveAckë¥¼ TRUEë¡œ í‘œì‹œí•˜ëŠ” ê²ƒ
                if (OutBunch->PacketId == AckedPacketId)
                {
                    OutBunch->ReceiveAck = 1;
                }
            }

            // based on newly-acked-bunches, process acks:
            // ìƒˆë¡œ í™•ì¸ëœ ë²ˆì¹˜ë“¤ì„ ê¸°ë°˜ìœ¼ë¡œ ackë“¤ì„ ì²˜ë¦¬:
            EChannelCloseReason CloseReason;
            if (Channel->ReceivedAcks(CloseReason))
            {
                const FChannelCloseInfo Info = {ChannelIndex, CloseReason};
                OutChannelsToClose.Emplace(Info);
            }
        }
    };

    // invoke AckChannelFunc on all channels written for this PacketId
    // ì´ PacketIdì— ëŒ€í•´ ì‘ì„±ëœ ëª¨ë“  ì±„ë„ì—ì„œ AckChannelFunc í˜¸ì¶œ
    FChannelRecordImpl::ConsumeChannelRecordsForPacket(ChannelRecord, AckPacketId, AckChannelFunc);
}
```