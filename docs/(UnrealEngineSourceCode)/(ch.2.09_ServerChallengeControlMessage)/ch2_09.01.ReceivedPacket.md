---
layout: default
title: "09-01. ReceivedPacket"
parent: "([Network] 09. ServerChallengeControlMessage)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** handle a packet we just received */
/** ë°©ê¸ˆ ë°›ì€ íŒ¨í‚·ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤ */

// it is the first time to see the real-logic
// UNetConnection::ReceivedPacket() process Packet's header(sequence-history) and disassemble and pass transformed data to channels are dealt by DispatchPacket()

// ì‹¤ì œ ë¡œì§ì„ ì²˜ìŒìœ¼ë¡œ ë³´ê²Œ ë©ë‹ˆë‹¤
// UNetConnection::ReceivedPacket()ì€ íŒ¨í‚·ì˜ í—¤ë”(ì‹œí€€ìŠ¤-íˆìŠ¤í† ë¦¬)ë¥¼ ì²˜ë¦¬í•˜ê³ , ë³€í™˜ëœ ë°ì´í„°ë¥¼ ì±„ë„ë¡œ ì „ë‹¬í•˜ëŠ” DispatchPacket()ì— ì˜í•´ ì²˜ë¦¬ë©ë‹ˆë‹¤

virtual void ReceivedPacket(FBitReader& Reader, bool bIsReinjectedPacket=false, bool bDispatchPacket=true)
{
// explain how to disable this routine for losing and delaying packets:
// demonstrate how to diable this in editor settings

// íŒ¨í‚· ì†ì‹¤ê³¼ ì§€ì—°ì„ ìœ„í•´ ì´ ë£¨í‹´ì„ ë¹„í™œì„±í™”í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤:
// ì—ë””í„° ì„¤ì •ì—ì„œ ì´ê²ƒì„ ë¹„í™œì„±í™”í•˜ëŠ” ë°©ë²•ì„ ë³´ì—¬ì¤ë‹ˆë‹¤

if (!IsInternalAck() && !bIsReinjectingDelayedPackets)
{
    if (PacketSimulationSettings.PktIncomingLoss)
    {
        if (FMath::FRand() * 100.f < PacketSimulationSettings.PktIncomingLoss)
        {
            return;
        }
    }
    if (PacketSimulationSettings.PktIncomingLagMin > 0 || PacketSimulationSettings.PktIncomingLagMax > 0)
    {
        const double LagVarianceInMS = FMath::FRand() * double(PacketSimulationSettings.PktIncomingLagMax - PacketSimulationSettings.PktIncomingLagMin);
        const double ExtraLagInSec = (double(PacketSimulationSettings.PktIncomingLagMin) + LagVarianceInMS) / 1000.f;

        FDelayedIncomingPacket DelayedPacket;
        DelayedPacket.PacketData = MakeUnique<FBitReader>(Reader);
        DelayedPacket.ReinjectionTime = FPlatformTime::Seconds() + ExtraLagInSec;

        DelayedIncomingPackets.Emplace(MoveTemp(DelayedPacket));

        return;
    }
}  

// [ServerChallengeControlMessage]
// see FChannelsToClose breifly

// FChannelsToCloseë¥¼ ê°„ë‹¨íˆ ì‚´í´ë´…ë‹ˆë‹¤

FChannelsToClose ChannelsToClose;

if (IsInternalAck())
{
    //...
}
else
{
    // read packet header
    // [ServerChallengeControlMessage]
    // do you remember that we write NotificationHeader when sending NMT_Hello control-channel-message?
    // see FNetPacketNotify::FNotificationHeader breifly
    // see FNetPacketNotify::ReadHeader

    // NMT_Hello ì»¨íŠ¸ë¡¤ ì±„ë„ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ë•Œ NotificationHeaderë¥¼ ì‘ì„±í–ˆë˜ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    // FNetPacketNotify::FNotificationHeaderë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
    // FNetPacketNotify::ReadHeaderë¥¼ ì‚´í´ë³´ì„¸ìš”

    FNetPacketNotify::FNotificationHeader Header;
    if (!PacketNotify.ReadHeader(Header, Reader))
    {
        return;
    }

    // [ServerChallengeControlMessage]
    // do you remember that we write packet-info for initialization of send-buffer for each frame?
    // one-frame, only one-send-buffer has PacketInfoPayload
    // e.g. within the one-frame, two send-buffers are constructed, only first send-buffer has packet-info
    // we are NOT going to cover the detail of ProcessJitter()
    // only focusing on serializing(write/read) bit-data which the client sent

    // ê° í”„ë ˆì„ë§ˆë‹¤ send-buffer ì´ˆê¸°í™”ë¥¼ ìœ„í•´ packet-infoë¥¼ ì‘ì„±í–ˆë˜ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    // í•œ í”„ë ˆì„ì—ì„œëŠ” ì˜¤ì§ í•˜ë‚˜ì˜ send-bufferë§Œ PacketInfoPayloadë¥¼ ê°€ì§‘ë‹ˆë‹¤
    // ì˜ˆë¥¼ ë“¤ì–´ í•œ í”„ë ˆì„ ë‚´ì—ì„œ ë‘ ê°œì˜ send-bufferê°€ ìƒì„±ë˜ë©´, ì²« ë²ˆì§¸ send-bufferë§Œ packet-infoë¥¼ ê°€ì§‘ë‹ˆë‹¤
    // ProcessJitter()ì˜ ì„¸ë¶€ì‚¬í•­ì€ ë‹¤ë£¨ì§€ ì•Šì„ ê²ƒì…ë‹ˆë‹¤
    // í´ë¼ì´ì–¸íŠ¸ê°€ ë³´ë‚¸ ë¹„íŠ¸ ë°ì´í„°ì˜ ì§ë ¬í™”(ì“°ê¸°/ì½ê¸°)ì—ë§Œ ì§‘ì¤‘í•˜ê² ìŠµë‹ˆë‹¤

    bool bHasPacketInfoPayload = true;
    if (PacketEngineNetVer >= FEngineNetworkCustomVersion::JitterInHeader)
    {
        bHasPacketInfoPayload = Reader.ReadBit() == 1u;
        if (bHasPacketInfoPayload)
        {
            // read jitter clock time from the packet header
            uint32 PacketJitterClockTimeMS = 0;
            Reader.SerializeInt(PacketJitterClockTimeMS, UE::Net::Connection::Private::MaxJitterClockTimeValue + 1);       
        
            ProcessJitter();
        }
    }

    // [ServerChallengeControlMessage]
    // what is 'PackedSequenceDelta'?
    // 'NetPacketNotify' has important role of dealing reliability for the UDP!
    // when dealing with any property in NetPacketNotify, plz care about its meaning!
    // see FNetPacketNotify::GetSequenceDelta

    // 'PackedSequenceDelta'ê°€ ë¬´ì—‡ì¼ê¹Œìš”?
    // 'NetPacketNotify'ëŠ” UDPì˜ ì‹ ë¢°ì„±ì„ ë‹¤ë£¨ëŠ”ë° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤!
    // NetPacketNotifyì˜ ì–´ë–¤ ì†ì„±ì„ ë‹¤ë£° ë•Œë„, ê·¸ ì˜ë¯¸ì— ì£¼ì˜ë¥¼ ê¸°ìš¸ì—¬ì£¼ì„¸ìš”!
    // FNetPacketNotify::GetSequenceDeltaë¥¼ ì‚´í´ë³´ì„¸ìš”

    const int32 PackedSequenceDelta = PacketNotify.GetSequenceDelta(Header);
    if (PackedSequenceDelta > 0)
    {
        // process acks
        // - lambda to dispatch delivery notification
        // [ServerChallengeControlMessage]
        // we'll cover this lambda in detail after FNetPacketNotify::Update
        // FNetPacketNotify::Update calls this lambda~

        // FNetPacketNotify::Update ì´í›„ì— ì´ ëŒë‹¤ë¥¼ ìì„¸íˆ ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤
        // FNetPacketNotify::Updateê°€ ì´ ëŒë‹¤ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤~

        auto HandlePacketNotification = [&Header, &ChannelsToClose, this](FNetPacketNotify::SequenceNumberT AckedSequence, bool bDelivered)
        {
            // 015 - Networking - ServerChallengeControlMessage - UNetConnection::HandlePacketNotification
            // AckedSequence is 'OutAckSeq' + N(<AckCount)
            // currently bDelivery is 'false' because we are handling outside of sequence-history range

            // AckedSequenceëŠ” 'OutAckSeq' + N(<AckCount)ì…ë‹ˆë‹¤
            // í˜„ì¬ bDeliveryëŠ” 'false'ì…ë‹ˆë‹¤. ì‹œí€€ìŠ¤-íˆìŠ¤í† ë¦¬ ë²”ìœ„ ë°–ì„ ì²˜ë¦¬í•˜ê³  ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤

            // increase LastNotifiedPacketId, this is a full packet-id
            // LastNotifiedPacketId is the tracking variable regardless of ACK and NAK
            // LastNotifiedPacketId == AckedSequence

            // LastNotifiedPacketIdëŠ” ACKì™€ NAKì— ê´€ê³„ì—†ì´ ì¶”ì í•˜ëŠ” ë³€ìˆ˜ì…ë‹ˆë‹¤
            // LastNotifiedPacketId == AckedSequence

            ++LastNotifiedPacketId;

            // sanity check
            if (FNetPacketNotify::SequenceNumberT(LastNotifiedPacketId) != AckedSequence)
            {
                // ERROR!
            }

            if (bDelivered)
            {
                ReceivedAck(LastNotifiedPacketId, ChannelsToClose);
                // go back to FNetPacketNotify::Update
            }
            else
            {
                // we are pending this function later
                // ì´ í•¨ìˆ˜ëŠ” ë‚˜ì¤‘ì— ë‹¤ë£° ì˜ˆì •ì…ë‹ˆë‹¤
                ReceivedNak(LastNotifiedPacketId);
            }
        };

        // update incoming sequence data and deliver packet notifications
        // packet is only accepted if both the incoming sequence number and incoming ack data are valid
        // [ServerChallengeControlMessage]
        // with NotificationHeader's History(bit-deliverity), we process Ack events
        // see FNetPacketNotify::Update

        // NotificationHeaderì˜ History(ë¹„íŠ¸ ì „ë‹¬)ë¡œ, Ack ì´ë²¤íŠ¸ë“¤ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤
        // FNetPacketNotify::Updateë¥¼ ì‚´í´ë³´ì„¸ìš”

        const int32 UpdatedPacketSequenceDelta = PacketNotify.Update(Header, HandlePacketNotification);

        InPacketId += PackedSequenceDelta;
        check(FNetPacketNotify::SequenceNumberT(InPacketId).Get() == Header.Seq.Get());
    }

    // extra information associated with the header (read only after acks have been processed)
    // see UNetConnection::ReadPacketInfo

    // UNetConnection::ReadPacketInfoë¥¼ ì‚´í´ë³´ì„¸ìš”

    if (PackedSequenceDelta > 0 && !ReadPacketInfo(Reader, bHasPacketInfoPayload, PacketEngineNetVer))
    {
        // ERROR!
        return;
    }
}
```

```cpp
// let's disassemble its properties one-by-one (from server-side view)
// - Seq: OutSeq from client-side
// - AckedSeq: InAckSeq from client-side(meaning 'In': server -> client)
// - History: bit-delivery history after InAckSeq
//   - History is used for calculating InAckSeqAck!

// ì„œë²„ ì¸¡ë©´ì—ì„œ ê° ì†ì„±ë“¤ì„ í•˜ë‚˜ì”© ë¶„ì„í•´ë³´ê² ìŠµë‹ˆë‹¤
// - Seq: í´ë¼ì´ì–¸íŠ¸ ì¸¡ì˜ OutSeq ê°’
// - AckedSeq: í´ë¼ì´ì–¸íŠ¸ ì¸¡ì˜ InAckSeq ê°’('In'ì€ ì„œë²„->í´ë¼ì´ì–¸íŠ¸ ë°©í–¥ì„ ì˜ë¯¸)
// - History: InAckSeq ì´í›„ì˜ íŒ¨í‚· ì „ë‹¬ ì´ë ¥
//   - HistoryëŠ” InAckSeqAck ê³„ì‚°ì— ì‚¬ìš©ë©ë‹ˆë‹¤!
//
//     ***FNetPacketNotify::FNotificationHeader                                       
//        â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       
//            â”‚                                                                       
//            â”œâ”€â”€AckedSeq: InAckSeq(client): 1024                                     
//            â”‚                                                                       
//            â””â”€â”€History:      â”Œâ”€â”€â”€bit-0 means latest bit-delivery(up-to-date)!       
//               â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â–¼â”€â”                                                    
//               â”‚ 1 â”‚ 1 â”‚ 0 â”‚ 0 â”‚                                                    
//               â””â”€â–²â”€â”´â”€â–²â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                                    
//                 â”‚   â”‚                                                              
//                 â”‚  ***1024 is acked successfully in client-side                    
//                 â”‚                                                                  
//                 â”‚                                                                  
//           ***1023 is acked successfully in client-side                             
//               â”‚                                                                    
//               â””â”€InAckSeq(client) == OutSeq(server)                                 
//                 : packet-id(1023) is sent by server and received by client         
//                                                                                    
struct FNotificationHeader
{
    SequenceHistoryT History;
    SIZE_T HisotryWordCount;
    SequenceNumberT Seq;
    SequenceNumberT AckedSeq;
}
```