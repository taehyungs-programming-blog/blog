---
layout: default
title: "06-01. ReceivedRawPacket"
parent: "([Network] 06. ClientChallengeResponse)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## FNetConnectionAddressResolution ê°œìš”

FNetConnectionAddressResolutionì€ ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì£¼ì†Œ í•´ì„ì„ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

### ì£¼ì†Œ í•´ì„ ìƒíƒœ ê´€ë¦¬

```cpp
enum class EAddressResolutionState
{
    TryNextAddress,  // ë‹¤ìŒ ì£¼ì†Œ ì‹œë„
    Connecting,      // ì—°ê²° ì¤‘
    Connected,       // ì—°ê²°ë¨ 
    Done            // ì™„ë£Œ
}
```

* ì£¼ìš” ì²˜ë¦¬ ê³¼ì •:
  * ì´ˆê¸°ì—ëŠ” TryNextAddress ìƒíƒœë¡œ ì‹œì‘
  * ì†Œì¼“ ì—°ê²° ì‹œë„ ì‹œ Connecting ìƒíƒœë¡œ ì „í™˜
  * ì„œë²„ë¡œë¶€í„° ì²« íŒ¨í‚· ìˆ˜ì‹  ì‹œ Connected ìƒíƒœë¡œ ë³€ê²½
  * ìµœì¢…ì ìœ¼ë¡œ Done ìƒíƒœê°€ ë˜ë©° ë¦¬ì†ŒìŠ¤ ì •ë¦¬

### ì¤‘ìš” ë©”ì„œë“œë“¤

* IsAddressResolutionEnabled()
  * ì£¼ì†Œ í•´ì„ ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì—ˆëŠ”ì§€ í™•ì¸
* IsAddressResolutionComplete()
  * ì£¼ì†Œ í•´ì„ ê³¼ì •ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
* NotifyAddressResolutionConnected()
  * ì„œë²„ì™€ì˜ ì—°ê²°ì´ ì„±ê³µí–ˆìŒì„ ì•Œë¦¬ê³  ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
* CheckAddressResolution()
  * í˜„ì¬ ì£¼ì†Œ í•´ì„ ìƒíƒœë¥¼ í™•ì¸í•˜ê³  í•„ìš”í•œ ì²˜ë¦¬ ìˆ˜í–‰

```cpp
class UIpConnection : public UNetConnection
{
    // ...
    TPimplPtr<FNetConnectionAddressResolution> Resolver;

virtual void ReceivedRawPacket(void* Data, int32 Count) override
{
    // set that we've gotten packet from the server, this begins destruction of the other elements
    //  from what we covered, FNetConnectionAddressResolution is enabled and not completed yet
    // - we update from EAddressResolutionState::Connecting to EAddressResolutionState::Connected
    // - do you remember when the state was updated as EAddressResolutionState::Connecting?
    //   - after socket/address is resolved, CheckAddressResolution() updates the state

    // ì„œë²„ë¡œë¶€í„° íŒ¨í‚·ì„ ë°›ì•˜ìŒì„ ì„¤ì •í•©ë‹ˆë‹¤. ì´ëŠ” ë‹¤ë¥¸ ìš”ì†Œë“¤ì˜ íŒŒê´´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
    //  ìš°ë¦¬ê°€ ë‹¤ë£¬ ë‚´ìš©ì— ë”°ë¥´ë©´, FNetConnectionAddressResolutionì´ í™œì„±í™”ë˜ì—ˆì§€ë§Œ ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
    // - EAddressResolutionState::Connectingì—ì„œ EAddressResolutionState::Connectedë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    // - EAddressResolutionState::Connectingìœ¼ë¡œ ìƒíƒœê°€ ì—…ë°ì´íŠ¸ëœ ì‹œì ì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    //   - ì†Œì¼“/ì£¼ì†Œê°€ í•´ê²°ëœ í›„, CheckAddressResolution()ì´ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    if (Resolver->IsAddressResolutionEnabled() && !Resolver->IsAddressResolutionComplete())
    {
        // we only want to write this once, because we don't want to waste cycles trying to clean up nothing
        // ì•„ë¬´ê²ƒë„ ì •ë¦¬í•˜ì§€ ì•Šìœ¼ë ¤ê³  ì‚¬ì´í´ì„ ë‚­ë¹„í•˜ì§€ ì•Šê¸° ìœ„í•´ ì´ê²ƒì„ í•œ ë²ˆë§Œ ì‘ì„±í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤.
        Resolver->NotifyAddressResolutionConnected();
    }

    UNetConnection::ReceivedRawPacket(Data, Count);
}
```

* ì‹¤ì œ ë™ì‘ ì‹œë‚˜ë¦¬ì˜¤
  * ì²« íŒ¨í‚· ìˆ˜ì‹  ì‹œ:
    * ì¡°ê±´ì´ ì°¸ì´ë©´ â†’ NotifyAddressResolutionConnected() í˜¸ì¶œ
    * ìƒíƒœê°€ Connectedë¡œ ë³€ê²½ë˜ê³  ë¶ˆí•„ìš”í•œ ì†Œì¼“ë“¤ì´ ì •ë¦¬ë¨
  * ì´í›„ íŒ¨í‚·ë“¤:
    * ì¡°ê±´ì´ ê±°ì§“ì´ë¯€ë¡œ â†’ ì¶”ê°€ì ì¸ ìƒíƒœ ë³€ê²½ì´ë‚˜ ì •ë¦¬ ì‘ì—…ì´ ë°œìƒí•˜ì§€ ì•ŠìŒ
  * ì´ëŸ¬í•œ ì²´í¬ëŠ” ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì„¤ì •ì˜ ì•ˆì •ì„±ê³¼ íš¨ìœ¨ì„±ì„ ë³´ì¥í•˜ëŠ” ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.

```cpp
// see when we are in 'Connected' state, what does it happen?
// 'Connected' ìƒíƒœì¼ ë•Œ ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ë´…ì‹œë‹¤.

// - we are into final state, 'Done'! and then clear up sockets cached in NetConnectionAddressResolution
// - ìš°ë¦¬ëŠ” ìµœì¢… ìƒíƒœì¸ 'Done'ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤! ê·¸ë¦¬ê³  NetConnectionAddressResolutionì— ìºì‹œëœ ì†Œì¼“ë“¤ì„ ì •ë¦¬í•©ë‹ˆë‹¤.

ECheckAddressResolutionResult CheckAddressResolution()
{
    ECheckAddressResolutionResult Result = ECheckAddressResolutionResult::None;

    // ResolutionState is lastly updated as 'TryNextAddress' by calling GetAddressInfoAsync() in NetDriverAddressResolution::InitConnect()
    // - we also updated "ResolverResults" from NetDriverAddressResolution
    // - "CurrentAddressIndex" starts from '0'

    // ResolutionStateëŠ” NetDriverAddressResolution::InitConnect()ì—ì„œ GetAddressInfoAsync()ë¥¼ í˜¸ì¶œí•˜ì—¬ ë§ˆì§€ë§‰ìœ¼ë¡œ 'TryNextAddress'ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤
    // - ìš°ë¦¬ëŠ” ë˜í•œ NetDriverAddressResolutionì—ì„œ "ResolverResults"ë¥¼ ì—…ë°ì´íŠ¸í–ˆìŠµë‹ˆë‹¤
    // - "CurrentAddressIndex"ëŠ” '0'ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤
    if (ResolutionState == EAddressResolutionState::TryNextAddress)
    {
        RemoteAddr = ResolverResults[CurrentAddressIndex];

        // BindSockets are passed through NetDriverAddressResolution by calling GetAddressInfoAsync() in NetDriverAddressResolution::InitConnect()
        // - as we covered, BindSockets usually has only one socket
        // - Protocol is whether IPv4 or IPv6, in usual case, they are always same:
        //   - RemoteAddr is server's address!

        // BindSocketsëŠ” NetDriverAddressResolution::InitConnect()ì—ì„œ GetAddressInfoAsync()ë¥¼ í˜¸ì¶œí•˜ì—¬ NetDriverAddressResolutionì„ í†µí•´ ì „ë‹¬ë©ë‹ˆë‹¤
        // - ìš°ë¦¬ê°€ ë‹¤ë¤˜ë“¯ì´, BindSocketsëŠ” ë³´í†µ í•˜ë‚˜ì˜ ì†Œì¼“ë§Œ ê°€ì§‘ë‹ˆë‹¤
        // - í”„ë¡œí† ì½œì€ IPv4 ë˜ëŠ” IPv6ì¸ë°, ì¼ë°˜ì ì¸ ê²½ìš° í•­ìƒ ê°™ìŠµë‹ˆë‹¤:
        //   - RemoteAddrì€ ì„œë²„ì˜ ì£¼ì†Œì…ë‹ˆë‹¤!
        ResolutionSocket.Reset();
        for (const TSharedPtr<FSocket>& BindSocket : BindSockets)
        {
            if (BindSocket->GetProtocol() == RemoteAddr->GetProtocolType())
            {
                ResolutionSocket = BindSocket;
                break;
            }
        }

        // now finally we update NetConnectionAddressResolution's ResolutionSocket
        // - we need to pass it through to IpConnection's SocketPrivate
        // - first, we update ResolutionState as 'Connecting' and return 'ECheckAddressResolutionResult::TryFirstAddress'

        // ì´ì œ ë§ˆì¹¨ë‚´ NetConnectionAddressResolutionì˜ ResolutionSocketì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        // - ì´ê²ƒì„ IpConnectionì˜ SocketPrivateë¡œ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤
        // - ë¨¼ì €, ResolutionStateë¥¼ 'Connecting'ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ê³  'ECheckAddressResolutionResult::TryFirstAddress'ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤
        if (ResolutionSocket.IsValid())
        {
            ResolutionState = EAddressResolutionState::Connecting;
            if (CurrentAddressIndex == 0)
            {
                Result = ECheckAddressResolutionResult::TryFirstAddress;
            }
            else
            {
                Result = ECheckAddressResolutionResult::TryNextAddress;
            }
            ++CurrentAddressIndex;
        }
    }
    else if (ResolutionState == EAddressResolutionState::Connected)
    {
        // finally, 'ResolutionState' is "::Done"
        // ë§ˆì¹¨ë‚´, 'ResolutionState'ëŠ” "::Done"ì…ë‹ˆë‹¤
        ResolutionState = EAddressResolutionState::Done;
        Result = ECheckAddressResolutionResult::Connected;
        CleanupResolutionSockets(ECleanupResolutionSocketsFlags::CleanInactive);
    }

    return Result;
}
```

```cpp
/** allows the connection to process the raw data that was received */
// ì—°ê²°ì´ ìˆ˜ì‹ í•œ ì›ì‹œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤

// the client receive any packet from the server by UNetConnection(ServerConnection)'s ReceivedRawPacket about handshake
// í´ë¼ì´ì–¸íŠ¸ëŠ” UNetConnection(ServerConnection)ì˜ ReceivedRawPacketì„ í†µí•´ ì„œë²„ë¡œë¶€í„° í•¸ë“œì…°ì´í¬ì— ê´€í•œ ëª¨ë“  íŒ¨í‚·ì„ ë°›ìŠµë‹ˆë‹¤
virtual void ReceivedRawPacket(void* Data, int32 Count)
{
    uint8* Data = (uint8*)InData;

    if (Handler.IsValid())
    {
        FReceivedPacketView PacketView;
        PacketView.DataView = {Data, Count, ECountUnits::Bytes};

        // we are in handshake process, PacketHandler(Handler) may catch the handshake packet from the server here!
        // ìš°ë¦¬ëŠ” í•¸ë“œì…°ì´í¬ ê³¼ì • ì¤‘ì— ìˆìœ¼ë©°, PacketHandler(Handler)ê°€ ì—¬ê¸°ì„œ ì„œë²„ë¡œë¶€í„°ì˜ í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì„ ì¡ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!
        EIncomingResult IncomingResult = Handler->Incoming(PacketView);

        if (IncomingResult == EIncomingResult::Success)
        {
            Count = PacketView.DataView.NumBytes();
            if (Count > 0)
            {
                Data = PacketView.DataView.GetMutableData();
            }
            else
            {
                // this packet has been consumed
                // ì´ íŒ¨í‚·ì€ ì†Œë¹„ë˜ì—ˆìŠµë‹ˆë‹¤
                
                // we are into here Count == 0
                // ìš°ë¦¬ëŠ” ì—¬ê¸°ì„œ Countê°€ 0ì¸ ê²½ìš°ì…ë‹ˆë‹¤
                return;
            }
        }

        //...
    }
}
```