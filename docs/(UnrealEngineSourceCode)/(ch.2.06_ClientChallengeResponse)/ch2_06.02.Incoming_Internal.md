---
layout: default
title: "06-02. Incoming_Internal"
parent: "([Network] 06. ClientChallengeResponse)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** internal handling for incoming/incomingconnectionless */
/* ë“¤ì–´ì˜¤ëŠ”/ë“¤ì–´ì˜¤ëŠ” ë¬´ì—°ê²° íŒ¨í‚·ì— ëŒ€í•œ ë‚´ë¶€ ì²˜ë¦¬ */

// to distinguish ServerInitialSendPacket and ClientChallengeResponse, add subscription like "[ClientChallengeResponse]""
// ServerInitialSendPacketê³¼ ClientChallengeResponseë¥¼ êµ¬ë¶„í•˜ê¸° ìœ„í•´, "[ClientChallengeResponse]"ì™€ ê°™ì€ êµ¬ë…ì„ ì¶”ê°€í•©ë‹ˆë‹¤

EIncomingResult Incoming_Internal(FReceivedPacketView& PacketView)
{
    EIncomingResult ReturnVal = EIncomingResult::Success;
    FPacketDataView& DataView = PacketView.DataView;
    int32 CountBits = DataView.NumBits();

    if (HandlerComponents.Num() > 0)
    {
        const uint8* DataPtr = DataView.GetData();
        uint8 LastByte = (UNLIKELY(DataPtr == nullptr)) ? 0 : DataPtr[DataView.NumBytes()-1];
        if (LastByte != 0)
        {
            CountBits--;
            while (!(LastByte & 0x80))
            {
                LastByte *= 2;
                CountBits--;
            }
        }
        else
        {
            PacketView.DataView = {nullptr, 0, ECountUnits::Bits};
            ReturnVal = EIncomingResult::Error;
        }
    }

    if (ReturnVal == EIncomingResult::Success)
    {
        // now we face 'FBitReader' 
        // ì´ì œ ìš°ë¦¬ëŠ” 'FBitReader'ë¥¼ ë§ˆì£¼í•©ë‹ˆë‹¤
        FBitReader ProcessedPacketReader(DataView.GetMutableData(), CountBits);
        FIncomingPacketRef PacketRef = {ProcessedPacketReader, PacketView.Address, PacketView.Traits};

        for (int32 i = HandlerComponents.Num() - 1; i >= 0; --i)
        {
            HandlerComponent& CurComponent = *HandlerComponents[i];
            if (CurComponent.IsActive() && !ProcessedPacketReader.IsError() && ProcessedPacketReader.GetBitsLeft() > 0)
            {
                // we are **NOT** mark 'bConnectionlessPacket' as true like 'IncomingConnectionless'
                // - we are getting here from 'Incoming'
                // - so we call 'CurComponent.Incoming(PacketRef)'

                // ìš°ë¦¬ëŠ” 'IncomingConnectionless'ì²˜ëŸ¼ 'bConnectionlessPacket'ì„ trueë¡œ í‘œì‹œí•˜ì§€ **ì•ŠìŠµë‹ˆë‹¤**
                // - ìš°ë¦¬ëŠ” 'Incoming'ì—ì„œ ì—¬ê¸°ë¡œ ì˜¤ê³  ìˆìŠµë‹ˆë‹¤
                // - ê·¸ë˜ì„œ ìš°ë¦¬ëŠ” 'CurComponent.Incoming(PacketRef)'ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤
                
                if (PacketView.Traits.bConnectionlessPacket)
                {
                    CurComponent.IncomingConnectionless(PacketRef);
                }
                else
                {
                    CurComponent.Incoming(PacketRef);
                }
            }
        }

        if (!ProcessedPacketReader.IsError())
        {
            ReplaceIncomingPacket(ProcessedPacketReader);
            PacketView.DataView = {IncomingPacket.GetData(), (int32)IncomingPacket.GetBitsLeft(), ECountBits::Bits};
        }
    }

    return ReturnVal;
}
```

```cpp
void SendChallengeResponse(EHandshakeVersion HandshakeVersion, uint8 InSecretId, double InTimestamp, uint8 InCookie[COOKIE_BYTE_SIZE])
{
    // it requires 'ServerConnection', so we can oversee that this function is only called by client-side
    // 'ServerConnection'ì´ í•„ìš”í•˜ë¯€ë¡œ, ì´ í•¨ìˆ˜ëŠ” í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œë§Œ í˜¸ì¶œëœë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤
    UNetConnection* ServerConn = (Driver != nullptr ? ToRawPtr(Driver->ServerConnection) : nullptr);
    if (ServerConn)
    {
        // note 'RESTART_RESPONSE_SIZE_BITS'
        // - 'RESTART_RESPONSE_SIZE_BITS' is bigger than 'HANDSHAKE_PACKET_SIZE_BITS' because it contains one extra 'old' cookie data
        // - FYI, restart could be initialiated by the server
        //   - in restart-handshake process, old/new cookie transfer is necessary for the server to know whether this connection is 'connected' or not

        // 'RESTART_RESPONSE_SIZE_BITS'ì— ì£¼ëª©í•˜ì„¸ìš”
        // - 'RESTART_RESPONSE_SIZE_BITS'ëŠ” 'HANDSHAKE_PACKET_SIZE_BITS'ë³´ë‹¤ í½ë‹ˆë‹¤. ì™œëƒí•˜ë©´ ì¶”ê°€ì ì¸ 'ì´ì „' ì¿ í‚¤ ë°ì´í„°ë¥¼ í¬í•¨í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤
        // - ì°¸ê³ ë¡œ, ì¬ì‹œì‘ì€ ì„œë²„ì— ì˜í•´ ì‹œì‘ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤
        //   - ì¬ì‹œì‘ í•¸ë“œì…°ì´í¬ ê³¼ì •ì—ì„œ, ì„œë²„ê°€ ì´ ì—°ê²°ì´ 'ì—°ê²°ëœ' ìƒíƒœì¸ì§€ ì•Œê¸° ìœ„í•´ ì´ì „/ìƒˆ ì¿ í‚¤ ì „ì†¡ì´ í•„ìš”í•©ë‹ˆë‹¤
        const int32 AdjustedSize = GetAdjustedSizeBits((bRestartedHandshake ? RESTART_RESPONSE_SIZE_BITS : HANDSHAKE_PACKET_SIZE_BITS), HandshakeVersion);

        // we are interested in EHandshakePacketType::Response
        // ìš°ë¦¬ëŠ” EHandshakePacketType::Responseì— ê´€ì‹¬ì´ ìˆìŠµë‹ˆë‹¤
        FBitWriter ResponsePacket(AdjustedSize + (BaseRandomDataLengthBytes * 8) + 1/*termination bit*/);
        EHandshakePacketType HandshakePacketType = bRestartHandshake ? EHandshakePacketType::RestartResponse : EHandshakePacketType::Response;
        
        // we update HandshakePacketType and repacked the received data including InCookie, send the packet
        // HandshakePacketTypeì„ ì—…ë°ì´íŠ¸í•˜ê³  InCookieë¥¼ í¬í•¨í•œ ë°›ì€ ë°ì´í„°ë¥¼ ë‹¤ì‹œ íŒ¨í‚¹í•˜ì—¬ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤
        BeginHandshakePacket(ResponsePacket, HandshakePacketType, HandshakeVersion, SentHandshakePacketCount, CachedClientID,
                            (bRestartedHandshake ? EHandshakePacketModifier::RestartHandshake : EHandshakePacketModifier::None));
        ResponsePacket.WriteBit(InSecretId);
        ResponsePacket << InTimestamp;
        ResponsePacket.Serialize(InCookie, COOKIE_BYTE_SIZE);
        if (bRestartedHandshake)
        {
            // previously authorized cookie is saved in StatelessConnectHandlerComponent::AuthorizedCookie
            // ì´ì „ì— ì¸ì¦ëœ ì¿ í‚¤ëŠ” StatelessConnectHandlerComponent::AuthorizedCookieì— ì €ì¥ë©ë‹ˆë‹¤
            ResponsePacket.Serialize(AuthorizedCookie, COOKIE_BYTE_SIZE);
        }

        // *** briefly see SendToServer again
        // *** SendToServerë¥¼ ë‹¤ì‹œ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
        SendToServer(HandshakeVersion, HandshakePacketType, ResponsePacket);

        // 'LastServerSequence' and 'LastClientSequence' are derived from 'InCookie'
        // - try to understand what Cookie is: see StatelessConnectHandlerComponent::GenerateCookie briefly
        // - there is no any readable-info in Cookie for SequenceNumber
        // - Cookie size is 20 bytes and encrypted token by SHA1:

        // 'LastServerSequence'ì™€ 'LastClientSequence'ëŠ” 'InCookie'ì—ì„œ íŒŒìƒë©ë‹ˆë‹¤
        // - Cookieê°€ ë¬´ì—‡ì¸ì§€ ì´í•´í•´ ë³´ì„¸ìš”: StatelessConnectHandlerComponent::GenerateCookieë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
        // - Cookieì—ëŠ” SequenceNumberì— ëŒ€í•œ ì½ì„ ìˆ˜ ìˆëŠ” ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤
        // - Cookie í¬ê¸°ëŠ” 20ë°”ì´íŠ¸ì´ë©° SHA1ë¡œ ì•”í˜¸í™”ëœ í† í°ì…ë‹ˆë‹¤:
        //
        //                       Cookie(20 bytes)                              
        //   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ 
        //   â”‚ int16(2bytes)   int16(2bytes)                                 â”‚ 
        //   â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                               â”‚ 
        //   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 
        //   â”‚      â–²        â”‚       â–²       â”‚                               â”‚ 
        //   â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ 
        //   â”‚      â”‚        â”‚       â”‚       â”‚                               â”‚ 
        //   â”‚      â”‚                â”‚                                       â”‚ 
        //          â”‚                â”‚                                         
        //          â”‚                â”‚                                         
        //     CurSequence      CurSequence+1                                  
        //                                                                     
        // *** LastServerSequence and LastClientSequence can be considered as 'random number' generated by Timestamp and AddressString
        //     - note that we 'InTimestamp' is came from the server! we send back what we received
        //     - see MAX_PACKETID briefly
        //       *** understand why (MAX_PACKETID - 1)! not (MAX_PACKETID)
        // *** LastServerSequenceì™€ LastClientSequenceëŠ” Timestampì™€ AddressStringì— ì˜í•´ ìƒì„±ëœ 'ëœë¤ ìˆ«ì'ë¡œ ê°„ì£¼ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤
        //     - 'InTimestamp'ëŠ” ì„œë²„ì—ì„œ ì˜¨ ê²ƒì„ì„ ì£¼ëª©í•˜ì„¸ìš”! ìš°ë¦¬ëŠ” ë°›ì€ ê²ƒì„ ê·¸ëŒ€ë¡œ ë‹¤ì‹œ ë³´ëƒ…ë‹ˆë‹¤
        //     - MAX_PACKETIDë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”
        //       *** (MAX_PACKETID - 1)ì¸ ì´ìœ ë¥¼ ì´í•´í•˜ì„¸ìš”! (MAX_PACKETID)ê°€ ì•„ë‹™ë‹ˆë‹¤
        int16* CurSequence = (int16*)InCookie;
        LastSecretId = InSecretId;
        LastServerSequence = *CurSequence & (MAX_PACKETID - 1);
        LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);

        // cache InCookie to LastCookie
        // InCookieë¥¼ LastCookieì— ìºì‹œí•©ë‹ˆë‹¤
        FMemory::Memcpy(LastCookie, InCookie, UE_ARRAY_COUNT(LastCookie));
    }
}
```