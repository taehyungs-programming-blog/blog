---
layout: default
title: "([Network] 06. ClientChallengeResponse)"
parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
has_children: true
nav_order: 3
---

```cpp
class UPendingNetGame : public UObject, FNetworkNotify
{
    virtual void Tick(float DeltaTime)
    {
        // ...
        // Tickì—ì„œ ì‹œì‘ì´ ëœë‹¤.

        NetDriver->TickDispatch(DeltaTime);
}
```

### FReceivedPacketView ì„¤ëª…

* FReceivedPacketViewëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ì—ì„œ ìˆ˜ì‹ ëœ ë„¤íŠ¸ì›Œí¬ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ êµ¬ì¡°ì²´ì…ë‹ˆë‹¤. 

```cpp
struct FReceivedPacketView
{
    FInPacketTraits Traits;        // íŒ¨í‚·ì˜ íŠ¹ì„± ì •ë³´
    FInternetAddrView Address;     // ë°œì‹ ìì˜ ì£¼ì†Œ ì •ë³´
    FArrayView<uint8> DataView;    // ì‹¤ì œ íŒ¨í‚· ë°ì´í„°
};
```

* ì£¼ìš” ìš©ë„:
  * ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ìˆ˜ì‹ ëœ ì›ì‹œ íŒ¨í‚· ë°ì´í„°ë¥¼ êµ¬ì¡°í™”ëœ í˜•íƒœë¡œ ê´€ë¦¬
  * íŒ¨í‚·ì˜ ë©”íƒ€ë°ì´í„°(ë°œì‹ ì ì£¼ì†Œ, í¬ê¸° ë“±) ì €ì¥
  * TickDispatch í•¨ìˆ˜ì—ì„œ íŒ¨í‚· ì²˜ë¦¬ ì‹œ ì‚¬ìš©

```cpp
// íŒ¨í‚· ë°˜ë³µìë¥¼ í†µí•´ ìˆ˜ì‹ ëœ íŒ¨í‚·ì„ ì²˜ë¦¬
FReceivedPacketView ReceivedPacket;
bool bOk = It.GetCurrentPacket(ReceivedPacket);

// íŒ¨í‚· ë°ì´í„°ëŠ” Connectionì„ í†µí•´ ì²˜ë¦¬ë¨
Connection->ReceivedRawPacket(
    (uint8*)ReceivedPacket.DataView.GetData(), 
    ReceivedPacket.DataView.NumBytes()
);
```

```cpp
/** handle time update; read and process packets */

// [ClientChallengeResponse]
// most of code to process received packets are same, for now what we are interested in is "ChallengeResponse"
//   - first focus on "Connection" variable on client-side

// ìˆ˜ì‹ ëœ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ëŠ” ëŒ€ë¶€ë¶„ì˜ ì½”ë“œëŠ” ë™ì¼í•©ë‹ˆë‹¤. í˜„ì¬ ìš°ë¦¬ê°€ ê´€ì‹¬ ìˆëŠ” ê²ƒì€ "ChallengeResponse"ì…ë‹ˆë‹¤.
//   - ë¨¼ì € í´ë¼ì´ì–¸íŠ¸ ì¸¡ì˜ "Connection" ë³€ìˆ˜ì— ì§‘ì¤‘í•˜ê² ìŠµë‹ˆë‹¤
virtual void TickDispatch(float DeltaTime) override
{
    // ...

    for (FPacketIterator It(this); It; ++It)
    {
        FReceivedPacketView ReceivedPacket;
        FInPacketTraits& ReceivedTraits = ReceivedPacket.Traits;
        bool bOk = It.GetCurrentPacket(ReceivedPacket);

        const TSharedRef<const FInternetAddr> FromAddr = ReceivedPacket.Address.ToSharedRef();

        UNetConnection* Connection = nullptr;
        UIpConnection* const MyServerConnection = GetServerConnection();

    if (MyServerConnection)
    {
        // [ClientChallengeResponse]
        // do we have valid "MyServerConnection"?
        // - YES: for client-side, we already construct IpConnection successfully and we are ready to send/receive packet by ServerConnection
        // - we also meet the condition, 'MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr)'
        // - now we set "Connection" with "MyServerConnection" successfully in **client-side**
        // - we'll go straight to the code line

        // [ClientChallengeResponse]
        // ìœ íš¨í•œ "MyServerConnection"ì´ ìˆë‚˜ìš”?
        // - ë„¤: í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œëŠ” ì´ë¯¸ IpConnectionì„ ì„±ê³µì ìœ¼ë¡œ êµ¬ì„±í–ˆê³  ServerConnectionìœ¼ë¡œ íŒ¨í‚·ì„ ì†¡ìˆ˜ì‹ í•  ì¤€ë¹„ê°€ ë˜ì–´ ìˆìŠµë‹ˆë‹¤
        // - ë˜í•œ 'MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr)' ì¡°ê±´ë„ ì¶©ì¡±í•©ë‹ˆë‹¤
        // - ì´ì œ **í´ë¼ì´ì–¸íŠ¸ ì¸¡**ì—ì„œ "Connection"ì„ "MyServerConnection"ìœ¼ë¡œ ì„±ê³µì ìœ¼ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤
        // - ë°”ë¡œ ì½”ë“œ ë¼ì¸ìœ¼ë¡œ ì´ë™í•˜ê² ìŠµë‹ˆë‹¤
        if (MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr))
        {
            Connection = MyServerConnection;
        }
    }

    // send the packet to the connection for processing
    // íŒ¨í‚·ì„ ì—°ê²°ë¡œ ë³´ë‚´ ì²˜ë¦¬í•©ë‹ˆë‹¤

    //  it is the first time for client to be handled by FPacketIterator
    //  í´ë¼ì´ì–¸íŠ¸ê°€ FPacketIteratorì— ì˜í•´ ì²˜ë¦¬ë˜ëŠ” ì²« ë²ˆì§¸ ì‹œì ì…ë‹ˆë‹¤

    if (Connection != nullptr && !bIgnorePacket)
    {
        Connection->ReceivedRawPacket((uint8*)ReceivedPacket.DataView.GetData(), ReceivedPacket.DataView.NumBytes());
    }
```

---

## ê·¼ë³¸ì  ì§ˆë¬¸ `UPendingNetGame`ëŠ” ë­”ê°€?

```cpp
struct FWorldContext
{
    // ...

    // ìš°ì„  WorldContextì—ì„œ ê´€ë¦¬ëœë‹¤.
    TObjectPtr<UPendingNetGame> PendingNetGame;
};
```

```cpp
virtual EBrowseReturnVal::Type Browse(FWorldContext& WorldContext, FURL URL, FString& Error)
{
    //...

    if (URL.IsLocalInternal())
    {
        //...
    }
    else if (URL.IsInternal() && GIsClient)
    {
        // Browse ì‹œì— ìƒì„±ì´ ë˜ë©°
        WorldContext.PendingNetGame = NewObject<UPendingNetGame>();
        WorldContext.PendingNetGame->Initialize(URL);
        WorldContext.PendingNetGame->InitNetDriver();

        return EBrowseReturnVal::Pending;
    }
}

virtual void TickWorldTravel(FWorldContext& Context, float DeltaSeconds)
{
    //...

    // Tickì„ ë°›ê²Œ ëœë‹¤.
    if (Context.PendingNetGame)
    {
        Context.PendingNetGame->Tick(DeltaSeconds);
    }
} 
```

* ê·¸ëŸ¼ ê²°êµ­ì€ NetWorkì™€ ê´€ë ¨ëœ ë­”ê°€ë¥¼ í•˜ëŠ” ì• ê³ , Worldì—ì„œ ì§ì ‘í•˜ê¸° ê·¸ëŸ¬ë‹ˆ ì–˜ë¥¼ í†µí•´ í•œë‹¤
* ë‚´ë¶€ë¥¼ ì¢€ ë” ë´ì•¼ê² êµ°?

```cpp
class UPendingNetGame : public UObject, FNetworkNotify
{
    // ...


    /** URL associated with this level */
    FURL URL;

    /**
     * NetDriver created for contacting the new server
     * transferred to world on successful connection
     */
    // as comments said, we use NetDriver while connecting to server, after that, we still reuse this NetDriver
    TObjectPtr<class UNetDriver> NetDriver;

    // it could be spoiler, but I'd like to mention that, after successfully connect to the server, we still need another stage 'JOIN' getting into gameplay
    bool bSuccessfullyConnected;
    bool bSentJoinRequest;

    /** set when we call LoadMapCompleted */
    // when we finally loading map, we'll transition from UPendingNetGame to UWorld(loaded map)
    bool bLoadedMapSuccessfully;

    FString ConnectionError;
};
```

* ê²°êµ­ `UPendingNetGame`ë„ `UNetDriver`ë¥¼ í†µí•´ ë­”ê°€ë¥¼ ì§„í–‰

