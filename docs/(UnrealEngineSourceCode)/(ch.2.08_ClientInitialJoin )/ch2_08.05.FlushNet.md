---
layout: default
title: "08-05. FlushNet"
parent: "([Network] 08. ClientInitialJoin)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/**
    * flushes any pending data, bundling it into a packet and sending it via LowLevelSend()
    * also handles network simulation settings (simulated lag, packet loss, etc) unless bIngoreSimulation is true
    */
/**
    * ë³´ë¥˜ ì¤‘ì¸ ë°ì´í„°ë¥¼ íŒ¨í‚·ìœ¼ë¡œ ë¬¶ì–´ LowLevelSend()ë¥¼ í†µí•´ ì „ì†¡í•©ë‹ˆë‹¤.
    * bIgnoreSimulationì´ trueê°€ ì•„ë‹ˆë¼ë©´ ë„¤íŠ¸ì›Œí¬ ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •(ì‹œë®¬ë ˆì´ì…˜ëœ ì§€ì—°, íŒ¨í‚· ì†ì‹¤ ë“±)ë„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    */
virtual void FlushNet(bool bIgnoreSimulation = false)
{
    // update info
    // ì •ë³´ ì—…ë°ì´íŠ¸
    LastEnd = FBitWriterMark();
    TimeSensitive = 0;

    // if there is any pending data to send, send it
    // ë³´ë‚¼ ë³´ë¥˜ ì¤‘ì¸ ë°ì´í„°ê°€ ìˆë‹¤ë©´ ì „ì†¡í•©ë‹ˆë‹¤
    if (SendBuffer.GetNumBits() || 
        HasDirtyAcks || 
        (Driver->GetElapsedTime() - LastSendTime > Driver->KeepAliveTime && !IsInternalAck() && GetConnectionState() != USOCK_Closed))
    {
        FOutPacketTraits Traits;

        // if sending keepalive packet or just acks, still write the packet header
        // keepalive íŒ¨í‚·ì´ë‚˜ ë‹¨ìˆœ acksë¥¼ ë³´ë‚´ëŠ” ê²½ìš°ì—ë„ íŒ¨í‚· í—¤ë”ë¥¼ ì‘ì„±í•©ë‹ˆë‹¤
        if (SendBuffer.GetNumBits() == 0)
        {
            WriteBitsToSendBuffer(NULL, 0); // this will force the packet header to be written
                                            // ì´ëŠ” íŒ¨í‚· í—¤ë”ê°€ ì‘ì„±ë˜ë„ë¡ ê°•ì œí•©ë‹ˆë‹¤
            Traits.bIsKeepAlive = true;
        }

        double PacketSentTimeInS = FPlatformTime::Seconds();

        // write the UNetConnection-level termination bit
        // UNetConnection ë ˆë²¨ì˜ ì¢…ë£Œ ë¹„íŠ¸ë¥¼ ì‘ì„±í•©ë‹ˆë‹¤
        SendBuffer.WriteBit(1);

        // refresh outgoing header with latest data
        // ìµœì‹  ë°ì´í„°ë¡œ ì†¡ì‹  í—¤ë”ë¥¼ ê°±ì‹ í•©ë‹ˆë‹¤
        if (!IsInternalAck())
        {
            // if we update ack, we also update received ack associated with outgoing seq
            // so we know how many ack bits we need to write (which is updated in received packet)
            // ackë¥¼ ì—…ë°ì´íŠ¸í•˜ë©´, ì†¡ì‹  ì‹œí€€ìŠ¤ì™€ ê´€ë ¨ëœ ìˆ˜ì‹ ëœ ackë„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
            // ë”°ë¼ì„œ ìš°ë¦¬ëŠ” ì–¼ë§ˆë‚˜ ë§ì€ ack ë¹„íŠ¸ë¥¼ ì‘ì„±í•´ì•¼ í•˜ëŠ”ì§€ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤ (ìˆ˜ì‹ ëœ íŒ¨í‚·ì—ì„œ ì—…ë°ì´íŠ¸ë¨)
            WritePacketHeader(SendBuffer);
            WriteFinalPacketInfo(SendBuffer, PacketSentTimeInS);
        }

        Traits.NumAckBits = NumAckBits;
        Traits.NumBunchBits = NumBunchBits;

        // send now
        // ì§€ê¸ˆ ì „ì†¡í•©ë‹ˆë‹¤
        if (Driver->IsNetResourceValid())
        {
            LowLevelSend(SendBuffer.GetData(), SendBuffer.GetNumBits(), Traits);
        }

        // increase outgoing sequence number
        // ì†¡ì‹  ì‹œí€€ìŠ¤ ë²ˆí˜¸ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤
        if (!IsInternalAck())
        {
            PacketNotify.CommitAndIncrementOutSeq();
        }

        LastSendTime = Driver->GetElapsedTime();

        ++OutPacketId;

        bFlushedNetThisFrame = true;

        // ì „ì†¡ ë²„í¼ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤
        InitSendBuffer();
    }
}
```

```cpp
class UIpConnection : public UNetConnection
{
    // ...

    virtual void LowLevelSend(void* Data, int32 CountBits, FOutPacketTraits& Traits) override
    {
        const uint8* DataToSend = reinterpret_cast<uint8*>(Data);

        if (Handler.IsValid() && !Handler->GetRawSend())
        {
            const ProcessedPacket ProcessedData = Handler->Outgoing(reinterpret_cast<uint8*>(Data), CountBits, Traits);
            if (!ProcessedData.bError)
            {
                DataToSend = ProcessedData.Data;
                CountBits = ProcessedData.CountBits;
            }
            else
            {
                CountBits = 0;
            }
        }

        FSocketSendResult SendResult;
        int32 CountBytes = FMath::DivideAndRoundUp(CountBits, 8);
        if (CountBytes > 0)
        {
            FSocket* CurSocket = GetSocket();
            bool bWasSuccessful = CurSocket->SendTo(DataToSend, CountBytes, SendResult.BytesSent, *RemoteAddr);
            if (!bWasSuccessful)
            {
                ISocketSubsystem* const SocketSubsystem = Driver->GetSocketSubsystem();
                SendResult.Error = SocketSubsystem->GetLastErrorCode();
            }
        }
    }
```