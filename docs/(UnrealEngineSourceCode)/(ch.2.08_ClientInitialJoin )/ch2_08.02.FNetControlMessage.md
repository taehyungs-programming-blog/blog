---
layout: default
title: "08-02. FNetControlMessage"
parent: "([Network] 08. ClientInitialJoin)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
#define DEFINE_CONTROL_CHANNEL_MESSAGE(Name, Index, ...) \
enum { NMT_##NAME = Index };
template<> class FNetControlMessage<Index> \
{ \
    static uint8 Initialize() \
    { \
        FNetControlMessageInfo::SetName(Index, TEXT(#Name)); \
    } \
    /** \
     * sends a message of this type on the specified connection's control channel \
     * @note: const not used only because of the FArchive interface: the parameters are not modified \
     */ \
    template<typename... ParamTypes> \
    static void Send(UNetConnection* Conn, ParamTypes&... Params) \
    { \
        static_assert(Index < FNetControlMessageInfo::MaxNames, "control channel message must be a byte.")  \
        if (Conn->Channels[0] != NULL && !Conn->Channels[0]->Closing) \
        { \
            // ...
            // ì±„ë„ë¡œ ë©”ì‹œì§€ì™€ íŒŒëŒì„ ë‹´ì•„ ë³´ë‚¸ë‹¤.
            FControlChannelOutBunch Bunch(Conn->Channels[0], false); \
            uint8 MessageType = Index; \
            Bunch << MessageType;
            FNetControlMessageInfo::SendParams(Bunch, Params...); \
            Conn->Channels[0]->SendBunch(&Bunch, true); \
        } \
    } \
```

* FOutBunch
  * FOutBunchëŠ” ë„¤íŠ¸ì›Œí¬ë¡œ ì „ì†¡í•  ë°ì´í„°ë¥¼ íŒ¨í‚¤ì§•í•˜ëŠ” ì»¨í…Œì´ë„ˆì…ë‹ˆë‹¤
  * FNetBitWriterë¥¼ ìƒì†ë°›ì•„ ë°ì´í„°ë¥¼ ë¹„íŠ¸ ë‹¨ìœ„ë¡œ ì§ë ¬í™”í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤
* ì£¼ìš” ê¸°ëŠ¥

* ì±„ë„ ê¸°ë°˜ í†µì‹ 

```cpp
UChannel* Channel;  // ë°ì´í„°ê°€ ì „ì†¡ë  ì±„ë„
int32 ChIndex;     // ì±„ë„ ì¸ë±ìŠ¤
FName ChName;      // ì±„ë„ ì´ë¦„
```

* ì‹ ë¢°ì„± ê´€ë¦¬

```cpp
uint8 bReliable : 1;      // ì‹ ë¢°ì„± ìˆëŠ” ì „ì†¡ ì—¬ë¶€
uint8 ReceivedAck : 1;    // ìˆ˜ì‹  í™•ì¸ ì—¬ë¶€
int32 ChSequence;         // ì‹œí€€ìŠ¤ ë²ˆí˜¸
```

* ë¶„í•  ì „ì†¡ ì§€ì›

```cpp
uint8 bPartial : 1;         // ë¶„í• ëœ ë°ì´í„°ì¸ì§€ ì—¬ë¶€
uint8 bPartialInitial : 1;  // ë¶„í•  ë°ì´í„°ì˜ ì‹œì‘
uint8 bPartialFinal : 1;    // ë¶„í•  ë°ì´í„°ì˜ ë
```

---

```cpp
/** a bunch of data to send */
// ì „ì†¡í•  ë°ì´í„° ë¬¶ìŒ

// FOutBunch is another packet form inheriting from 'FNetBitWriter'
// - skimming its member variables, we'll see how it is used and see them repeatedly (don't afraid to remember all these member variables!)
// FOutBunchëŠ” 'FNetBitWriter'ë¥¼ ìƒì†ë°›ëŠ” ë˜ ë‹¤ë¥¸ íŒ¨í‚· í˜•íƒœì…ë‹ˆë‹¤
// - ë©¤ë²„ ë³€ìˆ˜ë“¤ì„ í›‘ì–´ë³´ë©´ì„œ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ ì‚´í´ë³´ê³  ë°˜ë³µì ìœ¼ë¡œ ë³´ê²Œ ë  ê²ƒì…ë‹ˆë‹¤ (ì´ ëª¨ë“  ë©¤ë²„ ë³€ìˆ˜ë“¤ì„ ê¸°ì–µí•˜ëŠ” ê²ƒì„ ë‘ë ¤ì›Œí•˜ì§€ ë§ˆì„¸ìš”!)

class FOutBunch : public FNetBitWriter
{
    FOutBunch(UChannel* InChannel, bool bInClose)
        : FNetBitWriter(InChannel->Connection->PackageMap, InChannel->Connection->GetMaxSingleBunchSizeBits())
        , Next(nullptr)
        , Channel(InChannel)
        , Time(0)
        , ChIndex(InChannel->ChIndex)
        , ChName(InChannel->ChName)
        , ChSequence(0)
        , PacketId(0)
        , ReceivedAck(0)
        , bOpen(0)
        , bClose(bInClose)
        , bReliable(0)
        , bPartial(0)
        , bPartialInitial(0)
        , bPartialFinal(0)
        , bHasPackageMapExports(0)
        , bHasMustBeMappedGUIDs(0)
    {
    }

    // 'Next' indicates FOutBunch is managed by linked-list form
    // - 'Channel' indicates OutBunch is managed by the channel
    // - 'PacketId' looks like: it is related to SequenceNumber(OutSeq in channel~ :))
    // 'Next'ëŠ” FOutBunchê°€ ì—°ê²° ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ê´€ë¦¬ë¨ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤
    // - 'Channel'ì€ OutBunchê°€ ì±„ë„ì— ì˜í•´ ê´€ë¦¬ë¨ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤
    // - 'PacketId'ëŠ” ì‹œí€€ìŠ¤ ë²ˆí˜¸ì™€ ê´€ë ¨ì´ ìˆì–´ ë³´ì…ë‹ˆë‹¤(ì±„ë„ì˜ OutSeqì™€ ê´€ë ¨ë¨)

    FOutBunch* Next;
    UChannel* Channel;
    double Time;
    int32 ChIndex;
    FName ChName;
    int32 ChSequence;
    int32 PacketId;

    // whether the OutBunch is received ACK or not:
    // - like this, we'll fill the description of each of bitfields while looking-through the codes
    // OutBunchê°€ ACKë¥¼ ë°›ì•˜ëŠ”ì§€ ì—¬ë¶€:
    // - ì´ì²˜ëŸ¼ ì½”ë“œë¥¼ ì‚´í´ë³´ë©´ì„œ ê° ë¹„íŠ¸í•„ë“œì˜ ì„¤ëª…ì„ ì±„ì›Œë‚˜ê°ˆ ê²ƒì…ë‹ˆë‹¤

    uint8 ReceivedAck : 1;
    uint8 bOpen : 1;
    uint8 bClose : 1;
    uint8 bReliable : 1;
    /** not a complete bunch */
    /** ì™„ì „í•œ ë²ˆì¹˜ê°€ ì•„ë‹˜ */
    uint8 bPartial : 1;
    /** the first bunch of a partial bunch */
    /** ë¶€ë¶„ ë²ˆì¹˜ì˜ ì²« ë²ˆì§¸ ë²ˆì¹˜ */
    uint8 bPartialInitial : 1;
    /** the last bunch of a partial bunch */
    /** ë¶€ë¶„ ë²ˆì¹˜ì˜ ë§ˆì§€ë§‰ ë²ˆì¹˜ */
    uint8 bPartialFinal : 1;
    /** this bunch has networkGUID name/id pairs */
    /** ì´ ë²ˆì¹˜ëŠ” networkGUID ì´ë¦„/id ìŒì„ ê°€ì§€ê³  ìˆìŒ */
    uint8 bHasPackageMapExports : 1;
    /** this bunch has guids that must be mapped before we can process this bunch */
    /** ì´ ë²ˆì¹˜ë¥¼ ì²˜ë¦¬í•˜ê¸° ì „ì— ë§¤í•‘ë˜ì–´ì•¼ í•˜ëŠ” guidë“¤ì„ ê°€ì§€ê³  ìˆìŒ */
    uint8 bHasMustBeMappedGUIDs : 1;

    EChannelCloseReason CloseReason;

    /** list of GUIDs that went out on this bunch */
    /** ì´ ë²ˆì¹˜ì—ì„œ ë‚˜ê°„ GUIDë“¤ì˜ ë¦¬ìŠ¤íŠ¸ */
    TArray<FNetworkGUID> ExportNetGUIDs;
    
    TArray<uint64> NetFieldExports;
};

struct FControlChannelOutBunch : public FOutBunch
{
    FControlChannelOutBunch(class UChannel* InChannel, bool bClose)
        : FOutBunch(InChannel, bClose)
    {
        // control channel bunches contain critical handshaking/synchronization and should always be reliable
        // ì»¨íŠ¸ë¡¤ ì±„ë„ ë²ˆì¹˜ëŠ” ì¤‘ìš”í•œ í•¸ë“œì‰ì´í‚¹/ë™ê¸°í™”ë¥¼ í¬í•¨í•˜ë¯€ë¡œ í•­ìƒ ì‹ ë¢°ì„±ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤
        bReliable = true;
    }
};
```