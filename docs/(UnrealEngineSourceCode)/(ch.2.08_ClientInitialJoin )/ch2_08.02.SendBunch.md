---
layout: default
title: "08-02. SendBunch"
parent: "([Network] 08. ClientInitialJoin)"
grand_parent: "(UE SourceCode 분석 🤖)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** send a bunch if it's not overflowed, and queue it if it's reliable */
/** 오버플로우되지 않은 번치를 전송하고, reliable한 경우 큐에 추가합니다 */
virtual FPacketIdRange SendBunch(FOutBunch* Bunch, bool Merge)
{
    // not complete implementation
    // - as times goes, we'll fill-up this function
    
    // 완전한 구현이 아닙니다
    // - 시간이 지나면서 이 함수를 채워나갈 것입니다

    // set bunch flags
    // dormancy means 'sleeping', because it is not necessary
    // - for now, just try to understand channel can be 'closed' when it is in dormant (we'll see this freqeuntly in near future)
    
    // bunch 플래그를 설정합니다
    // dormancy는 '휴면'을 의미하며, 필요하지 않을 때를 뜻합니다
    // - 지금은 채널이 휴면 상태일 때 닫힐 수 있다는 것만 이해하면 됩니다 (앞으로 자주 보게 될 것입니다)

    const bool bDormancyClose = Bunch->bClose && (Bunch->CloseReason == EChannelCloseReason::Dormancy);
    if (OpenedLocally && ((OpenPacketId.First == INDEX_NONE) || ((Connection->ResendAllDataState != EResendAllDataState::None) && !bDormancyClose)))
    {
        bool bOpenBunch = true;
        if (Connection->ResendAllDataState == EResendAllDataState::SinceCheckpoint)
        {
            // @todo
        }

        // 'bOpenBunch' is TRUE
        // - do you remember FControlChannelOutBunch's bReliable is 'TRUE'
        //   - OpenTemporary is 'FALSE'
        //   - Bunch's bOpen is 'TRUE'
        
        // 'bOpenBunch'는 TRUE입니다
        // - FControlChannelOutBunch의 bReliable이 'TRUE'인 것을 기억하시나요
        //   - OpenTemporary는 'FALSE'입니다
        //   - Bunch의 bOpen은 'TRUE'입니다

        if (bOpenBunch)
        {
            Bunch->bOpen = 1;
            OpenTemporary = !Bunch->bReliable;
        }
    }

    // if channel was opened temporarily, we are never allowed to send reliable packets on it
    
    // 채널이 임시로 열린 경우, 절대로 reliable 패킷을 보낼 수 없습니다
    check(!OpenTemporary || !Bunch->bReliable);

    // this is the max number of bits we can have in a single bunch
    // - MAX_SINGLE_BUNCH_SIZE_BITS is (7620)
    
    // 이것은 단일 번치에서 가질 수 있는 최대 비트 수입니다
    // - MAX_SINGLE_BUNCH_SIZE_BITS는 (7620)입니다
    const int64 MAX_SINGLE_BUNCH_SIZE_BITS = Connection->GetMaxSingleBunchSizeBits();

    // max bytes we'll put in a partial bunch
    
    // partial bunch에 넣을 최대 바이트 수입니다
    const int64 MAX_SINGLE_BUNCH_SIZE_BYTES = MAX_SINGLE_BUNCH_SIZE_BITS / 8;

    // max bits will put in a partial bunch (byte aligned, we don't want to deal with partial bytes in the partial bunches)
    // MAX_SINGLE_BUNCH_SIZE_BITS != MAX_PARTIAL_BUNCH_SIZE_BITS
    // - consider MAX_SINGLE_BUNCH_SIZE_BITS == 9:
    //   - MAX_SINGLE_BUNCH_SIZE_BYTES = (9/8)*8 == 8!!!
    //   *** this formula is capping into bytes!
    
    // partial bunch에 넣을 최대 비트 수입니다 (바이트 정렬됨, partial bunch에서 부분 바이트를 다루고 싶지 않습니다)
    // MAX_SINGLE_BUNCH_SIZE_BITS != MAX_PARTIAL_BUNCH_SIZE_BITS
    // - MAX_SINGLE_BUNCH_SIZE_BITS가 9인 경우를 고려해보세요:
    //   - MAX_SINGLE_BUNCH_SIZE_BYTES = (9/8)*8 == 8!!!
    //   *** 이 공식은 바이트 단위로 제한됩니다!
    const int64 MAX_PARTIAL_BUNCH_SIZE_BITS = MAX_SINGLE_BUNCH_SIZE_BYTES * 8;

    // we use OutgoingBunches storage resided in UNetConnection
    // - in UE, it is usual pattern to reduce memory allocation overhead in stack-scope
    
    // UNetConnection에 있는 OutgoingBunches 저장소를 사용합니다
    // - UE에서는 스택 범위의 메모리 할당 오버헤드를 줄이기 위한 일반적인 패턴입니다
    TArray<FOutBunch*>& OutgoingBunches = Connection->GetOutgoingBunches();
    OutgoingBunches.Reset();

    //-----------------------------------------------------
    // contemplate merging.
    //-----------------------------------------------------
    int32 PreExistingBits = 0;
    FOutBunch* OutBunch = NULL;
    if (/**@todo*/)
    {
        // @todo
    }

    //-----------------------------------------------------
    // possibly split large bunch into list of smaller partial bunches
    //-----------------------------------------------------
    if (Bunch->GetNumBits() > MAX_SINGLE_BUNCH_SIZE_BITS)
    {
        // @todo
    }
    else
    {
        // we add our FControlChannelOutBunch to 'OutgoingBunches'
        
        // FControlChannelOutBunch를 'OutgoingBunches'에 추가합니다
        OutgoingBunches.Add(Bunch);
    }

    //-----------------------------------------------------
    // send all the bunches we need to
    // NOTE: this is done all at once. We could queue this up somewhere else before sending to Out.
    //----------------------------------------------------- 
    // it is helpful to understand what 'FPacketIdRange' is:
    // - see FPacketIdRange first briefly
    // - FPacketIdRange is the 'range' packets
    //   - BUT, for what?
    //   - it is for partial bunches!
    
    // 모든 필요한 번치들을 전송합니다
    // 참고: 이것은 한번에 모두 수행됩니다. Out으로 보내기 전에 다른 곳에서 큐에 넣을 수 있습니다.
    // 'FPacketIdRange'가 무엇인지 이해하는 것이 도움이 됩니다:
    // - 먼저 FPacketIdRange를 간단히 보세요
    // - FPacketIdRange는 패킷들의 '범위'입니다
    //   - 하지만 무엇을 위한 것일까요?
    //   - partial bunch들을 위한 것입니다!
                                                                                    
    FPacketIdRange PacketIdRange;

    // we'll cover this later ~ :)
    
    // 이것은 나중에 다루겠습니다 ~ :)
    const bool bOverflowsReliable = (NumOutRec + OutgoingBunches.Num() >= RELIABLE_BUFFER + Bunch->bClose);
    if (Bunch->bReliable && bOverflowsReliable)
    {
        // @todo
    }

    // in our case, OutgoingBunches.Num() == 1 
    
    // 우리의 경우, OutgoingBunches.Num() == 1 입니다
    for (int32 PartialNum = 0; PartialNum < OutgoingBunches.Num(); ++PartialNum)
    {
        FOutBunch* NextBunch = OutgoingBunches[PartialNum];

        // bReliable = true
        // bOpen = true
        // bClose = false
        // CloseReason = Destroyed
        // ChIndex = 0
        // ChName = "Control"
        
        // bReliable = true
        // bOpen = true
        // bClose = false
        // CloseReason = Destroyed
        // ChIndex = 0
        // ChName = "Control"
        NextBunch->bReliable = Bunch->Reliable;
        NextBunch->bOpen = Bunch->bOpen;
        NextBunch->bClose = Bunch->bClose;
        NextBunch->CloseReason = Bunch->CloseReason;
        NextBunch->ChIndex = Bunch->ChIndex;
        NextBunch->ChName = Bunch->ChName;

        if (!NextBunch->bHasPackageMapExports)
        {
            NextBunch->bHasMustBeMappedGUIDs |= Bunch->bHasMustBeMappedGUIDs;
        }

        if (OutgoingBunches.Num() > 1)
        {
            // @todo
        }

        // we prepare the bunch
        // remember that "OutBunch == nullptr" in our case
        // - see UChannel::PrepBunch(goto 017: ClientInitialJoin)
        //   - 'ThisOutBunch' is new-instance based upon 'NextBunch'!
        
        // bunch를 준비합니다
        // "OutBunch == nullptr"인 것을 기억하세요
        // - UChannel::PrepBunch를 보세요(017: ClientInitialJoin으로 이동)
        //   - 'ThisOutBunch'는 'NextBunch'를 기반으로 한 새로운 인스턴스입니다!
        FOutBunch* ThisOutBunch = PrepBunch(NextBunch, OutBunch, Merge);

        // update packet range
        // 'ThisOutBunch' is the **copy** of 'NextBunch'
        // - see UChannel::SendRawBunch(goto 019: ClientInitialJoin)
        
        // 패킷 범위를 업데이트합니다
        // 'ThisOutBunch'는 'NextBunch'의 **복사본**입니다
        // - UChannel::SendRawBunch를 보세요(019: ClientInitialJoin으로 이동)
        int32 PacketId = SendRawBunch(ThisOutBunch, Merge, nullptr);

        // in our case PartialNum == 0, so single PacketId is saved in PacketIdRange
        // - from our code inspection, PacketIdRange's size is same as the number of FlushNet() is called
        
        // 우리의 경우 PartialNum == 0이므로, 단일 PacketId가 PacketIdRange에 저장됩니다
        // - 코드 검사에서 볼 수 있듯이, PacketIdRange의 크기는 FlushNet()이 호출된 횟수와 같습니다
        if (PartialNum == 0)
        {
            PacketIdRange = FPacketIdRange(PacketId);
        }
        else
        {
            PacketIdRange.Last = PacketId;
        }

        // update channel sequence count
        // keep updating UNetConnection::LastOut and UNetConnection::LastEnd
        
        // 채널 시퀀스 카운트를 업데이트합니다
        // UNetConnection::LastOut과 UNetConnection::LastEnd를 계속 업데이트합니다
        Connection->LastOut = *ThisOutBunch;
        Connection->LastEnd = FBitWriterMark(Connection->SendBuffer);
    }

    // update open range if necessary
    // the UChannel keep tracking OpenPacketId which is the range of packet-id not called FlushNet() yet
    
    // 필요한 경우 open 범위를 업데이트합니다
    // UChannel은 아직 FlushNet()이 호출되지 않은 packet-id의 범위인 OpenPacketId를 추적합니다
    if (Bunch->bOpen && (Connection->ResendAllDataState == EResendAllDataState::None))
    {
        OpenPacketId = PacketIdRange;
    }

    // destroy outgoing bunch now that they are sent, except the one that was passed into ::SendBunch
    // - this is because the one passed in ::SendBunch is the responsibility of the caller, the other bunches in OutgoingBunches
    //   were either allocated in this function for partial bunches, or taken from the package map, which expects us to destroy them
    // OutgoingBunches except for 'Bunch' we passed as parameter of this function, are already serialized into send-buffer
    // - it is totally "OK" to delete and should be deleted!~
    // the newly-created bunches by PrepBunch() is remained in the channel
    
    // 전송된 outgoing bunch를 파괴합니다. ::SendBunch에 전달된 것은 제외합니다
    // - 이는 ::SendBunch에 전달된 것은 호출자의 책임이기 때문입니다. OutgoingBunches의 다른 번치들은
    //   partial bunch를 위해 이 함수에서 할당되었거나, 패키지 맵에서 가져온 것으로 우리가 파괴해야 합니다
    // 이 함수의 매개변수로 전달한 'Bunch'를 제외한 OutgoingBunches는 이미 send-buffer에 직렬화되었습니다
    // - 삭제해도 완전히 "괜찮으며" 삭제되어야 합니다!
    // PrepBunch()에 의해 새로 생성된 번치들은 채널에 남아있습니다
    for (auto It = OutgoingBunches.CreateIterator(); It; ++It)
    {
        FOutBunch* DeleteBunch = *It;
        if (DeleteBunch != Bunch)
            delete DeleteBunch;
    }

    return PacketIdRange;
}
```