---
layout: default
title: "08-02. SendBunch"
parent: "([Network] 08. ClientInitialJoin)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** send a bunch if it's not overflowed, and queue it if it's reliable */
/** ì˜¤ë²„í”Œë¡œìš°ë˜ì§€ ì•Šì€ ë²ˆì¹˜ë¥¼ ì „ì†¡í•˜ê³ , reliableí•œ ê²½ìš° íì— ì¶”ê°€í•©ë‹ˆë‹¤ */
virtual FPacketIdRange SendBunch(FOutBunch* Bunch, bool Merge)
{
    // not complete implementation
    // - as times goes, we'll fill-up this function
    
    // ì™„ì „í•œ êµ¬í˜„ì´ ì•„ë‹™ë‹ˆë‹¤
    // - ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ ì´ í•¨ìˆ˜ë¥¼ ì±„ì›Œë‚˜ê°ˆ ê²ƒì…ë‹ˆë‹¤

    // set bunch flags
    // dormancy means 'sleeping', because it is not necessary
    // - for now, just try to understand channel can be 'closed' when it is in dormant (we'll see this freqeuntly in near future)
    
    // bunch í”Œë˜ê·¸ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤
    // dormancyëŠ” 'íœ´ë©´'ì„ ì˜ë¯¸í•˜ë©°, í•„ìš”í•˜ì§€ ì•Šì„ ë•Œë¥¼ ëœ»í•©ë‹ˆë‹¤
    // - ì§€ê¸ˆì€ ì±„ë„ì´ íœ´ë©´ ìƒíƒœì¼ ë•Œ ë‹«í ìˆ˜ ìˆë‹¤ëŠ” ê²ƒë§Œ ì´í•´í•˜ë©´ ë©ë‹ˆë‹¤ (ì•ìœ¼ë¡œ ìì£¼ ë³´ê²Œ ë  ê²ƒì…ë‹ˆë‹¤)

    const bool bDormancyClose = Bunch->bClose && (Bunch->CloseReason == EChannelCloseReason::Dormancy);
    if (OpenedLocally && ((OpenPacketId.First == INDEX_NONE) || ((Connection->ResendAllDataState != EResendAllDataState::None) && !bDormancyClose)))
    {
        bool bOpenBunch = true;
        if (Connection->ResendAllDataState == EResendAllDataState::SinceCheckpoint)
        {
            // @todo
        }

        // 'bOpenBunch' is TRUE
        // - do you remember FControlChannelOutBunch's bReliable is 'TRUE'
        //   - OpenTemporary is 'FALSE'
        //   - Bunch's bOpen is 'TRUE'
        
        // 'bOpenBunch'ëŠ” TRUEì…ë‹ˆë‹¤
        // - FControlChannelOutBunchì˜ bReliableì´ 'TRUE'ì¸ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”
        //   - OpenTemporaryëŠ” 'FALSE'ì…ë‹ˆë‹¤
        //   - Bunchì˜ bOpenì€ 'TRUE'ì…ë‹ˆë‹¤

        if (bOpenBunch)
        {
            Bunch->bOpen = 1;
            OpenTemporary = !Bunch->bReliable;
        }
    }

    // if channel was opened temporarily, we are never allowed to send reliable packets on it
    
    // ì±„ë„ì´ ì„ì‹œë¡œ ì—´ë¦° ê²½ìš°, ì ˆëŒ€ë¡œ reliable íŒ¨í‚·ì„ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
    check(!OpenTemporary || !Bunch->bReliable);

    // this is the max number of bits we can have in a single bunch
    // - MAX_SINGLE_BUNCH_SIZE_BITS is (7620)
    
    // ì´ê²ƒì€ ë‹¨ì¼ ë²ˆì¹˜ì—ì„œ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ ë¹„íŠ¸ ìˆ˜ì…ë‹ˆë‹¤
    // - MAX_SINGLE_BUNCH_SIZE_BITSëŠ” (7620)ì…ë‹ˆë‹¤
    const int64 MAX_SINGLE_BUNCH_SIZE_BITS = Connection->GetMaxSingleBunchSizeBits();

    // max bytes we'll put in a partial bunch
    
    // partial bunchì— ë„£ì„ ìµœëŒ€ ë°”ì´íŠ¸ ìˆ˜ì…ë‹ˆë‹¤
    const int64 MAX_SINGLE_BUNCH_SIZE_BYTES = MAX_SINGLE_BUNCH_SIZE_BITS / 8;

    // max bits will put in a partial bunch (byte aligned, we don't want to deal with partial bytes in the partial bunches)
    // MAX_SINGLE_BUNCH_SIZE_BITS != MAX_PARTIAL_BUNCH_SIZE_BITS
    // - consider MAX_SINGLE_BUNCH_SIZE_BITS == 9:
    //   - MAX_SINGLE_BUNCH_SIZE_BYTES = (9/8)*8 == 8!!!
    //   *** this formula is capping into bytes!
    
    // partial bunchì— ë„£ì„ ìµœëŒ€ ë¹„íŠ¸ ìˆ˜ì…ë‹ˆë‹¤ (ë°”ì´íŠ¸ ì •ë ¬ë¨, partial bunchì—ì„œ ë¶€ë¶„ ë°”ì´íŠ¸ë¥¼ ë‹¤ë£¨ê³  ì‹¶ì§€ ì•ŠìŠµë‹ˆë‹¤)
    // MAX_SINGLE_BUNCH_SIZE_BITS != MAX_PARTIAL_BUNCH_SIZE_BITS
    // - MAX_SINGLE_BUNCH_SIZE_BITSê°€ 9ì¸ ê²½ìš°ë¥¼ ê³ ë ¤í•´ë³´ì„¸ìš”:
    //   - MAX_SINGLE_BUNCH_SIZE_BYTES = (9/8)*8 == 8!!!
    //   *** ì´ ê³µì‹ì€ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ì œí•œë©ë‹ˆë‹¤!
    const int64 MAX_PARTIAL_BUNCH_SIZE_BITS = MAX_SINGLE_BUNCH_SIZE_BYTES * 8;

    // we use OutgoingBunches storage resided in UNetConnection
    // - in UE, it is usual pattern to reduce memory allocation overhead in stack-scope
    
    // UNetConnectionì— ìˆëŠ” OutgoingBunches ì €ì¥ì†Œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤
    // - UEì—ì„œëŠ” ìŠ¤íƒ ë²”ìœ„ì˜ ë©”ëª¨ë¦¬ í• ë‹¹ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê¸° ìœ„í•œ ì¼ë°˜ì ì¸ íŒ¨í„´ì…ë‹ˆë‹¤
    TArray<FOutBunch*>& OutgoingBunches = Connection->GetOutgoingBunches();
    OutgoingBunches.Reset();

    //-----------------------------------------------------
    // contemplate merging.
    //-----------------------------------------------------
    int32 PreExistingBits = 0;
    FOutBunch* OutBunch = NULL;
    if (/**@todo*/)
    {
        // @todo
    }

    //-----------------------------------------------------
    // possibly split large bunch into list of smaller partial bunches
    //-----------------------------------------------------
    if (Bunch->GetNumBits() > MAX_SINGLE_BUNCH_SIZE_BITS)
    {
        // @todo
    }
    else
    {
        // we add our FControlChannelOutBunch to 'OutgoingBunches'
        
        // FControlChannelOutBunchë¥¼ 'OutgoingBunches'ì— ì¶”ê°€í•©ë‹ˆë‹¤
        OutgoingBunches.Add(Bunch);
    }

    //-----------------------------------------------------
    // send all the bunches we need to
    // NOTE: this is done all at once. We could queue this up somewhere else before sending to Out.
    //----------------------------------------------------- 
    // it is helpful to understand what 'FPacketIdRange' is:
    // - see FPacketIdRange first briefly
    // - FPacketIdRange is the 'range' packets
    //   - BUT, for what?
    //   - it is for partial bunches!
    
    // ëª¨ë“  í•„ìš”í•œ ë²ˆì¹˜ë“¤ì„ ì „ì†¡í•©ë‹ˆë‹¤
    // ì°¸ê³ : ì´ê²ƒì€ í•œë²ˆì— ëª¨ë‘ ìˆ˜í–‰ë©ë‹ˆë‹¤. Outìœ¼ë¡œ ë³´ë‚´ê¸° ì „ì— ë‹¤ë¥¸ ê³³ì—ì„œ íì— ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    // 'FPacketIdRange'ê°€ ë¬´ì—‡ì¸ì§€ ì´í•´í•˜ëŠ” ê²ƒì´ ë„ì›€ì´ ë©ë‹ˆë‹¤:
    // - ë¨¼ì € FPacketIdRangeë¥¼ ê°„ë‹¨íˆ ë³´ì„¸ìš”
    // - FPacketIdRangeëŠ” íŒ¨í‚·ë“¤ì˜ 'ë²”ìœ„'ì…ë‹ˆë‹¤
    //   - í•˜ì§€ë§Œ ë¬´ì—‡ì„ ìœ„í•œ ê²ƒì¼ê¹Œìš”?
    //   - partial bunchë“¤ì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤!
                                                                                    
    FPacketIdRange PacketIdRange;

    // we'll cover this later ~ :)
    
    // ì´ê²ƒì€ ë‚˜ì¤‘ì— ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤ ~ :)
    const bool bOverflowsReliable = (NumOutRec + OutgoingBunches.Num() >= RELIABLE_BUFFER + Bunch->bClose);
    if (Bunch->bReliable && bOverflowsReliable)
    {
        // @todo
    }

    // in our case, OutgoingBunches.Num() == 1 
    
    // ìš°ë¦¬ì˜ ê²½ìš°, OutgoingBunches.Num() == 1 ì…ë‹ˆë‹¤
    for (int32 PartialNum = 0; PartialNum < OutgoingBunches.Num(); ++PartialNum)
    {
        FOutBunch* NextBunch = OutgoingBunches[PartialNum];

        // bReliable = true
        // bOpen = true
        // bClose = false
        // CloseReason = Destroyed
        // ChIndex = 0
        // ChName = "Control"
        
        // bReliable = true
        // bOpen = true
        // bClose = false
        // CloseReason = Destroyed
        // ChIndex = 0
        // ChName = "Control"
        NextBunch->bReliable = Bunch->Reliable;
        NextBunch->bOpen = Bunch->bOpen;
        NextBunch->bClose = Bunch->bClose;
        NextBunch->CloseReason = Bunch->CloseReason;
        NextBunch->ChIndex = Bunch->ChIndex;
        NextBunch->ChName = Bunch->ChName;

        if (!NextBunch->bHasPackageMapExports)
        {
            NextBunch->bHasMustBeMappedGUIDs |= Bunch->bHasMustBeMappedGUIDs;
        }

        if (OutgoingBunches.Num() > 1)
        {
            // @todo
        }

        // we prepare the bunch
        // remember that "OutBunch == nullptr" in our case
        // - see UChannel::PrepBunch(goto 017: ClientInitialJoin)
        //   - 'ThisOutBunch' is new-instance based upon 'NextBunch'!
        
        // bunchë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤
        // "OutBunch == nullptr"ì¸ ê²ƒì„ ê¸°ì–µí•˜ì„¸ìš”
        // - UChannel::PrepBunchë¥¼ ë³´ì„¸ìš”(017: ClientInitialJoinìœ¼ë¡œ ì´ë™)
        //   - 'ThisOutBunch'ëŠ” 'NextBunch'ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤!
        FOutBunch* ThisOutBunch = PrepBunch(NextBunch, OutBunch, Merge);

        // update packet range
        // 'ThisOutBunch' is the **copy** of 'NextBunch'
        // - see UChannel::SendRawBunch(goto 019: ClientInitialJoin)
        
        // íŒ¨í‚· ë²”ìœ„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        // 'ThisOutBunch'ëŠ” 'NextBunch'ì˜ **ë³µì‚¬ë³¸**ì…ë‹ˆë‹¤
        // - UChannel::SendRawBunchë¥¼ ë³´ì„¸ìš”(019: ClientInitialJoinìœ¼ë¡œ ì´ë™)
        int32 PacketId = SendRawBunch(ThisOutBunch, Merge, nullptr);

        // in our case PartialNum == 0, so single PacketId is saved in PacketIdRange
        // - from our code inspection, PacketIdRange's size is same as the number of FlushNet() is called
        
        // ìš°ë¦¬ì˜ ê²½ìš° PartialNum == 0ì´ë¯€ë¡œ, ë‹¨ì¼ PacketIdê°€ PacketIdRangeì— ì €ì¥ë©ë‹ˆë‹¤
        // - ì½”ë“œ ê²€ì‚¬ì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´, PacketIdRangeì˜ í¬ê¸°ëŠ” FlushNet()ì´ í˜¸ì¶œëœ íšŸìˆ˜ì™€ ê°™ìŠµë‹ˆë‹¤
        if (PartialNum == 0)
        {
            PacketIdRange = FPacketIdRange(PacketId);
        }
        else
        {
            PacketIdRange.Last = PacketId;
        }

        // update channel sequence count
        // keep updating UNetConnection::LastOut and UNetConnection::LastEnd
        
        // ì±„ë„ ì‹œí€€ìŠ¤ ì¹´ìš´íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        // UNetConnection::LastOutê³¼ UNetConnection::LastEndë¥¼ ê³„ì† ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        Connection->LastOut = *ThisOutBunch;
        Connection->LastEnd = FBitWriterMark(Connection->SendBuffer);
    }

    // update open range if necessary
    // the UChannel keep tracking OpenPacketId which is the range of packet-id not called FlushNet() yet
    
    // í•„ìš”í•œ ê²½ìš° open ë²”ìœ„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
    // UChannelì€ ì•„ì§ FlushNet()ì´ í˜¸ì¶œë˜ì§€ ì•Šì€ packet-idì˜ ë²”ìœ„ì¸ OpenPacketIdë¥¼ ì¶”ì í•©ë‹ˆë‹¤
    if (Bunch->bOpen && (Connection->ResendAllDataState == EResendAllDataState::None))
    {
        OpenPacketId = PacketIdRange;
    }

    // destroy outgoing bunch now that they are sent, except the one that was passed into ::SendBunch
    // - this is because the one passed in ::SendBunch is the responsibility of the caller, the other bunches in OutgoingBunches
    //   were either allocated in this function for partial bunches, or taken from the package map, which expects us to destroy them
    // OutgoingBunches except for 'Bunch' we passed as parameter of this function, are already serialized into send-buffer
    // - it is totally "OK" to delete and should be deleted!~
    // the newly-created bunches by PrepBunch() is remained in the channel
    
    // ì „ì†¡ëœ outgoing bunchë¥¼ íŒŒê´´í•©ë‹ˆë‹¤. ::SendBunchì— ì „ë‹¬ëœ ê²ƒì€ ì œì™¸í•©ë‹ˆë‹¤
    // - ì´ëŠ” ::SendBunchì— ì „ë‹¬ëœ ê²ƒì€ í˜¸ì¶œìì˜ ì±…ì„ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. OutgoingBunchesì˜ ë‹¤ë¥¸ ë²ˆì¹˜ë“¤ì€
    //   partial bunchë¥¼ ìœ„í•´ ì´ í•¨ìˆ˜ì—ì„œ í• ë‹¹ë˜ì—ˆê±°ë‚˜, íŒ¨í‚¤ì§€ ë§µì—ì„œ ê°€ì ¸ì˜¨ ê²ƒìœ¼ë¡œ ìš°ë¦¬ê°€ íŒŒê´´í•´ì•¼ í•©ë‹ˆë‹¤
    // ì´ í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•œ 'Bunch'ë¥¼ ì œì™¸í•œ OutgoingBunchesëŠ” ì´ë¯¸ send-bufferì— ì§ë ¬í™”ë˜ì—ˆìŠµë‹ˆë‹¤
    // - ì‚­ì œí•´ë„ ì™„ì „íˆ "ê´œì°®ìœ¼ë©°" ì‚­ì œë˜ì–´ì•¼ í•©ë‹ˆë‹¤!
    // PrepBunch()ì— ì˜í•´ ìƒˆë¡œ ìƒì„±ëœ ë²ˆì¹˜ë“¤ì€ ì±„ë„ì— ë‚¨ì•„ìˆìŠµë‹ˆë‹¤
    for (auto It = OutgoingBunches.CreateIterator(); It; ++It)
    {
        FOutBunch* DeleteBunch = *It;
        if (DeleteBunch != Bunch)
            delete DeleteBunch;
    }

    return PacketIdRange;
}
```