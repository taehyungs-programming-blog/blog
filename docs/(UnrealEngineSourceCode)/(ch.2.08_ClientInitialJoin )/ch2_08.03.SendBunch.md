---
layout: default
title: "08-03. SendBunch"
parent: "([Network] 08. ClientInitialJoin)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
class UControlChannel : public UChannel
{
    // ...

    virtual FPacketIdRange SendBunch(FOutBunch* Bunch, bool Merge) override
    {
        if (!Bunch->IsError())
        {
            return UChannel::SendBunch(Bunch, Merge);
        }
        return FPacketIdRange(INDEX_NONE);
    }
```

* í˜¹ì‹œë‚˜ í—·ê°ˆë¦´ ìˆ˜ ìˆìœ¼ë‹ˆ ì™œ `UControlChannel::SendBunch`ë¥¼ ë³´ê³ ìˆëƒ?

```cpp
// ...
template<typename... ParamTypes> \
static void Send(UNetConnection* Conn, ParamTypes&... Params) \
{ \
    static_assert(Index < FNetControlMessageInfo::MaxNames, "control channel message must be a byte.")  \
    if (Conn->Channels[0] != NULL && !Conn->Channels[0]->Closing) \
    { \
        // ...
        FControlChannelOutBunch Bunch(Conn->Channels[0], false); \
        uint8 MessageType = Index; \
        Bunch << MessageType;
        FNetControlMessageInfo::SendParams(Bunch, Params...); \

        // ì—¬ê¸°ì„œ ì“°ê²Œ ëœë‹¤.
        Conn->Channels[0]->SendBunch(&Bunch, true); \
    } \
} \
```

---

* ë‹¤ì‹œ ì‹œì‘í•´ ë³´ì.

```cpp
class UChannel : public UObject
{
    // ...

    virtual FPacketIdRange SendBunch(FOutBunch* Bunch, bool Merge)
    {
        // ì™„ì „í•œ êµ¬í˜„ì´ ì•„ë‹™ë‹ˆë‹¤
        // - ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ ì´ í•¨ìˆ˜ë¥¼ ì±„ì›Œë‚˜ê°ˆ ê²ƒì…ë‹ˆë‹¤


        const bool bDormancyClose = Bunch->bClose && (Bunch->CloseReason == EChannelCloseReason::Dormancy);
        if (OpenedLocally && ((OpenPacketId.First == INDEX_NONE) || ((Connection->ResendAllDataState != EResendAllDataState::None) && !bDormancyClose)))
        {
            bool bOpenBunch = true;
            if (Connection->ResendAllDataState == EResendAllDataState::SinceCheckpoint)
            {
                // @todo
            }

            // 'bOpenBunch'ëŠ” TRUEì…ë‹ˆë‹¤
            // - FControlChannelOutBunchì˜ bReliableì´ 'TRUE'ì¸ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”
            //   - OpenTemporaryëŠ” 'FALSE'ì…ë‹ˆë‹¤
            //   - Bunchì˜ bOpenì€ 'TRUE'ì…ë‹ˆë‹¤
            if (bOpenBunch)
            {
                Bunch->bOpen = 1;
                OpenTemporary = !Bunch->bReliable;
            }
        }

        // if channel was opened temporarily, we are never allowed to send reliable packets on it
        // ì±„ë„ì´ ì„ì‹œë¡œ ì—´ë¦° ê²½ìš°, ì ˆëŒ€ë¡œ ì‹ ë¢°ì„± ìˆëŠ” íŒ¨í‚·ì„ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
        check(!OpenTemporary || !Bunch->bReliable);

        // this is the max number of bits we can have in a single bunch
        // - MAX_SINGLE_BUNCH_SIZE_BITS is (7620)

        // í•˜ë‚˜ì˜ bunchê°€ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ìµœëŒ€ ë¹„íŠ¸ ìˆ˜ì…ë‹ˆë‹¤
        // - MAX_SINGLE_BUNCH_SIZE_BITSëŠ” (7620)ì…ë‹ˆë‹¤
        const int64 MAX_SINGLE_BUNCH_SIZE_BITS = Connection->GetMaxSingleBunchSizeBits();

        // max bytes we'll put in a partial bunch
        // partial bunchì— ë„£ì„ ìµœëŒ€ ë°”ì´íŠ¸ ìˆ˜ì…ë‹ˆë‹¤
        const int64 MAX_SINGLE_BUNCH_SIZE_BYTES = MAX_SINGLE_BUNCH_SIZE_BITS / 8;

        // max bits will put in a partial bunch (byte aligned, we don't want to deal with partial bytes in the partial bunches)
        // MAX_SINGLE_BUNCH_SIZE_BITS != MAX_PARTIAL_BUNCH_SIZE_BITS
        // - consider MAX_SINGLE_BUNCH_SIZE_BITS == 9:
        //   - MAX_SINGLE_BUNCH_SIZE_BYTES = (9/8)*8 == 8!!!
        //   *** this formula is capping into bytes!

        // partial bunchì— ë„£ì„ ìµœëŒ€ ë¹„íŠ¸ ìˆ˜ì…ë‹ˆë‹¤ (ë°”ì´íŠ¸ ì •ë ¬ë¨, partial bunchì—ì„œ ë¶€ë¶„ ë°”ì´íŠ¸ë¥¼ ë‹¤ë£¨ê³  ì‹¶ì§€ ì•ŠìŠµë‹ˆë‹¤)
        // MAX_SINGLE_BUNCH_SIZE_BITS != MAX_PARTIAL_BUNCH_SIZE_BITS
        // - MAX_SINGLE_BUNCH_SIZE_BITSê°€ 9ì¸ ê²½ìš°ë¥¼ ìƒê°í•´ë³´ì„¸ìš”:
        //   - MAX_SINGLE_BUNCH_SIZE_BYTES = (9/8)*8 == 8!!!
        //   *** ì´ ê³µì‹ì€ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ì œí•œë©ë‹ˆë‹¤!
        const int64 MAX_PARTIAL_BUNCH_SIZE_BITS = MAX_SINGLE_BUNCH_SIZE_BYTES * 8;

        // we use OutgoingBunches storage resided in UNetConnection
        // - in UE, it is usual pattern to reduce memory allocation overhead in stack-scope

        // UNetConnectionì— ìˆëŠ” OutgoingBunches ì €ì¥ì†Œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤
        // - UEì—ì„œëŠ” ìŠ¤íƒ ë²”ìœ„ì˜ ë©”ëª¨ë¦¬ í• ë‹¹ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê¸° ìœ„í•œ ì¼ë°˜ì ì¸ íŒ¨í„´ì…ë‹ˆë‹¤
        TArray<FOutBunch*>& OutgoingBunches = Connection->GetOutgoingBunches();
        OutgoingBunches.Reset();

        //-----------------------------------------------------
        // contemplate merging.
        //-----------------------------------------------------
        int32 PreExistingBits = 0;
        FOutBunch* OutBunch = NULL;
        if (/**@todo*/)
        {
            // @todo
        }

        //-----------------------------------------------------
        // possibly split large bunch into list of smaller partial bunches
        //-----------------------------------------------------
        if (Bunch->GetNumBits() > MAX_SINGLE_BUNCH_SIZE_BITS)
        {
            // @todo
        }
        else
        {
            // we add our FControlChannelOutBunch to 'OutgoingBunches'
            // FControlChannelOutBunchë¥¼ 'OutgoingBunches'ì— ì¶”ê°€í•©ë‹ˆë‹¤
            OutgoingBunches.Add(Bunch);
        }

        // ë³´ë‚´ì•¼ í•  ëª¨ë“  bunchë“¤ì„ ì „ì†¡í•©ë‹ˆë‹¤
        // ì°¸ê³ : ì´ê²ƒì€ í•œ ë²ˆì— ìˆ˜í–‰ë©ë‹ˆë‹¤. Outìœ¼ë¡œ ë³´ë‚´ê¸° ì „ì— ë‹¤ë¥¸ ê³³ì—ì„œ íì— ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        // 'FPacketIdRange'ê°€ ë¬´ì—‡ì¸ì§€ ì´í•´í•˜ëŠ” ê²ƒì´ ë„ì›€ì´ ë©ë‹ˆë‹¤:
        // - ë¨¼ì € FPacketIdRangeë¥¼ ê°„ë‹¨íˆ ë³´ì„¸ìš”
        // - FPacketIdRangeëŠ” íŒ¨í‚·ë“¤ì˜ 'ë²”ìœ„'ì…ë‹ˆë‹¤
        //   - í•˜ì§€ë§Œ ë¬´ì—‡ì„ ìœ„í•œ ê²ƒì¼ê¹Œìš”?
        //   - partial bunchë“¤ì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤!
        //                                                                                               
        //      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     
        //      â”‚ Bunch0             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ Bunch1             â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ Bunch2             â”‚     
        //      â”‚ bPartial==1        â”‚         â”‚ bPartial==1        â”‚         â”‚ bPartial==1        â”‚     
        //      â”‚ bPartialInitial==1 â”‚         â”‚ bPartialInitial==0 â”‚         â”‚ bPartialInitial==0 â”‚     
        //      â”‚ bPartialFinal==0   â”‚         â”‚ bPartialFinal==0   â”‚         â”‚ bPartialFinal==1   â”‚     
        //      â”‚ PacketId==10       â”‚         â”‚ PacketId==11       â”‚         â”‚ PacketId==12       â”‚     
        //      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     
        //                                                                                                                                                              
        //       *** PacketIdRange is:                                                                   
        //            - First == 10                                                                      
        //            - Last == 12                                                                       
        //                                                                                               
        //                                                                                               
        //      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                                   
        //      â”‚ Bunch3             â”œ                                                                   
        //      â”‚ bPartial==0        â”‚                                                                   
        //      â”‚ bPartialInitial==0 â”‚                                                                   
        //      â”‚ bPartialFinal==0   â”‚                                                                   
        //      â”‚ PacketId==13       â”‚                                                                   
        //      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                   
        //                                                                                                                                                          
        //       *** PacketIdRange is:                                                                   
        //            - First == 13                                                                      
        //            - Last == 13                                                                       
        //                                                                                               
                                                                                      
        FPacketIdRange PacketIdRange;

        // ì´ê²ƒì€ ë‚˜ì¤‘ì— ë‹¤ë£° ê²ƒì…ë‹ˆë‹¤ ~ :)
        const bool bOverflowsReliable = (NumOutRec + OutgoingBunches.Num() >= RELIABLE_BUFFER + Bunch->bClose);
        if (Bunch->bReliable && bOverflowsReliable)
        {
            // @todo
        }

        // in our case, OutgoingBunches.Num() == 1 
        // ìš°ë¦¬ì˜ ê²½ìš°, OutgoingBunches.Num()ì€ 1ì…ë‹ˆë‹¤
        for (int32 PartialNum = 0; PartialNum < OutgoingBunches.Num(); ++PartialNum)
        {
            FOutBunch* NextBunch = OutgoingBunches[PartialNum];

            // bReliable = true
            // bOpen = true
            // bClose = false
            // CloseReason = Destroyed
            // ChIndex = 0
            // ChName = "Control"
            NextBunch->bReliable = Bunch->Reliable;
            NextBunch->bOpen = Bunch->bOpen;
            NextBunch->bClose = Bunch->bClose;
            NextBunch->CloseReason = Bunch->CloseReason;
            NextBunch->ChIndex = Bunch->ChIndex;
            NextBunch->ChName = Bunch->ChName;

            if (!NextBunch->bHasPackageMapExports)
            {
                NextBunch->bHasMustBeMappedGUIDs |= Bunch->bHasMustBeMappedGUIDs;
            }

            if (OutgoingBunches.Num() > 1)
            {
                // @todo
            }

            // we prepare the bunch
            // remember that "OutBunch == nullptr" in our case
            //   - 'ThisOutBunch' is new-instance based upon 'NextBunch'!

            // bunchë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤
            // "OutBunch == nullptr"ì¸ ê²ƒì„ ê¸°ì–µí•˜ì„¸ìš”
            //   - 'ThisOutBunch'ëŠ” 'NextBunch'ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤!
            FOutBunch* ThisOutBunch = PrepBunch(NextBunch, OutBunch, Merge);


            // íŒ¨í‚· ë²”ìœ„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
            // 'ThisOutBunch'ëŠ” 'NextBunch'ì˜ **ë³µì‚¬ë³¸**ì…ë‹ˆë‹¤
            int32 PacketId = SendRawBunch(ThisOutBunch, Merge, nullptr);

            // in our case PartialNum == 0, so single PacketId is saved in PacketIdRange
            // - from our code inspection, PacketIdRange's size is same as the number of FlushNet() is called

            // ìš°ë¦¬ì˜ ê²½ìš° PartialNum == 0ì´ë¯€ë¡œ, ë‹¨ì¼ PacketIdê°€ PacketIdRangeì— ì €ì¥ë©ë‹ˆë‹¤
            // - ì½”ë“œ ê²€ì‚¬ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ì´, PacketIdRangeì˜ í¬ê¸°ëŠ” FlushNet()ì´ í˜¸ì¶œëœ íšŸìˆ˜ì™€ ê°™ìŠµë‹ˆë‹¤
            if (PartialNum == 0)
            {
                PacketIdRange = FPacketIdRange(PacketId);
            }
            else
            {
                PacketIdRange.Last = PacketId;
            }

            // update channel sequence count
            // keep updating UNetConnection::LastOut and UNetConnection::LastEnd

            // ì±„ë„ ì‹œí€€ìŠ¤ ì¹´ìš´íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
            // UNetConnection::LastOutê³¼ UNetConnection::LastEndë¥¼ ê³„ì† ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
            Connection->LastOut = *ThisOutBunch;
            Connection->LastEnd = FBitWriterMark(Connection->SendBuffer);
        }

        // update open range if necessary
        // the UChannel keep tracking OpenPacketId which is the range of packet-id not called FlushNet() yet

        // í•„ìš”í•œ ê²½ìš° open ë²”ìœ„ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
        // UChannelì€ ì•„ì§ FlushNet()ì´ í˜¸ì¶œë˜ì§€ ì•Šì€ packet-idì˜ ë²”ìœ„ì¸ OpenPacketIdë¥¼ ê³„ì† ì¶”ì í•©ë‹ˆë‹¤
        if (Bunch->bOpen && (Connection->ResendAllDataState == EResendAllDataState::None))
        {
            OpenPacketId = PacketIdRange;
        }

        // ì „ì†¡ëœ outgoing bunchë“¤ì„ ì œê±°í•©ë‹ˆë‹¤. ::SendBunchì— ì „ë‹¬ëœ ê²ƒì€ ì œì™¸í•©ë‹ˆë‹¤
        // - ì´ëŠ” ::SendBunchì— ì „ë‹¬ëœ ê²ƒì€ í˜¸ì¶œìì˜ ì±…ì„ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. OutgoingBunchesì˜ ë‹¤ë¥¸ bunchë“¤ì€
        //   partial bunchë¥¼ ìœ„í•´ ì´ í•¨ìˆ˜ì—ì„œ í• ë‹¹ë˜ì—ˆê±°ë‚˜, íŒ¨í‚¤ì§€ ë§µì—ì„œ ê°€ì ¸ì˜¨ ê²ƒìœ¼ë¡œ ìš°ë¦¬ê°€ ì œê±°í•´ì•¼ í•©ë‹ˆë‹¤
        // ì´ í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•œ 'Bunch'ë¥¼ ì œì™¸í•œ OutgoingBunchesëŠ” ì´ë¯¸ send-bufferì— ì§ë ¬í™”ë˜ì—ˆìŠµë‹ˆë‹¤
        // - ì‚­ì œí•´ë„ ì™„ì „íˆ "ê´œì°®ìœ¼ë©°" ì‚­ì œë˜ì–´ì•¼ í•©ë‹ˆë‹¤!
        // PrepBunch()ì— ì˜í•´ ìƒˆë¡œ ìƒì„±ëœ bunchë“¤ì€ ì±„ë„ì— ë‚¨ì•„ìˆìŠµë‹ˆë‹¤
        for (auto It = OutgoingBunches.CreateIterator(); It; ++It)
        {
            FOutBunch* DeleteBunch = *It;
            if (DeleteBunch != Bunch)
                delete DeleteBunch;
        }

        return PacketIdRange;
    }
```