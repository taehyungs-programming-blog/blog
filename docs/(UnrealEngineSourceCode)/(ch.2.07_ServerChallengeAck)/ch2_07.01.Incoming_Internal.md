---
layout: default
title: "07-01. Incoming_Internal"
parent: "([Network] 07. ServerChallengeAck)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** internal handling for incoming/incomingconnectionless */


// [ServerChallengeAck]
// it is very confusing right?
// - in other words, PacketHandler::Incoming_Internal is very IMPORTANT function!

// ë§¤ìš° í˜¼ë€ìŠ¤ëŸ½ì£ ?
// - ë‹¤ì‹œ ë§í•´ì„œ, PacketHandler::Incoming_Internalì€ ë§¤ìš° ì¤‘ìš”í•œ í•¨ìˆ˜ì…ë‹ˆë‹¤!
EIncomingResult Incoming_Internal(FReceivedPacketView& PacketView)
{
    EIncomingResult ReturnVal = EIncomingResult::Success;
    FPacketDataView& DataView = PacketView.DataView;
    int32 CountBits = DataView.NumBits();

    // [ServerInitialSendPacket]
    // the below code is about shrinking Bits as much as we can
    // - also we verify the invalid packet simply
    // - do you remember we received packet from FPacketIterator in form of 'Bytes'?
    //   - we fit the data in form of 'Bits' here
    // - the below code is **NOT** important to understand the overall code flow
    // - let's look through the code briefly

    // ì•„ë˜ ì½”ë“œëŠ” ê°€ëŠ¥í•œ í•œ ë§ì€ Bitsë¥¼ ì¤„ì´ëŠ” ê²ƒì— ê´€í•œ ê²ƒì…ë‹ˆë‹¤
    // - ë˜í•œ ìœ íš¨í•˜ì§€ ì•Šì€ íŒ¨í‚·ì„ ê°„ë‹¨íˆ í™•ì¸í•©ë‹ˆë‹¤
    // - FPacketIteratorì—ì„œ 'Bytes' í˜•íƒœë¡œ íŒ¨í‚·ì„ ë°›ì•˜ë˜ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    //   - ì—¬ê¸°ì„œëŠ” ë°ì´í„°ë¥¼ 'Bits' í˜•íƒœë¡œ ë§ì¶¥ë‹ˆë‹¤
    // - ì•„ë˜ ì½”ë“œëŠ” ì „ì²´ ì½”ë“œ íë¦„ì„ ì´í•´í•˜ëŠ”ë° ì¤‘ìš”í•˜ì§€ **ì•ŠìŠµë‹ˆë‹¤**
    // - ì½”ë“œë¥¼ ê°„ë‹¨íˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤
    if (HandlerComponents.Num() > 0)
    {
        const uint8* DataPtr = DataView.GetData();
        uint8 LastByte = (UNLIKELY(DataPtr == nullptr)) ? 0 : DataPtr[DataView.NumBytes()-1];
        if (LastByte != 0)
        {
            // what is the meaning of 0x80?
            // - we already seen '0x80' in GShift
            // - 0x80 == 10000000(2) == 128(2^7)
            // - 'while(!(LastByte & 0x80))' means that we iterates bits until we reach valid 7-th bit value
            // - we substract early for 0x80 case
            // - '*= 2' is same as '<<= 1'

            // 0x80ì˜ ì˜ë¯¸ëŠ” ë¬´ì—‡ì¼ê¹Œìš”?
            // - ìš°ë¦¬ëŠ” ì´ë¯¸ GShiftì—ì„œ '0x80'ì„ ë³´ì•˜ìŠµë‹ˆë‹¤
            // - 0x80 == 10000000(2) == 128(2^7)
            // - 'while(!(LastByte & 0x80))'ëŠ” ìœ íš¨í•œ 7ë²ˆì§¸ ë¹„íŠ¸ ê°’ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ë¹„íŠ¸ë¥¼ ë°˜ë³µí•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤
            // - 0x80 ì¼€ì´ìŠ¤ì— ëŒ€í•´ ë¯¸ë¦¬ ëºë‹ˆë‹¤
            // - '*= 2'ëŠ” '<<= 1'ê³¼ ê°™ìŠµë‹ˆë‹¤
            CountBits--;
            while (!(LastByte & 0x80))
            {
                LastByte *= 2;
                CountBits--;
            }
        }
        else
        {
            PacketView.DataView = {nullptr, 0, ECountUnits::Bits};
            ReturnVal = EIncomingResult::Error;
        }
    }

    if (ReturnVal == EIncomingResult::Success)
    {
        FBitReader ProcessedPacketReader(DataView.GetMutableData(), CountBits);
        FIncomingPacketRef PacketRef = {ProcessedPacketReader, PacketView.Address, PacketView.Traits};

        for (int32 i = HandlerComponents.Num() - 1; i >= 0; --i)
        {
            HandlerComponent& CurComponent = *HandlerComponents[i];
            if (CurComponent.IsActive() && !ProcessedPacketReader.IsError() && ProcessedPacketReader.GetBitsLeft() > 0)
            {
                // [ServerInitialSendPacket]
                // we marked bConnectionlessPacket as 'true' in PacketHandler::IncomingConnectionless

                // PacketHandler::IncomingConnectionlessì—ì„œ bConnectionlessPacketì„ 'true'ë¡œ í‘œì‹œí–ˆìŠµë‹ˆë‹¤
                if (PacketView.Traits.bConnectionlessPacket)
                {
                    CurComponent.IncomingConnectionless(PacketRef);
                }
                else
                {
                    CurComponent.Incoming(PacketRef);
                }
            }
        }

        // 031 - Networking - ServerInitialSendPacket *
        // we override ProcessedPacketReader in PacketHandler::IncomingPacket
        // - we processed all handshake packet, so PacketView.DataView's data is null (size == 0)

        // PacketHandler::IncomingPacketì—ì„œ ProcessedPacketReaderë¥¼ ì¬ì •ì˜í•©ë‹ˆë‹¤
        // - ëª¨ë“  í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì„ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ PacketView.DataViewì˜ ë°ì´í„°ëŠ” nullì…ë‹ˆë‹¤ (í¬ê¸° == 0)
        if (!ProcessedPacketReader.IsError())
        {
            ReplaceIncomingPacket(ProcessedPacketReader);
            PacketView.DataView = {IncomingPacket.GetData(), (int32)IncomingPacket.GetBitsLeft(), ECountBits::Bits};
        }
    }

    return ReturnVal;
}
```

