---
layout: default
title: "([Network] 07. ServerChallengeAck)"
parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
has_children: true
nav_order: 3
---

```cpp
virtual void IncomingConnectionless(FIncomingPacketRef PacketRef) override
{
    FBitReader& Packet = PacketRef.Packet;

    
    // in ServerInitialSendPacket, 'Address' will be the client who try to connect
    // ServerInitialSendPacketì—ì„œ 'Address'ëŠ” ì—°ê²°ì„ ì‹œë„í•˜ëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ ë  ê²ƒì…ë‹ˆë‹¤

    const TSharedPtr<const FInternetAddr> Address = PacketRef.Address;

    
    // the below code is deserialize the received packet
    // ì•„ë˜ ì½”ë“œëŠ” ìˆ˜ì‹ ëœ íŒ¨í‚·ì„ ì—­ì§ë ¬í™”í•©ë‹ˆë‹¤

    if (MagicHeader.Num() > 0)
    {
        //...
    }

    
    // imagine how SerializeBits are called and deserialize data into SessionID and ClientID
    // SerializeBitsê°€ ì–´ë–»ê²Œ í˜¸ì¶œë˜ì–´ SessionIDì™€ ClientIDë¡œ ë°ì´í„°ë¥¼ ì—­ì§ë ¬í™”í•˜ëŠ”ì§€ ìƒìƒí•´ë³´ì„¸ìš”

    bool bHasValidSessionID = true;
    uint8 SessionID = 0;
    uint8 ClientID = 0;
    {
        Packet.SerializeBits(&SessionID, SessionIDSizeBits);
        Packet.SerializeBits(&ClientID, ClientIDSizeBits);
        bHasValidSessionID = (SessionID == CachedGlobalNetTravelCount && !Packet.IsError());
    }

    
    // do you remember we add bHandshakePacket when we make InitialPacket?
    // - see StatelessConnectHandlerComponent::BeginHandshakePacket() briefly

    // InitialPacketë¥¼ ë§Œë“¤ ë•Œ bHandshakePacketì„ ì¶”ê°€í•œ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    // - StatelessConnectHandlerComponent::BeginHandshakePacket()ì„ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”

    bool bHandshakePacket = !!Packet.ReadBit() && !Packet.IsError();
    if (bHandshakePacket)
    {
        
        // when bHandshakePacket is 'true', we deserialize the rest of handshake packet data into FParsedHandshakeData
        // bHandshakePacketì´ 'true'ì¼ ë•Œ, ìš°ë¦¬ëŠ” ë‚˜ë¨¸ì§€ í•¸ë“œì…°ì´í¬ íŒ¨í‚· ë°ì´í„°ë¥¼ FParsedHandshakeDataë¡œ ì—­ì§ë ¬í™”í•©ë‹ˆë‹¤

        FParsedHandshakeData HandshakeData;
        bHandshakePacket = ParseHandshakePacket(Packet, HandshakeData);

        if (bHandshakePacket)
        {
            EHandshakeVersion TargetVersion = EHandshakeVersion::Latest;

            
            // when HandshakePacketType is 'InitialPacket', Timestamp is '0.0'
            // - see StatelessConnectHandlerComponent::SendInitialPacket
            //   - we just add zero'ed with Filler!
            //   - so, Timestamp becomes 0.0
            // - in ServerInitialSendPacket, bInitialConnect is 'TRUE'

            // HandshakePacketTypeì´ 'InitialPacket'ì¼ ë•Œ, TimestampëŠ” '0.0'ì…ë‹ˆë‹¤
            // - StatelessConnectHandlerComponent::SendInitialPacket ì°¸ì¡°
            //   - ìš°ë¦¬ëŠ” ë‹¨ìˆœíˆ Fillerë¡œ 0ì„ ì¶”ê°€í•©ë‹ˆë‹¤!
            //   - ë”°ë¼ì„œ TimestampëŠ” 0.0ì´ ë©ë‹ˆë‹¤
            // - ServerInitialSendPacketì—ì„œ bInitialConnectëŠ” 'TRUE'ì…ë‹ˆë‹¤

            const bool bInitialConnect = HandshakeData.HandshakePacketType == EHandshakePacketType::InitialPacket && HandshakeData.Timestamp == 0.0;
            if (Handler->Mode == UE::Handler::Mode::Server && (bHasValidSessionID || bInitialConnect))
            {
                
                // note that we are handling server-side logic, so PacketHandler::Mode is Mode::Server
                // - as we saw, bInitialConnect is 'TRUE' for ***ServerInitialSendPacket***
                
                // ìš°ë¦¬ê°€ ì„œë²„ ì¸¡ ë¡œì§ì„ ì²˜ë¦¬í•˜ê³  ìˆë‹¤ëŠ” ì ì— ì£¼ëª©í•˜ì„¸ìš”, ë”°ë¼ì„œ PacketHandler::ModeëŠ” Mode::Serverì…ë‹ˆë‹¤
                // - ìš°ë¦¬ê°€ ë´¤ë“¯ì´, ***ServerInitialSendPacket***ì—ì„œ bInitialConnectëŠ” 'TRUE'ì…ë‹ˆë‹¤

                if (bInitialConnect)
                {
                    SendConnectChallenge(FCommonSendToClientParams(Address, TargetVersion, ClientID), HandshakeData.RemoteSentHandshakePacketCount);

                }
                // challenge response
                
                // as the response of 'ChallengeResponse', the server prepare the packet, 'ChallengeAck'
                // - if we are in this stage, we can think of it as "the server identifies and verifies client as belivable"
                // 'ChallengeResponse'ì— ëŒ€í•œ ì‘ë‹µìœ¼ë¡œ, ì„œë²„ëŠ” 'ChallengeAck' íŒ¨í‚·ì„ ì¤€ë¹„í•©ë‹ˆë‹¤
                // - ìš°ë¦¬ê°€ ì´ ë‹¨ê³„ì— ìˆë‹¤ë©´, "ì„œë²„ê°€ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê²ƒìœ¼ë¡œ ì‹ë³„í•˜ê³  í™•ì¸í•œë‹¤"ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

                else if (Driver != nullptr)
                {
                    // NOTE: allow CookieDelta to be 0.0, as it is possible for a server to send a challenge and receive a response during the same tick
                    // ì°¸ê³ : ì„œë²„ê°€ ë™ì¼í•œ í‹± ë™ì•ˆ ì±Œë¦°ì§€ë¥¼ ë³´ë‚´ê³  ì‘ë‹µì„ ë°›ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ CookieDeltaê°€ 0.0ì´ ë  ìˆ˜ ìˆë„ë¡ í—ˆìš©í•©ë‹ˆë‹¤

                    bool bChallengeSuccess = false;
                    
                    
                    // verify 'Cookie' and 'Secret' is in valid time-range
                    // - LastSecretUpdateTimestampe is updated in StatelessConnectHandlerComponent::UpdateSecret
                    // - MAX_COOKIE_LIFETIME == 30s
                    // 'Cookie'ì™€ 'Secret'ì´ ìœ íš¨í•œ ì‹œê°„ ë²”ìœ„ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤
                    // - LastSecretUpdateTimestampëŠ” StatelessConnectHandlerComponent::UpdateSecretì—ì„œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤
                    // - MAX_COOKIE_LIFETIME == 30ì´ˆ

                    const double CookieDelta = Driver->GetElapsedTime() - HandshakeData.Timestamp;
                    const double SecretDelta = HandshakeData.Timestamp - LastSecretUpdateTimestamp;
                    const bValidCookieLifetime = CookieDelta >= 0.0 && (MAX_COOKIE_LIFETIME - CookieDelta) > 0.0;
                    const bValidSecretIdTimestamp = (HandshakeData.SecretId == ActiveSecret) ? (SecretDelta >= 0.0) : (SecretDelta <= 0.0);
                    if (bValidCookieLifetime && bValidSecretIdTimestamp)
                    {
                        // regenerate the cookie from the packet info, and see if the received cookie matches the regenerated one
                        // verify Cookie with server's information
                        // - Address + Timestamp + SecretId == Content
                        // - SHA1(Content) == RegenCookie
                        // íŒ¨í‚· ì •ë³´ì—ì„œ ì¿ í‚¤ë¥¼ ì¬ìƒì„±í•˜ê³ , ìˆ˜ì‹ ëœ ì¿ í‚¤ê°€ ì¬ìƒì„±ëœ ì¿ í‚¤ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤
                        // ì„œë²„ì˜ ì •ë³´ë¡œ Cookieë¥¼ í™•ì¸í•©ë‹ˆë‹¤
                        // - Address + Timestamp + SecretId == Content
                        // - SHA1(Content) == RegenCookie

                        uint8 RegenCookie[COOKIE_BYTE_SIZE];
                        GenerateCookie(Address, HandshakeData.SecretId, HandshakeData.Timestamp, RegenCookie);
                        
                        // compare RegenCookie and HandshakeData.Cookie with memcmp:
                        // - if values are same, memcmp() returns '0'!
                        
                        // RegenCookieì™€ HandshakeData.Cookieë¥¼ memcmpë¡œ ë¹„êµí•©ë‹ˆë‹¤:
                        // - ê°’ì´ ê°™ë‹¤ë©´, memcmp()ëŠ” '0'ì„ ë°˜í™˜í•©ë‹ˆë‹¤!

                        bChallengeSuccess = FMemory::Memcmp(HandshakeData.Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0;
                        if (bChallengeSuccess)
                        {
                            // we are NOT interested in 'RestartHandshake' in this course (I'll leave it to you~^^)
                            // ì´ ê³¼ì •ì—ì„œëŠ” 'RestartHandshake'ì— ê´€ì‹¬ì´ ì—†ìŠµë‹ˆë‹¤ (ì—¬ëŸ¬ë¶„ì—ê²Œ ë§¡ê¸°ê² ìŠµë‹ˆë‹¤~^^)

                            if (HandshakeData.bRestartHandshake)
                            {
                                //...
                            }
                            else
                            {
                                // do you remember how we set ServerSequence/ClientSequence when handling 'Challenge' packet in client-side?
                                // - the server retrieve sequence numbers for 'server' and 'client' in the exact same way of what the client did
                                // - (CurSequence + 1) is not arithmatic adding but pointer adding!
                                // í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œ 'Challenge' íŒ¨í‚·ì„ ì²˜ë¦¬í•  ë•Œ ServerSequence/ClientSequenceë¥¼ ì–´ë–»ê²Œ ì„¤ì •í–ˆëŠ”ì§€ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
                                // - ì„œë²„ëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ í•œ ê²ƒê³¼ ì •í™•íˆ ê°™ì€ ë°©ì‹ìœ¼ë¡œ 'server'ì™€ 'client'ì˜ ì‹œí€€ìŠ¤ ë²ˆí˜¸ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤
                                // - (CurSequence + 1)ì€ ì‚°ìˆ  ë§ì…ˆì´ ì•„ë‹ˆë¼ í¬ì¸í„° ë§ì…ˆì…ë‹ˆë‹¤!

                                int16* CurSequence = (int16*)HandshakeData.Cookie;
                                LastServerSequence = *CurSequence & (MAX_PACKETID - 1);
                                LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1);

                                // we store Cookie as AuthorizedCookie for this client connection request (for debugging purpose)
                                // ì´ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìš”ì²­ì— ëŒ€í•´ Cookieë¥¼ AuthorizedCookieë¡œ ì €ì¥í•©ë‹ˆë‹¤ (ë””ë²„ê¹… ëª©ì )

                                FMemory::Memcpy(AuthorisedCookie, HandshakeData.Cookie, UE_ARRAY_COUNT(AuthorisedCookie));
                            }

                            // bRestartedHandshake is 'FALSE'
                            // - we cache LastChallengeSuccessAddress with 'Address' from the received packet
                            // *** remember that we update 'LastChallengeSuccessAddress' with 'Address(Client)'
                            //     - it is the indicator which represents the success of Challenge between server and client
                            // bRestartedHandshakeëŠ” 'FALSE'ì…ë‹ˆë‹¤
                            // - ìš°ë¦¬ëŠ” ìˆ˜ì‹ ëœ íŒ¨í‚·ì˜ 'Address'ë¡œ LastChallengeSuccessAddressë¥¼ ìºì‹œí•©ë‹ˆë‹¤
                            // *** 'LastChallengeSuccessAddress'ë¥¼ 'Address(Client)'ë¡œ ì—…ë°ì´íŠ¸í•œë‹¤ëŠ” ê²ƒì„ ê¸°ì–µí•˜ì„¸ìš”
                            //     - ì´ëŠ” ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ê°„ì˜ Challenge ì„±ê³µì„ ë‚˜íƒ€ë‚´ëŠ” ì§€í‘œì…ë‹ˆë‹¤

                            bRestartedHandshake = HandshakeData.bRestartHandshake;
                            LastChallengeSuccessAddress = Address->Clone();
                            CachedClientID = ClientID;

                            // now ack the challenge response - the cookie is stored in AuthorizedCookie, to enable retries
                            // send 'challenge ack' to the client
                            
                            // ì´ì œ challenge responseë¥¼ í™•ì¸í•©ë‹ˆë‹¤ - ì¬ì‹œë„ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ê¸° ìœ„í•´ ì¿ í‚¤ëŠ” AuthorizedCookieì— ì €ì¥ë©ë‹ˆë‹¤
                            // í´ë¼ì´ì–¸íŠ¸ì—ê²Œ 'challenge ack'ë¥¼ ë³´ëƒ…ë‹ˆë‹¤
                            

                            SendChallengeAck(FCommonSendToClientParams(Address, TargetVersion, ClientID),
                                HandshakeData.RemoteSentHandshakePacketCount, AuthorizedCookie);
                        }
                    }
                }
            }
        }
    }
}
```