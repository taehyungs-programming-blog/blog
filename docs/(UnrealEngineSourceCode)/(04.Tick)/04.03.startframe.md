---
layout: default
title: "03. StartFrame"
parent: "(04.Tick ë¶„ì„)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* Frameì˜ ì‹œì‘ ì 
* ë“¤ì–´ê°€ê¸° ì „ FTickTaskManagerì— ëŒ€í•´ ë¨¼ì € ì´í•´ í•˜ê³  ê°€ì

## FTickTaskManager

```cpp
class FTickTaskManager : public FTickTaskManagerInterface
{
    // ...

    // FTickTaskManagerì˜ ìŠ¤ì¼€ì¥´ëŸ¬
    FTickTaskSequencer& TickTaskSequencer;

    TArray<FTickTaskLevel*> LevelList;

    /** tick context */
    FTickContext Context;

    /** true during the tick phase, when true, tick function adds also go to the newly spawned list */
    bool bTickNewlySpawned;
}
```

---

## StartFrame

```cpp
virtual void StartFrame(UWorld* InWorld, float InDeltaSeconds, ELevelTick InTickType, const TArray<ULevel*>& LevelsToTick) override
{
    Context.TickGroup = ETickingGroup(0); // reset this to the start tick group
    Context.DeltaSeconds = InDeltaSeconds;
    Context.TickType = InTickType;
    
    Context.Thread = ENamedThreads::GameThread;
    Context.World = InWorld;

    TickTaskSequencer.StartFrame();

    FillLevelList(LevelsToTick);

    int32 TotalTickFunctions = 0;
    for (int32 LevelIndex = 0; LevelIndex < LevelList.Num(); LevelIndex++)
    {
        TotalTickFunctions += LevelList[LevelIndex]->StartFrame(Context);
    }

    for (int32 LevelIndex = 0; LevelIndex < LevelList.Num(); LevelIndex++)
    {
        LevelList[LevelIndex]->QueueAllTicks();
    }
}
```