---
layout: default
title: "05. RunTickGroup"
parent: "(04.Tick ë¶„ì„)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
virtual void RunTickGroup(ETickingGroup Group, bool bBlockTillComplete) override
{
    TickTaskSequencer.ReleaseTickGroup(Group, bBlockTillComplete);

    Context.TickGroup = ETickingGroup(Context.TickGroup + 1);

    // ...
}
```

```cpp
void ReleaseTickGroup(ETickingGroup WorldTickGroup, bool bBlockTillComplete)
{
    {
        if (CVarAllowAsyncTickDispatch.GetValueOnGameThread() == 0)
        {
            DispatchTickGroup(ENamedThreads::GameThread, WorldTickGroup);
        }
        else
        {
            FTaskGraphInterface::Get().WaitUntilTaskCompletes(
                TGraphTask<FDipatchTickGroupTask>::CreateTask(nullptr, ENamedThreads::GameThread).ConstructAndDispatchWhenReady(*this, WorldTickGroup));
        }
    }

    if (bBlockTillComplete)
    {
        for (ETickingGroup Block = WaitForTickGroup; Block <= WorldTickGroup; Block = ETickingGroup(Block + 1))
        {
            if (TickCompletionEvents[Block].Num())
            {
                FTaskGraphInterface::Get().WaitUntilTasksComplete(TickCompletionEvents[Block],  ENamedThreads::GameThread);

                if (Block == TG_NewlySpawned || TickCompletionEvents[Block].Num() < 50)
                {
                    ResetTickGroup(Block);
                }
                else
                {
                    CleanupTasks.Add(TGraphTask<FResetTickGroupTask>::CreateTask(nullptr, ENamedThreads::GameThread).ConstructAndDispatchWhenReady(*this, Block));
                }
            }
        }
        // don't advance for newly spawned
        WaitForTickGroup = ETickingGroup(WorldTickGroup + (WorldTickGroup == TG_NewlySpawned ? 0 : 1)); 
    }
    else
    {
        // Diagram:                                                                                     
        //    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” 
        //    â”‚TickFunction4â—„â”€â”€â”€â”€â”€â”€â”€â”¤TickFunction3â—„â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¤TickFunction1â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¤TickFunction0â”‚ 
        //    â”‚ bAnyThread: â”‚       â”‚ bAnyThread: â”‚    â”‚    â”‚ bAnyThread: â”‚        â”‚ bAnyThread: â”‚ 
        //    â”‚   False     â”‚       â”‚   False     â”‚    â”‚    â”‚   False     â”‚        â”‚   False     â”‚ 
        //    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 
        //                                             â”‚                                           
        //                                             â”‚                                           
        //                                             â”‚                                           
        //                                             â”‚                                           
        //                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                                           
        //                          â”‚TickFunction2â—„â”€â”€â”€â”€â”˜                                           
        //                          â”‚ bAnyThread: â”‚                                                
        //                          â”‚ **True**    â”‚                                                
        //                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                

        FTaskGraphInterface::Get().ProcessThreadUntilIdle(ENamedThreads::GameThread);
    }
}
```