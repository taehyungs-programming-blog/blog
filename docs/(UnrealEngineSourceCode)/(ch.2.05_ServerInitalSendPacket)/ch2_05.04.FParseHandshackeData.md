---
layout: default
title: "05-04. FParsedHandshakeData"
parent: "([Network] 05. ServerInitalSendPacket)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** handshake data parsed from a packet */
// íŒ¨í‚·ì—ì„œ íŒŒì‹±ëœ í•¸ë“œì…°ì´í¬ ë°ì´í„°

// see the member variables briefly, remembering what data are pushed by SendInitialPacket
// SendInitialPacketì—ì„œ ì–´ë–¤ ë°ì´í„°ê°€ í‘¸ì‹œë˜ì—ˆëŠ”ì§€ ê¸°ì–µí•˜ë©´ì„œ ë©¤ë²„ ë³€ìˆ˜ë“¤ì„ ê°„ë‹¨íˆ ì‚´í´ë³´ì„¸ìš”

//   - this variable (or data) is important to catch what the progression of handshake is
//   - ì´ ë³€ìˆ˜(ë˜ëŠ” ë°ì´í„°)ëŠ” í•¸ë“œì…°ì´í¬ì˜ ì§„í–‰ ìƒí™©ì„ íŒŒì•…í•˜ëŠ” ë° ì¤‘ìš”í•©ë‹ˆë‹¤
struct FParsedHandshakeData
{
    /** the minimum supported handshake protocol version of the remote side */
    // ì›ê²© ì¸¡ì˜ ìµœì†Œ ì§€ì› í•¸ë“œì…°ì´í¬ í”„ë¡œí† ì½œ ë²„ì „
    EHandshakeVersion RemoteMinVersion = EHandshakeVersion::Latest;

    /** the current handshake protocol version the remote side used for communication */
    // ì›ê²© ì¸¡ì´ í†µì‹ ì— ì‚¬ìš©í•œ í˜„ì¬ í•¸ë“œì…°ì´í¬ í”„ë¡œí† ì½œ ë²„ì „
    EHandshakeVersion RemoteCurVersion = EHandshakeVersion::Latest;

    /** the network CL version of the remote side */
    // ì›ê²© ì¸¡ì˜ ë„¤íŠ¸ì›Œí¬ CL ë²„ì „
    uint32 RemoteNetworkVersion = 0;

    /** the net runtime features of the remote side */
    // ì›ê²© ì¸¡ì˜ ë„¤íŠ¸ì›Œí¬ ëŸ°íƒ€ì„ ê¸°ëŠ¥
    EEngineNetworkRuntimeFeatures RemoteNetworkFeatures;

    /** the type of handshake packet */
    // í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì˜ ìœ í˜•
    EHandshakePacketType HandshakePacketType = EHandshakePacketType::InitialPacket;

    /** the remote value of 'SentHandshakePacketCount' */
    // ì›ê²© ì¸¡ì˜ 'SentHandshakePacketCount' ê°’
    uint8 RemoteSentHandshakePacketCount = 0;

    /** whether or not this packet is a restart handshake packet */
    // ì´ íŒ¨í‚·ì´ ì¬ì‹œì‘ í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì¸ì§€ ì—¬ë¶€
    bool bRestartHandshake = false;

    /** which of the two serverside HandshakeSecret values this is based on */
    // ì´ê²ƒì´ ì„œë²„ ì¸¡ ë‘ HandshakeSecret ê°’ ì¤‘ ì–´ëŠ ê²ƒì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ”ì§€
    uint8 SecretId = 0;

    /** the server timestamp, from the moment the challenge was sent (or 0.f if from the client) */
    // ì„œë²„ íƒ€ì„ìŠ¤íƒ¬í”„, ì±Œë¦°ì§€ê°€ ì „ì†¡ëœ ìˆœê°„ë¶€í„° (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì˜¨ ê²½ìš° 0.f)
    double Timestamp = 0.0;

    /** a unique identifier, generated by the server, which the client must reply with (or 0, for initial packet) */
    // ì„œë²„ì—ì„œ ìƒì„±í•œ ê³ ìœ  ì‹ë³„ì, í´ë¼ì´ì–¸íŠ¸ê°€ ì´ì— ì‘ë‹µí•´ì•¼ í•¨ (ì´ˆê¸° íŒ¨í‚·ì˜ ê²½ìš° 0)
    uint8 Cookie[COOKIE_BYTE_SIZE] = {};

    /** if this is a restart handshake challenge response, this is the original handshake's cookie */
    // ì´ê²ƒì´ ì¬ì‹œì‘ í•¸ë“œì…°ì´í¬ ì±Œë¦°ì§€ ì‘ë‹µì¸ ê²½ìš°, ì´ëŠ” ì›ë˜ í•¸ë“œì…°ì´í¬ì˜ ì¿ í‚¤ì…ë‹ˆë‹¤
    uint8 OrigCookie[COOKIE_BYTE_SIZE] = {};
};
```