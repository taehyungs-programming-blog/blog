---
layout: default
title: "05-01. TickDispatch"
parent: "([Network] 05. ServerInitalSendPacket)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** handle time update; read and process packets */
// ì‹œê°„ ì—…ë°ì´íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê³  íŒ¨í‚·ì„ ì½ê³  ì²˜ë¦¬í•©ë‹ˆë‹¤
virtual void TickDispatch(float DeltaTime) override
{
    //...

    for (FPacketIterator It(this); It; ++It)
    {
        // if we are in this scope, we successfully get a single packet from the socket
        // - by calling FPacketIterator::GetCurrentPacket(), we can retrieve packet data into FReceivedPacketView
        // ì´ ë²”ìœ„ì— ìˆë‹¤ë©´, ì†Œì¼“ì—ì„œ ë‹¨ì¼ íŒ¨í‚·ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì˜¨ ê²ƒì…ë‹ˆë‹¤
        // - FPacketIterator::GetCurrentPacket()ì„ í˜¸ì¶œí•˜ì—¬ íŒ¨í‚· ë°ì´í„°ë¥¼ FReceivedPacketViewë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
        FReceivedPacketView ReceivedPacket;
        FInPacketTraits& ReceivedTraits = ReceivedPacket.Traits;
        bool bOk = It.GetCurrentPacket(ReceivedPacket);

        // retrieve 'FromAddr(client address)' or 'FromAddr(server address)'
        // 'FromAddr(í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œ)' ë˜ëŠ” 'FromAddr(ì„œë²„ ì£¼ì†Œ)'ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤
        const TSharedRef<const FInternetAddr> FromAddr = ReceivedPacket.Address.ToSharedRef();

        UNetConnection* Connection = nullptr;
        UIpConnection* const MyServerConnection = GetServerConnection();

        // figure out which socket the received data came from
        // ìˆ˜ì‹ ëœ ë°ì´í„°ê°€ ì–´ëŠ ì†Œì¼“ì—ì„œ ì™”ëŠ”ì§€ íŒŒì•…í•©ë‹ˆë‹¤

        // [ServerInitialSendPacket]
        // if we have valid ServerConnection, the current TickDispatch is for client-side
        // - as client-side connection, we just try to only receive any packet from the 'server'
        // - so, we compare the received packet's address and RemoteAddr(server address)
        // - and if it is matched, we set our connection as 'MyServerConnection'
        // - but, for now server-side, ServerConnection is null!

        // [ServerInitialSendPacket]
        // ìœ íš¨í•œ ServerConnectionì´ ìˆë‹¤ë©´, í˜„ì¬ TickDispatchëŠ” í´ë¼ì´ì–¸íŠ¸ ì¸¡ì„ ìœ„í•œ ê²ƒì…ë‹ˆë‹¤
        // - í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì—°ê²°ë¡œì„œ, ìš°ë¦¬ëŠ” 'ì„œë²„'ë¡œë¶€í„° ì˜¤ëŠ” ëª¨ë“  íŒ¨í‚·ë§Œ ìˆ˜ì‹ í•˜ë ¤ê³  í•©ë‹ˆë‹¤
        // - ë”°ë¼ì„œ, ìˆ˜ì‹ ëœ íŒ¨í‚·ì˜ ì£¼ì†Œì™€ RemoteAddr(ì„œë²„ ì£¼ì†Œ)ë¥¼ ë¹„êµí•©ë‹ˆë‹¤
        // - ê·¸ë¦¬ê³  ì¼ì¹˜í•œë‹¤ë©´, ìš°ë¦¬ì˜ ì—°ê²°ì„ 'MyServerConnection'ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤
        // - í•˜ì§€ë§Œ, ì§€ê¸ˆì€ ì„œë²„ ì¸¡ì´ë¯€ë¡œ ServerConnectionì€ nullì…ë‹ˆë‹¤!

        if (MyServerConnection)
        {
            // ...
        }

        if (Connection == nullptr)
        {
            // [ServerInitialSendPacket]
            // server-side logic: try to find constructed connections from 'MappedClientConnections'
            // - note that server has connected client-connections
            // - the server distinguish client connection by 'FromAddr'

            // [ServerInitialSendPacket]
            // ì„œë²„ ì¸¡ ë¡œì§: 'MappedClientConnections'ì—ì„œ êµ¬ì„±ëœ ì—°ê²°ì„ ì°¾ìœ¼ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤
            // - ì„œë²„ê°€ ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ê°€ì§€ê³  ìˆë‹¤ëŠ” ì ì— ì£¼ëª©í•˜ì„¸ìš”
            // - ì„œë²„ëŠ” 'FromAddr'ë¡œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ êµ¬ë¶„í•©ë‹ˆë‹¤
            auto* Result = MappedClientConnections.Find(FromAddr);
            if (Result)
            {
                UNetConnection* ConnVal = *Result;
                if (ConnVal)
                {
                    Connection = ConnVal;
                }
            }
            // [ServerInitialSendPacket]
            // it is natural to match client-connection's RemoteAddr is client-address!
            // - server's NetConnection's RemoteAddr has client's address
            // - from the server point of view, remote means client's address and local means server address~ :)

            // [ServerInitialSendPacket]
            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì˜ RemoteAddrì´ í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œì™€ ì¼ì¹˜í•˜ëŠ” ê²ƒì€ ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤!
            // - ì„œë²„ì˜ NetConnectionì˜ RemoteAddrì€ í´ë¼ì´ì–¸íŠ¸ì˜ ì£¼ì†Œë¥¼ ê°€ì§‘ë‹ˆë‹¤
            // - ì„œë²„ ê´€ì ì—ì„œ remoteëŠ” í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œë¥¼ ì˜ë¯¸í•˜ê³  localì€ ì„œë²„ ì£¼ì†Œë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤~ :)
            check(Connection == nullptr || CastChecked<UIpConnection>(Connection)->RemoteAddr->CompareEndpoints(*FromAddr));
        }

        if (bOk == false)
        {
            // ERROR
            // ì˜¤ë¥˜
        }
        else
        {
            // if we didn't find a client connection, maybe create new one
            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ ì°¾ì§€ ëª»í–ˆë‹¤ë©´, ìƒˆë¡œìš´ ì—°ê²°ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

            // [ServerInitialSendPacket]
            // the server get the packet from not-mapped clients
            // - it is very high possibility to be the packet for connection
            // - to construct complete-client-UNetConnection, first as we saw, need to succeed on handshake

            // [ServerInitialSendPacket]
            // ì„œë²„ê°€ ë§¤í•‘ë˜ì§€ ì•Šì€ í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° íŒ¨í‚·ì„ ë°›ìŠµë‹ˆë‹¤
            // - ì—°ê²°ì„ ìœ„í•œ íŒ¨í‚·ì¼ ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤
            // - ì™„ì „í•œ í´ë¼ì´ì–¸íŠ¸-UNetConnectionì„ êµ¬ì„±í•˜ë ¤ë©´, ë¨¼ì € ìš°ë¦¬ê°€ ë³¸ ëŒ€ë¡œ í•¸ë“œì…°ì´í¬ì— ì„±ê³µí•´ì•¼ í•©ë‹ˆë‹¤

            if (Connection == nullptr)
            {
                FPacketBufferView WorkingBuffer = It.GetWorkingBuffer();
                Connection = ProcessConnectionlessPacket(ReceivedPacket, WorkingBuffer);

                // for now, 'bIngorePacket' is TRUE:
                // - ReceivedPacket.DataView.NumBytes() == 0, cuz we consume all data in the packet of handshake
                // ì§€ê¸ˆì€ 'bIgnorePacket'ì´ TRUEì…ë‹ˆë‹¤:
                // - ReceivedPacket.DataView.NumBytes() == 0, í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì†Œë¹„í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤
                bIgnorePacket = ReceivedPacket.DataView.NumBytes() == 0;
            }

            // send the packet to the connection for processing
            // ì²˜ë¦¬ë¥¼ ìœ„í•´ íŒ¨í‚·ì„ ì—°ê²°ë¡œ ë³´ëƒ…ë‹ˆë‹¤

            // it is the first time for client to be handled by FPacketIterator
            // í´ë¼ì´ì–¸íŠ¸ê°€ FPacketIteratorì— ì˜í•´ ì²˜ë¦¬ë˜ëŠ” ì²« ë²ˆì§¸ ì‹œê°„ì…ë‹ˆë‹¤
            
            if (Connection != nullptr && !bIgnorePacket)
            {
                Connection->ReceivedRawPacket((uint8*)ReceivedPacket.DataView.GetData(), ReceivedPacket.DataView.NumBytes());
            }
        }
    }
}
```