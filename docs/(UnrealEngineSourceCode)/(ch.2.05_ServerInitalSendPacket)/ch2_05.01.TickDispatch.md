---
layout: default
title: "05-01. TickDispatch"
parent: "([Network] 05. ServerInitalSendPacket)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
class UIpNetDriver : public UNetDriver
{
    // ...

/** handle time update; read and process packets */
// ì‹œê°„ ì—…ë°ì´íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê³  íŒ¨í‚·ì„ ì½ê³  ì²˜ë¦¬í•©ë‹ˆë‹¤

// most of code to process received packets are same, for now what we are interested in is "ChallengeResponse"
// - see partial code one by one:

// ëŒ€ë¶€ë¶„ì˜ ìˆ˜ì‹ ëœ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ëŠ” ì½”ë“œëŠ” ë™ì¼í•˜ë©°, í˜„ì¬ ìš°ë¦¬ê°€ ê´€ì‹¬ìˆëŠ” ê²ƒì€ "ChallengeResponse"ì…ë‹ˆë‹¤
// - ì½”ë“œë¥¼ í•˜ë‚˜ì”© ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤:

virtual void TickDispatch(float DeltaTime) override
{
    //...

    // process all incoming packets
    // finally we can have a change to see how unreal networking engine receive packets

    // ëª¨ë“  ìˆ˜ì‹  íŒ¨í‚·ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤
    // ë§ˆì¹¨ë‚´ ì–¸ë¦¬ì–¼ ë„¤íŠ¸ì›Œí‚¹ ì—”ì§„ì´ ì–´ë–»ê²Œ íŒ¨í‚·ì„ ìˆ˜ì‹ í•˜ëŠ”ì§€ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤

    for (FPacketIterator It(this); It; ++It)
    {
        // if we are in this scope, we successfully get a single packet from the socket
        // - by calling FPacketIterator::GetCurrentPacket(), we can retrieve packet data into FReceivedPacketView

        // ì´ ìŠ¤ì½”í”„ì— ìˆë‹¤ë©´, ì†Œì¼“ìœ¼ë¡œë¶€í„° ë‹¨ì¼ íŒ¨í‚·ì„ ì„±ê³µì ìœ¼ë¡œ ë°›ì•˜ë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤
        // - FPacketIterator::GetCurrentPacket()ì„ í˜¸ì¶œí•˜ì—¬ íŒ¨í‚· ë°ì´í„°ë¥¼ FReceivedPacketViewë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤

        FReceivedPacketView ReceivedPacket;
        FInPacketTraits& ReceivedTraits = ReceivedPacket.Traits;
        bool bOk = It.GetCurrentPacket(ReceivedPacket);

        // retrieve 'FromAddr(client address)' or 'FromAddr(server address)'
        // 'FromAddr(í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œ)' ë˜ëŠ” 'FromAddr(ì„œë²„ ì£¼ì†Œ)'ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤

        const TSharedRef<const FInternetAddr> FromAddr = ReceivedPacket.Address.ToSharedRef();

        UNetConnection* Connection = nullptr;
        UIpConnection* const MyServerConnection = GetServerConnection();

        // figure out which socket the received data came from
        // ìˆ˜ì‹ ëœ ë°ì´í„°ê°€ ì–´ë–¤ ì†Œì¼“ì—ì„œ ì™”ëŠ”ì§€ íŒŒì•…í•©ë‹ˆë‹¤

        // if we have valid ServerConnection, the current TickDispatch is for client-side
        // - as client-side connection, we just try to only receive any packet from the 'server'
        // - so, we compare the received packet's address and RemoteAddr(server address)
        // - and if it is matched, we set our connection as 'MyServerConnection'
        // - but, for now server-side, ServerConnection is null!

        // ìœ íš¨í•œ ServerConnectionì´ ìˆë‹¤ë©´, í˜„ì¬ TickDispatchëŠ” í´ë¼ì´ì–¸íŠ¸ ì¸¡ì…ë‹ˆë‹¤
        // - í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì—°ê²°ë¡œì„œ, 'ì„œë²„'ë¡œë¶€í„° ì˜¤ëŠ” íŒ¨í‚·ë§Œ ìˆ˜ì‹ í•˜ë ¤ê³  í•©ë‹ˆë‹¤
        // - ë”°ë¼ì„œ ìˆ˜ì‹ ëœ íŒ¨í‚·ì˜ ì£¼ì†Œì™€ RemoteAddr(ì„œë²„ ì£¼ì†Œ)ë¥¼ ë¹„êµí•©ë‹ˆë‹¤
        // - ì¼ì¹˜í•œë‹¤ë©´, ìš°ë¦¬ì˜ ì—°ê²°ì„ 'MyServerConnection'ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤
        // - í•˜ì§€ë§Œ í˜„ì¬ ì„œë²„ ì¸¡ì—ì„œëŠ” ServerConnectionì´ nullì…ë‹ˆë‹¤!

        if (MyServerConnection)
        {
            // do we have valid "MyServerConnection"?
            // - YES: for client-side, we already construct IpConnection successfully and we are ready to send/receive packet by ServerConnection
            // - we also meet the condition, 'MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr)'
            // - now we set "Connection" with "MyServerConnection" successfully in **client-side**

            // ìœ íš¨í•œ "MyServerConnection"ì´ ìˆë‚˜ìš”?
            // - ë„¤: í´ë¼ì´ì–¸íŠ¸ ì¸¡ì—ì„œëŠ” ì´ë¯¸ IpConnectionì„ ì„±ê³µì ìœ¼ë¡œ êµ¬ì„±í–ˆê³  ServerConnectionìœ¼ë¡œ íŒ¨í‚·ì„ ì†¡ìˆ˜ì‹ í•  ì¤€ë¹„ê°€ ë˜ì–´ìˆìŠµë‹ˆë‹¤
            // - 'MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr)' ì¡°ê±´ë„ ì¶©ì¡±í•©ë‹ˆë‹¤
            // - ì´ì œ **í´ë¼ì´ì–¸íŠ¸ ì¸¡**ì—ì„œ "Connection"ì„ "MyServerConnection"ìœ¼ë¡œ ì„±ê³µì ìœ¼ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤

            if (MyServerConnection->RemoteAddr->CompareEndpoints(*FromAddr))
            {
                Connection = MyServerConnection;
            }
        }

        if (Connection == nullptr)
        {
            // server-side logic: try to find constructed connections from 'MappedClientConnections'
            // - note that server has connected client-connections
            // - the server distinguish client connection by 'FromAddr'

            // ì„œë²„ ì¸¡ ë¡œì§: 'MappedClientConnections'ì—ì„œ êµ¬ì„±ëœ ì—°ê²°ì„ ì°¾ìœ¼ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤
            // - ì„œë²„ëŠ” ì—°ê²°ëœ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ë“¤ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤
            // - ì„œë²„ëŠ” 'FromAddr'ë¡œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì„ êµ¬ë¶„í•©ë‹ˆë‹¤

            auto* Result = MappedClientConnections.Find(FromAddr);
            if (Result)
            {
                UNetConnection* ConnVal = *Result;
                if (ConnVal)
                {
                    Connection = ConnVal;
                }
            }

            // it is natural to match client-connection's RemoteAddr is client-address!
            // - server's NetConnection's RemoteAddr has client's address
            // - from the server point of view, remote means client's address and local means server address~ :)

            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ì˜ RemoteAddrì´ í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œì™€ ì¼ì¹˜í•˜ëŠ” ê²ƒì€ ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤!
            // - ì„œë²„ì˜ NetConnectionì˜ RemoteAddrì€ í´ë¼ì´ì–¸íŠ¸ì˜ ì£¼ì†Œë¥¼ ê°€ì§‘ë‹ˆë‹¤
            // - ì„œë²„ ê´€ì ì—ì„œ remoteëŠ” í´ë¼ì´ì–¸íŠ¸ ì£¼ì†Œë¥¼ ì˜ë¯¸í•˜ê³  localì€ ì„œë²„ ì£¼ì†Œë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤~ :)

            check(Connection == nullptr || CastChecked<UIpConnection>(Connection)->RemoteAddr->CompareEndpoints(*FromAddr));
        }

        if (bOk == false)
        {
            // ERROR
        }
        else
        {
            // the server get the packet from not-mapped clients
            // - it is very high possibility to be the packet for connection
            // - to construct complete-client-UNetConnection, first as we saw, need to succeed on handshake

            // ì„œë²„ê°€ ë§¤í•‘ë˜ì§€ ì•Šì€ í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° íŒ¨í‚·ì„ ë°›ì•˜ìŠµë‹ˆë‹¤
            // - ì—°ê²°ì„ ìœ„í•œ íŒ¨í‚·ì¼ ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤
            // - ì™„ì „í•œ í´ë¼ì´ì–¸íŠ¸-UNetConnectionì„ êµ¬ì„±í•˜ê¸° ìœ„í•´ì„œëŠ”, ìš°ë¦¬ê°€ ë´¤ë“¯ì´, ë¨¼ì € í•¸ë“œì…°ì´í¬ê°€ ì„±ê³µí•´ì•¼ í•©ë‹ˆë‹¤

            if (Connection == nullptr)
            {
                FPacketBufferView WorkingBuffer = It.GetWorkingBuffer();
                Connection = ProcessConnectionlessPacket(ReceivedPacket, WorkingBuffer);

                // for now, 'bIngorePacket' is TRUE:
                // - ReceivedPacket.DataView.NumBytes() == 0, cuz we consume all data in the packet of handshake

                // í˜„ì¬, 'bIgnorePacket'ì€ TRUEì…ë‹ˆë‹¤:
                // - ReceivedPacket.DataView.NumBytes() == 0, í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì˜ ëª¨ë“  ë°ì´í„°ë¥¼ ì†Œë¹„í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤

                bIgnorePacket = ReceivedPacket.DataView.NumBytes() == 0;
            }

            // send the packet to the connection for processing
            // it is the first time for client to be handled by FPacketIterator

            // ì²˜ë¦¬ë¥¼ ìœ„í•´ íŒ¨í‚·ì„ ì—°ê²°ë¡œ ë³´ëƒ…ë‹ˆë‹¤
            // í´ë¼ì´ì–¸íŠ¸ê°€ FPacketIteratorì— ì˜í•´ ì²˜ë¦¬ë˜ëŠ” ì²« ë²ˆì§¸ ì‹œì ì…ë‹ˆë‹¤

            if (Connection != nullptr && !bIgnorePacket)
            {
                Connection->ReceivedRawPacket((uint8*)ReceivedPacket.DataView.GetData(), ReceivedPacket.DataView.NumBytes());
            }
        }
    }
}
```