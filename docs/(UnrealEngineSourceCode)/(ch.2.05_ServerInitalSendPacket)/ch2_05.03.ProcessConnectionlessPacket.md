---
layout: default
title: "05-03. ProcessConnectionlessPacket"
parent: "([Network] 05. ServerInitalSendPacket)"
grand_parent: "(UE SourceCode ë¶„ì„ ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
/** process packets not associated with a NetConnection, performing handshaking and NetConnection creation or remapped as necessary */
// NetConnectionê³¼ ì—°ê´€ë˜ì§€ ì•Šì€ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ê³ , í•„ìš”ì— ë”°ë¼ í•¸ë“œì…°ì´í‚¹ ë° NetConnection ìƒì„± ë˜ëŠ” ì¬ë§¤í•‘ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

// this function is only called in server-side
// ì´ í•¨ìˆ˜ëŠ” ì„œë²„ ì¸¡ì—ì„œë§Œ í˜¸ì¶œë©ë‹ˆë‹¤
UNetConnection* ProcessConnectionlessPacket(FReceivedPacketView& PacketRef, const FPacketBufferView& WorkingBuffer)
{
    UNetConnection* ReturnVal = nullptr;
    TSharedPtr<StatelessConnectHandlerComponent> StatelessConnect;

    // in this course, we are NOT dealing with 'RestartHandshake'
    // ì´ ê³¼ì •ì—ì„œëŠ” 'RestartHandshake'ë¥¼ ë‹¤ë£¨ì§€ ì•ŠìŠµë‹ˆë‹¤
    bool bRestartedHandshake = false;

    // focus on these two variables
    // ì´ ë‘ ë³€ìˆ˜ì— ì§‘ì¤‘í•˜ì„¸ìš”
    bool bPassedChallenge = false;
    bool bIgnorePacket = true;

    // for handling "initialpacket" for requesting connection to the server, it will get into this statement
    // ì„œë²„ì— ì—°ê²°ì„ ìš”ì²­í•˜ëŠ” "initialpacket"ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì´ êµ¬ë¬¸ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤
    if (Notify != nullptr && ConnectionlessHandler.IsValid() && StatelessConnectComponent.IsValid())
    {
        // ConnectionlessHandler is 'PacketHandler'
        // ConnectionlessHandlerëŠ” 'PacketHandler'ì…ë‹ˆë‹¤

        StatelessConnect = ConnectionlessHandler.Pin();
        EIncomingResult Result = ConnectionlessHandler->IncomingConnectionless(PacketRef);
        if (Result == EIncomingResult::Success)
        {
            // we just send 'ConnectChanllenge' packet
            // ìš°ë¦¬ëŠ” ë°©ê¸ˆ 'ConnectChallenge' íŒ¨í‚·ì„ ë³´ëƒˆìŠµë‹ˆë‹¤
            
            // - for now, we failed to pass 'challenge' yet
            // - ì§€ê¸ˆì€ ì•„ì§ 'challenge'ë¥¼ í†µê³¼í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
            
            bPassedChallenge = StatelessConnect->HasPassedChallenge(Address, bRestartedHandshake);
            if (bPassedChallenge)
            {
                int32 NewCountBytes = PacketRef.DataView.NumBytes();
                uint8* WorkingData = WorkingBuffer.Buffer.GetData();
                if (NewCountBytes > 0)
                {
                    // NewCountBytes == 0
                }
                PacketRef.DataView = {WorkingData, NewCountBytes, ECountUnits::Bytes};
            }
        }
    }

    if (bPassedChallenge)
    {
        if (!bRestartedHandshake)
        {
            ReturnVal = NewObject<UIpConnection>(GetTransientPackage(), NewConnectionClass);

            // we pass IpNetDriver's SocketPrivate
            // IpNetDriverì˜ SocketPrivateë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤
            ReturnVal->InitRemoteConnection(this, SocketPrivate.Get(), World ? World->URL : FURL(), *Address, USOCK_Open);

            // set the initial packet sequence from the handshake data
            // í•¸ë“œì…°ì´í¬ ë°ì´í„°ì—ì„œ ì´ˆê¸° íŒ¨í‚· ì‹œí€€ìŠ¤ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤
            if (StatelessConnect.IsValid())
            {
                int32 ServerSequence = 0;
                int32 ClientSequence = 0;
                StatelessConnect->GetChallengeSequence(ServerSequence, ClientSequence);

                // ì—¬ê¸° ì¤‘ìš”í•˜ë‹ˆ ìŠ¤í‚µí•˜ì§€ ë§ì! (UNetConnection::InitSequence)
                ReturnVal->InitSequence(ClientSequence, ServerSequence);
            }

            // PacketHandlerì˜ ModeëŠ” ì—¬ê¸°ì„œ Serverì„!
            // - ì°¸ê³ ë¡œ ì„œë²„ëŠ” StatelessConnectHandlerComponentëŠ” Initializedëœ ìƒíƒœ!
            if (ReturnVal->Handler.IsValid())
            {
                ReturnVal->Handler->BeginHandshaking();
            }

            // UNetDriver::AddClientConnection()
            AddClientConnection(ReturnVal);
        }

        if (StatelessConnect.IsValid())
        {
            StatelessConnect->ResetChallengeData();
        }
    }

    if (bIgnorePacket)
    {
        PacketRef.DataView = {PacketRef.DataView.GetData(), 0, ECountUnits::Bits};
    }

    return ReturnVal;
}
```

* `IncomingConnectionless` ì—°ì‚°

```cpp
/** internal handling for incoming/incomingconnectionless */
// ë‚´ë¶€ì ì¸ incoming/incomingconnectionless ì²˜ë¦¬
EIncomingResult Incoming_Internal(FReceivedPacketView& PacketView)
{
    EIncomingResult ReturnVal = EIncomingResult::Success;
    FPacketDataView& DataView = PacketView.DataView;
    int32 CountBits = DataView.NumBits();

    // [ServerInitialSendPacket]
    // the below code is about shrinking Bits as much as we can
    // - also we verify the invalid packet simply
    // - do you remember we received packet from FPacketIterator in form of 'Bytes'?
    //   - we fit the data in form of 'Bits' here
    // - let's look through the code briefly

    // ì•„ë˜ ì½”ë“œëŠ” ê°€ëŠ¥í•œ í•œ ë§ì´ Bitsë¥¼ ì¤„ì´ëŠ” ê²ƒì— ê´€í•œ ê²ƒì…ë‹ˆë‹¤
    // - ë˜í•œ ìš°ë¦¬ëŠ” ê°„ë‹¨íˆ ìœ íš¨í•˜ì§€ ì•Šì€ íŒ¨í‚·ì„ í™•ì¸í•©ë‹ˆë‹¤
    // - 'Bytes' í˜•íƒœë¡œ FPacketIteratorì—ì„œ íŒ¨í‚·ì„ ë°›ì•˜ë˜ ê²ƒì„ ê¸°ì–µí•˜ì‹œë‚˜ìš”?
    //   - ì—¬ê¸°ì„œ ìš°ë¦¬ëŠ” ë°ì´í„°ë¥¼ 'Bits' í˜•íƒœë¡œ ë§ì¶¥ë‹ˆë‹¤
    // - the below code is **NOT** important to understand the overall code flow
    // - ì•„ë˜ ì½”ë“œëŠ” ì „ì²´ ì½”ë“œ íë¦„ì„ ì´í•´í•˜ëŠ” ë° ì¤‘ìš”í•˜ì§€ **ì•ŠìŠµë‹ˆë‹¤**
    // - ì½”ë“œë¥¼ ê°„ë‹¨íˆ ì‚´í´ë´…ì‹œë‹¤
    if (HandlerComponents.Num() > 0)
    {
        const uint8* DataPtr = DataView.GetData();
        uint8 LastByte = (UNLIKELY(DataPtr == nullptr)) ? 0 : DataPtr[DataView.NumBytes()-1];
        if (LastByte != 0)
        {
            // what is the meaning of 0x80?
            // 0x80ì˜ ì˜ë¯¸ëŠ” ë¬´ì—‡ì¼ê¹Œìš”?
            // - we already seen '0x80' in GShift
            // - ìš°ë¦¬ëŠ” ì´ë¯¸ GShiftì—ì„œ '0x80'ì„ ë³´ì•˜ìŠµë‹ˆë‹¤
            // - 0x80 == 10000000(2) == 128(2^7)
            // - 'while(!(LastByte & 0x80))' means that we iterates bits until we reach valid 7-th bit value
            // - 'while(!(LastByte & 0x80))'ëŠ” ìœ íš¨í•œ 7ë²ˆì§¸ ë¹„íŠ¸ ê°’ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ë¹„íŠ¸ë¥¼ ë°˜ë³µí•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤
            // - we substract early for 0x80 case
            // - 0x80 ê²½ìš°ì— ëŒ€í•´ ì¼ì° ëºë‹ˆë‹¤
            // - '*= 2' is same as '<<= 1'
            // - '*= 2'ëŠ” '<<= 1'ê³¼ ê°™ìŠµë‹ˆë‹¤
            CountBits--;
            while (!(LastByte & 0x80))
            {
                LastByte *= 2;
                CountBits--;
            }
        }
        else
        {
            PacketView.DataView = {nullptr, 0, ECountUnits::Bits};
            ReturnVal = EIncomingResult::Error;
        }
    }

    if (ReturnVal == EIncomingResult::Success)
    {
        FBitReader ProcessedPacketReader(DataView.GetMutableData(), CountBits);
        FIncomingPacketRef PacketRef = {ProcessedPacketReader, PacketView.Address, PacketView.Traits};

        for (int32 i = HandlerComponents.Num() - 1; i >= 0; --i)
        {
            HandlerComponent& CurComponent = *HandlerComponents[i];
            if (CurComponent.IsActive() && !ProcessedPacketReader.IsError() && ProcessedPacketReader.GetBitsLeft() > 0)
            {
                // [ServerInitialSendPacket]
                // we marked bConnectionlessPacket as 'true' in PacketHandler::IncomingConnectionless
                // - see StatelessConnectHandlerComponent::IncomingConnectionless

                // PacketHandler::IncomingConnectionlessì—ì„œ bConnectionlessPacketì„ 'true'ë¡œ í‘œì‹œí–ˆìŠµë‹ˆë‹¤
                // - StatelessConnectHandlerComponent::IncomingConnectionlessë¥¼ ë³´ì„¸ìš”

                if (PacketView.Traits.bConnectionlessPacket)
                {
                    CurComponent.IncomingConnectionless(PacketRef);
                }
                else
                {
                    CurComponent.Incoming(PacketRef);
                }
            }
        }

        // we override ProcessedPacketReader in PacketHandler::IncomingPacket
        // PacketHandler::IncomingPacketì—ì„œ ProcessedPacketReaderë¥¼ ì˜¤ë²„ë¼ì´ë“œí•©ë‹ˆë‹¤
        // - we processed all handshake packet, so PacketView.DataView's data is null (size == 0)
        // - ëª¨ë“  í•¸ë“œì…°ì´í¬ íŒ¨í‚·ì„ ì²˜ë¦¬í–ˆìœ¼ë¯€ë¡œ PacketView.DataViewì˜ ë°ì´í„°ëŠ” nullì…ë‹ˆë‹¤ (í¬ê¸° == 0)
        //   - see where 'SetAtEnd()' is called: StatelessConnectHandlerComponent::ParseHandshakePacket()
        //   - 'SetAtEnd()'ê°€ í˜¸ì¶œë˜ëŠ” ê³³ì„ ë³´ì„¸ìš”: StatelessConnectHandlerComponent::ParseHandshakePacket()
        if (!ProcessedPacketReader.IsError())
        {
            ReplaceIncomingPacket(ProcessedPacketReader);
            PacketView.DataView = {IncomingPacket.GetData(), (int32)IncomingPacket.GetBitsLeft(), ECountBits::Bits};
        }
    }

    return ReturnVal;
}
```

```cpp
struct FBitReader : public FBitArchive
{
    FBitReader(const uint8* Src = nullptr, int64 CountBits = 0)
        : Num(CountBits)
        , Pos(0)
    {
        // similar to FBitWriter except we set it as 'ArIsLoading' not 'ArIsSaving'
        // - "(CountBits + 7) >> 3" is padding by byte(8 bits)
        Buffer.AddUninitialized((CountBits + 7) >> 3);
        this->SetIsLoading(true);
        this->SetIsPersistent(true);
        ArIsNetArchive = true;

        // we cache all data from Src to Buffer before serializing any data
        // *** See GMask
        if (Src != nullptr)
        {
            FMemory::Memcpy(Buffer.GetData(), Src, (CountBits + 7) >> 3);
            // why we are checkin with '7'?
            // - see GMask[7] value
            // - if we are checking it with '8' means 0xff(11111111) complete byte, no need to adjust byte value with valid bits
            // - try to understand it with examples
            //   1. what is the cases when 'Num & 7' is true?
            //      *** 1, 2, 3, 4, 5, 6, 7 -> remainder!!
            //      - e.g. (1(001) & 7(111)) > 0, (4(100) & 7(111)) > 0
            //   2. what is the meaning of 'Num >> 3'?
            //      - [0,7] bits' byte offset of Buffer[]
            //      - "Buffer[Num >> 3] &= GMask[Num & 7]" clears invalid bits:
            //
            //                 (Num) == 27: 00011011                                                                                           
            //            (Num >> 3) == 3 : 00000011                                                                                           
            //             (Num & 7) == 3 : 00000011                                                                                           
            //                   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”                                         Clear Bits â”‚ Keep Bits(Buffer[3])  
            //         Buffer[3]:â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 1 â”œâ”€â”€â”€â”€â”                                          â—„â”€â”€â”€â”€â”¼â”€â”€â”€â”€â–º                  
            //                   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜    â”‚                                               â”‚                       
            //         BitOffset:  7   6   5   4   3   2   1   0      â”‚  Buffer[3] & GMask[3]     â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¼â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”           
            //                    31  30  29  28  27  26  25  24      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 0 â”‚ 1 â”œ           
            //                   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”    â”‚                           â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”¼â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜           
            //          GMask[3]:â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 0 â”‚ 1 â”‚ 1 â”‚ 1 â”œâ”€â”€â”€â”€â”˜                                               â”‚                       
            //          0x07     â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜                                                    â”‚                                                                                                         â”‚                       
            //                                                                                                                                 
            //   3. why do we need this?
            //      - Buffer: TArray<uint8> is not cleared with FMemory::Memzero()
            //      - clearing all bits bigger than Num is waste ops!
            //
            //   4. what about Num == 8 or Num == 16?
            //      - Num & 7 is '0' and FMemory::Memcpy() copies full bits successfully
            //      - it is for handling remainder of 8!
            //        - keep or clear bits simultaneously on one-byte
            if (Num & 7)
            {
                Buffer[Num >> 3] &= GMask[Num & 7];
            }
        }
    }
```

* ë” ìƒì„¸í•œ ë¶„ì„ì€ ìƒëµ ...