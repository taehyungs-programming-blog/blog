---
layout: default
title: "(04. Tick 2íƒ„)"
parent: "(UE SourceCode ë¶„ì„ ðŸ¤–)"
has_children: true
nav_order: 2
---

* ë„ˆë¬´ ê¸¸ì–´ì ¸ 2íƒ„ìœ¼ë¡œ ì—°ìž¥í•©ë‹ˆë‹¤ 

```cpp
/**
* update the level after a variable amount of time, DeltaSeconds, has passed
* all child actors are ticked after their owners have been ticked 
*/
void Tick(ELevelTick TickType, float DeltaSeconds)
{
    FWorldDelegates::OnWorldTickStart.Broadcast(this, TickType, DeltaSeconds);

    bool bDoingActorTicks = 
        (TickType != LEVELTICK_TimeOnly);

    // if only the DynamicLevel collection has entries, we can skip the validation and tick all levels
    // it just minor optimization to skip the code: Levels.Contains(CollectionLevel)
    // DynamicLevelë§Œ ì»¬ë ‰ì…˜ì— ì¡´ìž¬í•  ê²½ìš° Tickì— ëŒ€í•œ ìœ íš¨ì„± ì²´í¬ê°€ í•„ìš” ì—†ê¸° ë•Œë¬¸ì— ê°„ë‹¨í•œ ìµœì í™”ë¥¼ ìœ„í•´ ë¯¸ë¦¬ ì²´í¬í•˜ëŠ” ë¡œì§ ìž…ë‹ˆë‹¤.
    bool bValidateLevelList = false;
    for (const FLevelCollection& LevelCollection : LevelCollections)
    {
        if (LevelCollection.GetType() != ELevelCollectionType::DynamicSourceLevels)
        {
            const int32 NumLevels = LevelCollection.GetLevels().Num();
            if (NumLevels != 0)
            {
                bValidateLevelList = true;
                break;
            }
        }
    }

/*
ìœ„ì—ì„œ ì§„í–‰í•œ ìµœì í™”ì— ëŒ€í•œ ì´ìœ ìž…ë‹ˆë‹¤. 

WorldLevelì€ ì „ì— í•™ìŠµí–ˆë“¯ì´ Dynamic , Staticìœ¼ë¡œ ë¶„ë¥˜ê°€ ë©ë‹ˆë‹¤. 
Staticì˜ ê²½ìš° Tickì„ ì‹¤í–‰í•˜ì§€ ì•Šì„ ìˆ˜ë„ ìžˆê¸° ë•Œë¬¸ì— Tickì— ëŒ€í•œ ì²´í¬ë¥¼ ë§¤
ë²ˆ ì§„í–‰í•´ì•¼í•˜ì§€ë§Œ Dynamicë§Œ ì¡´ìž¬ í•  ê²½ìš° Tickì— ëŒ€í•œ ì‹¤í–‰ì´ ë°˜ë“œì‹œ í•„ìš”í•©ë‹ˆë‹¤. 

ìœ„ì˜ ë¡œì§ì—ì„œ ëª¨ë“  Levelì´ Dynamicì¼ ê²½ìš° bValidateLevelListê°€ falseì´ê¸° ë•Œë¬¸ì— 
Level.Containsë¥¼ ì§„í–‰í•˜ì§€ ì•Šê³  bAddtoTickListì˜ ê²°ê³¼ë¥¼ ì–»ì–´ ì˜¬ ìˆ˜ ìžˆìœ¼ë¯€ë¡œ ì„±ëŠ¥ìƒì˜ 
ì´ì ì„ ì–»ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ìµœì¢…ì ìœ¼ë¡œ Tickì´ í•„ìš”í•œ Levelë“¤ë§Œ LevelsToTickì— ë¶„ë¥˜í•©ë‹ˆë‹¤.
*/
    // we can understand what FLevelCollection for:
    // - object can be categorized into static/dynamic
    // - dynamic or static objects are into different category (LevelCollection)
    // - each level collection ticks on different moment (dynamic -> static)
    for (int32 i = 0; i < LevelCollections.Num(); ++i)
    {
        // build a list of levels from the collection that are also in the world's level array
        // collections may contain levels that aren't loaded in the world at the moment
        TArray<ULevel*> LevelsToTick;
        for (ULevel* CollectionLevel : LevelCollections[i].GetLevels())
        {
            // haker: here!
            const bool bAddToTickList = (bValidateLevelList == false) || Levels.Contains(CollectionLevel);
            if (bAddToTickList && CollectionLevel)
            {
                LevelsToTick.Add(CollectionLevel);
            }
        }

        // set up context on the world for this level collection
        // update active level collection by level collection's index
        FScopedLevelCollectionContextSwitch LevelContext(i, this);
```