---
layout: default
title: "21. Engine Main"
parent: "(Part.3 - 엔진 내부 구현)"
grand_parent: "(나의 게임엔진 🎲)"
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code 🌎](https://github.com/Arthur880708/KTHGameEngine/tree/21)

```cpp
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)
{
#if _DEBUG
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif
    if (engine_initialize())
    {
        MSG msg{};
        bool is_running{ true };
        while (is_running)
        {
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                is_running &= (msg.message != WM_QUIT);
            }

            engine_update();
        }
    }
    engine_shutdown();
    return 0;
}
```

```cpp
bool engine_initialize()
{
    bool result{ primal::content::load_game() };
    return result;
}
```

```cpp
bool
load_game()
{
    // ...

    for (u32 entity_index{ 0 }; entity_index < num_entities; ++entity_index)
    {
        game_entity::entity_info info{};
        const u32 entity_type{ *at }; at += su32;
        const u32 num_components{ *at }; at += su32;
        if (!num_components) return false;

        for (u32 component_index{ 0 }; component_index < num_components; ++component_index)
        {
            const u32 component_type{ *at }; at += su32;
            assert(component_type < component_type::count);
            if (!component_readers[component_type](at, info)) return false;
        }

        assert(info.transform);
        game_entity::entity entity{ game_entity::create(info) };
        if (!entity.is_valid()) return false;
        entities.emplace_back(entity);
    }

    assert(at == buffer.data() + buffer.size());
    return true;
}
```

```cpp
component_reader component_readers[]
{
    read_transform,
    read_script,
};
```

```cpp
bool
read_transform(const u8*& data, game_entity::entity_info& info)
{
    using namespace DirectX;
    f32 rotation[3];

    assert(!info.transform);
    memcpy(&transform_info.position[0], data, sizeof(transform_info.position)); data += sizeof(transform_info.position);
    memcpy(&rotation[0], data, sizeof(rotation)); data += sizeof(rotation);
    memcpy(&transform_info.scale[0], data, sizeof(transform_info.scale)); data += sizeof(transform_info.scale);

    XMFLOAT3A rot{ &rotation[0] };
    XMVECTOR quat{ XMQuaternionRotationRollPitchYawFromVector(XMLoadFloat3A(&rot)) };
    XMFLOAT4A rot_quat{};
    XMStoreFloat4A(&rot_quat, quat);
    memcpy(&transform_info.rotation[0], &rot_quat.x, sizeof(transform_info.rotation));

    info.transform = &transform_info;

    return true;
}
```