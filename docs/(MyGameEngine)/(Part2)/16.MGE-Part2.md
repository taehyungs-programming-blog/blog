---
layout: default
title: "16. Script 클래스 생성 + Script 등록"
parent: "(Part.2 - 엔진 구조 잡기)"
grand_parent: "(나의 게임엔진 🎲)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code 🌎](https://github.com/Arthur880708/ArthurDX12GameEngine/commit/96a8f6ff279eec62aaac828ddbab316674354c7b)

## 살짝 복습

```cpp
namespace primal {

// INIT_INFO - component라는 namespace에 init_info라는 struct를 만들어준다.
/*
    (참고)
struct init_info
{
    f32 position[3]{};
    f32 rotation[4]{};
    f32 scale[3]{1.f, 1.f, 1.f};
};
*/
#define INIT_INFO(component) namespace component { struct init_info; }

INIT_INFO(transform);
INIT_INFO(script);

#undef INIT_INFO

namespace game_entity {
struct entity_info
{
    transform::init_info* transform{ nullptr };
    script::init_info* script{ nullptr };
};

entity create(entity_info info);
void remove(entity_id id);
bool is_alive(entity_id id);
}
}
```

---

## GameEntity

* 크게 어렵진 않다.

```cpp
namespace detail {
using script_ptr = std::unique_ptr<entity_script>;
using script_creator = script_ptr(*)(game_entity::entity entity);
using string_hash = std::hash<std::string>;
u8 register_script(size_t, script_creator);

template<class script_class>
script_ptr create_script(game_entity::entity entity)
{
    assert(entity.is_valid());
    return std::make_unique<script_class>(entity);
}

#define REGISTER_SCRIPT(TYPE)                                           \
        class TYPE;                                                     \
        namespace {                                                     \
        const u8 _reg##TYPE                                             \
        { primal::script::detail::register_script(                      \
              primal::script::detail::string_hash()(#TYPE),             \
              &primal::script::detail::create_script<TYPE>) };          \
        }


} // namespace detail
```

```cpp
u8
register_script(size_t tag, script_creator func)
{
    bool result{ registery().insert(script_registery::value_type{tag, func}).second };
    assert(result);
    return result;
}

// ...

using script_registery = std::unordered_map<size_t, detail::script_creator>;
script_registery&
registery()
{
    static script_registery reg;
    return reg;
}
```

---

## 이제 Script를 써보자.

* 이후 이 작업 모두 자동화 될 예정.
* VisualStudio 2019
    * 빈 프로젝트(C++)
    * 속성 -> C/C++ -> 추가 포함 디렉터리 -> `${ProjectPath}\Engine\EngineAPI`
    * 속성 -> C/C++ -> 고급 -> 강제 포함 파일 -> `GameEntity.h`
    * 속성 -> 링커 -> 입력 -> 추가 종속성 -> `Engine.lib`
    * 속성 -> 링커 -> 입력 -> 추가 라이브러리 디렉터리 -> `${ProjectPath}\x64\Debug`

```cpp
#pragma once

namespace first_game_project {

REGISTER_SCRIPT(CharacterScript)
class CharacterScript : public primal::script::entity_script
{
public:
	constexpr explicit CharacterScript(primal::game_entity::entity entity)
		: primal::script::entity_script(entity) {}

	void update(float dt) override {}
};

}
```

* 유의해야할 점은 Rider로 Engine빌드시 엔트리 포인트를 못찾는 버그가 있다.
* 그래서 VisualStudio로 빌드해야한다.