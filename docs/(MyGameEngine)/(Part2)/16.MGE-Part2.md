---
layout: default
title: "16. Script í´ë˜ìŠ¤ ìƒì„± + Script ë“±ë¡"
parent: "(Part.2 - ì—”ì§„ êµ¬ì¡° ì¡ê¸°)"
grand_parent: "(ë‚˜ì˜ ê²Œì„ì—”ì§„ ğŸ²)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/ArthurDX12GameEngine/commit/96a8f6ff279eec62aaac828ddbab316674354c7b)

## ì‚´ì§ ë³µìŠµ

```cpp
namespace primal {

// INIT_INFO - componentë¼ëŠ” namespaceì— init_infoë¼ëŠ” structë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.
/*
    (ì°¸ê³ )
struct init_info
{
    f32 position[3]{};
    f32 rotation[4]{};
    f32 scale[3]{1.f, 1.f, 1.f};
};
*/
#define INIT_INFO(component) namespace component { struct init_info; }

INIT_INFO(transform);
INIT_INFO(script);

#undef INIT_INFO

namespace game_entity {
struct entity_info
{
    transform::init_info* transform{ nullptr };
    script::init_info* script{ nullptr };
};

entity create(entity_info info);
void remove(entity_id id);
bool is_alive(entity_id id);
}
}
```

---

## GameEntity

* í¬ê²Œ ì–´ë µì§„ ì•Šë‹¤.

```cpp
namespace detail {
using script_ptr = std::unique_ptr<entity_script>;
using script_creator = script_ptr(*)(game_entity::entity entity);
using string_hash = std::hash<std::string>;
u8 register_script(size_t, script_creator);

template<class script_class>
script_ptr create_script(game_entity::entity entity)
{
    assert(entity.is_valid());
    return std::make_unique<script_class>(entity);
}

#define REGISTER_SCRIPT(TYPE)                                           \
        class TYPE;                                                     \
        namespace {                                                     \
        const u8 _reg##TYPE                                             \
        { primal::script::detail::register_script(                      \
              primal::script::detail::string_hash()(#TYPE),             \
              &primal::script::detail::create_script<TYPE>) };          \
        }


} // namespace detail
```

```cpp
u8
register_script(size_t tag, script_creator func)
{
    bool result{ registery().insert(script_registery::value_type{tag, func}).second };
    assert(result);
    return result;
}

// ...

using script_registery = std::unordered_map<size_t, detail::script_creator>;
script_registery&
registery()
{
    static script_registery reg;
    return reg;
}
```

---

## ì´ì œ Scriptë¥¼ ì¨ë³´ì.

* ì´í›„ ì´ ì‘ì—… ëª¨ë‘ ìë™í™” ë  ì˜ˆì •.
* VisualStudio 2019
    * ë¹ˆ í”„ë¡œì íŠ¸(C++)
    * ì†ì„± -> C/C++ -> ì¶”ê°€ í¬í•¨ ë””ë ‰í„°ë¦¬ -> `${ProjectPath}\Engine\EngineAPI`
    * ì†ì„± -> C/C++ -> ê³ ê¸‰ -> ê°•ì œ í¬í•¨ íŒŒì¼ -> `GameEntity.h`
    * ì†ì„± -> ë§ì»¤ -> ì…ë ¥ -> ì¶”ê°€ ì¢…ì†ì„± -> `Engine.lib`
    * ì†ì„± -> ë§ì»¤ -> ì…ë ¥ -> ì¶”ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë””ë ‰í„°ë¦¬ -> `${ProjectPath}\x64\Debug`

```cpp
#pragma once

namespace first_game_project {

REGISTER_SCRIPT(CharacterScript)
class CharacterScript : public primal::script::entity_script
{
public:
	constexpr explicit CharacterScript(primal::game_entity::entity entity)
		: primal::script::entity_script(entity) {}

	void update(float dt) override {}
};

}
```

* ìœ ì˜í•´ì•¼í•  ì ì€ Riderë¡œ Engineë¹Œë“œì‹œ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸ë¥¼ ëª»ì°¾ëŠ” ë²„ê·¸ê°€ ìˆë‹¤.
* ê·¸ë˜ì„œ VisualStudioë¡œ ë¹Œë“œí•´ì•¼í•œë‹¤.