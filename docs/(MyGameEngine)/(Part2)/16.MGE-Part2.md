---
layout: default
title: "16. Script í´ë˜ìŠ¤ ìƒì„±"
parent: "(Part.2 - ì—”ì§„ êµ¬ì¡° ì¡ê¸°)"
grand_parent: "(ë‚˜ì˜ ê²Œì„ì—”ì§„ ğŸ²)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/KTHGameEngine/tree/16)

## ì‚´ì§ ë³µìŠµ

```cpp
namespace primal {

// INIT_INFO - componentë¼ëŠ” namespaceì— init_infoë¼ëŠ” structë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.
/*
    (ì°¸ê³ )
struct init_info
{
    f32 position[3]{};
    f32 rotation[4]{};
    f32 scale[3]{1.f, 1.f, 1.f};
};
*/
#define INIT_INFO(component) namespace component { struct init_info; }

INIT_INFO(transform);
INIT_INFO(script);

#undef INIT_INFO

namespace game_entity {
struct entity_info
{
    transform::init_info* transform{ nullptr };
    script::init_info* script{ nullptr };
};

entity create(entity_info info);
void remove(entity_id id);
bool is_alive(entity_id id);
}
}
```

---

## GameEntity

```cpp
namespace detail {
using script_ptr = std::unique_ptr<entity_script>;
using script_creator = script_ptr(*)(game_entity::entity entity);
using string_hash = std::hash<std::string>;
u8 register_script(size_t, script_creator);

template<class script_class>
script_ptr create_script(game_entity::entity entity)
{
    assert(entity.is_valid());
    return std::make_unique<script_class>(entity);
}

#define REGISTER_SCRIPT(TYPE)                                           \
        class TYPE;                                                     \
        namespace {                                                     \
        const u8 _reg##TYPE                                             \
        { primal::script::detail::register_script(                      \
              primal::script::detail::string_hash()(#TYPE),             \
              &primal::script::detail::create_script<TYPE>) };          \
        }


} // namespace detail
```

```cpp
u8
register_script(size_t tag, script_creator func)
{
    bool result{ registery().insert(script_registery::value_type{tag, func}).second };
    assert(result);
    return result;
}

// ...

using script_registery = std::unordered_map<size_t, detail::script_creator>;
script_registery&
registery()
{
    static script_registery reg;
    return reg;
}
```