---
layout: default
title: "10. Entity, Transform êµ¬í˜„ì²´"
parent: "(Part.2 - ì—”ì§„ êµ¬ì¡° ì¡ê¸°)"
grand_parent: "(ë‚˜ì˜ ê²Œì„ì—”ì§„ ğŸ²)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/ArthurDX12GameEngine/commit/4b3d9bd8a97231b2193efbb3bf21005aa9405b23)

```cpp
#define INIT_INFO(component) namespace component { struct init_info; }

INIT_INFO(transform);

#undef INIT_INFO

namespace game_entity {
struct entity_info
{
    transform::init_info* transform{ nullptr };
};

entity create_game_entity(const entity_info& info);
void remove_game_entity(entity e);
bool is_alive(entity e);
}
```

```cpp
// í¬ê²Œ ì–´ë ¤ìš´ ë¶€ë¶„ì€ ì—†ê³  object poolingì„ êµ¬í˜„í•œ ë¶€ë¶„ì´ ì¢€ ì‹ ê¸°?

utl::vector<transform::component>       transforms;

utl::vector<id::generation_type>        generations;
utl::deque<entity_id>                   free_ids;

} // anonymous namespace

entity
create_game_entity(const entity_info& info)
{
    assert(info.transform);
    if (!info.transform) return entity{};

    entity_id id;

    if(free_ids.size() > id::min_deleted_elements)
    { 
        // ì¼ì¢…ì˜ object poolingì´ë‹¤
        id = free_ids.front();
        assert(!is_alive(entity{ id }));
        free_ids.pop_front();
        id = entity_id{ id::new_generation(id) };
        ++generations[id::index(id)];
    }
    else
    {
        id = entity_id{ (id::id_type)generations.size() };
        generations.push_back(0);
        transforms.emplace_back();
    }

    const entity new_entity{ id };
    const id::id_type index{ id::index(id) };

    // Create transform component
    assert(!transforms[index].is_valid());
    transforms[index] = transform::create_transform(*info.transform, new_entity);
    if (!transforms[index].is_valid()) return {};

    return new_entity;
}
```