---
layout: default
title: "7. Log, History ë‚˜ëˆ„ê³  Entity Undoë˜ê²Œ ìˆ˜ì •"
parent: "(Part.1 - ì—”ì§„ êµ¬ì¡° ì¡ê¸°)"
grand_parent: "(ë‚˜ì˜ ê²Œì„ì—”ì§„ ğŸ²)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/KTHGameEngine/tree/7)

## ë³µìŠµ í•œ ë²ˆ!

```csharp
[DataContract]
[KnownType(typeof(Transform))]
public class GameEntity : ViewModelBase
{
    private bool _isEnabled = true;
    [DataMember]
    public bool IsEnabled
    {
        get => _isEnabled;
        set
        {
            if (_isEnabled != value)
            {
                _isEnabled = value;
                OnPropertyChanged(nameof(IsEnabled));
            }
        }
    }

    // ...
```

* **(ì°¸ê³ )** `[KnownType(typeof(Transform))]` ì†ì„±ì€ DataContractSerializerê°€ GameEntity í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì§ë ¬í™”í•˜ê±°ë‚˜ ì—­ì§ë ¬í™”í•  ë•Œ Transform íƒ€ì…ì˜ ê°ì²´ë„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

```xml
<CheckBox IsChecked="{Binding IsEnabled, Mode=OneWay}" 
            Command="{Binding IsEnabledCommand}"
            CommandParameter="{Binding IsChecked, RelativeSource={RelativeSource Self}}"
            Margin="5,0" VerticalAlignment="Center"/>
```

* ëŒ€ëµ ì´ëŸ°ì‹ìœ¼ë¡œ ì“°ì„

---

## Logger

```csharp
static class Logger
{
    private static int _messageFilter = (int)(MessageType.Info | MessageType.Warning | MessageType.Error);
    private static ObservableCollection<LogMessage> _messages = new ObservableCollection<LogMessage>();
    public static ReadOnlyObservableCollection<LogMessage> Messages
    { get; } = new ReadOnlyObservableCollection<LogMessage>(_messages);
    public static CollectionViewSource FilteredMessages
    { get; } = new CollectionViewSource() { Source = Messages };

    public static async void Log(MessageType type, string msg,
        [CallerFilePath] string file = "", [CallerMemberName] string caller = "",
        [CallerLineNumber] int line = 0)
    {
        await Application.Current.Dispatcher.BeginInvoke(new Action(() =>
        {
            _messages.Add(new LogMessage(type, msg, file, caller, line));
        }));
    }

    public static async void Clear()
    {
        await Application.Current.Dispatcher.BeginInvoke(new Action(() =>
        {
            _messages.Clear();
        }));
    }
    
    public static void SetMessageFilter(int mask)
    {
        _messageFilter = mask;
        FilteredMessages.View.Refresh();
    }
    
    static Logger()
    {
        FilteredMessages.Filter += (s, e) =>
        {
            var type = (int)(e.Item as LogMessage).MessageType;
            e.Accepted = (type & _messageFilter) != 0;
        };
    }
}
```

* **CollectionViewSource** ë€?
    * CollectionViewSourceëŠ” ë°ì´í„° ì†ŒìŠ¤ë¥¼ ê´€ë¦¬í•˜ê³  XAMLì—ì„œ ë°ì´í„° ë°”ì¸ë”©ì„ ìš©ì´í•˜ê²Œ í•˜ëŠ” ê°ì²´ì…ë‹ˆë‹¤. ì´ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„° ì†ŒìŠ¤ë¥¼ í•„í„°ë§, ì •ë ¬, ê·¸ë£¹í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ë¡œê·¸ ë©”ì‹œì§€ë¥¼ í•„í„°ë§í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì¦‰, CollectionViewSourceë¥¼ ì‚¬ìš©í•˜ë©´ ë¡œê·¸ ë©”ì‹œì§€ì˜ íŠ¹ì • ìœ í˜•ë§Œ ë³´ì—¬ì£¼ê±°ë‚˜ ìˆ¨ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
static Logger()
{
    FilteredMessages.Filter += (s, e) =>
    {
        var type = (int)(e.Item as LogMessage).MessageType;
        e.Accepted = (type & _messageFilter) != 0;
    };
}
```

* `ReadOnlyObservableCollection<LogMessage> Messages` ë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ 
    * ReadOnlyObservableCollection<T>ëŠ” ObservableCollection<T>ì˜ ì½ê¸° ì „ìš© ë²„ì „ì…ë‹ˆë‹¤. 
    * ì´ ì»¬ë ‰ì…˜ì€ ë³€ê²½ ê°€ëŠ¥í•˜ì§€ë§Œ, ì´ ë³€ê²½ì€ ì˜¤ì§ ë‚´ë¶€ì—ì„œë§Œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤. ì™¸ë¶€ì—ì„œëŠ” ì´ ì»¬ë ‰ì…˜ì˜ í•­ëª©ì„ ì¶”ê°€, ì‚­ì œ ë˜ëŠ” ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ êµ¬í˜„í•˜ëŠ” ì´ìœ ëŠ” ì•ˆì „ì„±ê³¼ ìº¡ìŠí™”ë¥¼ ê°•í™”í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤. Logger í´ë˜ìŠ¤ëŠ” ë¡œê·¸ ë©”ì‹œì§€ë¥¼ ê´€ë¦¬í•˜ë©°, ì™¸ë¶€ì—ì„œëŠ” ì´ ë©”ì‹œì§€ë“¤ì„ ì½ê¸°ë§Œ ê°€ëŠ¥í•˜ë„ë¡ ì œí•œí•©ë‹ˆë‹¤. ì´ëŠ” ì™¸ë¶€ì—ì„œ ë¡œê·¸ ë©”ì‹œì§€ ì»¬ë ‰ì…˜ì„ ë³€ê²½í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê³ , ë°ì´í„° ë¬´ê²°ì„±ì„ ìœ ì§€í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.

* `Application.Current.Dispatcher.BeginInvoke` ë€?
    * Application.Current.Dispatcher.BeginInvokeëŠ” WPFì—ì„œ **UI ìŠ¤ë ˆë“œì— ì ‘ê·¼í•  ë•Œ ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œ**ì…ë‹ˆë‹¤. 
    * WPF ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ì‹±ê¸€ ìŠ¤ë ˆë“œ ì•„íŒŒíŠ¸ë¨¼íŠ¸ ëª¨ë¸ì„ ì‚¬ìš©í•˜ë©°, UI ìš”ì†ŒëŠ” ì˜¤ì§ ìƒì„±ëœ ê·¸ ìŠ¤ë ˆë“œ(ì¼ë°˜ì ìœ¼ë¡œ ë©”ì¸ ìŠ¤ë ˆë“œ)ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë”°ë¼ì„œ, ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ë˜ëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ UI ìš”ì†Œë¥¼ ì—…ë°ì´íŠ¸í•˜ë ¤ë©´ Dispatcher.BeginInvokeë¥¼ ì‚¬ìš©í•˜ì—¬ UI ìŠ¤ë ˆë“œì— ì‘ì—…ì„ ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ì½”ë“œì—ì„œëŠ” ë¡œê·¸ ë©”ì‹œì§€ë¥¼ ObservableCollectionì— ì¶”ê°€í•˜ê±°ë‚˜ í´ë¦¬ì–´í•˜ëŠ” ë™ì‘ì„ UI ìŠ¤ë ˆë“œì—ì„œ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ì´ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.