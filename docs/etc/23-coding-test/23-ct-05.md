---
layout: default
title: "5. 그리디,라인스위핑,투포인터"
parent: "23년 Coding Test 😤"
grand_parent: "Etc 🛠"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 예제 A - 2109

* [문제 🌎](https://www.acmicpc.net/problem/2109)
    * [해설 🌎](https://www.acmicpc.net/source/share/6e588586acd84253831fe9ff32b382ae)

---

## 예제 D - 7795

* [문제 🌎](https://www.acmicpc.net/problem/9935)
    * [해설 🌎](https://www.acmicpc.net/source/share/74b637e8c3cb4f73a4e2fe16c567436e)

---

## 예제 A - 2109

* [문제 🌎](https://www.acmicpc.net/problem/2109)

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

struct Lecture {
    int pay;
    int day;
};

struct cmp {
    bool operator()(Lecture a, Lecture b) {
        return a.pay < b.pay;
    }
};

int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    
    int n, maxDay = 0;
    cin >> n;
    vector<Lecture> v(n);
    
    for (int i = 0; i < n; ++i) {
        cin >> v[i].pay >> v[i].day;
        maxDay = max(maxDay, v[i].day);
    }
    
    sort(v.begin(), v.end(), [](Lecture a, Lecture b) {
        return a.day > b.day;
    });

    priority_queue<Lecture, vector<Lecture>, cmp> pq;
    int j = 0, result = 0;

    for (int i = maxDay; i >= 1; --i) {
        while (j < n && v[j].day == i) {
            pq.push(v[j++]);
        }
        if (!pq.empty()) {
            result += pq.top().pay;
            pq.pop();
        }
    }
    cout << result;
    
    return 0;
}
```


---

## 예제 B - 9935

* [문제 🌎](https://www.acmicpc.net/problem/9935)

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

struct Lecture {
    int pay;
    int day;
};

struct cmp {
    bool operator()(Lecture a, Lecture b) {
        return a.pay < b.pay;
    }
};

int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    
    int n, maxDay = 0;
    cin >> n;
    vector<Lecture> v(n);
    
    for (int i = 0; i < n; ++i) {
        cin >> v[i].pay >> v[i].day;
        maxDay = max(maxDay, v[i].day);
    }
    
    sort(v.begin(), v.end(), [](Lecture a, Lecture b) {
        return a.day > b.day;
    });

    priority_queue<Lecture, vector<Lecture>, cmp> pq;
    int j = 0, result = 0;

    for (int i = maxDay; i >= 1; --i) {
        while (j < n && v[j].day == i) {
            pq.push(v[j++]);
        }
        if (!pq.empty()) {
            result += pq.top().pay;
            pq.pop();
        }
    }
    cout << result;
    
    return 0;
}
```