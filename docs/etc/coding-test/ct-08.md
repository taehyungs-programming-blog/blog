---
layout: default
title: "(Easy) LRU"
parent: "Coding Test ğŸ’»"
grand_parent: "Etc ğŸ› "
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## LRU(Least Recently Used Algorithm)

* ê°€ì¥ ì˜¤ë«ë™ì•ˆ ì°¸ì¡°ë˜ì§€ ì•Šì€ í˜ì´ì§€ë¥¼ êµì²´í•˜ëŠ” ê¸°ë²•

* ì˜ˆë¥¼ë“¤ì–´ 123145ê°€ ë“¤ì–´ì˜¨ë‹¤ë©´

<ì‚¬ì§„>

* 4ì´ˆ - 1ì€ ì¬ì°¸ì¡°ëœ ê²ƒìœ¼ë¡œ ê°€ì¥ ì˜¤ë«ë™ì•ˆ ì°¸ì¡°ë˜ì§€ ì•Šì€ ìˆœìœ¼ë¡œ ìˆœì„œë¥¼ ì •ë ¬
* 6ì´ˆ - cacheê°€ ê°€ë“ì°¨ 5ê°€ ë“¤ì–´ê°ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ, ê°€ì¥ ì˜¤ë˜ëœ ì°¸ì¡°ë˜ì§€ ì•Šì€ 2ë¥¼ ì œê±° í›„ 5ë¥¼ ì €ì¥

```cpp
// Q

class LRUCache
{
    list<int> dq;

    unordered_map<int, list<int>::iterator> ma;
    int csize;      // maximum capacity of cache

public:
    LRUCache(int);
    void refer(int);
    void display();
};

LRUCache::LRUCache(int n) { csize = n; }

void LRUCache::refer(int x)
{
    // LRUë¥¼ êµ¬í˜„í•˜ë¼
}
```

```cpp
// A

class LRUCache
{
    list<int> dq;

    unordered_map<int, list<int>::iterator> ma;
    int csize;      // maximum capacity of cache

public:
    LRUCache(int);
    void refer(int);
    void display();
};

LRUCache::LRUCache(int n) { csize = n; }

void LRUCache::refer(int x)
{
    if(ma.find(x) == ma.end())
    {
        if(dq.size() == csize)
        {
            int last = dq.back();
            dq.pop_back();
            ma.erase(last);
        }
    }
    else
    {
        dq.erase(ma[x]);
    }

    dq.push_front(x);
    ma[x]=dq.begin();
}
```