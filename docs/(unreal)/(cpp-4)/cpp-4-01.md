---
layout: default
title: "01. Player movement"
parent: "(Unreal C++ Part3 - Simple Shooter)"
grand_parent: "(Unreal 🚀)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* Project는 아래와 같은 순서로 진행 예정
    * Player movement
    * Animation
    * Shooting
    * Health / Death
    * Enemy AI
    * Win / Lose Conditions
* 시작은 **Player movement!**

---

## Pawn과 Character차이?

* 우선, Pawn과 Character모두 사용자가 possess하여 컨트롤이가능하다.
* 그럼 차이는 뭘까?
    * **Pawn** - 
    * **Character** - Pawn의 자손이다. 따라서 Pawn에 특정 기능을 추가한 개념이다. 그 특정 개념이 **Movement**!! 

* C++로 만든 Character를 Blueprint로 상속해 열어보면, 아래와 같이 Animation이 존재함을 확인할 수 있다.
* 아직은 무슨 기능인진 모르겠으나 우선 있다만 알고있자!

<사진>

---

## 이동적용

```cpp
UCLASS()
class SIMPLESHOOTER_API AShooterCharacter : public ACharacter
{
	GENERATED_BODY()

    // ...

private:
    // 움직임
	void MoveForward(float AxisValue);
	void MoveRight(float AxisValue);

    // 회전
	void LookUpRate(float AxisValue);
	void LookRightRate(float AxisValue);
};
```

```cpp
void AShooterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);

	PlayerInputComponent->BindAxis(TEXT("MoveForward"), this, &AShooterCharacter::MoveForward);
	PlayerInputComponent->BindAxis(TEXT("LookUp"), this, &APawn::AddControllerPitchInput);
	PlayerInputComponent->BindAxis(TEXT("MoveRight"), this, &AShooterCharacter::MoveRight);
	PlayerInputComponent->BindAxis(TEXT("LookRight"), this, &APawn::AddControllerYawInput);
	PlayerInputComponent->BindAxis(TEXT("LookUpRate"), this, &AShooterCharacter::LookUpRate);
	PlayerInputComponent->BindAxis(TEXT("LookRightRate"), this, &AShooterCharacter::LookRightRate);
	PlayerInputComponent->BindAction(TEXT("Jump"), EInputEvent::IE_Pressed, this, &ACharacter::Jump);
}

void AShooterCharacter::MoveForward(float AxisValue) 
{
	AddMovementInput(GetActorForwardVector() * AxisValue);
}

void AShooterCharacter::MoveRight(float AxisValue) 
{
	AddMovementInput(GetActorRightVector() * AxisValue);
}

void AShooterCharacter::LookUpRate(float AxisValue) 
{
	AddControllerPitchInput(AxisValue * RotationRate * GetWorld()->GetDeltaSeconds());
}

void AShooterCharacter::LookRightRate(float AxisValue) 
{
	AddControllerYawInput(AxisValue * RotationRate * GetWorld()->GetDeltaSeconds());
}
```

* Animation이 적용된 상태가 아니라 그냥 서있는 상태로 이동만 한다

---

## Skeletal Animation 붙이기

* 우선 **Skeletal Animation**이란 Skeletal Mesh에 Animation을 붙이는거다
* 뭔? Mesh에 Skeletal(뼈)를 할당하고 거기에 맞게 Animation을 적용해 준다고 생각하면 된다.
* 예시로 Animation파일을 하나 열어보자

<사진2>

* 오른쪽 위의 Skeletal버튼을 누르면 Skeletal이 어떻게 적용되어 있는지 나온다

<사진3>

* 그럼 시험삼아서 Blueprint에 적용해 보자

<사진4>

* 이제는 상황에 맞게 Animation을 붙이기만 하면된다.

---

## (Tips) Collision

* 가끔 특정 Object에서 아래 그림과 같이 원치않는 Collision이 생성될수 있다
* 그냥 클릭 후 삭제하면 됨.

<사진5>

---

## Animation Blueprint

* 우선 Animation Blueprint를 하나 생성해 보자

<사진6>

* Skeleton을 하나 지정해 줘야한다

<사진7>

* 다음과 같이 AnimGraph를 구성해 보자

<사진8>

* Alpha가 두 Animation을 Blend해주기에 적당히 변경하며 테스트 해보자

---

## Blend Space 활용

<사진9>

---

### 실제 Blueprint에 적용하기

* 우선 Blueprint에서 Animation Blueprint를 지정

<사진10>

<사진11>

* 현재는 속도만 반영된 상태(Angle은 반영안됨)

---

### Angle을 반영해 보자

* 알아야 할 점은 Actor의 Transform 정보를 받을수 있다는것!

<사진12>

* Transform에서 필요한 정보는 Rotation일 것이다.
* 구하는 방법은 다음과 같다
    * Pawn의 Transform을 받는다
    * Pawn의 Transform은 World좌표계이기에 Inverse Transform Direction을 이용해 Local좌표계로 바꾼다
    * X축만을 이용해 Yaw값을 구하면 Angle을 구할수 있다

<사진13>

---

### 발걸음과 속도 맞추기

* 현재 실행해 보면 발걸음은 너무 빠른데 걷는속도는 느려서 마치 얼음위를 달리는것 같다

<사진14>

* 발걸음 시작이 0.16초

<사진15>

* 종료가 0.3초, 한 걸음에 0.14초 정도가 걸리며 Y축으로 얼마나 움직였나 확인해 보면

<사진16>

* 시작위치 17.088 / 종료위치 -28.42
* 속도 = 거리/시간 = -45.50/0.14 = -325.07
* 이제 Blend Space에 적용하자

<사진17>

---

## Gun

* Spawn 후 Actor에 붙임

```cpp
UCLASS()
class SIMPLESHOOTER_API AShooterCharacter : public ACharacter
{
	GENERATED_BODY()
    // ...

	UPROPERTY(EditDefaultsOnly)
	TSubclassOf<AGun> GunClass;

	UPROPERTY()
	AGun* Gun;
};
```

```cpp
void AShooterCharacter::BeginPlay()
{
	Super::BeginPlay();

	Gun = GetWorld()->SpawnActor<AGun>(GunClass);
	GetMesh()->HideBoneByName(TEXT("weapon_r"), EPhysBodyOp::PBO_None);
	Gun->AttachToComponent(GetMesh(), FAttachmentTransformRules::KeepRelativeTransform, TEXT("WeaponSocket"));
	Gun->SetOwner(this);
}
```