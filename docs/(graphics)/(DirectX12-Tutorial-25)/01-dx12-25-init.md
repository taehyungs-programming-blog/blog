---
layout: default
title: "01. DXGI, CommandList, Fence ì´ë¡  ì •ë¦¬"
parent: "(DirectX12 25ë…„ Tutorial)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ì‚¬ì „ì§€ì‹ DXGI(DirectX Graphics Infrastructure)

**DXGI (DirectX Graphics Infrastructure)**ëŠ” DirectX 10ë¶€í„° ë„ì…ëœ ì €ìˆ˜ì¤€ ê·¸ë˜í”½ ì¸í”„ë¼ë¡œ, Direct3Dì™€ í•˜ë“œì›¨ì–´ ì‚¬ì´ì˜ ê³µí†µ í”„ë ˆì„ì›Œí¬ë¥¼ ì œê³µ

### ì´ê²Œ ì™œ í•„ìš”í• ê¹Œ?

#### ê·¼ë³¸ì  ì´ìœ 

* DirectX 9ê¹Œì§€ëŠ” D3Dê°€ ëª¨ë“  ê±¸ ë‹¤ í•¨. ë””ë°”ì´ìŠ¤ ìƒì„±ë¶€í„° í™”ë©´ ì¶œë ¥, ì „ì²´í™”ë©´ ì „í™˜ê¹Œì§€ ì „ë¶€ D3D API ì˜ ì—­í• . ê·¸ëŸ°ë°... ì´ê²Œ ë¬¸ì œê°€ ë§ì•˜ìŠµë‹ˆë‹¤ :<
* ì¤‘ë³µ ì½”ë“œ: D3D9, D3D10, D3D11... ê° ë²„ì „ë§ˆë‹¤ ê°™ì€ ê¸°ëŠ¥(í™”ë©´ ì¶œë ¥, ëª¨ë‹ˆí„° ì—´ê±° ë“±)ì„ ê³„ì† ë‹¤ì‹œ êµ¬í˜„
* API ê°„ í˜¸í™˜ì„± ì—†ìŒ: D3D9ê³¼ D3D10ì„ ê°™ì´ ì“°ë ¤ë©´ ê±°ì˜ ë¶ˆê°€ëŠ¥

#### ê´€ì‹¬ì‚¬ì˜ ë¶„ë¦¬

* DXGI: "í•˜ë“œì›¨ì–´ì™€ OS ë ˆë²¨" - GPU ì°¾ê¸°, ëª¨ë‹ˆí„° ê´€ë¦¬, í™”ë©´ ì¶œë ¥
* D3D: "ë Œë”ë§ API" - ê·¸ë˜í”½ìŠ¤ íŒŒì´í”„ë¼ì¸, ì…°ì´ë”, ë¦¬ì†ŒìŠ¤
* ì´ë ‡ê²Œ ë‚˜ëˆ„ë‹ˆê¹Œ ê°ì ì—­í• ì´ ëª…í™•í•´ì§€ê³  ì½”ë“œë„ ê¹”ë”

### DXGIì˜ ì—­í• 

- **í•˜ë“œì›¨ì–´ ì¶”ìƒí™”**: GPU, ëª¨ë‹ˆí„° ë“±ì˜ ê·¸ë˜í”½ í•˜ë“œì›¨ì–´ë¥¼ ì¶”ìƒí™”í•˜ì—¬ ê´€ë¦¬
- **í”Œë«í¼ ë…ë¦½ì„±**: Direct3D ë²„ì „(D3D11, D3D12)ê³¼ ë¬´ê´€í•˜ê²Œ ê³µí†µ ì¸í„°í˜ì´ìŠ¤ ì œê³µ
- **ë””ìŠ¤í”Œë ˆì´ ê´€ë¦¬**: ì „ì²´í™”ë©´/ì°½ëª¨ë“œ ì „í™˜, í•´ìƒë„ ë³€ê²½, ë‹¤ì¤‘ ëª¨ë‹ˆí„° ì§€ì›
- **ë¦¬ì†ŒìŠ¤ ê³µìœ **: ì—¬ëŸ¬ ê·¸ë˜í”½ API ê°„ ë¦¬ì†ŒìŠ¤ ê³µìœ  ê°€ëŠ¥
- **ë²„í¼ ê´€ë¦¬**: ìŠ¤ì™‘ì²´ì¸ì„ í†µí•œ ë²„í¼ë§ ë° í™”ë©´ ì¶œë ¥

### ì£¼ìš” DXGI ì¸í„°í˜ì´ìŠ¤

#### IDXGIFactory

**ì—­í• **: DXGIë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ê°ì¢… ì¸í„°í˜ì´ìŠ¤ ìƒì„±ì˜ ì§„ì…ì 

#### ì£¼ìš” ê¸°ëŠ¥
- **IDXGIAdapter ì—´ê±°**: ì‹œìŠ¤í…œì— ì„¤ì¹˜ëœ ê·¸ë˜í”½ ì¹´ë“œ ëª©ë¡ ì¡°íšŒ
- **IDXGISwapChain ìƒì„±**: í™”ë©´ ì¶œë ¥ì„ ìœ„í•œ ìŠ¤ì™‘ì²´ì¸ ìƒì„±
- **ì „ì²´í™”ë©´ ìƒíƒœ ê´€ë¦¬**: ì „ì²´í™”ë©´ ì „í™˜ ë° ê´€ë¦¬

---

## D3D12 ì£¼ìš” ê°œë…

- **Command List**: GPUì—ê²Œ ì‹¤í–‰ì‹œí‚¬ ëª…ë ¹ë“¤ì„ ê¸°ë¡í•˜ëŠ” ì»¨í…Œì´ë„ˆ
- **Command Allocator**: Command Listê°€ ëª…ë ¹ì„ ê¸°ë¡í•  ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬ ((ì£¼ì˜) CPUì— ë©”ëª¨ë¦¬ê°€ ì˜¬ë¼ê°)
- **Command Queue**: CPUì—ì„œ ê¸°ë¡í•œ Command Listë¥¼ GPUì— ì œì¶œí•˜ì—¬ ì‹¤í–‰
- **Fence**: CPUì™€ GPU ê°„ì˜ ë™ê¸°í™”ë¥¼ ìœ„í•œ ê°ì²´

---

## Command List

### ê°œë…

* Command List(`ID3D12GraphicsCommandList`)ëŠ” GPUê°€ ì‹¤í–‰í•  ê·¸ë˜í”½ ëª…ë ¹ë“¤ì„ ê¸°ë¡í•˜ëŠ” ê°ì²´
* CPUì—ì„œ ëª…ë ¹ì„ ê¸°ë¡í•˜ê³ , Command Queueì— ì œì¶œí•˜ë©´ GPUê°€ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰

### íŠ¹ì§•

- **Recording State**: ìƒì„± ì§í›„ ë˜ëŠ” Reset í˜¸ì¶œ í›„ ëª…ë ¹ì„ ê¸°ë¡í•  ìˆ˜ ìˆëŠ” ìƒíƒœ
- **Closed State**: Close í˜¸ì¶œ í›„ Command Queueì— ì œì¶œí•  ìˆ˜ ìˆëŠ” ìƒíƒœ
- **Command List Type**:
  - `D3D12_COMMAND_LIST_TYPE_DIRECT`: ê·¸ë˜í”½ ë° ì»´í“¨íŠ¸ ëª…ë ¹ (ê°€ì¥ ì¼ë°˜ì )
  - `D3D12_COMMAND_LIST_TYPE_BUNDLE`: ë¯¸ë¦¬ ê¸°ë¡ëœ ëª…ë ¹ ë²ˆë“¤ (ì¬ì‚¬ìš© ê°€ëŠ¥)
  - `D3D12_COMMAND_LIST_TYPE_COMPUTE`: ì»´í“¨íŠ¸ ì „ìš©
  - `D3D12_COMMAND_LIST_TYPE_COPY`: ë³µì‚¬ ì „ìš©

### ìƒì„± ë°©ë²•

```cpp
ID3D12GraphicsCommandList* pCommandList = nullptr;
ID3D12CommandAllocator* pCommandAllocator = nullptr;

// 1. Command Allocator ìƒì„±
hr = pDevice->CreateCommandAllocator(
    D3D12_COMMAND_LIST_TYPE_DIRECT,
    IID_PPV_ARGS(&pCommandAllocator)
);

// 2. Command List ìƒì„±
hr = pDevice->CreateCommandList(
    0,                                  // nodeMask (ë©€í‹° GPUìš©)
    D3D12_COMMAND_LIST_TYPE_DIRECT,    // íƒ€ì…
    pCommandAllocator,                  // ë©”ëª¨ë¦¬ í• ë‹¹ì
    nullptr,                            // ì´ˆê¸° Pipeline State (ì„ íƒ)
    IID_PPV_ARGS(&pCommandList)
);

// 3. Command ListëŠ” ìƒì„± ì‹œ Recording ìƒíƒœì´ë¯€ë¡œ Close í•„ìš”
pCommandList->Close();
```

### ì£¼ìš” ë©”ì„œë“œ

```cpp
// ëª…ë ¹ ê¸°ë¡ ì‹œì‘ (Reset)
pCommandList->Reset(pCommandAllocator, pPipelineState);

// ë¦¬ì†ŒìŠ¤ ìƒíƒœ ì „í™˜
pCommandList->ResourceBarrier(
    1,
    &CD3DX12_RESOURCE_BARRIER::Transition(
        pResource,
        D3D12_RESOURCE_STATE_PRESENT,
        D3D12_RESOURCE_STATE_RENDER_TARGET
    )
);

// ë Œë” íƒ€ê²Ÿ í´ë¦¬ì–´
const float clearColor[] = { 0.0f, 0.0f, 1.0f, 1.0f };
pCommandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);

// ë“œë¡œìš° ì½œ
pCommandList->DrawInstanced(vertexCount, 1, 0, 0);

// ëª…ë ¹ ê¸°ë¡ ì¢…ë£Œ
pCommandList->Close();
```

---

## Command Allocator

### ê°œë…

* Command Allocator(`ID3D12CommandAllocator`)ëŠ” Command Listê°€ ëª…ë ¹ì„ ê¸°ë¡í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬

### íŠ¹ì§•

- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: Command Listì˜ ëª…ë ¹ë“¤ì´ ì €ì¥ë  ë©”ëª¨ë¦¬ ê³µê°„ ì œê³µ
- **ì¬ì‚¬ìš© ê°€ëŠ¥**: GPUê°€ ëª…ë ¹ ì‹¤í–‰ì„ ì™„ë£Œí•œ í›„ Reset í˜¸ì¶œë¡œ ì¬ì‚¬ìš©
- **Command Listì™€ 1:N ê´€ê³„**: í•˜ë‚˜ì˜ Allocatorì— ì—¬ëŸ¬ Command Listê°€ ì—°ê²°ë  ìˆ˜ ìˆìŒ (ë‹¨, ë™ì‹œì— Recording ì¤‘ì¸ ê²ƒì€ í•˜ë‚˜ë§Œ ê°€ëŠ¥)

### ìƒì„± ë°©ë²•

```cpp
ID3D12CommandAllocator* pCommandAllocator = nullptr;

hr = pDevice->CreateCommandAllocator(
    D3D12_COMMAND_LIST_TYPE_DIRECT,
    IID_PPV_ARGS(&pCommandAllocator)
);
```

### Reset ê·œì¹™

```cpp
// GPUê°€ í•´ë‹¹ Allocatorì˜ ëª…ë ¹ì„ ëª¨ë‘ ì‹¤í–‰ ì™„ë£Œí•œ í›„ì—ë§Œ Reset ê°€ëŠ¥
// Fenceë¥¼ í†µí•´ GPU ì‹¤í–‰ ì™„ë£Œë¥¼ í™•ì¸í•œ í›„ í˜¸ì¶œ
pCommandAllocator->Reset();
```

**âš ï¸ ì£¼ì˜ì‚¬í•­**: GPUê°€ ì•„ì§ ì‹¤í–‰ ì¤‘ì¸ ëª…ë ¹ì„ ê°€ì§„ Allocatorë¥¼ Resetí•˜ë©´ **ì •ì˜ë˜ì§€ ì•Šì€ ë™ì‘**ì´ ë°œìƒ

---

## Command Queue

### ê°œë…

* Command Queue(`ID3D12CommandQueue`)ëŠ” Command Listë¥¼ GPUì— ì œì¶œí•˜ì—¬ ì‹¤í–‰í•˜ëŠ” í
* CPUê°€ ëª…ë ¹ì„ ê¸°ë¡í•œ Command Listë¥¼ ì´ íì— ë„£ìœ¼ë©´, GPUê°€ ìˆœì°¨ì ìœ¼ë¡œ êº¼ë‚´ì„œ ì‹¤í–‰

### ìƒì„± ë°©ë²•

```cpp
ID3D12CommandQueue* pCommandQueue = nullptr;

D3D12_COMMAND_QUEUE_DESC queueDesc = {};
queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
queueDesc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
queueDesc.NodeMask = 0;

hr = pDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&pCommandQueue));
```

### Command List ì‹¤í–‰

```cpp
// Command List ë°°ì—´ ìƒì„±
ID3D12CommandList* ppCommandLists[] = { pCommandList };

// Command Queueì— ì œì¶œí•˜ì—¬ GPU ì‹¤í–‰
pCommandQueue->ExecuteCommandLists(
    _countof(ppCommandLists),  // ê°œìˆ˜
    ppCommandLists             // Command List ë°°ì—´
);
```

### Signalì„ í†µí•œ Fence ì œì–´

```cpp
// Command Queueì— Fence Signal ëª…ë ¹ ì‚½ì…
// Queueì˜ ì´ ì§€ì ê¹Œì§€ ëª…ë ¹ì´ ì‹¤í–‰ë˜ë©´ Fence ê°’ì„ ì—…ë°ì´íŠ¸
pCommandQueue->Signal(pFence, fenceValue);
```

---

## Fence

### ê°œë…

* Fence(`ID3D12Fence`)ëŠ” CPUì™€ GPU ê°„ì˜ ë™ê¸°í™”ë¥¼ ìœ„í•œ ê°ì²´
* GPUì˜ ì‘ì—… ì§„í–‰ ìƒíƒœë¥¼ ì¶”ì í•˜ê³ , CPUê°€ GPUì˜ ì‘ì—… ì™„ë£Œë¥¼ ëŒ€ê¸°í•  ìˆ˜ ìˆê²Œ í•¨

### ë™ì‘ ì›ë¦¬

```
CPU                         GPU
 â”‚                           â”‚
 â”œâ”€ CommandList ê¸°ë¡         â”‚
 â”œâ”€ ExecuteCommandLists()    â”‚
 â”œâ”€ Signal(fence, N)         â”‚
 â”‚                           â”œâ”€ CommandList ì‹¤í–‰ ì‹œì‘
 â”œâ”€ GetCompletedValue()      â”‚
 â”‚   (ì•„ì§ Në³´ë‹¤ ì‘ìŒ)        â”‚
 â”‚                           â”œâ”€ ëª…ë ¹ ì‹¤í–‰ ì¤‘...
 â”‚                           â”œâ”€ ëª…ë ¹ ì‹¤í–‰ ì™„ë£Œ
 â”‚                           â”œâ”€ Fence ê°’ì„ Nìœ¼ë¡œ ì„¤ì •
 â”œâ”€ GetCompletedValue()      â”‚
 â”‚   (N ì´ìƒ, ì™„ë£Œ!)          â”‚
```

### ìƒì„± ë°©ë²•

```cpp
ID3D12Fence* pFence = nullptr;
UINT64 fenceValue = 0;
HANDLE fenceEvent = nullptr;

// 1. Fence ìƒì„±
hr = pDevice->CreateFence(
    0,                          // ì´ˆê¸° ê°’
    D3D12_FENCE_FLAG_NONE,     // í”Œë˜ê·¸
    IID_PPV_ARGS(&pFence)
);

// 2. ì´ë²¤íŠ¸ í•¸ë“¤ ìƒì„± (CPU ëŒ€ê¸°ìš©)
fenceEvent = CreateEvent(nullptr, FALSE, FALSE, nullptr);
```

### Fenceë¥¼ í†µí•œ ë™ê¸°í™”

#### ë°©ë²• 1: í´ë§(Polling)

```cpp
// GPUì— Fence Signal ëª…ë ¹ ì œì¶œ
const UINT64 targetValue = ++fenceValue;
pCommandQueue->Signal(pFence, targetValue);

// CPUì—ì„œ GPU ì™„ë£Œ ëŒ€ê¸° (í´ë§ ë°©ì‹)
while (pFence->GetCompletedValue() < targetValue)
{
    // ëŒ€ê¸° (ë¹„íš¨ìœ¨ì  - CPU ì‚¬ì´í´ ë‚­ë¹„)
}
```

#### ë°©ë²• 2: ì´ë²¤íŠ¸ ëŒ€ê¸° (ê¶Œì¥)

```cpp
// GPUì— Fence Signal ëª…ë ¹ ì œì¶œ
const UINT64 targetValue = ++fenceValue;
pCommandQueue->Signal(pFence, targetValue);

// GPUê°€ ì•„ì§ ì™„ë£Œí•˜ì§€ ì•Šì•˜ë‹¤ë©´
if (pFence->GetCompletedValue() < targetValue)
{
    // Fence ê°’ì´ targetValueì— ë„ë‹¬í•˜ë©´ ì´ë²¤íŠ¸ ë°œìƒ
    pFence->SetEventOnCompletion(targetValue, fenceEvent);
    
    // CPUë¥¼ Sleep ìƒíƒœë¡œ ì „í™˜í•˜ì—¬ ëŒ€ê¸° (íš¨ìœ¨ì )
    WaitForSingleObject(fenceEvent, INFINITE);
}
```

### Fence ê°’ ê´€ë¦¬

```cpp
class Renderer
{
private:
    ID3D12Fence* m_pFence;
    UINT64 m_fenceValue;        // í˜„ì¬ Fence ê°’
    HANDLE m_fenceEvent;

public:
    UINT64 SignalFence()
    {
        // Fence ê°’ ì¦ê°€ í›„ Signal
        m_fenceValue++;
        m_pCommandQueue->Signal(m_pFence, m_fenceValue);
        return m_fenceValue;
    }

    void WaitForFence(UINT64 targetValue)
    {
        // GPUê°€ í•´ë‹¹ ê°’ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ëŒ€ê¸°
        if (m_pFence->GetCompletedValue() < targetValue)
        {
            m_pFence->SetEventOnCompletion(targetValue, m_fenceEvent);
            WaitForSingleObject(m_fenceEvent, INFINITE);
        }
    }

    void WaitForGPUIdle()
    {
        // ëª¨ë“  GPU ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        UINT64 currentFence = SignalFence();
        WaitForFence(currentFence);
    }
};
```

---

### RTV íë¦„

```cpp
BOOL CD3D12Renderer::CreateDescriptorHeap()
{
	HRESULT hr = S_OK;

	// ë Œë”íƒ€ê²Ÿìš© ë””ìŠ¤í¬ë¦½í„°í™ì„ ìƒì„±í•¨ìœ¼ë¡œì„œ ë©”ëª¨ë¦¬ í• ë‹¹
	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
	rtvHeapDesc.NumDescriptors = SWAP_CHAIN_FRAME_COUNT;	// SwapChain Buffer 0	| SwapChain Buffer 1
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	if (FAILED(m_pD3DDevice->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&m_pRTVHeap))))
	{
		__debugbreak();
	}

	m_rtvDescriptorSize = m_pD3DDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	return TRUE;
}
```

```cpp
// RTV ë””ìŠ¤í¬ë¦½í„°í™ìœ¼ë¡œ ë¶€í„° í•¸ë“¤ì„ ë°›ê³ 
CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_pRTVHeap->GetCPUDescriptorHandleForHeapStart());

for (UINT n = 0; n < SWAP_CHAIN_FRAME_COUNT; n++)
{
    // m_pRenderTargetsì— ìŠ¤ì™‘ì²´ì¸ì˜ ì£¼ì†Œë¥¼ ë‹´ëŠ”ë‹¤
    m_pSwapChain->GetBuffer(n, IID_PPV_ARGS(&m_pRenderTargets[n]));
    // m_pRenderTargetsì™€ rtvHandleë¥¼ ì—°ê²°. ì´ì œ rtvHandleì— ì“°ë©´ ìŠ¤ì™‘ì²´ì¸ì— ì¨ì§„ë‹¤
    m_pD3DDevice->CreateRenderTargetView(m_pRenderTargets[n], nullptr, rtvHandle);
    // ++ì˜ ì—­í• 
    rtvHandle.Offset(1, m_rtvDescriptorSize);
}
```

```cpp
void CD3D12Renderer::BeginRender()
{
	//
	// í™”ë©´ í´ë¦¬ì–´ ë° ì´ë²ˆ í”„ë ˆì„ ë Œë”ë§ì„ ìœ„í•œ ìë£Œêµ¬ì¡° ì´ˆê¸°í™”
	//
	if (FAILED(m_pCommandAllocator->Reset()))
		__debugbreak();

	if (FAILED(m_pCommandList->Reset(m_pCommandAllocator, nullptr)))
		__debugbreak();

	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(m_pRTVHeap->GetCPUDescriptorHandleForHeapStart(), m_uiRenderTargetIndex, m_rtvDescriptorSize);

	m_pCommandList->ResourceBarrier(1, 
        &CD3DX12_RESOURCE_BARRIER::Transition(m_pRenderTargets[m_uiRenderTargetIndex],  // ì—¬ê¸°ì—
        D3D12_RESOURCE_STATE_PRESENT,                                                   // presentë¥¼
        D3D12_RESOURCE_STATE_RENDER_TARGET));                                           // rtë¡œ

	// Record commands.
	const float BackColor[] = { 0.0f, 0.0f, 1.0f, 1.0f };
	m_pCommandList->ClearRenderTargetView(rtvHandle, BackColor, 0, nullptr);

}
```

---

## ë™ê¸°í™” íë¦„

### í”„ë ˆì„ ë Œë”ë§ ì‚¬ì´í´

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Frame N ë Œë”ë§ ì‚¬ì´í´                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CPU                                     GPU
 â”‚                                       â”‚
 â”œâ”€ 1. CommandAllocator->Reset()        â”‚ (Frame N-1 ì‹¤í–‰ ì¤‘)
 â”‚                                       â”‚
 â”œâ”€ 2. CommandList->Reset(Allocator)    â”‚
 â”‚                                       â”‚
 â”œâ”€ 3. CommandListì— ëª…ë ¹ ê¸°ë¡          â”‚
 â”‚    - ResourceBarrier                  â”‚
 â”‚    - ClearRenderTargetView            â”‚
 â”‚    - DrawInstanced                    â”‚
 â”‚    - ResourceBarrier                  â”‚
 â”‚                                       â”‚
 â”œâ”€ 4. CommandList->Close()             â”‚
 â”‚                                       â”‚
 â”œâ”€ 5. ExecuteCommandLists()            â”‚
 â”‚                                       â”œâ”€ Frame N ì‹¤í–‰ ì‹œì‘
 â”œâ”€ 6. Present()                        â”‚
 â”‚                                       â”‚
 â”œâ”€ 7. Signal(Fence, N)                 â”‚
 â”‚                                       â”œâ”€ ëª…ë ¹ ì‹¤í–‰ ì¤‘...
 â”œâ”€ 8. WaitForFenceValue(N)             â”‚
 â”‚    (Frame N-1 ì™„ë£Œ ëŒ€ê¸°)              â”‚
 â”‚                                       â”œâ”€ Frame N ì™„ë£Œ
 â”‚                                       â”œâ”€ Fence = N
 â”œâ”€ ì´ë²¤íŠ¸ ë°œìƒ, CPU ê¹¨ì–´ë‚¨             â”‚
 â”‚                                       â”‚
 â”œâ”€ ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ...                   â”‚
 â”‚                                       â”‚
```

### ë”ë¸” ë²„í¼ë§ì—ì„œì˜ Fence ì‚¬ìš©

```cpp
// ê° í”„ë ˆì„ë§ˆë‹¤ ë³„ë„ì˜ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
const UINT FRAME_COUNT = 2;
ID3D12CommandAllocator* pCommandAllocators[FRAME_COUNT];
UINT64 frameFenceValues[FRAME_COUNT] = { 0, 0 };
UINT frameIndex = 0;

void Render()
{
    // í˜„ì¬ í”„ë ˆì„ì˜ CommandAllocatorê°€ GPUì—ì„œ ì‚¬ìš© ì™„ë£Œë˜ì—ˆëŠ”ì§€ í™•ì¸
    if (pFence->GetCompletedValue() < frameFenceValues[frameIndex])
    {
        pFence->SetEventOnCompletion(frameFenceValues[frameIndex], fenceEvent);
        WaitForSingleObject(fenceEvent, INFINITE);
    }

    // GPU ì‚¬ìš© ì™„ë£Œ í™•ì¸ í›„ Reset
    pCommandAllocators[frameIndex]->Reset();
    pCommandList->Reset(pCommandAllocators[frameIndex], nullptr);

    // ë Œë”ë§ ëª…ë ¹ ê¸°ë¡
    RecordCommandList();
    pCommandList->Close();

    // GPUì— ì œì¶œ
    ExecuteCommandList();

    // Present
    pSwapChain->Present(1, 0);

    // í˜„ì¬ í”„ë ˆì„ì— Fence ê°’ ê¸°ë¡
    frameFenceValues[frameIndex] = ++currentFenceValue;
    pCommandQueue->Signal(pFence, frameFenceValues[frameIndex]);

    // ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ
    frameIndex = (frameIndex + 1) % FRAME_COUNT;
}
```

