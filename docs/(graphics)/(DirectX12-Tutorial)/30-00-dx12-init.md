---
layout: default
title: "30-00. Instancing"
parent: "(DirectX12 Tutorial)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 4
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/DirextX12-Example/tree/24)

## ì´ë¡  - Instancingì´ í•„ìš”í•œ ì´ìœ ?

* Particleì„ ë§Œë“¤ì‹œ Instanceë¥¼ ì—¬ëŸ¬ê°œ ë‘˜ ìˆ˜ ìˆì—ˆë‹¤.

```cpp
void Mesh::Render(uint32 instanceCount)
{
    // Instance í•˜ë‚˜ë¥¼ PipelineëŒì•„ì£¼ì„¸ìš”. ì´ëŸ° ëª…ë ¹ì´ë¼ ë³´ë©´ ëœë‹¤.
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, instanceCount/*í•˜ë‚˜*/, 0, 0, 0);
}
```

* ì™œ Instanceë¥¼ ì—¬ëŸ¬ê°œ ë‘˜ ì‹œ ì„±ëŠ¥ìƒ ì´ë“ì„ ë³´ëŠ”ê°€?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-29-2.png"/>
</p>

* ì–´ë–»ê²Œ ë³´ë©´ ë‹¹ì—°í•œ ì–˜ê¸°ì¼ ìˆ˜ ìˆìœ¼ë‚˜ Vertex, Index Bufferë¥¼ GPUë¡œ ë„˜ê¸°ëŠ” ì‹œê°„ + Materialì„ ë„˜ê¸°ëŠ” ì‹œê°„ + ì‰ì´ë”ë¥¼ ê³„ì‚°í•˜ëŠ” ì‹œê°„ = ì´ ì†Œëª¨í•˜ëŠ” ì‹œê°„ì´ ëœë‹¤. ê²°ë¡ ì ìœ¼ë¡œ ë§í•˜ìë©´ Vertex, Index, Material, Shaderê°€ ê°™ë‹¤ë©´ Instancingì„ ì´ìš©í•˜ëŠ” ê²ƒì´ ì„±ëŠ¥ìƒ ë§¤ìš°ë§¤ìš°ë§¤ìš° ìœ ë¦¬í•˜ë‹¤
* ëŒ€í‘œì ì¸ ì˜ˆì‹œë¡  ì €ê¸€ë§ 200ë§ˆë¦¬ë¥¼ ë§¤ë²ˆ Pipelineë„ëŠ”ê²ƒ ë³´ë‹¤. Instancingìœ¼ë¡œ ê·¸ë¦¬ë©´ ë” íš¨ìœ¨ì ì´ê² ì§€?

---

* ì´ì „ê°• Instanceë¥¼ ì´ìš©ì‹œ GPUì—ì„œ í¬ê¸°, ìœ„ì¹˜, ì†ë„ ë“±ì„ ê³„ì‚°í–ˆëŠ”ë° ê·¸ëŸ° ì •ë³´ë¥¼ CPUì—ì„œ ì§ì ‘ì£¼ê³  ì‹¶ë‹¤ë©´ Constant Bufferë¥¼ ì‚¬ìš©í•´ì•¼í• ê¹Œ? 

```cpp
// ìš°ì„  ì •ë‹µë¶€í„° ë§í•˜ìë©´ Constant Bufferë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ê²Œ ë§ìŒ

void Mesh::Render(shared_ptr<InstancingBuffer>& buffer)
{
	D3D12_VERTEX_BUFFER_VIEW bufferViews[] = { _vertexBufferView, buffer->GetBufferView() };
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 2/* CBë¥¼ 2ê°œ ì‚¬ìš©í•œë‹¤ ì•Œë¦°ë‹¤ */, bufferViews);
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, buffer->GetCount(), 0, 0, 0);
}
```

---

## êµ¬í˜„

```cpp
struct InstancingParams
{
    // ì¸ìŠ¤í„´ìŠ¤ë§ˆë‹¤ì˜ ì¢Œí‘œì •ë³´
	Matrix matWorld;
	Matrix matWV;
	Matrix matWVP;
};

class InstancingBuffer
{
public:
	InstancingBuffer();
	~InstancingBuffer();

	void Init(uint32 maxCount = 10);

	void Clear();
	void AddData(InstancingParams& params);
	void PushData();

public:
	uint32						GetCount() { return static_cast<uint32>(_data.size()); }
	ComPtr<ID3D12Resource>		GetBuffer() { return _buffer; }
	D3D12_VERTEX_BUFFER_VIEW	GetBufferView() { return _bufferView; }

	void	SetID(uint64 instanceId) { _instanceId = instanceId; }
	uint64	GetID() { return _instanceId; }

private:
	uint64						_instanceId = 0;
	ComPtr<ID3D12Resource>		_buffer;
	D3D12_VERTEX_BUFFER_VIEW	_bufferView;

	uint32						_maxCount = 0;
	vector<InstancingParams>	_data;
};
```

```cpp
// Instanceë„ ë³„ë„ì˜ Managerë¡œ ê´€ë¦¬í•˜ê²Œ ë˜ëŠ”ë°
class InstancingManager
{
	DECLARE_SINGLE(InstancingManager);

public:
	void Render(vector<shared_ptr<GameObject>>& gameObjects);

	void ClearBuffer();
	void Clear() { _buffers.clear(); }

private:
    // ì°¸ê³ ë¡œ ì´ì œ Instanceë¥¼ Instanceë³„ IDë¡œ ê´€ë¦¬í•˜ê²Œ ëœë‹¤.
    // Instance IDëŠ” Vertex, Index, Material ì •ë³´ê°€ ì¼ì¹˜í• ì‹œ ê°™ì€ IDë¥¼ ë¶€ì—¬í•  ê²ƒì¸ë° ë’¤ì—ì„œ ìì„¸íˆ ë‚˜ì˜´.
	void AddParam(uint64 instanceId, InstancingParams& data);

private:
	map<uint64/*instanceId*/, shared_ptr<InstancingBuffer>> _buffers;
    /*
        // InstanceIDëŠ” ì´ë ‡ê²Œ êµ¬í•œë‹¤
        uint64 MeshRenderer::GetInstanceID()
        {
            if (_mesh == nullptr || _material == nullptr)
                return 0;

            //uint64 id = (_mesh->GetID() << 32) | _material->GetID();
            InstanceID instanceID{ _mesh->GetID(), _material->GetID() };
            return instanceID.id;
        }
    */
};
```

```cpp
void InstancingManager::Render(vector<shared_ptr<GameObject>>& gameObjects)
{
	map<uint64, vector<shared_ptr<GameObject>>> cache;

	for (shared_ptr<GameObject>& gameObject : gameObjects)
	{
		const uint64 instanceId = gameObject->GetMeshRenderer()->GetInstanceID();
		cache[instanceId].push_back(gameObject);
	}

	for (auto& pair : cache)
	{
		const vector<shared_ptr<GameObject>>& vec = pair.second;

		if (vec.size() == 1)
		{
            // Instancingì´ í•„ìš”ì—†ëŠ” ê²½ìš° ê·¸ëƒ¥ Render
			vec[0]->GetMeshRenderer()->Render();
		}
		else
		{
			const uint64 instanceId = pair.first;

            // Instancingí•  ì• ë“¤ì„ í•œ ë°©ì— ì •ë¦¬í•´ì„œ
			for (const shared_ptr<GameObject>& gameObject : vec)
			{
				InstancingParams params;
				params.matWorld = gameObject->GetTransform()->GetLocalToWorldMatrix();
				params.matWV = params.matWorld * Camera::S_MatView;
				params.matWVP = params.matWorld * Camera::S_MatView * Camera::S_MatProjection;

				AddParam(instanceId, params);
			}

            // ì—¬ê¸°ì„œ ê·¸ë ¤ë‹¬ë¼ê³  ìš”ì²­
			shared_ptr<InstancingBuffer>& buffer = _buffers[instanceId];
			vec[0]->GetMeshRenderer()->Render(buffer);
		}
	}
}
```

```cpp
void MeshRenderer::Render(shared_ptr<InstancingBuffer>& buffer)
{
	buffer->PushData();
    /*
        void InstancingBuffer::PushData()
        {
            const uint32 dataCount = GetCount();
            if (dataCount > _maxCount)
                Init(dataCount);

            const uint32 bufferSize = dataCount * sizeof(InstancingParams);

            void* dataBuffer = nullptr;
            D3D12_RANGE readRange{ 0, 0 };
            _buffer->Map(0, &readRange, &dataBuffer);
            memcpy(dataBuffer, &_data[0], bufferSize);
            _buffer->Unmap(0, nullptr);

            _bufferView.BufferLocation = _buffer->GetGPUVirtualAddress();
            _bufferView.StrideInBytes = sizeof(InstancingParams);
            _bufferView.SizeInBytes = bufferSize;
        }
    */

	_material->PushGraphicsData();
	_mesh->Render(buffer);
}
```

```cpp
void Mesh::Render(shared_ptr<InstancingBuffer>& buffer)
{
	D3D12_VERTEX_BUFFER_VIEW bufferViews[] = { _vertexBufferView, buffer->GetBufferView() };
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 
            2/*ë‘ê°œì˜ ë²„í¼ë¥¼ ë„˜ê¸´ë‹¤. ({ _vertexBufferView, buffer->GetBufferView() })*/, 
            bufferViews);
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, buffer->GetCount(), 0, 0, 0);
}
```

```cpp
void Shader::CreateGraphicsShader(const wstring& path, ShaderInfo info, const string& vs, const string& ps, const string& gs)
{
	_info = info;

	CreateVertexShader(path, vs, "vs_5_0");
	CreatePixelShader(path, ps, "ps_5_0");

	if (gs.empty() == false)
		CreateGeometryShader(path, gs, "gs_5_0");

	D3D12_INPUT_ELEMENT_DESC desc[] =
	{
        // ì²« ë²ˆì§¸ ë²„í¼
            // D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA - classë§ˆë‹¤ ê³ ìœ í•œ ê°’ì´ ìˆìŒ
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 20, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 32, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },

        // ë‘ ë²ˆì§¸ ë²„í¼ì— ì¶”ê°€ë¡œ ë„˜ì–´ê°ˆ ë¶€ë¶„ ì¶”ê°€ë¨
		    // 4*4 Matrixë¥¼ ë„˜ê¸°ê¸° ìœ„í•´ 0~3ì„ floatìœ¼ë¡œ ë§Œë“ ë‹¤
            // D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA - ì¸ìŠ¤í„´ìŠ¤ë§ˆë‹¤ ê³ ìœ í•œ ê°’ì´ ìˆìŒ
        { "W", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0,  D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "W", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 16, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "W", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 32, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "W", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 48, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 64, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 80, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 96, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WV", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 112, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 128, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 1, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 144, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 2, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 160, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
		{ "WVP", 3, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 176, D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA, 1},
	};

    // ...
```

```cpp
// defer.fx
struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;

    // shaderì—­ì‹œ ì¶”ê°€ë¨.
    row_major matrix matWorld : W;
    row_major matrix matWV : WV;
    row_major matrix matWVP : WVP;
    uint instanceID : SV_InstanceID;
};

// ...

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    if (g_int_0 == 1)
    {
        output.pos = mul(float4(input.pos, 1.f), input.matWVP);
        output.uv = input.uv;

        output.viewPos = mul(float4(input.pos, 1.f), input.matWV).xyz;
        output.viewNormal = normalize(mul(float4(input.normal, 0.f), input.matWV).xyz);
        output.viewTangent = normalize(mul(float4(input.tangent, 0.f), input.matWV).xyz);
        output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));
    }
    else
    {
        output.pos = mul(float4(input.pos, 1.f), g_matWVP);
        output.uv = input.uv;

        output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;
        output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);
        output.viewTangent = normalize(mul(float4(input.tangent, 0.f), g_matWV).xyz);
        output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));
    }   

    return output;
}
```
