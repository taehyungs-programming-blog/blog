---
layout: default
title: "19. [êµ¬í˜„] Lighting"
parent: "(DirectX12 Tutorial)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/DirextX12-Example/tree/15)

## Light Componentë¥¼ ì¶”ê°€í•´ ë³´ì

```cpp
#pragma once
#include "Component.h"

// ë¹›ì´ ì–´ë–»ê²Œ ì˜¬ ê²ƒì¸ê°€ ì •ë³´
enum class LIGHT_TYPE : uint8
{
	DIRECTIONAL_LIGHT,
	POINT_LIGHT,
	SPOT_LIGHT,
};

// ë¹›ë§ˆë‹¤ ì†ì„±
struct LightColor
{
    // ì—¬ê¸°ì„œ ë“œëŠ” ì˜ë¬¸ì  RGBë¼ Vec3ì´ì§€ ì™œ Vec4ì¸ê°€?
    // bytes padding(ì•„ë˜ì„œ ë‚˜ì˜´) ë•Œë¬¸ì„.
	Vec4	diffuse;
	Vec4	ambient;
	Vec4	specular;
};

// ì‰ì´ë”ì— ë„˜ê²¨ì¤„ ë¹›ì˜ ì •ë³´
struct LightInfo
{
	LightColor	color;          // ë¹›ì˜ ì†ì„±
	Vec4		position;       // ë¹›ì˜ ìœ„ì¹˜   
	Vec4		direction;      // ë¹›ì˜ ë°©í–¥
	int32		lightType;      // LIGHT_TYPE
	float		range;          // ë¹›ì˜ ìµœëŒ€ ë²”ìœ„
	float		angle;          // ë¹›ì´ ì˜ëŠ” ê°ë„
	int32		padding;        // 16 bytes ë¡œ ë§Œë“¤ê¸° ìœ„í•œ padding
};

struct LightParams
{
	uint32		lightCount;     // ë¹›ì˜ ê°œìˆ˜
	Vec3		padding;
	LightInfo	lights[50];     // ë¹›ì˜ ì •ë³´ë¥¼ í•˜ë‚˜ë¡œ ë¬¶ì–´ì„œ ë³´ë‚¸ë‹¤
};

class Light : public Component
{
public:
	Light();
	virtual ~Light();

	virtual void FinalUpdate() override;
    /*
        void Light::FinalUpdate()
        {
            _lightInfo.position = GetTransform()->GetWorldPosition();
        }
    */

public:
	const LightInfo& GetLightInfo() { return _lightInfo; }

	void SetLightDirection(const Vec3& direction) { _lightInfo.direction = direction; }

	// Vec3ë¥¼ Vec4ì— ë„£ëŠ”ë‹¤ê³ ??
	/*
	SimpeMath.hì— ë‹¤ìŒì„ ì¶”ê°€
	Vector4& operator=(const Vector3& V) noexcept { x = V.x; y = V.y; z = V.z; w = 0.f; return *this; }
	*/
	void SetDiffuse(const Vec3& diffuse) { _lightInfo.color.diffuse = diffuse; }
	void SetAmbient(const Vec3& ambient) { _lightInfo.color.ambient = ambient; }
	void SetSpecular(const Vec3& specular) { _lightInfo.color.specular = specular; }

	void SetLightType(LIGHT_TYPE type) { _lightInfo.lightType = static_cast<int32>(type); }
	void SetLightRange(float range) { _lightInfo.range = range; }
	void SetLightAngle(float angle) { _lightInfo.angle = angle; }

private:
	LightInfo _lightInfo = {};
};
```

* GameObjectì— Lightë¥¼ ì¶”ê°€

```cpp
class GameObject : public Object, public enable_shared_from_this<GameObject>
{
	// ...
	shared_ptr<Light> GetLight();

// ...

shared_ptr<Light> GameObject::GetLight()
{
	shared_ptr<Component> component = GetFixedComponent(COMPONENT_TYPE::LIGHT);
	return static_pointer_cast<Light>(component);
}
```

---


### ì ê¹ë³µìŠµ ConstantBuffer Vs Descriptor Table

* ì§€ê¸ˆ í—·ê°ˆë¦¬ëŠ”ê²Œ ConstantBufferì—ì„œ `PushData`ë¥¼ í•˜ë©´ ì‚¬ì‹¤ DescriptorTableì„ ì‚¬ìš©í•´ Pushë¥¼ í•œë‹¤.
* ë”°ë¼ì„œ ìƒˆë¡œìš´ `SetGlobalData`ë¥¼ ë§Œë“¤ì–´ ConstantBufferë¥¼ ë„˜ê²¨ì•¼í•œë‹¤.

```cpp
void ConstantBuffer::PushData(void* buffer, uint32 size)
{
	assert(_currentIndex < _elementCount);
	assert(_elementSize == ((size + 255) & ~255));

	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
	GEngine->GetTableDescHeap()->SetCBV(cpuHandle, _reg);

	_currentIndex++;
}

void ConstantBuffer::SetGlobalData(void* buffer, uint32 size)
{
	assert(_elementSize == ((size + 255) & ~255));
	::memcpy(&_mappedBuffer[0], buffer, size);
	CMD_LIST->SetGraphicsRootConstantBufferView(0, GetGpuVirtualAddress(0));
}
```

* ìœ„ì—ì„œë„ ì„¤ëª…ì„ í–ˆì§€ë§Œ ì¶”ê°€ì ìœ¼ë¡œ ì„¤ëª…í•˜ìë©´ Renderë¥¼ í•  ì‹œì— LightDataë¥¼ í•œ ë²ˆë§Œ ë©”ëª¨ë¦¬ë¡œ ë³´ë‚´ì¤˜ë„ ëœë‹¤(ì–´ì°¨í”¼ ê²Œì„ë‚´ ëª¨ë“  objectì— ë™ì¼í•˜ê²Œ ì ìš©ë  ê²ƒì´ê¸° ë•Œë¬¸)

```cpp
void Scene::Render()
{
    // LightëŠ” í•œ ë²ˆë§Œ
	PushLightData();

	for (auto& gameObject : _gameObjects)
	{
		if (gameObject->GetCamera() == nullptr)
			continue;

        // gameObjectëŠ” ëª¨ë‘ Renderë¥¼ ëŒë©°
		gameObject->GetCamera()->Render();
        /*
            // mesh ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì¹´ë“œì— ë„˜ê²¨ì•¼í•œë‹¤.
            void MeshRenderer::Render()
            {
                GetTransform()->PushData();
                _material->PushData();
                _mesh->Render();
            }
        */
	}
}
```

---

* ë‹¤ì‹œ ëŒì•„ê°€ì„œ...

```cpp
void RootSignature::CreateRootSignature()
{
    /*
        // ê¸°ì¡´ì—ëŠ” Descriptor Tableë§Œ ì‚¬ìš©í•˜ê³  ìˆì—ˆë‹¤.
        void RootSignature::CreateRootSignature()
        {
            CD3DX12_DESCRIPTOR_RANGE ranges[] =
            {
                CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT, 0), // b0~b4
                CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t4
            };

            CD3DX12_ROOT_PARAMETER param[1];
            param[0].InitAsDescriptorTable(_countof(ranges), ranges);
    */

    // Descriptor Table ì„ ì–¸
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT - 1/*b0ë¥¼ ë¹¼ì¤€ë‹¤(ConstantBufferë¡œ ì“¸ ì˜ˆì •)*/, 1), // b1~b4
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t4
	};

	CD3DX12_ROOT_PARAMETER param[2];

    // Constant Buffer ì„ ì–¸
	param[0].InitAsConstantBufferView(static_cast<uint32>(CBV_REGISTER::b0)); // b0 -> Constant Buffer
	param[1].InitAsDescriptorTable(_countof(ranges), ranges);	

	// ...
```

```cpp
void TableDescriptorHeap::Init(uint32 count)
{
	_groupCount = count;

	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = count * (REGISTER_COUNT - 1); // b0ëŠ” ì „ì—­ ì´ê¸°ì— ëº€ë‹¤
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

	DEVICE->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&_descHeap));

	_handleSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	_groupSize = _handleSize * (REGISTER_COUNT - 1); // b0ëŠ” ì „ì—­ ì´ê¸°ì— ëº€ë‹¤
}
```

```cpp
D3D12_CPU_DESCRIPTOR_HANDLE TableDescriptorHeap::GetCPUHandle(uint8 reg)
{
	assert(reg > 0);    // b0ë¥¼ ì„ íƒí•˜ì§€ ëª»í•˜ê²Œ ê±¸ëŸ¬ì•¼í•œë‹¤.
	D3D12_CPU_DESCRIPTOR_HANDLE handle = _descHeap->GetCPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	handle.ptr += (reg - 1) * _handleSize;
	return handle;
}
```

```cpp
void Engine::Init(const WindowInfo& info)
{
	// ...

    // LightëŠ” Constant Bufferë¡œ ì„ ì–¸
	CreateConstantBuffer(CBV_REGISTER::b0, sizeof(LightParams), 1);

	// b1, b2ëŠ” êµì²´ë˜ëŠ” ë¶€ë¶„
	CreateConstantBuffer(CBV_REGISTER::b1, sizeof(TransformParams), 256);
	CreateConstantBuffer(CBV_REGISTER::b2, sizeof(MaterialParams), 256);
```

```cpp
// b0ìš© Constant Buffer ë°ì´í„° ë³µì‚¬
void ConstantBuffer::SetGlobalData(void* buffer, uint32 size)
{
	assert(_elementSize == ((size + 255) & ~255));
	::memcpy(&_mappedBuffer[0], buffer, size);
	CMD_LIST->SetGraphicsRootConstantBufferView(0, GetGpuVirtualAddress(0));
}
```

```cpp
void Scene::PushLightData()
{
	LightParams lightParams = {};
/*
    struct LightParams
    {
        uint32		lightCount;     // ë¹›ì˜ ê°œìˆ˜
        Vec3		padding;
        LightInfo	lights[50];     // ë¹›ì˜ ì •ë³´ë¥¼ í•˜ë‚˜ë¡œ ë¬¶ì–´ì„œ ë³´ë‚¸ë‹¤(ìµœëŒ€ 50ê°œ ë¹› ì§€ì›)
    };
*/

	for (auto& gameObject : _gameObjects)
	{
		if (gameObject->GetLight() == nullptr)
			continue;

		const LightInfo& lightInfo = gameObject->GetLight()->GetLightInfo();

		lightParams.lights[lightParams.lightCount] = lightInfo;
		lightParams.lightCount++;
	}

	CONST_BUFFER(CONSTANT_BUFFER_TYPE::GLOBAL)->SetGlobalData(&lightParams, sizeof(lightParams));
}
```

---

```cpp
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

// í˜„ì¬ ì‰ì´ë”ì—ì„œëŠ” matWVP(World, View, Projection)ì´ ê³„ì‚°ì´ ì™„ë£Œëœ Matrixë¥¼ ê·¸ëŒ€ë¡œ ì“°ê³ ìˆìŒ.
/*
    // ì½”ë“œì—ì„  ì´ë ‡ê²Œ ë„˜ê²¨ì¤€ë‹¤
    void Transform::PushData()
    {
        Matrix matWVP = _matWorld * Camera::S_MatView * Camera::S_MatProjection;
        CONST_BUFFER(CONSTANT_BUFFER_TYPE::TRANSFORM)->PushData(&matWVP, sizeof(matWVP));
    }
*/

    output.pos = mul(float4(input.pos, 1.f), matWVP);
    output.uv = input.uv;

    return output;
}
```

* í˜„ì œëŠ” ì‰ì´ë”ì— ì¢Œí‘œê³„ê°€ World, View, Projectionì´ ì™„ë£Œëœ matWVPê°€ ë“¤ì–´ê°€ëŠ”ë°
ë¹›ê³¼ ê´€ë ¨ëœ ì‰ì´ë” ì²˜ë¦¬ í˜¹ì€ ì´í›„ì˜ ë‹¤ë¥¸ ì²˜ë¦¬ë¥¼ ìœ„í•´ World, View, Projectionê°ê°ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í• ì§€ ëª¨ë¥¸ë‹¤. -> ê°ê°ì˜ ì¢Œí‘œê³„ë¥¼ ì‰ì´ë”ë¡œ ë„˜ê²¨ë³´ì
* ìš°ì„  ë„˜ê¸¸ êµ¬ì¡°ì²´ë¥¼ ìƒì„±

```cpp
// EnginePch.h

struct TransformParams
{
	Matrix matWorld;
	Matrix matView;
	Matrix matProjection;
	Matrix matWV;
	Matrix matWVP;
};
```

```cpp
void Transform::PushData()
{
	TransformParams transformParams = {};
	transformParams.matWorld = _matWorld;
	transformParams.matView = Camera::S_MatView;
	transformParams.matProjection = Camera::S_MatProjection;
	transformParams.matWV = _matWorld * Camera::S_MatView;
	transformParams.matWVP = _matWorld * Camera::S_MatView * Camera::S_MatProjection;

	CONST_BUFFER(CONSTANT_BUFFER_TYPE::TRANSFORM)->PushData(&transformParams, sizeof(transformParams));
}
```

```
 (ë¹›)(L)
 \              (ì •ë°˜ì‚¬)(R)
  \      (N)      /
   \      |      /
    \     |     /
     \    |    /
      \(a)|   /
       \  |  /
--------------------------------------
 (   ë¹›ì´ ë§ì€ ê³³   )
```

```cpp
// default.hlsli

struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
    float3 normal : NORMAL; // normal ë²¡í„°
};

struct VS_OUT
{
    float4 pos : SV_Position;
    float2 uv : TEXCOORD;
    float3 viewPos : POSITION;  // ë¹›ì´ ë”± ë§ì€ ê³³ì˜ ìœ„ì¹˜
    float3 viewNormal : NORMAL; // ë¹›ì´ ë”± ë§ì€ ê³³ì˜ ë…¸ë©€ ë²¡í„°
};

// ...

// ì‰ì´ë” ì½”ë“œì— ëŒ€í•œ ì„¤ëª…ì€ ë‹¤ìŒê°•ì—ì„œ ì§„í–‰í•œë‹¤.
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    // ìœ„ì¹˜ ì¢Œí‘œë¥¼ êµ¬í•˜ê¸° ìœ„í•´ mul(float4(input.pos, 1.f /*ë§ˆì§€ë§‰ 1ì£¼ì˜*/)
    output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;
    
    // ë°©í–¥ ë²¡í„°ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ normalize(mul(float4(input.normal, 0.f/*ë§ˆì§€ë§‰ 0ì£¼ì˜*/)
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);

    return output;
}

float4 PS_Main(VS_OUT input) : SV_Target
{
    //float4 color = g_tex_0.Sample(g_sam_0, input.uv);
    float4 color = float4(1.f, 1.f, 1.f, 1.f);

    LightColor totalColor = (LightColor)0.f;

    for (int i = 0; i < g_lightCount; ++i)
    {
         LightColor color = CalculateLightColor(i, input.viewNormal, input.viewPos);
         totalColor.diffuse += color.diffuse;
         totalColor.ambient += color.ambient;
         totalColor.specular += color.specular;
    }

    color.xyz = (totalColor.diffuse.xyz * color.xyz)
        + totalColor.ambient.xyz * color.xyz
        + totalColor.specular.xyz;

     return color;
}
```

```cpp
// params.hlsli

#ifndef _PARAMS_HLSLI_
#define _PARAMS_HLSLI_

struct LightColor
{
    float4      diffuse;
    float4      ambient;
    float4      specular;
};

struct LightInfo
{
    LightColor  color;
    float4	    position;
    float4	    direction; 
    int		    lightType;
    float	    range;
    float	    angle;
    int  	    padding;
};

cbuffer GLOBAL_PARAMS : register(b0)
{
    int         g_lightCount;
    float3      g_lightPadding;
    LightInfo   g_light[50];
}

cbuffer TRANSFORM_PARAMS : register(b1)
{
    row_major matrix g_matWorld;
    row_major matrix g_matView;
    row_major matrix g_matProjection;
    row_major matrix g_matWV;
    row_major matrix g_matWVP;
};

cbuffer MATERIAL_PARAMS : register(b2)
{
    int     g_int_0;
    int     g_int_1;
    int     g_int_2;
    int     g_int_3;
    int     g_int_4;
    float   g_float_0;
    float   g_float_1;
    float   g_float_2;
    float   g_float_3;
    float   g_float_4;
};

Texture2D g_tex_0 : register(t0);
Texture2D g_tex_1 : register(t1);
Texture2D g_tex_2 : register(t2);
Texture2D g_tex_3 : register(t3);
Texture2D g_tex_4 : register(t4);

SamplerState g_sam_0 : register(s0);

#endif
```

