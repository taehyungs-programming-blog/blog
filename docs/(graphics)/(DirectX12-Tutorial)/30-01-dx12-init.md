---
layout: default
title: "30-01. Q. Instancingì´ Rendering Pipelineì„ ëª¨ë‘ íƒ€ëŠ”ê±° ê°™ì€ë°?"
parent: "(DirectX12 Tutorial)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 4
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Q. Instancingì´ Rendering Pipelineì„ ëª¨ë‘ íƒ€ëŠ”ê±° ê°™ì€ë°?

```cpp
void Mesh::Render(shared_ptr<InstancingBuffer>& buffer)
{
	D3D12_VERTEX_BUFFER_VIEW bufferViews[] = { _vertexBufferView, buffer->GetBufferView() };
	GRAPHICS_CMD_LIST->IASetVertexBuffers(0, 2, bufferViews);
	GRAPHICS_CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	GEngine->GetGraphicsDescHeap()->CommitTable();

    // ì´ë ‡ê²Œ Instanceë¥¼ ê·¸ë ¤ë‹¬ë¼ ëª…ë ¹.
	GRAPHICS_CMD_LIST->DrawIndexedInstanced(_indexCount, buffer->GetCount(), 0, 0, 0);
}
```

* ì´ë ‡ê²Œ ë˜ë©´ ì‰ì´ë”ì—ì„ 

```cpp
struct VS_IN
{
    float3 pos : POSITION;
    float2 uv : TEXCOORD;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;

    // instanceë¥¼ ìœ„í•œ ë¶€ë¶„
    row_major matrix matWorld : W;
    row_major matrix matWV : WV;
    row_major matrix matWVP : WVP;
    uint instanceID : SV_InstanceID;
};

// ...

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    if (g_int_0 == 1)
    {
        output.pos = mul(float4(input.pos, 1.f), input.matWVP);
        output.uv = input.uv;

        // paramì— ë”°ë¼ ì ë‹¹í•œ ìœ„ì¹˜ë¡œ ì´ë™
        output.viewPos = mul(float4(input.pos, 1.f), input.matWV).xyz;
        output.viewNormal = normalize(mul(float4(input.normal, 0.f), input.matWV).xyz);
        output.viewTangent = normalize(mul(float4(input.tangent, 0.f), input.matWV).xyz);
        output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));
    }
    // ...

    return output;
}

struct PS_OUT
{
    float4 position : SV_Target0;
    float4 normal : SV_Target1;
    float4 color : SV_Target2;
};

PS_OUT PS_Main(VS_OUT input)
{
    //...

    // ì—¬ê¸°ì„œ ê·¸ë ¤ì¤€
    output.position = float4(input.viewPos.xyz, 0.f);
    output.normal = float4(viewNormal.xyz, 0.f);
    output.color = color;

    return output;
}

#endif
```

* í•µì‹¬ì€ 
    * **ì¸ìŠ¤í„´ì‹±**ì€ ê°™ì€ ë©”ì‹œ(mesh)ë¥¼ ì—¬ëŸ¬ ë²ˆ ê·¸ë¦¬ëŠ” ê³¼ì •ì„ ìµœì í™”í•˜ì—¬ íŒŒì´í”„ë¼ì¸ì˜ ë¶€í•˜ë¥¼ ì¤„ì¸ë‹¤.
* ì¸ìŠ¤í„´ì‹±ì˜ ì‘ë™ ë°©ì‹:
    * **ë™ì¼í•œ ë©”ì‹œ ì¬ì‚¬ìš©**: ì¸ìŠ¤í„´ì‹±ì€ ë™ì¼í•œ ì§€ì˜¤ë©”íŠ¸ë¦¬(ë©”ì‹œ)ë¥¼ ì‚¬ìš©í•˜ì—¬ ì—¬ëŸ¬ ê°ì²´ë¥¼ ê·¸ë¦´ ë•Œ ìœ ìš©,
        * ê° ì¸ìŠ¤í„´ìŠ¤ëŠ” ê³ ìœ í•œ ìœ„ì¹˜, íšŒì „, í¬ê¸° ë“±ì˜ ì†ì„±ì„ ê°€ì§€ê³  ìˆì§€ë§Œ, **ê¸°ë³¸ ë©”ì‹œëŠ” ë™ì¼** í•˜ê¸°ì— ê°€ëŠ¥.
    * **ë‹¨ì¼ ë“œë¡œìš° ì½œ**: ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê·¸ë¦´ ë•Œ, ì¸ìŠ¤í„´ì‹±ì€ ë‹¨ì¼ ë“œë¡œìš° ì½œ(draw call)ì„ ì‚¬ìš©
        * ì´ëŠ” CPUì™€ GPU ê°„ì˜ í†µì‹ ì„ ì¤„ì´ê³ , ë“œë¡œìš° ì½œì˜ ì˜¤ë²„í—¤ë“œë¥¼ ê°ì†Œ
        * ê¸°ì¡´ì˜ ë°©ë²•ì—ì„œëŠ” ê° ê°ì²´ë§ˆë‹¤ ë³„ë„ì˜ ë“œë¡œìš° ì½œì´ í•„ìš”
    * **ì‰ì´ë”ì—ì„œì˜ ì²˜ë¦¬**: ì‰ì´ë” ì½”ë“œì—ì„œëŠ” ì¸ìŠ¤í„´ìŠ¤ IDë¥¼ ì‚¬ìš©í•˜ì—¬ ê° ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ ê³ ìœ í•œ ë³€í™˜(ìœ„ì¹˜, íšŒì „ ë“±)ì„ ê³„ì‚°
        * ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ëŠ” ë™ì¼í•œ ì •ì  ì‰ì´ë”ì™€ í”½ì…€ ì‰ì´ë”ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, ì¸ìŠ¤í„´ìŠ¤ IDì— ë”°ë¼ ë‹¤ë¥¸ ê²°ê³¼ë¥¼ ìƒì„±
