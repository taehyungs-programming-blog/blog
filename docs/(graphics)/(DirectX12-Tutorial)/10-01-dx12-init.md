---
layout: default
title: "10-01. Material êµ¬í˜„"
parent: "(DirectX12 Tutorial)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Material Class êµ¬í˜„

* `Material`í´ë˜ìŠ¤ì— í†µí•©í•´ í•´ê²°ì˜ˆì • ë§Œë“¤ì–´ ë³´ì!
* Materialì—ëŠ” ë‹¤ìŒì´ í¬í•¨ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤
    * `Shader`
    * ì‰ì´ë”ì— ì „ë‹¬ë  `Param`
    * `Texture`

```cpp
class Material
{
// ...

private:
	shared_ptr<Shader>	_shader;
	MaterialParams		_params;
	array<shared_ptr<Texture>, MATERIAL_TEXTURE_COUNT> _textures;
};
```

---

## ì¡°ê¸ˆ ë” ì„¸ë¶€ì  ì„¤ëª…

```cpp
#pragma once

class Shader;
class Texture;

enum
{
	MATERIAL_INT_COUNT = 5,			// int 5ê°œ
	MATERIAL_FLOAT_COUNT = 5,		// float 5ê°œ
	MATERIAL_TEXTURE_COUNT = 5,		// texture 5ê°œ ë¥¼ ì“¸ê²ƒì´ë‹¤.
};

struct MaterialParams
{
	void SetInt(uint8 index, int32 value) { intParams[index] = value; }
	void SetFloat(uint8 index, float value) { floatParams[index] = value; }

	array<int32, MATERIAL_INT_COUNT> intParams;
	array<float, MATERIAL_FLOAT_COUNT> floatParams;

// (ì°¸ê³  : array)
    // int32 intParams[MATERIAL_INT_COUNT];
    // arrayëŠ” vectorì²˜ëŸ¼ ê¸¸ì´ë¥¼ ëŠ˜ë¦´ìˆ˜ ìˆëŠ”ê²ƒë„ ì•„ë‹ˆê³ 
    // int32 [] ì´ê±°ë‘ ë¬´ìŠ¨ ì°¨ì´ì¸ê°€??
    // -> ë²”ìœ„ ì²´í¬ê°€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.(ì€ê·¼ ìœ ìš©í•¨)
    // intParams[index] = value; ì´ê±¸í• ë•Œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ Crash!!
};

class Material
{
public:
	shared_ptr<Shader> GetShader() { return _shader; }

	void SetShader(shared_ptr<Shader> shader) { _shader = shader; }
	void SetInt(uint8 index, int32 value) { _params.SetInt(index, value); }
	void SetFloat(uint8 index, float value) { _params.SetFloat(index, value); }
	void SetTexture(uint8 index, shared_ptr<Texture> texture) { _textures[index] = texture; }

	void Update();

private:
	shared_ptr<Shader>	_shader;
	MaterialParams		_params;
	array<shared_ptr<Texture>, MATERIAL_TEXTURE_COUNT> _textures;
};
```

```cpp
void Material::Update()
{
	// CBV ì—…ë¡œë“œ
	CONST_BUFFER(CONSTANT_BUFFER_TYPE::MATERIAL)->PushData(&_params, sizeof(_params));

	// SRV ì—…ë¡œë“œ
	for (size_t i = 0; i < _textures.size(); i++)
	{
		if (_textures[i] == nullptr)
			continue;

		SRV_REGISTER reg = SRV_REGISTER(static_cast<int8>(SRV_REGISTER::t0) + i);
		GEngine->GetTableDescHeap()->SetSRV(_textures[i]->GetCpuHandle(), reg);
	}

	// íŒŒì´í”„ë¼ì¸ ì„¸íŒ…
        // ì´ê±¸ í•´ ì¤˜ì•¼ Shaderë¥¼ ì–´ë–¤ê±¸ ì“°ê² ë‹¤ ì•Œë¦¬ëŠ” ê²ƒì„.
	_shader->Update();
}
```

* ì‹¤ì‚¬ìš©ì€ ì´ë ‡ê²Œ í•  ì˜ˆì •

```cpp
void Game::Init(const WindowInfo& info)
{
	// ...

	mesh->Init(vec, indexVec);

	shared_ptr<Shader> shader = make_shared<Shader>();
	shared_ptr<Texture> texture = make_shared<Texture>();
	shader->Init(L"..\\Resources\\Shader\\default.hlsli");
	texture->Init(L"..\\Resources\\Texture\\veigar.jpg");

	shared_ptr<Material> material = make_shared<Material>();
	material->SetShader(shader);
	material->SetFloat(0, 0.3f);
	material->SetFloat(1, 0.4f);
	material->SetFloat(2, 0.3f);
	material->SetTexture(0, texture);
	mesh->SetMaterial(material);

	GEngine->GetCmdQueue()->WaitSync();
}
```

* ìœ„ ì˜ˆì‹œë¥¼ ë³´ë©´ì•Œê² ì§€ë§Œ ì¶”ê°€ì ìœ¼ë¡œ ìˆ˜ì •ëœ ë¶€ë¶„ì´ ì¡´ì¬
* ì•„ë˜ì—ì„œ ì„¤ëª…

---

## ConstantBuffer

* ConstantBuffer ì—­ì‹œ Materialë‹¨ìœ„ë¡œ ë°ì´í„°ë¥¼ ë„˜ê²¨ì£¼ê³  ì‹¶ë‹¤

```cpp
cbuffer TEST_B0 : register(b0)
{
    // ìœ„ì¹˜(Transform)ì •ë³´
    float4 offset0;
};

cbuffer MATERIAL_PARAMS : register(b1)
{
	// Materialì •ë³´ë¥¼ ì—¬ê¸° ë‹´ê² ë‹¤
    int int_0;
    int int_1;
    int int_2;
    int int_3;
    int int_4;
    float float_0;
    float float_1;
    float float_2;
    float float_3;
    float float_4;
};

// Textureë„ 5ê°œ
Texture2D tex_0 : register(t0);
Texture2D tex_1 : register(t1);
Texture2D tex_2 : register(t2);
Texture2D tex_3 : register(t3);
Texture2D tex_4 : register(t4);
```

* ConstantBufferë‚´ë¶€ë„ ìˆ˜ì •ì´ í•„ìš”í•´ì§„ë‹¤.

```cpp
enum class CONSTANT_BUFFER_TYPE : uint8
{
	TRANSFORM,		// Transform ìš©ë„ì¸ê°€
	MATERIAL,		// Material ìš©ë„ì¸ê°€
	END
};

enum
{
	CONSTANT_BUFFER_COUNT = static_cast<uint8>(CONSTANT_BUFFER_TYPE::END)
};

class ConstantBuffer
{
public:
	ConstantBuffer();
	~ConstantBuffer();

    // ì´ì œ Initì‹œì— ì–´ë–¤ ë ˆì§€ìŠ¤í„°ë¥¼ ì‚¬ìš©í•  ê²ƒì¸ì§€ ë„˜ê²¨ì•¼í•œë‹¤.
        // Transform(b0), Material(b1)ì— ë”°ë¼ ì‚¬ìš©í•˜ëŠ” ë ˆì§€ìŠ¤í„°ê°€ ë‹¬ë¼ì¡Œë‹¤
	void Init(CBV_REGISTER reg, uint32 size, uint32 count);

	void Clear();
	void PushData(void* buffer, uint32 size);

	D3D12_GPU_VIRTUAL_ADDRESS GetGpuVirtualAddress(uint32 index);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle(uint32 index);

private:
	void CreateBuffer();
	void CreateView();

private:
	ComPtr<ID3D12Resource>	_cbvBuffer;
	BYTE*					_mappedBuffer = nullptr;
	uint32					_elementSize = 0;
	uint32					_elementCount = 0;

	ComPtr<ID3D12DescriptorHeap>		_cbvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE			_cpuHandleBegin = {};
	uint32								_handleIncrementSize = 0;

	uint32					_currentIndex = 0;

	CBV_REGISTER			_reg = {};
};
```