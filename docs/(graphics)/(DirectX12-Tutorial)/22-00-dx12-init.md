---
layout: default
title: "22-00. Sky Box(í•˜ëŠ˜í‘œí˜„)"
parent: "(DirectX12 Tutorial)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/DirextX12-Example/tree/17)

## ì´ë¡ 

* í•˜ëŠ˜ì„ êµ¬í˜„í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ?

* ëª‡ ê°€ì§€ ê³ ë ¤ì‚¬í•­ì´ ìˆëŠ”ë°
    * ìºë¦­í„°ê°€ ì›€ì§ì—¬ì„œ í•˜ëŠ˜ì˜ ëì— ë‹¿ìœ¼ë©´ ì•ˆëœë‹¤.
    * í•˜ëŠ˜ë’¤ì— ì–´ë– í•œ ë¬¼ì²´ë„ ë†“ì´ê²Œ í•´ì„  ì•ˆëœë‹¤(ê·¸ëŸ´í•„ìš”ê°€ ì—†ìœ¼ë‹ˆ)
* ì§ì ‘ì  êµ¬í˜„ì˜ íŒì€
    * í•˜ëŠ˜ì˜ ìœ„ì¹˜ëŠ” ì¹´ë©”ë¼ì˜ ê¸°ì¤€(0, 0, 0)ê³¼ ë™ì¼ ğŸ‘‰ ì´ë ‡ê²Œ ì²˜ë¦¬í•´ì•¼ ì¹´ë©”ë¼(ìœ ì €)ê°€ ì´ë™í•˜ë©´ í•˜ëŠ˜ë„ ê°™ì´ ì´ë™í•˜ëŠ” íš¨ê³¼ê°€ ë‚˜íƒ€ë‚œë‹¤
    * ì´ë ‡ê²Œ ìƒê°í•˜ë©´ ì˜¤íˆë ¤ í¸í•˜ë‹¤. SkyëŠ” ê²°êµ­ Viewê¸°ì¤€ì—ì„œ ì›ì ì´ê¸°ì— Viewì˜ ì›ì ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ Skyë¥¼ ë„£ìœ¼ë©´ ëœë‹¤. (ê·¸ëƒ¥ ì›ì ì— ë‘ë©´ ëœë‹¤ëŠ” ë§.)
    * SRT(Scale, Rotation, Translation)ì¤‘ Scale, Translationì€ ì ìš©í•˜ì§€ ì•Šê³ (ì–´ì°¨í”¼ ì¹´ë©”ë¼ì™€ ê°™ì€ ìœ„ì¹˜ì— ìˆì–´ì•¼ í•˜ê¸°ì—) Rotationë§Œ ì ìš©ì´ ë˜ê²Œ ë§Œë“¤ë©´ ëœë‹¤.
    * Local Spaceì—ì„œ WorldëŠ” ë¬´ì‹œí•˜ê³  Viewì—ì„œë„ Rotationë§Œ ì ìš©í•˜ë©´ ëœë‹¤.

* ìš°ì„  ì´ ì •ë„ë§Œ ì´í•´í•˜ê³  ì§ì ‘ ì½”ë“œë¥¼ ë³´ëŠ”ê²Œ í¸í•˜ë‹¤

---

## êµ¬í˜„

* ìš°ì„ , Cullingì— ëŒ€í•´ ì´í•´ê°€ ì—†ë‹¤ë©´, ë‹¤ìŒì¥ì˜ Cullingì„ ë¨¼ì € ë³´ê³  ì˜¤ì!

```cpp
void Shader::Init(const wstring& path, ShaderInfo info)
{
	//..

	switch (info.rasterizerType)
	{
	case RASTERIZER_TYPE::CULL_BACK:
        // (ì°¸ê³ ) D3D12_FILL_MODE_SOLID - ìƒ‰ì„ ëª¨ë‘ ì±„ìš´ë‹¤ (ì¼ë°˜ì  ëª¨ë“œ)
		_pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;
		_pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_BACK;
		break;
	case RASTERIZER_TYPE::CULL_FRONT:
		_pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;
		_pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_FRONT;
		break;
	case RASTERIZER_TYPE::CULL_NONE:
		_pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_SOLID;
		_pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
		break;
	case RASTERIZER_TYPE::WIREFRAME:
        // (ì°¸ê³ ) WIREFRAME - ì™¸ê°ì„ ë§Œ ë‚˜íƒ€ë‚˜ê²Œ í•œë‹¤.
		_pipelineDesc.RasterizerState.FillMode = D3D12_FILL_MODE_WIREFRAME;
		_pipelineDesc.RasterizerState.CullMode = D3D12_CULL_MODE_NONE;
		break;
	}

	switch (info.depthStencilType)
	{
    case DEPTH_STENCIL_TYPE::LESS:
		_pipelineDesc.DepthStencilState.DepthEnable = TRUE;

        // ê¸°ë³¸ì€ Depthê°€ ë‚®ì„ìˆ˜ë¡(ë©€ë¦¬ìˆì„ìˆ˜ë¡) ì•ˆê·¸ë ¤ì£¼ê²Œë˜ëŠ”ë°
		_pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
		break;
	case DEPTH_STENCIL_TYPE::LESS_EQUAL:

        // í•˜ëŠ˜ì€ ë¬´ì¡°ê±´ ê·¸ë ¤ì•¼í•˜ë‹ˆ D3D12_COMPARISON_FUNC_LESS_EQUALë¡œ ë‘”ë‹¤
		_pipelineDesc.DepthStencilState.DepthEnable = TRUE;
		_pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
		break;
	case DEPTH_STENCIL_TYPE::GREATER:
		_pipelineDesc.DepthStencilState.DepthEnable = TRUE;
		_pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_GREATER;
		break;
	case DEPTH_STENCIL_TYPE::GREATER_EQUAL:
		_pipelineDesc.DepthStencilState.DepthEnable = TRUE;
		_pipelineDesc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_GREATER_EQUAL;
		break;
	}

	DEVICE->CreateGraphicsPipelineState(&_pipelineDesc, IID_PPV_ARGS(&_pipelineState));

    // ...
```

```cpp
shared_ptr<Scene> SceneManager::LoadTestScene()
{
	shared_ptr<Scene> scene = make_shared<Scene>();

#pragma region Camera
	shared_ptr<GameObject> camera = make_shared<GameObject>();
	camera->AddComponent(make_shared<Transform>());
	camera->AddComponent(make_shared<Camera>()); // Near=1, Far=1000, FOV=45ë„
	camera->AddComponent(make_shared<TestCameraScript>());
	camera->GetTransform()->SetLocalPosition(Vec3(0.f, 0.f, 0.f));
	scene->AddGameObject(camera);
#pragma endregion

#pragma region SkyBox
	{
		shared_ptr<GameObject> skybox = make_shared<GameObject>();
		skybox->AddComponent(make_shared<Transform>());
		shared_ptr<MeshRenderer> meshRenderer = make_shared<MeshRenderer>();
		{
			shared_ptr<Mesh> sphereMesh = GET_SINGLE(Resources)->LoadSphereMesh();
			meshRenderer->SetMesh(sphereMesh);
		}
		{
			shared_ptr<Shader> shader = make_shared<Shader>();
			shared_ptr<Texture> texture = make_shared<Texture>();
            // ì‰ì´ë”ë¥¼ skybox.hlslië¥¼ ì“°ê³ ìˆìŒì„ ì£¼ëª©.
			shader->Init(L"..\\Resources\\Shader\\skybox.hlsli",
				{ RASTERIZER_TYPE::CULL_NONE, DEPTH_STENCIL_TYPE::LESS_EQUAL });
			// ì‰ì´ë” initì‹œ RASTERIZER_TYPE::CULL_NONE, DEPTH_STENCIL_TYPE::LESS_EQUAL ì˜µì…˜ì„ ë„£ëŠ”ë‹¤.
			// RASTERIZER_TYPE::CULL_NONE : cullì„ í•˜ì§€ë§ë¼ (cull_frontë¡œ í•´ë„ ë™ì‘í•¨)
			texture->Init(L"..\\Resources\\Texture\\Sky01.jpg");
			shared_ptr<Material> material = make_shared<Material>();
			material->SetShader(shader);
			material->SetTexture(0, texture);
			meshRenderer->SetMaterial(material);
		}
		skybox->AddComponent(meshRenderer);
		scene->AddGameObject(skybox);
	}
#pragma endregion

    // ...
```

```cpp
// skybox.hlsli

#ifndef _SKYBOX_HLSLI_
#define _SKYBOX_HLSLI_

#include "params.hlsli"

struct VS_IN
{
    float3 localPos : POSITION;
    float2 uv : TEXCOORD;
};

struct VS_OUT
{
    float4 pos : SV_Position;
    float2 uv : TEXCOORD;
};

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    // float4(input.localPos, 0) : Translationì€ í•˜ì§€ ì•Šê³  Rotationë§Œ ì ìš©í•œë‹¤(ë§ˆì§€ë§‰ ê°’ì„ 0ìœ¼ë¡œ ë‘ )
    float4 viewPos = mul(float4(input.localPos, 0), g_matView);

	/*
        // ì°¸ê³  View MatrixëŠ” ì•„ë˜ì™€ ê°™ê³  right/up/look . x/y/zëŠ” ë‹¨ìœ„ë²¡í„°
        // c*right/up/look ì€ Translation ì •ë³´ì´ë‹¤.
        // ë”°ë¼ì„œ ë§ˆì§€ë§‰ í•­ì— 0ì„ ë„£ìœ¼ë©´(input.localPos, 0) Translation ì •ë³´ëŠ” ì‚¬ë¼ì§€ê³ 
        // Rotationì •ë³´ë§Œ ë‚¨ê²Œëœë‹¤.
        right.x  up.x  look.x  0
        right.y  up.y  look.y  0
        right.z  up.z  look.z  0
        -c*right -c*up -c*look 1
	*/

    float4 clipSpacePos = mul(viewPos, g_matProjection);

	// clipSpacePos.xyww : z(ê¹Šì´)ì— wë¥¼ ë„£ëŠ”ë‹¤
    // w/w=1ì´ê¸° ë•Œë¬¸ì— í•­ìƒ ê¹Šì´ê°€ 1ë¡œ ìœ ì§€ëœë‹¤
    output.pos = clipSpacePos.xyww;
    output.uv = input.uv;

    return output;
}

float4 PS_Main(VS_OUT input) : SV_Target
{
     float4 color = g_tex_0.Sample(g_sam_0, input.uv);
     return color;
}

#endif
```