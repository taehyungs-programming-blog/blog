---
layout: default
title: "06. Consume/Append Buffer"
parent: "(Computer Animation)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/Graphics_Part4/blob/main/Examples/Ex1405_ConsumeAppendBuffer.h)

* Consume/Append Buffer - Structured Bufferì— Counterê°€ ì¶”ê°€ëœ ê°œë…ì´ë‹¤.
* ìš°ì„  ë²„í¼ë¥¼ ì–´ë–»ê²Œ ë§Œë“œëŠ”ì§€ ë³´ì

```cpp
void CreateAppendBuffer(ComPtr<ID3D11Device> &device,
                                    const UINT numElements,
                                    const UINT sizeElement,
                                    const void *initData,
                                    ComPtr<ID3D11Buffer> &buffer,
                                    ComPtr<ID3D11ShaderResourceView> &srv,
                                    ComPtr<ID3D11UnorderedAccessView> &uav) {


    D3D11_BUFFER_DESC bufferDesc;
    ZeroMemory(&bufferDesc, sizeof(bufferDesc));
    bufferDesc.Usage = D3D11_USAGE_DEFAULT;
    bufferDesc.ByteWidth = numElements * sizeElement;
    bufferDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | // Compute Shader
                           D3D11_BIND_SHADER_RESOURCE;   // Vertex Shader
    bufferDesc.StructureByteStride = sizeElement;
    bufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;

    if (initData) {
        D3D11_SUBRESOURCE_DATA bufferData;
        ZeroMemory(&bufferData, sizeof(bufferData));
        bufferData.pSysMem = initData;
        ThrowIfFailed(device->CreateBuffer(&bufferDesc, &bufferData,
                                           buffer.GetAddressOf()));
    } else {
        ThrowIfFailed(
            device->CreateBuffer(&bufferDesc, NULL, buffer.GetAddressOf()));
    }

    D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
    ZeroMemory(&uavDesc, sizeof(uavDesc));
    uavDesc.Format = DXGI_FORMAT_UNKNOWN;
    uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
    uavDesc.Buffer.NumElements = numElements;
    uavDesc.Buffer.Flags =
        D3D11_BUFFER_UAV_FLAG_APPEND; // AppendBufferë¡œ ì‚¬ìš©í•˜ê² ë‹¤ëŠ” ì˜ë¯¸
    device->CreateUnorderedAccessView(buffer.Get(), &uavDesc,
                                      uav.GetAddressOf());

    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
    ZeroMemory(&srvDesc, sizeof(srvDesc));
    srvDesc.Format = DXGI_FORMAT_UNKNOWN;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
    srvDesc.BufferEx.NumElements = numElements;
    device->CreateShaderResourceView(buffer.Get(), &srvDesc,
                                     srv.GetAddressOf());
}
```

* ë‹¤ìŒì€ ì‰ì´ë”ë¥¼ ë³´ìë©´

```cpp
struct Particle
{
    float3 pos;
    float3 color;
};

static float dt = 1 / 60.0;

ConsumeStructuredBuffer<Particle> inputParticles : register(u0);
AppendStructuredBuffer<Particle> outputParticles : register(u1);

[numthreads(256, 1, 1)]
void main(int3 gID : SV_GroupID, 
        int3 gtID : SV_GroupThreadID,
        uint3 dtID : SV_DispatchThreadID)
{
    // Consumeìœ¼ë¡œ ì½ê³ 
    Particle p = inputParticles.Consume(); // Read
    
    float3 velocity = float3(-p.pos.y, p.pos.x, 0.0) * 0.1;
    p.pos += velocity * dt;
    
    // Appendë¡œ ì“´ë‹¤
    outputParticles.Append(p); // Write
}
```

* ??? ê·¼ë° ì‹ ê¸°í•œê²Œ ê·¸ëƒ¥ Consume, Appendë¥¼ í˜¸ì¶œí•´ ë²„ë¦¬ë©´ ìˆœì„œëŠ” ì–´ë–»ê²Œ ì•„ë‚˜ ???
    * DirectXê°€ ì•Œì•„ì„œ í•´ì¤€ë‹¤
* Renderë¶€ë¶„ì„ ì¡°ê¸ˆ ë” ë³´ë©´ ì´í•´ê°€ ëœë‹¤.

```cpp
void Render() {
    // Shaderë¡œ UAVë¥¼ ë„˜ê¸´ë‹¤
    ID3D11UnorderedAccessView *uavs[2] = {m_consume.GetUAV(),
                                          m_append.GetUAV()};

    // initCountsëŠ” Consumeì˜ ê°¯ìˆ˜, Appendì˜ ê°¯ìˆ˜ë¥¼ ë„˜ê¸´ë‹¤ (ì¤‘ìš”)
        // Appendê°€ 0ì¸ë””?
        // ê·¸ê²Œ ë§ìŒ Consumeì—ì„œ í•˜ë‚˜ì”© ë¹¼ì„œ Appendì— ë„£ì–´ì£¼ëŠ” êµ¬ì¡°ì´ë‹ˆ
    UINT initCounts[2] = {UINT(m_consume.m_cpu.size()), 0}; 

    m_context->CSSetUnorderedAccessViews(0, 2, uavs, initCounts/*initCountëŠ” ì—¬ê¸° ë„£ìŒ*/);
    m_context->CSSetShader(m_computeShader.Get(), 0, 0);
    m_context->Dispatch(UINT(ceil(m_consume.m_cpu.size() / 256.0f)), 1, 1);
    AppBase::ComputeShaderBarrier();

    // Appendì˜ ê°œìˆ˜ë¥¼ í™•ì¸í•´ ë³´ì
    m_context->CopyStructureCount(m_countStaging.m_gpu.Get(), 0,
                                  m_append.GetUAV());
    m_countStaging.Download(m_context);
    uint32_t appendCount = m_countStaging.m_cpu[0];
    cout << "AppendBuffer count: " << appendCount << endl;

    // Consumeì˜ ê°œìˆ˜ë¥¼ í™•ì¸í•´ ë³´ì
    m_context->CopyStructureCount(m_countStaging.m_gpu.Get(), 0,
                                  m_consume.GetUAV());
    m_countStaging.Download(m_context);

    // ...

    // ì œëŒ€ë¡œ ë™ì‘í–ˆìœ¼ë©´ Consumeì€ ë¹„ê³  AppendëŠ” ê½‰ ì°¬ ìƒíƒœì´ë‹ˆ ë°”ê¿”ì¤€ë‹¤
    ::swap(m_consume, m_append);
}
```
