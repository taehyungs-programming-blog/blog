---
layout: default
title: "05. Structured Buffer"
parent: "(Computer Animation)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/Graphics_Part4/blob/main/Examples/Ex1404_StructuredBuffer.h)

* ë§ ê·¸ëŒ€ë¡œ Structë¥¼ Shaderë¡œ ë³´ë‚´ëŠ” Bufferì´ë‹¤.

```cpp
struct Particle {
    Vector3 position;
    Vector3 color;
};
// ...

// ì´ ë²„í¼ë¥¼ Shaderë¡œ ë„˜ê¸°ê³ ì í•œë‹¤
StructuredBuffer<Particle> m_particles;
```

* ë²„í¼ì˜ ìƒì„±ì€ ì•„ë˜ì™€ ê°™ì´ í•œë‹¤

```cpp
void CreateStructuredBuffer(
    ComPtr<ID3D11Device> &device, const UINT numElements,
    const UINT sizeElement, const void *initData, ComPtr<ID3D11Buffer> &buffer,
    ComPtr<ID3D11ShaderResourceView> &srv,
    ComPtr<ID3D11UnorderedAccessView> &uav) {

    D3D11_BUFFER_DESC bufferDesc;
    ZeroMemory(&bufferDesc, sizeof(bufferDesc));
    bufferDesc.Usage = D3D11_USAGE_DEFAULT;
    bufferDesc.ByteWidth = numElements * sizeElement;
    bufferDesc.BindFlags = D3D11_BIND_UNORDERED_ACCESS | // Compute Shader ìš©
                           D3D11_BIND_SHADER_RESOURCE;   // Vertex Shader ìš©
    bufferDesc.StructureByteStride = sizeElement;
    bufferDesc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;

    if (initData) {
        D3D11_SUBRESOURCE_DATA bufferData;
        ZeroMemory(&bufferData, sizeof(bufferData));
        bufferData.pSysMem = initData;
        ThrowIfFailed(device->CreateBuffer(&bufferDesc, &bufferData,
                                           buffer.GetAddressOf()));
    } else {
        ThrowIfFailed(
            device->CreateBuffer(&bufferDesc, NULL, buffer.GetAddressOf()));
    }

    D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
    ZeroMemory(&uavDesc, sizeof(uavDesc));
    uavDesc.Format = DXGI_FORMAT_UNKNOWN;
    uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
    uavDesc.Buffer.NumElements = numElements;
    device->CreateUnorderedAccessView(buffer.Get(), &uavDesc,
                                      uav.GetAddressOf());

    D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
    ZeroMemory(&srvDesc, sizeof(srvDesc));
    srvDesc.Format = DXGI_FORMAT_UNKNOWN;
    srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
    srvDesc.BufferEx.NumElements = numElements;
    device->CreateShaderResourceView(buffer.Get(), &srvDesc,
                                     srv.GetAddressOf());
}
```

* ê·¸ë¦¬ëŠ” ë¶€ë¶„ì„ í•œ ë²ˆ ë³´ì

```cpp
void Render() {
    // Conpute Shader Dispatch
    m_context->CSSetUnorderedAccessViews(0, 1, m_particles.GetAddressOfUAV(),
                                         NULL);
    m_context->CSSetShader(m_computeShader.Get(), 0, 0);
    m_context->Dispatch(UINT(ceil(m_particles.m_cpu.size() / 256.0f)), 1, 1);
    AppBase::ComputeShaderBarrier();


    AppBase::SetMainViewport();
    const float clearColor[4] = {0.0f, 0.0f, 0.0f, 1.0f};
    m_context->ClearRenderTargetView(m_backBufferRTV.Get(), clearColor);
    m_context->OMSetRenderTargets(1, m_backBufferRTV.GetAddressOf(), NULL);
    m_context->VSSetShader(m_vertexShader.Get(), 0, 0);
    m_context->PSSetShader(m_pixelShader.Get(), 0, 0);
    m_context->CSSetShader(NULL, 0, 0);

    m_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);

    // Vertexì •ë³´ëŠ” ì–´ë””ì„œ ë„˜ê¸°ë‚˜ ???
        // StructedBufferë¥¼ ì‚¬ìš©í•¨
    m_context->VSSetShaderResources(0, 1, m_particles.GetAddressOfSRV());
    m_context->Draw(UINT(m_particles.m_cpu.size()), 0);
}
```

```cpp
struct PSInput
{
    float4 position : SV_POSITION;
    float3 color : COLOR;
};

struct Particle
{
    float3 position;
    float3 color;
};

StructuredBuffer<Particle> particles : register(t0);

PSInput main(uint vertexID : SV_VertexID)
{
    Particle p = particles[vertexID];
    
    PSInput output;
    
    output.position = float4(p.position.xyz, 1.0);
    
    output.color = p.color;

    return output;
}
```

* ë§ˆì§€ë§‰ Compute Shader

```cpp
struct Particle
{
    float3 pos;
    float3 color;
};

static float dt = 1 / 60.0; 

RWStructuredBuffer<Particle> outputParticles : register(u0);

[numthreads(256, 1, 1)]
void main(int3 gID : SV_GroupID, int3 gtID : SV_GroupThreadID,
          uint3 dtID : SV_DispatchThreadID)
{
    Particle p = outputParticles[dtID.x]; // Read
    
    // ì›€ì§ì„ì„ ë„£ì–´ë³´ì
        // -p.pos.y, p.pos.x --> ì™¼ìª½ìœ¼ë¡œ íšŒì „í•˜ê¸° ìœ„í•´ì„œ ì›ì ì—ì„œ ìˆ˜ì§ì¸ ë²¡í„°ë¥¼ ê³±í•¨ -sin90, cos90
        // ì†ë„ = ì‹œê°„/ì´ë™ê±°ë¦¬ --> ì´ë™ê±°ë¦¬ = ì†ë„ * ì‹œê°„ ì„ì„ ê¸°ì–µ
    float3 velocity = float3(-p.pos.y, p.pos.x, 0.0);
    p.pos += velocity * dt;
    
    outputParticles[dtID.x].pos = p.pos; // Write
}
```