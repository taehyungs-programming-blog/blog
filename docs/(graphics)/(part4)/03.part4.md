---
layout: default
title: "03. CSì´ìš© Gaussian Blur êµ¬í˜„"
parent: "(Computer Animation)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/Graphics_Part4/blob/main/Examples/Ex1402_Blur.h)

## ìš°ì„  ê¸°ì¡´ì— êµ¬í˜„ëœ Pixel Shaderë¥¼ ë¨¼ì € í™•ì¸í•´ ë³´ì.

```cpp
void Render() {

    // Renderì‹œì ì— ì´ë¯¸ì§€ë¥¼ Texture Aì— ë„£ì–´ë‘”ë‹¤
    m_context->CopyResource(m_texA.Get(), m_stagingTexture.Get());

    // ...
}

void PixelShaderBlur() {

    ID3D11ShaderResourceView *tempSRV[1] = {NULL};
    ID3D11RenderTargetView *tempRTV[1] = {NULL};

    AppBase::SetMainViewport();
    m_context->PSSetSamplers(0, 1, Graphics::pointClampSS.GetAddressOf());
    m_context->IASetVertexBuffers(0, 1,
                                  m_screenMesh->vertexBuffer.GetAddressOf(),
                                  &m_screenMesh->stride, &m_screenMesh->offset);
    m_context->IASetIndexBuffer(m_screenMesh->indexBuffer.Get(),
                                DXGI_FORMAT_R32_UINT, 0);

    // A to B
    AppBase::SetPipelineState(m_blurXPixelPSO);
    // RenderTargetì„ Bë¡œ ì¡ê³  ì´ë¯¸ì§€(ShaderResourceView A)ë¥¼ ë„£ëŠ”ë‹¤
    m_context->OMSetRenderTargets(1, m_rtvB.GetAddressOf(), NULL);
    m_context->PSSetShaderResources(0, 1, m_srvA.GetAddressOf());
    m_context->DrawIndexed(m_screenMesh->indexCount, 0, 0);

    // B to A
    AppBase::SetPipelineState(m_blurYPixelPSO);
    // ë°˜ëŒ€ë¡œ RenderTargetì„ Aë¡œ ì¡ê³  ì´ë¯¸ì§€(ShaderResourceView B)ë¥¼ ë„£ëŠ”ë‹¤
    m_context->OMSetRenderTargets(1, m_rtvA.GetAddressOf(), NULL);
    m_context->PSSetShaderResources(0, 1, m_srvB.GetAddressOf());
    m_context->DrawIndexed(m_screenMesh->indexCount, 0, 0);
}
```

```cpp
Texture2D inputTex : register(t0);
SamplerState pointClampSS : register(s0);

static const float weights[11] =
{
    0.05f, 0.05f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.05f, 0.05f,
};

static const int blurRadius = 5;

struct SamplingPixelShaderInput
{
    float4 position : SV_POSITION;
    float2 texcoord : TEXCOORD;
};

float4 main(SamplingPixelShaderInput input) : SV_TARGET
{
    uint width, height;
    inputTex.GetDimensions(width, height);
    
    const float2 dx = float2(1.0 / width, 0.0);
    
    float3 blurColor = float3(0, 0, 0);
    
    [unroll]
    for (int i = -blurRadius; i <= blurRadius; ++i)
    {
        float3 inputColor = inputTex.SampleLevel(pointClampSS, input.texcoord + float(i) * dx, 0.0).rgb;
        blurColor += weights[i + blurRadius] * inputColor;
    }
    
    return float4(blurColor, 1.0f);
}
```

---

## Compute Shaderë¥¼ ì´ìš©í•œ Blur (Cache í•˜ì§€ ì•ŠëŠ” ê²½ìš°)

```cpp
void Ex1402_Blur::ComputeShaderBlur(const bool useGroupCache) {

    m_context->CSSetSamplers(0, 1, Graphics::pointClampSS.GetAddressOf());

    if (useGroupCache) {
        // ...
    } else {
/*
m_screenWidth = 1280;
m_screenHeight = 768;

1280 / 32 = 40
768 / 32 = 24

40 * 24 = 960ê°œì˜ thread group ìƒì„±
*/
        const UINT tgx = UINT(ceil(m_screenWidth / 32.0f));
        const UINT tgy = UINT(ceil(m_screenHeight / 32.0f));

        // Horizontal X-Blur, A to B
        AppBase::SetPipelineState(m_blurXComputePSO);
        m_context->CSSetShaderResources(0, 1, m_srvA.GetAddressOf());
        m_context->CSSetUnorderedAccessViews(0, 1, m_uavB.GetAddressOf(), NULL);
        m_context->Dispatch(tgx, tgy, 1);
        AppBase::ComputeShaderBarrier();

        // Vertical Y-Blur, B to A
        AppBase::SetPipelineState(m_blurYComputePSO);
        m_context->CSSetShaderResources(0, 1, m_srvB.GetAddressOf());
        m_context->CSSetUnorderedAccessViews(0, 1, m_uavA.GetAddressOf(), NULL);
        m_context->Dispatch(tgx, tgy, 1);
        AppBase::ComputeShaderBarrier();
    }
}
```

```cpp
Texture2D<float4> inputTex : register(t0);
RWTexture2D<float4> outputTex : register(u0);
SamplerState pointClampSS : register(s0); 

static const float weights[11] =
{
    0.05f, 0.05f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.05f, 0.05f,
};

static const int blurRadius = 5;

// ìœ„ì—ì„œ 960ê°œì˜ thread groupì„ ìƒì„±í–ˆê¸°ì—
// 960 * 32 * 32 = 983,040 ê°œì˜ thread
    // 1280 * 768 = 983,040 pixel
[numthreads(32, 32, 1)]
void main(int3 gID : SV_GroupID, 
          int3 gtID : SV_GroupThreadID,
          uint3 dtID : SV_DispatchThreadID)
{
    float dx = 1.0 / 1280;
    float dy = 1.0 / 768;
    
/*
uvì¢Œí‘œëŠ” 0,0ì´ ì‹œì‘ 1,1ì´ ëì´ë‹¤.
+0.5ëŠ” ê°€ìš´ë°ë¡œ ì˜®ê¸°ëŠ” ì‘ì—…
*/
    float2 uv = float2((dtID.x + 0.5) * dx, (dtID.y + 0.5) * dy);
    float3 blurColor = float3(0, 0, 0);

    [unroll]
    for (int i = -blurRadius; i <= blurRadius; ++i)
    {
        float3 color = inputTex.SampleLevel(pointClampSS, uv + float2(float(i) * dx, 0.0), 0.0).rgb;

        blurColor += weights[i + blurRadius] * color;
    }

    outputTex[dtID.xy] = float4(blurColor, 1);
}
```

---

## ë‹¤ìŒì€ group cacheì‚¬ìš©í•˜ê¸°

```cpp
void Ex1402_Blur::ComputeShaderBlur(const bool useGroupCache) {

    m_context->CSSetSamplers(0, 1, Graphics::pointClampSS.GetAddressOf());

    if (useGroupCache) {
        const UINT tgx = UINT(ceil(m_screenWidth / 256.0f));
        const UINT tgy = UINT(ceil(m_screenHeight / 256.0f));

        AppBase::SetPipelineState(m_blurXGroupCacheComputePSO);
        m_context->CSSetShaderResources(0, 1, m_srvA.GetAddressOf());
        m_context->CSSetUnorderedAccessViews(0, 1, m_uavB.GetAddressOf(), NULL);
        m_context->Dispatch(tgx, m_screenHeight, 1);
        AppBase::ComputeShaderBarrier();

        AppBase::SetPipelineState(m_blurYGroupCacheComputePSO);
        m_context->CSSetShaderResources(0, 1, m_srvB.GetAddressOf());
        m_context->CSSetUnorderedAccessViews(0, 1, m_uavA.GetAddressOf(), NULL);
        m_context->Dispatch(m_screenWidth, tgy, 1);
        AppBase::ComputeShaderBarrier();
    } else {
        // ...
    }
}
```

```cpp
Texture2D<float4> inputTex : register(t0);
RWTexture2D<float4> outputTex : register(u0);

// ì°¸ê³  ìë£Œ: Luna DX11 êµì¬ Ch. 12

static const float weights[11] =
{
    0.05f, 0.05f, 0.1f, 0.1f, 0.1f, 0.2f, 0.1f, 0.1f, 0.1f, 0.05f, 0.05f,
};

static const int blurRadius = 5;

#define N 256
#define CACHE_SIZE (N + 2*blurRadius)
// ì™œ CACHE_SIZEëŠ” N + 2*blurRadiusì¼ê¹Œ?
    // í•œ ThreadGroupì´ Nê°œì´ê³  ì¢Œ/ìš° blurRadiusë§Œí¼ í”½ì…€ ìºì‹±ì´ í•„ìš”í•˜ê¸°ë•Œë¬¸

// Groupshared memoryëŠ” ìµœëŒ€ 16KBì´ê³ 
// Thread Groupë‹¨ìœ„ë¡œ ê³µìœ ë¨ì„ ê¸°ì–µí•˜ì
groupshared float4 groupCache[CACHE_SIZE];

[numthreads(N, 1, 1)]
void main(uint3 gID : SV_GroupID, uint3 gtID : SV_GroupThreadID,
          uint3 dtID : SV_DispatchThreadID)
{
    uint width, height;
    outputTex.GetDimensions(width, height);

    // ì¢Œì¸¡ í”½ì…€ ìºì‹±
    if (gtID.x < blurRadius)
    {
        int x = max(int(dtID.x) - blurRadius, 0);
        groupCache[gtID.x] = inputTex[int2(x, dtID.y)];
    }
    
    // ìš°ì¸¡ í”½ì…€ ìºì‹±
    if (gtID.x >= N - blurRadius)
    {
        int x = min(dtID.x + blurRadius, width - 1);
        groupCache[gtID.x + 2 * blurRadius] = inputTex[int2(x, dtID.y)];
    }
    
    groupCache[gtID.x + blurRadius] =
        inputTex[min(dtID.xy, uint2(width, height) - 1)];

    GroupMemoryBarrierWithGroupSync();
    
    float4 blurColor = float4(0, 0, 0, 0);

    [unroll]
    for (int i = -blurRadius; i <= blurRadius; ++i)
    {
        int k = gtID.x + blurRadius + i;
        blurColor += weights[i + blurRadius] * groupCache[k];
    }

    outputTex[dtID.xy] = blurColor;
}
```

---

## ê²°ë¡ 

* ëŒë ¤ë³´ë©´ Pixel Shaderê°€ ê°€ì¥ë¹ ë¥´ë‹¤. ê·¸ë¦¬ê³  ê·¸ ë‹¤ìŒì€ Groupí™” ë˜ì§€ ì•Šì€ Compute Shader
    * ??? ì´ê²Œ ë§ë‚˜?
    * Pixel Shaderê°€ ìµœì í™”ê°€ ê°€ì¥ ì˜ë˜ì–´ìˆë‹¤ëŠ” ì„¤? ë„ ìˆê³  Compute ShaderëŠ” Unordered Access Memì„ ì‚¬ìš©í•˜ëŠ”ë° ê·¸ ì˜í–¥ì´ë¼ëŠ” ì„¤? ë„ ìˆë‹¤.
    * ê·¸ëŸ¼ ì™œ Groupí™”ëœ Compute Shaderê°€ ë” ëŠë¦°ê°€? Groupí™”ë¥¼ ì–´ë–»ê²Œ í–ˆëŠ”ì§€ì— ë”°ë¼ ë‹¤ë¥´ë‹¤
    * ì´ê±´ ì§„ì§œ ì–´ë–»ê²Œ ìµœì í™” í–ˆëŠëƒì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ë¬¸ì œ.