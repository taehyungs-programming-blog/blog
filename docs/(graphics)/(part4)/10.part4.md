---
layout: default
title: "10. Particle System (+Staging Buffer)"
parent: "(Computer Animation)"
grand_parent: "(Graphics 😎)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code 🌎](https://github.com/Arthur880708/Graphics_Part4/blob/main/Examples/Ex1501_ParticleSystem.h)

* 구현자체는 쉽기에 코드를 보면 되고 핵심되는 부분만 정리.

```cpp
bool Initialize() {

    // ...

    // Structed Buffer를 두어 shader로 넘길준비
    D3D11Utils::CreateStructuredBuffer(
        m_device, UINT(m_particlesCPU.size()), sizeof(Particle),
        m_particlesCPU.data(), m_particlesGPU, m_particlesSRV, m_particlesUAV);

    // GPU메모리로 가는 임시거처인 Staging Buffer를 생성
    D3D11Utils::CreateStagingBuffer(m_device, UINT(m_particlesCPU.size()),
                                    sizeof(Particle), m_particlesCPU.data(),
                                    m_particlesStagingGPU);
```

```cpp
// 업데이트하며 Staging Buffer에 있던 데이터를 Structed Buffer로 옮긴다
D3D11Utils::CopyToStagingBuffer(
    m_context, m_particlesStagingGPU,
    UINT(sizeof(Particle) * m_particlesCPU.size()), m_particlesCPU.data());
m_context->CopyResource(m_particlesGPU.Get(), m_particlesStagingGPU.Get());
```

* 여기서 드는 궁금증, 왜 Staging이 더 빠르지??

```cpp
void D3D11Utils::CreateStagingBuffer(ComPtr<ID3D11Device> &device,
                                     const UINT numElements,
                                     const UINT sizeElement,
                                     const void *initData,
                                     ComPtr<ID3D11Buffer> &buffer) {

    // 옵션을 보면 알겠지만 그럴 목적으로 만든 버퍼임
    D3D11_BUFFER_DESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.ByteWidth = numElements * sizeElement;
    desc.Usage = D3D11_USAGE_STAGING;
    desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE | D3D11_CPU_ACCESS_READ;
    desc.StructureByteStride = sizeElement;

    if (initData) {
        D3D11_SUBRESOURCE_DATA bufferData;
        ZeroMemory(&bufferData, sizeof(bufferData));
        bufferData.pSysMem = initData;
        ThrowIfFailed(
            device->CreateBuffer(&desc, &bufferData, buffer.GetAddressOf()));
    } else {
        ThrowIfFailed(device->CreateBuffer(&desc, NULL, buffer.GetAddressOf()));
    }
}
```