---
layout: default
title: "12. Smoothed Particle Hydrodynamics(SPH)"
parent: "(Computer Animation)"
grand_parent: "(Graphics 😎)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code 🌎](https://github.com/Arthur880708/Graphics_Part4/blob/main/Examples/Ex1503_SphWater.h)


* 원리는 간단하다. 주변의 입자(Particle)를 분석후 가까이 있다면 서로를 밀어내게 만들자.
    * 추가적으로 거기다 점성을 더 함.
    * 점성이라 함은 ... 입자간의 속도가 다를때 빠른속도는 속도를 늦추고 느린속도는 속도를 더하면 점성이 구현된다.
* 코드로 보자면 ...

```cpp
class SphSimulation {
  public:
    struct Particle {
        Vector3 position = Vector3(0.0f);
        Vector3 velocity = Vector3(0.0f);
        Vector3 force = Vector3(0.0f);
        // 입자에 density와 pressure가 있다는것에 주목하자
        float density = 0.0f;
        float pressure = 0.0f;

        Vector3 color = Vector3(1.0f);
        float life = 0.0f;
        float size = 1.0f;
    };

    void Update(float dt);
    void UpdateDensity();
    void UpdateForces();

    vector<Particle> m_particlesCpu;
    float m_radius = 1.0f / 16.0f;
    float m_mass = 1.0f;

    // 입자간 얼마나 밀어내는지를 의미
    float m_pressureCoeff = 1.0f;
    float m_density0 = 1.0f;
    float m_viscosity = 0.1f;


    // ...
```

```cpp
void SphSimulation::UpdateDensity() {

#pragma omp parallel for
    for (int i = 0; i < m_particlesCpu.size(); i++) {

        // particle의 life가 0이라면 continue
        if (m_particlesCpu[i].life < 0.0f)
            continue;

        // 밀도를 구해본다
        m_particlesCpu[i].density = 0.0f;

        for (size_t j = 0; j < m_particlesCpu.size(); j++) {

            if (m_particlesCpu[j].life < 0.0f)
                continue;

            const float dist =
                (m_particlesCpu[i].position - m_particlesCpu[j].position)
                    .Length();

            // 너무 먼 particle은 무시
            if (dist >= m_radius)
                continue;

            m_particlesCpu[i].density +=
                m_mass * SphKernels::CubicSpline(dist * 2.0f / m_radius);
        }

        // density로 부터 압력구하기
        m_particlesCpu[i].pressure =
            m_pressureCoeff *
            (pow(m_particlesCpu[i].density / m_density0, 7.0f) - 1.0f);
    }
}
```
