---
layout: default
title: "02. Compute Shader"
parent: "(Computer Animation)"
grand_parent: "(Graphics ğŸ˜)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ê°„ë‹¨í•˜ê²Œ Compute Shaderë¥¼ ë§Œë“¤ì–´ ë³´ì

* [Get Code ğŸŒ](https://github.com/Arthur880708/Graphics_Part4/blob/main/Examples/Ex1401_Basic.h)

* í•˜ê³ ì í•˜ëŠ”ê±´ Compute Shaderë¡œ **Const Bufferë¥¼ ì»¨íŠ¸ë¡¤**í•´ë³´ì.
    * + Compute Shaderì‚¬ìš©ë²•ì„ ìµíŒë‹¤
* ê²°ê³¼ë¬¼ì€ ì´ë ‡ë‹¤

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/graphics/part4/p4-2-1.gif"/>
</p>

```cpp
// 256ë°”ì´íŠ¸ì˜ ê²½ê³„ì— ì •ë ¬
__declspec(align(256)) struct Constants {
    float scale = 1.0f;
};

// ...

// í•„ìš”í•œ ê°ì¢… ë³€ìˆ˜ ì„ ì–¸(ìš°ì„ ì€ ë°›ì•„ë“¤ì´ì.)
ComPtr<ID3D11ComputeShader> m_testCS;
ComputePSO m_testComputePSO;

ComPtr<ID3D11UnorderedAccessView> m_backUAV;

Constants m_constsCPU;
ComPtr<ID3D11Buffer> m_constsGPU;
```

* í—·ê°ˆë¦´ ë§Œí•œ ë¶€ë¶„ì´ `__declspec(align(256))`ì¸ë°
    * ë©”ëª¨ë¦¬ë¥¼ 256Bytes ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•´ ì¤€ë‹¤
    * ??? ë‹¹ì—°í•œê±° ì•„ë‹Œê°€ ???
    * ë‹¹ì—°í•˜ì§€ ì•ŠìŒ. ì»´íŒŒì¼ëŸ¬ê°€ ì••ì¶•í•˜ê±°ë‚˜ í˜¹ì€ Paddingì„ ì¶”ê°€í• ìˆ˜ ìˆìŒ ê·¸ê±¸ ë°©ì§€

```cpp
bool Initialize() {
    // Back Buffer Formatì„ R16G16B16A16_FLOATë¡œ ì§€ì •
    AppBase::m_backBufferFormat = DXGI_FORMAT_R16G16B16A16_FLOAT;

/*
// ì°¸ê³ ë¡œ BackBufferë¥¼ ë§Œë“¤ë•Œ DXGI_USAGE_UNORDERED_ACCESSë¥¼ ì˜µì…˜ìœ¼ë¡œ ë„£ì–´ì¤˜ì•¼í•˜ëŠ”ë°
// BackBufferì— ëœë¤ ì—‘ì„¸ìŠ¤ë¥¼ í•˜ê¸° ìœ„í•¨ì´ë‹¤.
    // DXGI_USAGE_UNORDERED_ACCESSë¥¼ ì˜µì…˜ìœ¼ë¡œ ì•ˆë„£ìœ¼ë©´ Pixelë³„ë¡œ ìƒ‰ìƒì„ ëª»ë°”ê¿ˆ.
sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT |
                    DXGI_USAGE_UNORDERED_ACCESS;
*/

    if (!AppBase::Initialize())
        return false;

    ComPtr<ID3D11Texture2D> backBuffer;
    ThrowIfFailed(
        m_swapChain->GetBuffer(0, IID_PPV_ARGS(backBuffer.GetAddressOf())));

    // ë°±ë²„í¼ì˜ UAV ìƒì„±
    D3D11_TEXTURE2D_DESC desc;
    backBuffer->GetDesc(&desc);

    D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
    ZeroMemory(&uavDesc, sizeof(uavDesc));
    uavDesc.Format = desc.Format;
    uavDesc.ViewDimension = D3D11_UAV_DIMENSION_TEXTURE2D;
    uavDesc.Texture2D.MipSlice = 0;
    ThrowIfFailed(m_device->CreateUnorderedAccessView(
        backBuffer.Get(), &uavDesc, m_backUAV.GetAddressOf()));

    // Compute Shader(CS) ìš© ë²„í¼ Constant ìƒì„±
    D3D11Utils::CreateConstBuffer(m_device, m_constsCPU, m_constsGPU);

    // CS ìƒì„±, CS.hlslê°€ ì‰ì–´ë”ê°€ ëœë‹¤.
    D3D11Utils::CreateComputeShader(m_device, L"CS.hlsl", m_testCS);

    // ComputeShader Test
    m_testComputePSO.m_computeShader = m_testCS;

    return true;
}
```

```cpp
// Bufferì— ì—…ë°ì´íŠ¸ëŠ” ì´ë ‡ê²Œ
template <typename T_DATA>
static void UpdateBuffer(ComPtr<ID3D11DeviceContext> &context,
                            const T_DATA &bufferData,
                            ComPtr<ID3D11Buffer> &buffer) {

    D3D11_MAPPED_SUBRESOURCE ms;
    context->Map(buffer.Get(), NULL, D3D11_MAP_WRITE_DISCARD, NULL, &ms);
    memcpy(ms.pData, &bufferData, sizeof(bufferData));
    context->Unmap(buffer.Get(), NULL);
}

void Render() {

    AppBase::SetPipelineState(m_testComputePSO);

    m_context->CSSetConstantBuffers(0, 1, m_constsGPU.GetAddressOf());
    m_context->CSSetUnorderedAccessViews(0, 1, m_backUAV.GetAddressOf(), NULL);

    // ì¼ë°˜ Shaderì— Renderê°€ ìˆë‹¤ë©´ CSëŠ” Dispatchê°€ ìˆë‹¤.
        // UINT(ceil(m_screenWidth / 256.0f)), m_screenHeight, 1 -> threadê·¸ë£¹ì„ ë‚˜ëˆˆë‹¤
        // ê°€ë¡œ 256 pixelë§ˆë‹¤ threadê·¸ë£¹ì„ ë‚˜ëˆ´ìŒì„ ê¸°ì–µ
    m_context->Dispatch(UINT(ceil(m_screenWidth / 256.0f)), m_screenHeight, 1);

    // ì»´í“¨í„° ì‰ì´ë”ê°€ í•˜ë˜ ì¼ì„ ëë‚´ê²Œ ë§Œë“¤ê³  Resources í•´ì œ
    AppBase::ComputeShaderBarrier();
}
```

* ìš°ì„  Shaderì½”ë“œë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ì„  ì„¤ëª…ì´ ì¢€ í•„ìš”í•˜ë‹¤
    * `m_screenWidth = 1920, m_screenHeight = 1080`ìœ¼ë¡œ ê°€ì •í•˜ìë©´
    * `m_context->Dispatch(UINT(ceil(m_screenWidth / 256.0f)), m_screenHeight, 1);`ì´ê³ 
    * `UINT(ceil(m_screenWidth / 256.0f)) = 5` -> Thread Groupì„ 5ê°œë¡œ í•´ë‹¬ë¼
    * 256 * 5 = **1280ê°œì˜ Threadê°€ ëŒì•„ê°€ê²Œ ëœë‹¤.**
* ë‹¤ì‹œ ì •ë¦¬í•˜ìë©´
    * `Dispatch`ì‹œ Thread Groupì„ ìƒì„±í•˜ê³ 
    * `numthreads`ì‹œ ê° Thread Groupì— ë“¤ì–´ê°€ëŠ” Threadë¥¼ ì •í•œë‹¤
* ì•„ë˜ ê·¸ë¦¼ìœ¼ë¡œ ì˜ˆì‹œë¥¼ ë“¤ìë©´
    * Dispatchë¡œ 5, 3, 2 (30ê°œ) Thread Groupì„ ìƒì„±
    * ê° Threadê·¸ë£¹ì†ì—ëŠ” 10, 8, 3 (240ê°œ) ê°œì˜ Threadê°€ ì¡´ì¬í•œë‹¤.
    * ê·¸ëŸ¼ ê·¸ ì†ì—ì„œ SV_GroupThreadID, SV_GroupID, SV_DispatchThreadID, SV_GroupIndexëŠ” ì•„ë˜ì™€ ê°™ì´ ê²°ì •ë¨

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/graphics/part4/p4-2-1.png"/>
</p>

```cpp
RWTexture2D<float4> gOutput : register(u0);

cbuffer MyBuffer : register(b0)
{
    float scale;
}

// thread ê·¸ë£¹ë³„ë¡œ ìƒ‰ìƒ ë³€ê²½
    // ì°¸ê³ ë¡œ 256 * 1 * 1ì´ í•˜ë‚˜ì˜ Thread Groupì´ ë˜ê³ 
    // í•˜ë‚˜ì˜ Thread Groupì€ 1024ë¥¼ ë„˜ìœ¼ë©´ ì•ˆë˜ê³ (DirecX11 ê¸°ì¤€)
    // Zì˜ ê°’ì€ 64ë¥¼ ë„˜ìœ¼ë©´ ì•ˆëœë‹¤.
// í˜„ì¬ëŠ” í•˜ë‚˜ì˜ Thread ê·¸ë£¹ì„ 256ê°œë¡œ ì„ ì–¸í•´ ë‹¬ë¼
    // 256ê°œì˜ Threadë¥¼ ëŒë ¤ë‹¬ë¼ëŠ” ë§.
[numthreads(256, 1, 1)] 
void main(int3 gID : SV_GroupID,            // SV_GroupID - ëª‡ ë²ˆì§¸ Thread Groupì¸ì§€ ì˜ë¯¸
         uint3 tID : SV_DispatchThreadID)   // SV_DispatchThreadID - ì „ì²´ Threadì¤‘ IDë¥¼ ì˜ë¯¸
         // SV_DispatchThreadIDê°€ Pixelê³¼ ë™ì¼í•´ ì§„ë‹¤
{
    // widthë³„ë¡œ Thread Groupì„ ë‚˜ëˆ  ë†¨ê¸°ì— gIDëŠ” 256ê¸°ì¤€ìœ¼ë¡œ ë‚˜ë‰¨
    if (gID.x % uint(2) == 0)
    {
        gOutput[tID.xy] = float4(0.5, 0.5, 0.5, 1.0);
    }
    else
    {
        gOutput[tID.xy] = float4(1, 1, 1, 1) * scale;
    }
}
```

* ê¸´ë§ í• ê²ƒ ì—†ì´ ì˜ˆì‹œ ê·¸ë¦¼ìœ¼ë¡œ ë³´ë©´ ì´í•´ê°€ ëœë‹¤.

```cpp
// 500 * 500 ì˜ thread groupì„ ìƒì„±
m_context->Dispatch(500, 500, 1);
```

```cpp
// ê° thread groupì—ëŠ” í•˜ë‚˜ì˜ threadë¥¼ ë„£ëŠ”ë‹¤
[numthreads(1, 1, 1)]
```

* 500 * 500ì— 1px ê¸°ì¤€ìœ¼ë¡œ ìƒ‰ìƒì´ ë³€ê²½ëœ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚œë‹¤

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/graphics/part4/p4-2-2.png"/>
</p>

```cpp
// ê° thread groupì— 5ê°œì˜ threadë¥¼ ë„£ëŠ”ë‹¤ë©´?
[numthreads(5, 1, 1)]
```

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/graphics/part4/p4-2-3.png"/>
</p>

* ê°€ì¥ ê¶ê¸ˆí•œê²Œ í•´ê²°ì´ ì•ˆëë‹¤.
    * ì™œ `SV_DispatchThreadID`ê°€ í™”ë©´ì˜ pixelê°’ì´ ë  ìˆ˜ ìˆì§€?
    * ë‹¤ì‹œ ì •ë¦¬í•˜ë©´ `SV_DispatchThreadID`ê°€ ë­”ê°€ ì–´ë–»ê²Œ ì •ì˜ë˜ëƒê°€ ì¤‘ìš”í•˜ë‹¤
    * ê·¸ë¦¼ì˜ ì˜ˆ ëŒ€ë¡œ (2, 1, 0)ì˜ Thread Groupì— (7, 5, 0) ë²ˆì§¸ Threadë¥¼ ì“´ë‹¤ë©´
    * (2, 1, 0) * (10, 8, 3) + (7, 5, 0) = (27, 13, 0)ì´ ëœë‹¤.
* ë‹¤ì‹œ ì›ë˜ì˜ ì˜ˆì‹œë¡œ ëŒì•„ê°€ì„œ

```cpp
// m_screenWidth = 1920
// m_screenHeight = 1080
m_context->Dispatch(UINT(ceil(m_screenWidth / 256.0f)), m_screenHeight, 1);
// m_context->Dispatch(8, 1080, 1);
    // 8,640ê°œì˜ thread groupì´ ìƒì„±ëœë‹¤
```

```cpp
// 8,640 * 256 = 2,211,840 ê°œì˜ thread
    // 1920 * 1080 = 2,073,600 ê°œëŠ” ëª¨ë‘ ì±„ì›Œì§ˆ threadëŠ” ë‚˜ì˜¤ê²Œ ëœë‹¤.
[numthreads(256, 1, 1)]
```

* height ê¸°ì¤€ 1pxì˜ í•œ ìƒ‰ìƒì˜ ë„ˆë¹„ê°€ í•˜ë‚˜ì˜ thread groupì´ë‹¤.
* ë‹¤ìŒ heightì¤„ì˜ ìƒ‰ìƒì´ ì¹ í•´ì§€ëŠ” ì´ìœ ëŠ” ë‹¤ìŒ thread group yë¡œ ë„˜ì–´ê°”ê¸° ë•Œë¬¸
    * ì°¸ ì„¤ëª…ì„ í—·ê°ˆë¦¬ê²Œ í•œê±° ê°™ì€ë° ìƒê°í•´ë³´ë©´ ì´í•´ê°€ ë¨ ;;
