---
layout: default
title: "00. ğŸ”¥ ì •ë¦¬ ğŸ”¥"
parent: "(C++) Socket"
grand_parent: "Game Server ğŸ‘¾"
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ê° ëª¨ë¸ì´ ë“±ì¥í•˜ê²Œ ëœ ì´ìœ ? ğŸ¤·â€â™‚ï¸

* ìˆ˜ì‹ ë²„í¼ì— ë°ì´í„°ê°€ ì—†ëŠ”ë°, read í•œë‹¤ê±°ë‚˜!
* ì†¡ì‹ ë²„í¼ê°€ ê½‰ ì°¼ëŠ”ë°, write í•œë‹¤ê±°ë‚˜!
    * ê²°ë¡ ì ìœ¼ë¡œ **ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°ë§Œ read, writeë¥¼ í•˜ê³  ì‹¶ë‹¤.**
* í•´ë‹¹ threadê°€ blockë˜ì–´ ë¬´í•œ ëŒ€ê¸°í•˜ëŠ” ê²ƒë„ ì‹«ê³ , ê·¸ë ‡ë‹¤ê³  non-blockìœ¼ë¡œ ë§¤ ë£¨í”„ë§ˆë‹¤ kernelì˜ì—­ì¸ send, read, acceptì˜ ì ‘ê·¼ë„ ì‹«ë‹¤
    * ì´ê±¸ ì¢€ ìš°ì•„í•˜ê²Œ í•´ê²°í•´ ë³´ì

---

* ì¼ë‹¨ ì•„ë˜ ê¸°ì¤€ì€ ëª¨ë‘ non-blockê¸°ì¤€ì„
    * ì¦‰, ì•Œê³  ì‹¶ì€ê²ƒì€ bufferì— read, write, accept ì •ë³´ê°€ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ ì²´í¬í•˜ëŠ” ë°©ë²•

## Select ëª¨ë¸

* **ì¥/ë‹¨ì **
    * ì¥ì ) ìœˆë„ìš°/ë¦¬ëˆ…ìŠ¤ ê³µí†µ. (í´ë¼ì´ì–¸íŠ¸ì— ì‚¬ìš©í•˜ê¸° ì¢‹ìŒ)
    * ë‹¨ì 1) ì„±ëŠ¥ ìµœí•˜ (ë§¤ë²ˆ ì†Œì¼“ ì…‹ ë“±ë¡ ë¹„ìš©) 
        * ğŸ‘‰ `FD_ZERO`, `FD_SET`ë¥¼ ë§¤ë²ˆ í•´ì•¼í•œë‹¤.
    * ë‹¨ì 2) 64ê°œ ì œí•œ(FD_SET ì†Œì¼“ ì…‹ì˜ ìµœëŒ€ê°€ 64ê°œ) 
        * ğŸ‘‰ FD_SETì´ ì¼ì¢…ì˜ Flagì´ë‹¤. 64ê°œì˜ bitsë§Œ ì“¸ ìˆ˜ ìˆì–´ì„œ ì†Œì¼“ ì…‹ì˜ ìµœëŒ€ê°€ 64ê°œê°€ ëœë‹¤.
* **êµ¬í˜„ë²•**

```cpp
// 1) FD_ ì´ˆê¸°í™”
FD_ZERO(&reads);
FD_ZERO(&writes);

// 2) Selectë¥¼ ë°›ì„ ì†Œì¼“ì„ SET
FD_SET(listenSocket, &reads);
FD_SET(s.socket, &writes);

// 3) ì¤€ë¹„ëœ ì†Œì¼“ì´ ìˆëŠ”ì§€ í™•ì¸
int32 retVal = ::select(0, &reads, &writes, nullptr, nullptr);
if (retVal == SOCKET_ERROR) break;

// 4) ì†Œì¼“ì„ ì²´í¬
if (FD_ISSET(listenSocket, &reads)) {
    // ...
    SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);
}

if (FD_ISSET(s.socket, &reads))
{
    int32 recvLen = ::recv(s.socket, s.recvBuffer, BUFSIZE, 0);
    // ...

// 5) ë‹¤ì‹œ 1)ë¡œ ëŒì•„ê°„ë‹¤.
```

---

## WSAEventSelect ëª¨ë¸

* Select ëª¨ë¸ì˜ ìµœëŒ€ ë‹¨ì ì¸ **ë§¤ë²ˆ ì†Œì¼“ ì…‹ ë“±ë¡ ë¹„ìš©** ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë‚˜ì™”ë‹¤.
* í•´ê²°ë²•ì€ **Eventë¥¼ ì‚¬ìš©**, ì£¼ì˜ í•  ì ì€ WSAEventSelect ëª¨ë¸ì„ ì“°ë©´ ì†Œì¼“ì€ ìë™ìœ¼ë¡œ **non-block** ëª¨ë¸ë¡œ ë™ì‘í•˜ê²Œ ëœë‹¤.
* **ì¥/ë‹¨ì **
    * ì¥ì ) (Selectì— ë¹„í•´) ë¹„êµì  ë›°ì–´ë‚œ ì„±ëŠ¥
    * ë‹¨ì ) 64ê°œ ì œí•œ ğŸ‘‰ `WSA_MAXIMUM_WAIT_EVENTS=64` Windowì—ì„œ ì œê³µí•˜ëŠ” ìµœëŒ€ Wait Eventê°œìˆ˜ëŠ” 64ê°œ ì´ë‹¤.
* **êµ¬í˜„ë²•**

```cpp
// 0) Socket ìƒì„±
SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);

// 1) Event ìƒì„±
WSAEVENT listenEvent = ::WSACreateEvent();

// 2-1) Eventì™€ Socket ì—°ê²°
if (::WSAEventSelect(listenSocket, listenEvent, FD_ACCEPT | FD_CLOSE) == SOCKET_ERROR)
    return 0;

// 2-2) êµ¬ì²´ì  Event ìˆ˜ì‹ 
if (::WSAEnumNetworkEvents(sessions[index].socket, wsaEvents[index], &networkEvents) == SOCKET_ERROR)
    continue;

// 3-1) Event ë°›ê¸°
int32 index = ::WSAWaitForMultipleEvents(wsaEvents.size(), &wsaEvents[0], FALSE, WSA_INFINITE, FALSE);
if (index == WSA_WAIT_FAILED)
    continue;

// 3-2) Event íŒŒì‹±
WSANETWORKEVENTS networkEvents;
if (::WSAEnumNetworkEvents(sessions[index].socket, wsaEvents[index], &networkEvents) == SOCKET_ERROR)
    continue;

if (networkEvents.lNetworkEvents & FD_ACCEPT)
{

    // or

if (networkEvents.lNetworkEvents & FD_READ || networkEvents.lNetworkEvents & FD_WRITE)
{
    // Error-Check
    if ((networkEvents.lNetworkEvents & FD_READ) && (networkEvents.iErrorCode[FD_READ_BIT] != 0))
```

---

* **Overlapped** : ë¹„ë™ê¸°(ë‹¹ì¥ ë™ì‹œì— ì‹¤í–‰ì´ ë˜ì§€ ì•Šì•„ë„ ë¨) + ë…¼ë¸”ë¡œí‚¹(ì½”ë“œë¥¼ ì¡ì§€ì•ŠëŠ”ë‹¤)

## Overlapped (ì´ë²¤íŠ¸ ê¸°ë°˜)

* **ì¥/ë‹¨ì **
    * ì¥ì ) ì„±ëŠ¥
    * ë‹¨ì ) 64ê°œ ì œí•œ(ì†Œì¼“í•˜ë‚˜ë‹¹ Eventí•˜ë‚˜ë¥¼ ì—°ê²°) ğŸ‘‰ í•œ ì“°ë ˆë“œ ë‹¹ ì´ë²¤íŠ¸ ì˜¤ë¸Œì íŠ¸ ìµœëŒ€ ì²˜ë¦¬ê°œìˆ˜ëŠ” 64ê°œì´ë‹¤.
* **êµ¬í˜„ë²•**

```cpp
// 1) Event ìƒì„±
WSAEVENT wsaEvent = ::WSACreateEvent();

// 2) Overlappedë¥¼ ê±´ë‹¤
if (::WSARecv(clientSocket, &wsaBuf, 1, &recvLen, &flags, &session.overlapped, nullptr) == SOCKET_ERROR)
{

// 3) í•„ìš”í•˜ë‹¤ë©´ ëŒ€ê¸° or ìˆ˜ì‹ 
::WSAWaitForMultipleEvents(1, &wsaEvent, TRUE, WSA_INFINITE, FALSE);
::WSAGetOverlappedResult(session.socket, &session.overlapped, &recvLen, FALSE, &flags);
```

---

## Overlapped (ì½œë°± ê¸°ë°˜)

* **ì¥/ë‹¨ì **
    * ì¥ì ) ì„±ëŠ¥
    * ë‹¨ì 1) ëª¨ë“  ë¹„ë™ê¸° ì†Œì¼“ í•¨ìˆ˜ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•˜ì§„ ì•ŠìŒ (accept).
    * ë‹¨ì 2) ë¹ˆë²ˆí•œ Alertable Waitìœ¼ë¡œ ì¸í•œ ì„±ëŠ¥ ì €í•˜
* **êµ¬í˜„ë²•**

```cpp
// 1) ì½œë°±í•¨ìˆ˜ ìƒì„±
void CALLBACK RecvCallback(DWORD error, DWORD recvLen, LPWSAOVERLAPPED overlapped, DWORD flags)

// 2) Overlappedë¥¼ ê±¸ì–´ì£¼ë©° ì½œë°±í•¨ìˆ˜ ì „ë‹¬
if (::WSARecv(clientSocket, &wsaBuf, 1, &recvLen, &flags, &session.overlapped, RecvCallback) == SOCKET_ERROR)

// 3) Alertable Waitì„ ì¤€ë‹¤
::SleepEx(INFINITE, TRUE);
```

---

* ë¹ˆë²ˆí•œ Alertable Waitì„ ì“°ê³ ì‹¶ì§€ ì•Šë‹¤

## IOCP

```cpp
// 1) CompletionPort ìƒì„±
HANDLE iocpHandle = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

// 2) Threadë¥¼ ë§Œë“¤ê³  CompletionPortì˜ HANDLEì„ ë˜ì§„ë‹¤.
GThreadManager->Launch([=]() { WorkerThreadMain(iocpHandle); });

// 3) WSARecvê°€ ê±¸ë¦°ë‹¤ë©´
::WSARecv(clientSocket, &wsaBuf, 1, &recvLen, &flags, &overlappedEx->overlapped, NULL);

// 4) í•´ë‹¹ Threadì—ì„œ CompletionPortë¥¼ ì½ëŠ”ë‹¤
void WorkerThreadMain(HANDLE iocpHandle)
{
	while (true)
	{
		DWORD bytesTransferred = 0;
		Session* session = nullptr;
		OverlappedEx* overlappedEx = nullptr;

		BOOL ret = ::GetQueuedCompletionStatus(iocpHandle, &bytesTransferred,
			(ULONG_PTR*)&session, (LPOVERLAPPED*)&overlappedEx, INFINITE);
```
