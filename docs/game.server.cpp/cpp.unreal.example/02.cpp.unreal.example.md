---
layout: default
title: "02. 복습 - 서버 개발의 핵심"
parent: "(UE + IOCP)"
grand_parent: "Game Server 👾"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code 🌎](https://github.com/Arthur880708/cpp.unreal.server.example/tree/1)

---

## Server의 중요 요소들

* Atomic, Lock
* Lamda, Functor
* SmartPointer
* Network (select, eventselect, ... iocp)
* TCP and UDP
* RecvBuffer
* SendBuffer
* 패킷 조립 (protobuf)

---

## 서버의 성능은 어떻게 측정이 될까?

* Thread를 어떻게 배분했냐?
* Lock을 어떻게 잡았느냐?
* 결국은 Thread를 **어떻게 분산**했느냐 가 핵심이다.

### Thread Job의 분산

* 구현 방법: 
    * 스레드 풀을 사용하여 요청마다 새로운 스레드를 생성하는 오버헤드를 줄였습니다. 
    * 요청이 들어오면, 스레드 풀에서 사용 가능한 스레드를 할당받아 요청을 처리하고 작업이 완료되면 스레드를 풀로 반환했습니다.
* 그래도 특정 Thread에 Job이 몰린다면?
    * 작업 큐(Job Queue) 사용:
        * 설명: 모든 요청을 중앙 작업 큐에 넣고, 스레드 풀 내의 스레드들이 이 큐에서 작업을 가져가 처리합니다. 이 방법은 작업이 도착하는 즉시 스레드에 할당되는 것이 아니라, 스레드가 사용 가능할 때 큐에서 작업을 가져가므로 더 균등한 작업 분산을 달성할 수 있습니다.
        * 장점: 간단하고 효율적인 방법으로, 스레드가 작업을 끝낼 때마다 다음 작업을 큐에서 가져옵니다.
    * 동적 스레드 할당(Dynamic Thread Allocation):
        * 설명: 작업의 양이나 현재 스레드의 부하를 기반으로 스레드 할당을 동적으로 조정합니다. 예를 들어, 특정 스레드가 과부하 상태일 때 추가 스레드를 생성하거나, 부하가 적은 스레드에 작업을 재할당할 수 있습니다.
    * 우선순위 기반 할당(Priority-Based Allocation):
        * 설명: 작업에 우선순위를 부여하고, 우선순위가 높은 작업을 먼저 처리하도록 스레드를 할당합니다. 이 방법은 특히 시간에 민감한 작업을 처리할 때 유용합니다.
    * 작업 분할(Job Partitioning):
        * 설명: 큰 작업을 더 작은 단위로 분할하여 여러 스레드에 균등하게 분배합니다. 이 방법은 병렬 처리가 가능한 작업에 특히 효과적입니다.

---

## mutex, atomic, semaphore

* Mutex
    * Mutual Exclusion (상호 배제)의 약자로, **한 번에 하나의 스레드만이 특정 코드 영역에 접근할 수 있도록 보장**합니다.
    * 뮤텍스는 공유 자원에 대한 접근을 제어하여 데이터 무결성을 유지하는 데 사용됩니다.
    * 사용 케이스:
        * 공유 데이터에 대한 **접근을 동기화**할 때 주로 사용됩니다.
        * 여러 스레드가 공유 데이터를 변경할 위험이 있을 때 사용합니다.
    * 사용 예시:
        * 데이터베이스에 대한 접근을 제어하거나, 여러 스레드가 동시에 파일에 쓰는 것을 방지하는 데 사용될 수 있습니다.
        * 예를 들어, 은행 시스템에서 여러 스레드가 고객의 계좌 잔액을 동시에 업데이트하는 것을 방지하기 위해 뮤텍스를 사용했습니다.
* Atomic 
    * 연산은 중단되거나 방해 받지 않고 완전히 실행되는 연산을 의미합니다.
    * `std::atomic`은 C++에서 원자적 연산을 지원하기 위해 제공되는 템플릿 클래스입니다.
    * 사용 케이스:
        * 주로 단순한 데이터(예: 카운터, 플래그)의 증가나 감소와 같은 작은 연산에 사용됩니다.
        * **락을 사용하지 않고도 데이터의 동시성 문제를 해결할 수 있어 오버헤드가 적습니다.**
    * 사용 예시:
        * 여러 스레드에서 공유 카운터를 증가시킬 때 `std::atomic<int>`를 사용하여 원자적으로 카운터를 관리했습니다.
        * 플래그를 통해 스레드 간 상태를 안전하게 통신하는 데에도 사용됩니다.
* Semaphore
    * Semaphore는 공유 자원에 대한 접근을 제한하는 동기화 메커니즘입니다.
    * 세마포어는 뮤텍스와 유사하지만, 한 번에 **여러 스레드가 공유 자원에 접근할 수 있는 '카운트' 개념을 가지고 있습니다.**
    * 사용 케이스:
        * 제한된 수의 자원을 여러 스레드가 공유해야 할 때 사용됩니다.
        * 특정 자원에 대한 동시 접근 수를 제어해야 할 때 유용합니다.
    * 사용 예시:
        * 데이터베이스 연결 풀(pool)이나 네트워크 연결과 같이 제한된 수의 자원에 대한 접근을 관리할 때 사용됩니다.
        * 예를 들어, 동시에 수행될 수 있는 최대 파일 다운로드 수를 제한하기 위해 세마포어를 사용했습니다.