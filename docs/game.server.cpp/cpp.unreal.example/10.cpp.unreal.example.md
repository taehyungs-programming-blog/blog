---
layout: default
title: "10. Job"
parent: "(UE + IOCP)"
grand_parent: "Game Server ğŸ‘¾"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/Arthur880708/cpp.unreal.server.example/tree/5)

---

* ê¸°ì¡´ì½”ë“œì— ë¬¸ì œê°€ ì—†ì—ˆì„ê¹Œ?

```cpp
bool Room::HandleEnterPlayerLocked(PlayerRef player)
{
    // Handleì„ ì²˜ë¦¬í•˜ëŠ” ë¶€ë¶„ì—ì„œ Lockì„ ì¡ëŠ”ê²Œ ë¬¸ì œì´ë‹¤.
        // ë§Œì•½ ì•„ë˜ ì‘ì—…ì˜ ì‹œê°„ì´ ì˜¤ë˜ê±¸ë¦°ë‹¤ë©´ í•´ë‹¹ë½ì€ ë¬´ì¡°ê±´ ì¡í˜€ìˆëŠ”ë‹¤
	WRITE_LOCK;

	bool success = EnterPlayer(player);

	// ...
```

---

## í•´ê²°ì±… Jobì„ ë§Œë“¤ê³  ë˜ì§„ë‹¤!

```cpp
bool Handle_C_ENTER_GAME(PacketSessionRef& session, Protocol::C_ENTER_GAME& pkt)
{
	PlayerRef player = ObjectUtils::CreatePlayer(static_pointer_cast<GameSession>(session));

	GRoom->DoAsync(&Room::HandleEnterPlayer, player);
	//GRoom->HandleEnterPlayerLocked(player);

	return true;
}
```

```cpp
class JobQueue : public enable_shared_from_this<JobQueue>
{
    // ...

	template<typename T, typename Ret, typename... Args>
	void DoAsync(Ret(T::*memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		Push(make_shared<Job>(owner, memFunc, std::forward<Args>(args)...));
	}

    // ...
```

```cpp
void JobQueue::Push(JobRef job, bool pushOnly)
{
	const int32 prevCount = _jobCount.fetch_add(1);
	_jobs.Push(job); // WRITE_LOCK

	// ì²«ë²ˆì§¸ Jobì„ ë„£ì€ ì“°ë ˆë“œê°€ ì‹¤í–‰ê¹Œì§€ ë‹´ë‹¹
	if (prevCount == 0)
	{
		// ì´ë¯¸ ì‹¤í–‰ì¤‘ì¸ JobQueueê°€ ì—†ìœ¼ë©´ ì‹¤í–‰
		if (LCurrentJobQueue == nullptr && pushOnly == false)
		{
			Execute();
		}
		else
		{
			// ì—¬ìœ  ìˆëŠ” ë‹¤ë¥¸ ì“°ë ˆë“œê°€ ì‹¤í–‰í•˜ë„ë¡ GlobalQueueì— ë„˜ê¸´ë‹¤
			GGlobalQueue->Push(shared_from_this());
		}
	}
}
```

```cpp
void DoWorkerJob(ServerServiceRef& service)
{
	while (true)
	{
		
		// ...

		// ê¸€ë¡œë²Œ í ì—ì„œ ì¡ì„ ì²˜ë¦¬í•˜ê³  ìˆëŠ”ë‹¤
		ThreadManager::DoGlobalQueueWork();
	}
}
```

---

## ë³µìŠµ) ì´ëŸ¬í•œ í˜„ìƒì´ ì™œ ìƒê¸¸ê¹Œ?

```cpp
int main()
{
	// ... network

	for (int32 i = 0; i < 5; i++)
	{
        // ë©”ì¸ì—ì„œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë¥¼ ëŒë¦¬ê²Œ ëœë‹¤.
		GThreadManager->Launch([&service]()
			{
				DoWorkerJob(service);
			});
	}
```

```cpp
// DoWorkerJobì€ ê²°êµ­ Dispatchë¡œ ê°€ê³  ê° ìŠ¤ë ˆë“œëŠ”
    // GetQueuedCompletionStatusë¥¼ ëŒ€ê¸°í•˜ê³  ì²˜ë¦¬í•œë‹¤.
bool IocpCore::Dispatch(uint32 timeoutMs)
{
	DWORD numOfBytes = 0;
	ULONG_PTR key = 0;	
	IocpEvent* iocpEvent = nullptr;

	if (::GetQueuedCompletionStatus(_iocpHandle, OUT &numOfBytes, OUT &key, OUT reinterpret_cast<LPOVERLAPPED*>(&iocpEvent), timeoutMs))
	{
        IocpObjectRef iocpObject = iocpEvent->owner;
		iocpObject->Dispatch(iocpEvent, numOfBytes);
        // ...
```

```cpp
// íŒ¨í‚·ì˜ ìˆ˜ì‹ ì„ ê¸°ì¤€ìœ¼ë¡œ ë³´ìë©´
void GameSession::OnRecvPacket(BYTE* buffer, int32 len)
{
	PacketSessionRef session = GetPacketSessionRef();
	PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);

	ServerPacketHandler::HandlePacket(session, buffer, len);
    // ì—¬ê¸°ì„œ íŒ¨í‚·ì„ ì²˜ë¦¬í•˜ëŠ”ë° ì—¬ê¸°ì„œ ë½ì„ ì¡ì•„ë²„ë¦¬ë©´ í•œ ìŠ¤ë ˆë“œê°€ ë©ˆì¶”ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤.
}
```

