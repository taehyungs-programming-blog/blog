---
layout: default
title: "(01. Componentì˜ Frame Updateë¥¼ ì–´ë–»ê²Œ ì²´í¬í• ê¹Œ?)"
parent: "(UE Code-Review ğŸ¤–)"
has_children: true
nav_order: 1
permalink: docs/review/ue/ver4/01/NeededEndOfFrameUpdate
---

* ì‚¬ì‹¤ ì˜ˆìƒí–ˆë˜ ê·¸ ëŒ€ë¡œì¼ ê²ƒì´ë‹¤.

```cpp
// ì»´í¬ë„ŒíŠ¸ì˜ ë³€í™˜(Transform)ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜
void UMyComponent::OnTransformChanged()
{
    // ë³€í™˜ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ë Œë” ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•¨
    
    // ê¸°ì¡´ ë°©ì‹: ì¦‰ì‹œ ë Œë” ëª…ë ¹ ìƒì„± (ë¹„íš¨ìœ¨ì )
    // SendRenderTransform_Concurrent();
    
    // ê°œì„ ëœ ë°©ì‹: í”„ë ˆì„ ëì— ì—…ë°ì´íŠ¸í•˜ë„ë¡ í‘œì‹œ
    // - false: ì¼ë°˜ ì—…ë°ì´íŠ¸ (ë Œë” ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥)
    GetWorld()->MarkActorComponentForNeededEndOfFrameUpdate(this, false);
    
    // ë§Œì•½ ê²Œì„ ìŠ¤ë ˆë“œì—ì„œ ê°•ì œë¡œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš°
    // GetWorld()->MarkActorComponentForNeededEndOfFrameUpdate(this, true);
}

// ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ê°€ ë™ì‹œì— ì—…ë°ì´íŠ¸ë˜ëŠ” ìƒí™©
void AMyActor::UpdateMultipleComponents()
{
    // ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ì˜ ìƒíƒœ ë³€ê²½
    for (UActorComponent* Component : Components)
    {
        // ê° ì»´í¬ë„ŒíŠ¸ë§ˆë‹¤ ì—…ë°ì´íŠ¸ í•„ìš” í‘œì‹œ
        GetWorld()->MarkActorComponentForNeededEndOfFrameUpdate(Component, false);
        
        // ì´ë ‡ê²Œ í•˜ë©´ ê° ì»´í¬ë„ŒíŠ¸ê°€ ê°œë³„ì ìœ¼ë¡œ ë Œë” ëª…ë ¹ì„ ìƒì„±í•˜ëŠ” ëŒ€ì‹ 
        // í”„ë ˆì„ ëì— ëª¨ì•„ì„œ ì²˜ë¦¬ë˜ì–´ ë Œë” ëª…ë ¹ì˜ ìˆ˜ê°€ ì¤„ì–´ë“¦
    }
}
```

## ê·¸ë˜ì„œ ì–´ë–»ê²Œ í•˜ë‚˜?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/01.00_01.png"/>
</p>

```cpp
void MarkActorComponentForNeededEndOfFrameUpdate(UActorComponent* Component, bool bForceGameThread)
{
    uint32 CurrentState = Component->GetMarkedForEndOfFrameUpdateState();

    if (CurrentState == EComponentMarkedForEndOfFrameUpdateState::Marked && bForceGameThread)
    {
        const int32 ArrayIndex = FMarkComponentEndOfFrameUpdateState::GetArrayIndex(Component);
        ComponentsThatNeedEndOfFrameUpdate[ArrayIndex] = nullptr;
        CurrentState = EComponentMarkedForEndOfFrameUpdateState::Unmarked;
    }
    
    if (CurrentState == EComponentMarkedForEndOfFrameUpdateState::Unmarked)
    {
        bForceGameThread = bForceGameThread || !GIsThreadedRendering || !FApp::ShouldUseThreadingForPerformance();
        if (!bForceGameThread)
        {
            bForceGameThread = !CVarAllowAsyncRenderThreadUpdates.GetValueOnAnyThread();
        }

        if (bForceGameThread)
        {
            FMarkComponentEndOfFrameUpdateState::Set(Component, ComponentsThatNeedEndOfFrameUpdate_OnGameThread.Num(), EComponentMarkedForEndOfFrameUpdateState::MarkedForGameThread);
            ComponentsThatNeedEndOfFrameUpdate_OnGameThread.Add(Component);
        }
        else
        {
            FMarkComponentEndOfFrameUpdateState::Set(Component, ComponentsThatNeedEndOfFrameUpdate.Num(), EComponentMarkedForEndOfFrameUpdateState::Marked);
            ComponentsThatNeedEndOfFrameUpdate.Add(Component);
        }

        if (Component->RequiresPreEndOfFrameSync())
        {
            FMarkComponentEndOfFrameUpdateState::SetMarkedForPreEndOfFrameSync(Component);
            ComponentsThatNeedPreEndOfFrameSync.Add(Component);
        }
    }
}
```

---

## ì—¬ê¸°ì„œ ì¶”ê°€ì§ˆë¬¸ Game Threadì˜ PrimitiveComponentë¥¼ ì–´ë–»ê²Œ Render Threadì¸ PrimitiveSceneProxyë¡œ ì „ë‹¬í• ê¹Œ?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/01.00_02.png"/>
</p>

* ê°„ëµí•œ ì„¤ëª…
    * Proxy ìƒì„±: ê° PrimitiveComponentëŠ” ë Œë”ë§ ìŠ¤ë ˆë“œì—ì„œ ì‚¬ìš©í•  ìì‹ ë§Œì˜ PrimitiveSceneProxyë¥¼ ìƒì„±
    * ë³€ê²½ì‚¬í•­ ë“±ë¡: ì»´í¬ë„ŒíŠ¸ê°€ ë³€ê²½ë˜ë©´ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•˜ë‹¤ê³  í‘œì‹œ
    * `SendAllEndOfFrameUpdates` í˜¸ì¶œ: í”„ë ˆì„ ëì— ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ì–´ ë³€ê²½ì‚¬í•­ì„ ì²˜ë¦¬
    * ìŠ¤ë ˆë“œ ê°„ í†µì‹ : `ENQUEUE_RENDER_COMMAND` ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ì—¬ ë Œë”ë§ ìŠ¤ë ˆë“œì— ëª…ë ¹ì„ ì „ì†¡

* ë­” ì†Œë¦¬ì§€? -> ì •í™•í•œ ë°˜ì‘ì´ë‹¤ ì—­ì‹œ ì˜ˆì‹œì½”ë“œë¡œ ..

```cpp
// 1. PrimitiveComponentì—ì„œ ë³€ê²½ì´ ë°œìƒ
UStaticMeshComponent* MeshComp = GetComponentByClass<UStaticMeshComponent>();
MeshComp->SetRelativeLocation(NewLocation);

// 2. ë‚´ë¶€ì ìœ¼ë¡œ ì»´í¬ë„ŒíŠ¸ëŠ” ë§ˆí‚¹ë¨
// World->MarkActorComponentForNeededEndOfFrameUpdate(MeshComp, false);

// 3. SendAllEndOfFrameUpdatesì—ì„œ ì²˜ë¦¬ë¨
// ê°„ëµí™”ëœ ì˜ˆì‹œ:
void UWorld::SendAllEndOfFrameUpdates()
{
    for (UActorComponent* Component : ComponentsThatNeedEndOfFrameUpdate)
    {
        if (UPrimitiveComponent* PrimComp = Cast<UPrimitiveComponent>(Component))
        {
            // 4. ë Œë”ë§ ìŠ¤ë ˆë“œë¡œ ëª…ë ¹ ì „ì†¡
            PrimComp->SendRenderTransform_Concurrent();
        }
    }
    ComponentsThatNeedEndOfFrameUpdate.Empty();
}

// 5. SendRenderTransform_Concurrent ë‚´ë¶€ (ê°„ëµí™”)
void UPrimitiveComponent::SendRenderTransform_Concurrent()
{
    if (SceneProxy)
    {
        // ENQUEUE_RENDER_COMMAND ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ì—¬ ë Œë”ë§ ìŠ¤ë ˆë“œì— ëª…ë ¹ ì „ì†¡
        ENQUEUE_RENDER_COMMAND(UpdateTransformCommand)(
            [SceneProxy = SceneProxy, NewTransform = GetComponentTransform()](FRHICommandListImmediate& RHICmdList)
            {
                // ë Œë”ë§ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œ
                SceneProxy->SetTransform(NewTransform);
            }
        );
    }
}
```

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/01.00_04.png"/>
</p>

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/01.00_03.png"/>
</p>

```cpp
// ì»´í¬ë„ŒíŠ¸ ë“±ë¡ ì‹œ
void UPrimitiveComponent::RegisterComponent()
{
    Super::RegisterComponent();
    
    if (ShouldCreateRenderState())
    {
        // ë Œë” ìƒíƒœ ìƒì„±
        CreateRenderState_Concurrent();
    }
}

// ë Œë” ìƒíƒœ ìƒì„±
void UPrimitiveComponent::CreateRenderState_Concurrent()
{
    // SceneProxy ìƒì„±
    SceneProxy = CreateSceneProxy();
    
    if (SceneProxy)
    {
        // Sceneì— ë“±ë¡
        UWorld* World = GetWorld();
        if (World && World->Scene)
        {
            World->Scene->AddPrimitive(this);
        }
    }
}

// ê° ì»´í¬ë„ŒíŠ¸ íƒ€ì…ë³„ë¡œ ì˜¤ë²„ë¼ì´ë“œë¨
FPrimitiveSceneProxy* UStaticMeshComponent::CreateSceneProxy()
{
    if (StaticMesh && StaticMesh->RenderData)
    {
        // StaticMeshìš© SceneProxy ìƒì„±
        return new FStaticMeshSceneProxy(this);
    }
    return nullptr;
}

// ìŠ¤ì¼ˆë ˆíƒˆ ë©”ì‹œ ì˜ˆì‹œ
FPrimitiveSceneProxy* USkeletalMeshComponent::CreateSceneProxy()
{
    if (SkeletalMesh && MeshObject)
    {
        // SkeletalMeshìš© SceneProxy ìƒì„±
        return new FSkeletalMeshSceneProxy(this);
    }
    return nullptr;
}
```

---

## ì°¸ê³ ) PrimitiveComponentì™€ PrimitivieSceneProxyì˜ ê´€ê³„

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/01.00_05.png"/>
</p>

---

## ì°¸ê³ 2) PrimitivieScneneì€ ì–´ë–»ê²Œ Renderê¹Œì§€ ê°ˆê¹Œ?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/01.00_06.png"/>
</p>

