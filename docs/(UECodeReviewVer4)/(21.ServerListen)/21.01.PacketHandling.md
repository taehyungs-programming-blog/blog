---
layout: default
title: "21.01. PacketHandling ë°©ë²•"
parent: "(21. ServerListen ê³¼ì •ìœ¼ë¡œ ë³´ëŠ” UEì—”ì§„ ì´í•´í•˜ê¸°)"
grand_parent: "(UE Code-Review ğŸ¤–)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
virtual void InitConnectionlessHandler()
{
    ConnectionlessHandler = MakeUnique<PacketHandler>(nullptr);
    if (ConnectionlessHandler.IsValid())
    {
        //                                                                                                          
        //  *** What is PacketHandler?                                                                              
        //                                                                                                          
        //     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                             
        //     â”‚ NetCode(Game-related) â”‚   â”‚   â”‚ Network Engine (Network-related) â”‚   â”‚                             
        //     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                             
        //                                 â”‚                                          â”‚                             
        //        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚      PacketHandler::Incoming()           â”‚                             
        //        â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â—„â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€     Actual Network World: 
        //        â””â”€â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”       â”‚                                          â”‚        e.g. Router          
        //          â””â”€â”¤  Channels  â”‚   â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â–º                          
        //            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚      PacketHandler::Outgoing()           â”‚                             
        //                                 â”‚                                          â”‚                             
        //                                 â”‚                                          â”‚                             
        //                                                                                                          
        //                     *** PacketHandler governs incoming/outgoing packets in unreal engine                 
        //                                       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                 
        //                                                                                                          
        
        ConnectionlessHandler->Initialize(UE::Handler::Mode::Server, MAX_PACKET_SIZE, true, nullptr, nullptr, NetDriverDefinition);

    
        TSharedPtr<HandlerComponent> NewComponent = 
            ConnectionlessHandler->AddHandler(TEXT("Engine.EngineHandlerComponentFactory(StatelessConnectHandlerComponent)"), true);
    
        StatelessConnectComponent = StaticCastSharedPtr<StatelessConnectHandlerComponent>(NewComponent);
        if (StatelessConnectComponent.IsValid())
        {
            StatelessConnectComponent.Pin()->SetDriver(this);
        }

        ConnectionlessHandler->InitializeComponents();
    }
}
```

```cpp
TSharedPtr<HandlerComponent> PacketHandler::AddHandler(const FString& ComponentStr, bool bDeferInitialize=false)
{
    TSharedPtr<HandlerComponent> ReturnVal = nullptr;
    if (!ComponentStr.IsEmpty())
    {
        //  Engine.EngineHandlerComponentFactory(StatelessConnectHandlerComponent) 
        //  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  
        //                    â”‚                              â”‚                     
        //                    â”‚                              â”‚                     
        //                ComponentName                 ComponentOption            
        //                                                                         
        FString ComponentName;
        FString ComponentOptions;
        for (int32 i = 0; i < ComponentStr.Len(); ++i)
        {
            TCHAR c = ComponentStr[i];

            // Parsing Options
            if (c == '(')
            {
                // Skip '('
                ++i;

                // Parse until end of options
                for (; i<ComponentStr.Len(); i++)
                {
                    c = ComponentStr[i];

                    // End of options
                    if (c == ')')
                    {
                        break;
                    }
                    // Append char to options
                    else
                    {
                        ComponentOptions.AppendChar(c);
                    }
                }
            }
            // Append char to component name if not whitespace
            else if (c != ' ')
            {
                ComponentName.AppendChar(c);
            }
        }

        if (ComponentName != TEXT("ReliabilityHandlerComponent"))
        {
            int32 FactoryComponentDelim = ComponentName.Find(TEXT("."));
            if (FactoryComponentDelim != INDEX_NONE)
            {
                FString SingletonName = ComponentName.Mid(FactoryComponentDelim + 1) + TEXT("_Singleton");

                UHandlerComponentFactory* Factory = FindFirstObject<UHandlerComponentFactory>(*SingletonName, EFindFirstObjectOptions::NativeFirst | EFindFirstObjectOptions::EnsureIfAmbiguous);
                if (Factory == nullptr)
                {
                    UClass* FactoryClass = StaticLoadClass(UHandlerComponentFactory::StaticClass(), nullptr, *ComponentName);
                    if (FactoryClass)
                    {
                        Factory = NewObject<UHandlerComponentFactory>(GetTransientPackage(), FactoryClass, *SingletonName);
                    }
                }

                if (Factory != nullptr)
                {
                    ReturnVal = Factory->CreateComponentInstance(ComponentOptions);
                }
            }
            else
            {
                //...
            }

            if (ReturnVal.IsValid())
            {
                AddHandler(ReturnVal, bDeferInitialize);
            }
        }
    }

    return ReturnVal;
}
```