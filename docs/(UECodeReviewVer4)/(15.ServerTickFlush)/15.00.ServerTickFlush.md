---
layout: default
title: "(15. Serverì—ì„  TickFlushë¥¼ í†µí•´ ì–´ë–¤ ì²˜ë¦¬ë¥¼ í• ê¹Œ?)"
parent: "(UE Code-Review ğŸ¤–)"
has_children: true
nav_order: 2
permalink: docs/review/ue/ver4/15/ServerTickFlush
---

```cpp
virtual void TickFlush(float DeltaSeconds)
{
    // ëŒ€ëµ ì´ì¯¤?
    if (IsServer() && ClientConnections.Num() > 0)
    {
        // ìš°ì„  Actorë¥¼ Replicateí•œë‹¤.
        ServerReplicateActors(DeltaSeconds);
    }

    if (ServerConnection)
    {
        ServerConnection->Tick(DeltaSeconds);
    }

    {
        for (UNetConnection* Connection : ClientConnections)
        {
            Connection->Tick(DeltaSeconds);
        }
    }

    //...

    if (!IsUsingIrisReplication())
    {
        UpdateUnmappedObjects();
    }

}
```

```cpp
int32 NetDriver::ServerReplicateActors(float DeltaSeconds)
{
    // ë­”ê°€ Replicationì„ ìœ„í•œ countê°€ ìˆìŒ.
    ReplicationFrame++;

    // clientì¤‘ì— ì—…ë°ì´íŠ¸í•´ì•¼í•  ì•„ì´ê°€ ìˆë‹ˆ?
    const int32 NumClientsToTick = ServerReplicateActors_PrepConnections(DeltaSeconds);
    if (NumClientsToTick == 0)
    {
        // no connections are ready this frame
        return 0;
    }

    // ... ì´í›„ ë‚´ìš©ì€ ì¡°ê¸ˆ ë” í›„ì— ì‚´í´ë³´ì.
```

### ReplicationFrameì´ë€?

1. ì†ì„± ë³€ê²½ ì¶”ì : ë³µì œ ì‹œìŠ¤í…œì´ ì–´ë–¤ ì†ì„±ì´ ì´ì „ í”„ë ˆì„ê³¼ ë¹„êµí•˜ì—¬ ë³€ê²½ë˜ì—ˆëŠ”ì§€ íŒë‹¨í•˜ëŠ” ë° ì‚¬ìš©
2. ë¶ˆí•„ìš”í•œ ë³µì œ ë°©ì§€: ê°™ì€ í”„ë ˆì„ ë‚´ì—ì„œ ë™ì¼í•œ ì•¡í„°ì— ëŒ€í•´ ì—¬ëŸ¬ ë²ˆì˜ `CallPreReplication()`ì´ í˜¸ì¶œë˜ëŠ” ê²ƒì„ ë°©ì§€
3. ë³µì œ ìµœì í™”: 'unchanged'ë¡œ í‘œì‹œëœ ì†ì„±ë“¤ì„ ë¬´íš¨í™”í•˜ì—¬ ìƒˆë¡œìš´ ë³µì œ ì‚¬ì´í´ì—ì„œ ë‹¤ì‹œ ê²€ì‚¬
* íŠ¹íˆ ë©€í‹°ìºìŠ¤íŠ¸ RPCê°€ í˜¸ì¶œë  ë•Œ, ì—¬ëŸ¬ ë²ˆì˜ PreReplicationê³¼ ì†ì„± ë¹„êµê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ RemoteFunctionFlagsì— ReplicatedActor í”Œë˜ê·¸ë¥¼ ì„¤ì •í•˜ì—¬ ê°™ì€ í”„ë ˆì„ ë‚´ì—ì„œ ì¤‘ë³µ ì²˜ë¦¬ë¥¼ ë°©ì§€
* ReplicationFrameì´ ì¦ê°€í•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ë³µì œ ì‚¬ì´í´ì´ ì‹œì‘ë˜ë©°, ì´ëŠ” ë„¤íŠ¸ì›Œí¬ ìµœì í™”ì— ì¤‘ìš”í•œ ì—­í• 

```cpp
// ì†ì„± ë³€ê²½ ì¶”ì ì„ ìœ„í•œ ì˜ˆì‹œ ì½”ë“œ
void FRepLayout::CompareProperties(
    const uint8* RESTRICT Data, 
    const uint8* RESTRICT Defaults,
    UObject* Owner,
    UNetConnection* Connection,
    uint32 CompareFlags) const
{
    // í˜„ì¬ ë³µì œ í”„ë ˆì„ ê°€ì ¸ì˜¤ê¸°
    const uint32 CurRepFrame = Connection->Driver->ReplicationFrame;
    
    // ê° ì†ì„±ì— ëŒ€í•´ ë°˜ë³µ
    for (int32 i = 0; i < RepProperties.Num(); i++)
    {
        const FRepProperty& Property = RepProperties[i];
        
        // ì´ì „ í”„ë ˆì„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬ëœ ì†ì„±ì¸ì§€ í™•ì¸
        if (Property.LastCompareFrame == CurRepFrame)
        {
            // ì´ë¯¸ ì´ í”„ë ˆì„ì—ì„œ ë¹„êµë¨, ê±´ë„ˆë›°ê¸°
            continue;
        }
        
        // í˜„ì¬ í”„ë ˆì„ ë²ˆí˜¸ ê¸°ë¡
        Property.LastCompareFrame = CurRepFrame;
        
        // ì†ì„± ê°’ ë¹„êµ ë° ë³€ê²½ ê°ì§€
        if (!Property.Identical(Data, Defaults))
        {
            // ë³€ê²½ëœ ì†ì„± í‘œì‹œ
            Property.MarkAsChanged();
        }
    }
}

// RPC ì²˜ë¦¬ ì¤‘ ReplicationFrame ì¦ê°€ ì˜ˆì‹œ
void UNetDriver::ProcessRemoteFunctionForChannel(UActorChannel* Channel, UFunction* Function, void* Params)
{
    EProcessRemoteFunctionFlags RemoteFunctionFlags = EProcessRemoteFunctionFlags::None;
    
    // ì´ RPC í˜¸ì¶œì—ì„œ ì•„ì§ ì•¡í„°ê°€ ë³µì œë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
    if (!EnumHasAnyFlags(RemoteFunctionFlags, EProcessRemoteFunctionFlags::ReplicatedActor))
    {
        // ë³µì œ í”„ë ˆì„ ì¦ê°€ë¡œ ëª¨ë“  'unchanged' ì†ì„± ë¬´íš¨í™”
        ReplicationFrame++;
        
        // ì•¡í„°ì˜ PreReplication í˜¸ì¶œ
        Channel->GetActor()->CallPreReplication(this);
        
        // ì´ RPC ì²˜ë¦¬ ì¤‘ì— ì•¡í„°ê°€ ë³µì œë˜ì—ˆìŒì„ í‘œì‹œ
        RemoteFunctionFlags |= EProcessRemoteFunctionFlags::ReplicatedActor;
        
        // ì•¡í„° ë³µì œ ìˆ˜í–‰
        Channel->ReplicateActor();
    }
    
    // RPC ì²˜ë¦¬ ê³„ì†...
}

// ì•¡í„°ì˜ PreReplication ë©”ì„œë“œ ì˜ˆì‹œ
void AActor::CallPreReplication(UNetDriver* NetDriver)
{
    // ë§ˆì§€ë§‰ ë³µì œ í”„ë ˆì„ í™•ì¸
    if (LastReplicationFrame != NetDriver->ReplicationFrame)
    {
        // ìƒˆ í”„ë ˆì„ì—ì„œ ì²˜ìŒ í˜¸ì¶œë¨
        LastReplicationFrame = NetDriver->ReplicationFrame;
        
        // ë³µì œ ì¤€ë¹„ ì‘ì—… ìˆ˜í–‰
        PreReplication(*NetDriver->RepPropertyConditionMap);
        
        // ì»´í¬ë„ŒíŠ¸ ë³µì œ ì¤€ë¹„
        for (UActorComponent* Component : ReplicatedComponents)
        {
            Component->PreReplication(*NetDriver->RepPropertyConditionMap);
        }
    }
    // ê°™ì€ í”„ë ˆì„ì—ì„œ ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
}

// ê°•ì œ ë„¤íŠ¸ì›Œí¬ ì—…ë°ì´íŠ¸ ì˜ˆì‹œ
void AActor::ForceNetUpdate()
{
    if (NetDriverName != NAME_None && GetNetDriver())
    {
        GetNetDriver()->ForceNetUpdate(this);
    }
}

// NetDriverì—ì„œ ê°•ì œ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
void UNetDriver::ForceNetUpdate(AActor* Actor)
{
    if (Actor && Actor->GetNetDriverName() == NetDriverName)
    {
        FNetworkObjectInfo* NetActor = GetNetworkObjectList().FindOrAdd(Actor, this);
        if (NetActor)
        {
            // ë‹¤ìŒ ì—…ë°ì´íŠ¸ ì‹œê°„ì„ í˜„ì¬ë¡œ ì„¤ì •í•˜ì—¬ ì¦‰ì‹œ ë³µì œë˜ë„ë¡ í•¨
            NetActor->NextUpdateTime = GetElapsedTime();
            
            // ë³µì œ í”„ë ˆì„ ì¦ê°€ë¡œ ì†ì„± ë³€ê²½ ê°ì§€ ê°•ì œí™”
            ReplicationFrame++;
        }
    }
}
```

---

* ë‹¤ì‹œ ëŒì•„ê°€ì„œ `ServerReplicateActors`

```cpp
int32 NetDriver::ServerReplicateActors(float DeltaSeconds)
{
    // ...

    AWorldSettings* WorldSettings = World->GetWorldSettings();

    bool bCPUSaturated = false;
    float ServerTickTime = GEngine->GetMaxTickRate(DeltaSeconds);
    if (ServerTickTime == 0.f)
    {
        ServerTickTime = DeltaSeconds;
    }
    else
    {
        ServerTickTime = 1.0f / ServerTickTime;
        bCPUSaturated = DeltaSeconds > 1.2f * ServerTickTime;
    }

    // ConsiderListë¼ëŠ”ê±¸ ê´€ë¦¬í•˜ëŠ”êµ¬ë‚˜
    TArray<FNetworkObjectInfo*> ConsiderList;
    ConsiderList.Reserve(GetNetworkObjectList().GetActiveObjects().Num());

    ServerReplicateActors_BuildConsiderList(ConsiderList, ServerTickTime);

    FMemMark Mark(FMemStack::Get());

    for (int32 i = 0; i < ClientConnections.Num(); ++i)
    {
        UNetConnection* Connection = ClientConnections[i];

        if (i >= NumClientsToTick)
        {
            for (int32 ConsiderIdx = 0; ConsiderIdx < ConsiderList.Num(); ConsiderIdx++)
            {
                AActor* Actor = ConsiderList[ConsiderIdx]->Actor;

                if (Actor != NULL && !ConsiderList[ConsiderIdx]->bPendingNetUpdate)
                {
                    UActorChannel* Channel = Connection->FindActorChannelRef(ConsiderList[ConsiderIdx]->WeakActor);

                    if (Channel != NULL && Channel->LastUpdateTime < ConsiderList[ConsiderIdx]->LastNetUpdateTimestamp)
                    {
                        ConsiderList[ConsiderIdx]->bPendingNetUpdate = true;
                    }
                }
            }

            Connection->Timesensitive = false;
        }
        else if (Connection->ViewTarget)
        {
            TArray<FNetViewer>& ConnectionViewers = WorldSettings->ReplicationViewers;

            ConnectionViewers.Reset();
            new (ConnectionViewers) FNetViewer(Connection, DeltaSeconds);
            
            if (Connection->PlayerController)
            {
                Connection->PlayerController->SendClientAdjustment();
            }

            FMemMark RelevantActorMark(FMemStack::Get());
            {
                FActorPriority* PriorityList = NULL;
                FActorPriority** PriorityActors = NULL;

                const int32 FinalSortedCount = ServerReplicateActors_PrioritizeActors(Connection, ConnectionViewers, ConsiderList, bCPUSaturated, PriorityList, PriorityActors);
            
                TInterval<int32> ActorsIndexRange(0, FinalSortedCount);
                const int32 LastProcessedActor = ServerReplicateActors_ProcessPrioritizedActorsRange(Connection, ConnectionViewers, PriorityActors, ActorsIndexRange, Updated);
            
                ServerReplicateActors_MarkRelevantActors(Connection, ConnectionViewers, LastProcessedActor, FinalSortedCount, PriorityActors);
            }

            RelevantActorMark.Pop();

            ConnectionViewers.Reset();

            Connection->LastProcessedFrame = ReplicationFrame;
        }

        // if (i >= NumClientsToTick) í™•ì¸í•˜ê¸°
    }

    if (NumClientsToTick < ClientConnections.Num())
    {
        int32 NumConnectionsToMove = NumClientsToTick;
        while (NumConnectionsToMove > 0)
        {
            UNetConnection *Connection = ClientConnections[0];
            ClientConnections.RemoveAt(0,1);
            ClientConnections.Add(Connection);
            NumConnectionsToMove--;
        }
    }
    Mark.Pop();

    return Updated;
}
```

---

## UNetDriver, UNetConnection, UChannel ê´€ê³„

* UNetDriver
    * `UWorld`ì— ì˜í•´ ê´€ë¦¬ ë¨ `NetDriver = GEngine->CreateNetDriver(this, NAME_GameNetDriver);`
    * ë„¤íŠ¸ì›Œí¬ ì‹œìŠ¤í…œì˜ ìµœìƒìœ„ ê´€ë¦¬ì
    * ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ê°„ì˜ ëª¨ë“  ì—°ê²°ì„ ê´€ë¦¬
    * ì—¬ëŸ¬ UNetConnection ê°ì²´ë¥¼ í¬í•¨í•¨
    * íŒ¨í‚· ì†¡ìˆ˜ì‹ ì˜ ì „ì²´ íë¦„ì„ ì œì–´
* UNetConnection
    * `UNetDriver`ì— ì˜í•´ ê´€ë¦¬ ë¨ `UNetConnection* Connection = NewObject<UNetConnection>();`
    * ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ê°„ì˜ ë‹¨ì¼ ì—°ê²°ì„ ë‚˜íƒ€ëƒ„
    * ì—¬ëŸ¬ UChannel ê°ì²´ë¥¼ ê´€ë¦¬
    * íŒ¨í‚·ì˜ ì‹ ë¢°ì„± ë° ìˆœì„œ ë³´ì¥ ì²˜ë¦¬
    * ì—°ê²° ìƒíƒœ ê´€ë¦¬ (í•¸ë“œì…°ì´í¬, íƒ€ì„ì•„ì›ƒ ë“±)
* UChannel
    * íŠ¹ì • ìœ í˜•ì˜ ë°ì´í„° ì „ì†¡ì„ ìœ„í•œ ê°€ìƒ í†µë¡œ
    * ë‹¤ì–‘í•œ ì±„ë„ ìœ í˜•ì´ ì¡´ì¬ (UControlChannel, UActorChannel, UVoiceChannel ë“±)
    * ê° ì±„ë„ì€ íŠ¹ì • ëª©ì ì„ ìœ„í•œ ë°ì´í„° ì „ì†¡ì„ ë‹´ë‹¹
* FObjectReplicator
    * ê°ì²´ ë³µì œë¥¼ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤
    * ì†ì„± ë³€ê²½ ê°ì§€ ë° ë„¤íŠ¸ì›Œí¬ ì „ì†¡ ì²˜ë¦¬
    * UActorChannelê³¼ í•¨ê»˜ ì‘ë™í•˜ì—¬ ì•¡í„° ë³µì œ ìˆ˜í–‰

### UNetDriver, UNetConnection

```cpp
// ì„œë²„ ì¸¡ ë„¤íŠ¸ì›Œí¬ ì´ˆê¸°í™”
void AMyGameMode::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
{
    Super::InitGame(MapName, Options, ErrorMessage);
    
    // NetDriver ì ‘ê·¼
    UNetDriver* NetDriver = GetNetDriver();
    if (NetDriver)
    {
        // NetDriver ì„¤ì •
        NetDriver->MaxNetTickRate = 120;
    }
}

// í´ë¼ì´ì–¸íŠ¸ê°€ ì„œë²„ì— ì—°ê²°ë  ë•Œ (ì„œë²„ ì¸¡)
void UNetDriver::AddClientConnection(UNetConnection* NewConnection)
{
    // ìƒˆ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¶”ê°€
    ClientConnections.Add(NewConnection);
    
    // ì œì–´ ì±„ë„ ìƒì„±
    UControlChannel* ControlChannel = (UControlChannel*)NewConnection->CreateChannel(CHANNEL_Control, true);
    if (ControlChannel)
    {
        ControlChannel->SetChannelActor(nullptr);
    }
}
```

### UNetConnection, UChannel

```cpp
// ì•¡í„° ì±„ë„ ìƒì„± (ì„œë²„ ì¸¡)
UActorChannel* UNetConnection::CreateActorChannelForActor(AActor* Actor)
{
    // ìƒˆ ì•¡í„° ì±„ë„ ìƒì„±
    UActorChannel* Channel = (UActorChannel*)CreateChannel(CHANNEL_Actor, true);
    if (Channel)
    {
        // ì±„ë„ì— ì•¡í„° ì„¤ì •
        Channel->SetChannelActor(Actor);
        
        // ì•¡í„°ì™€ ì±„ë„ ë§¤í•‘
        AddActorChannel(Actor, Channel);
        
        // ì±„ë„ì„ í‹± ëª©ë¡ì— ì¶”ê°€
        ChannelsToTick.Add(Channel);
    }
    
    return Channel;
}
```

```cpp
// ì•¡í„° ë³µì œ (ì„œë²„ ì¸¡)
void UActorChannel::ReplicateActor()
{
    // ì•¡í„°ê°€ ìœ íš¨í•œì§€ í™•ì¸
    AActor* Actor = GetActor();
    if (!Actor)
    {
        return;
    }
    
    // ê°ì²´ ë³µì œê¸° ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒì„±
    if (!ActorReplicator.IsValid())
    {
        ActorReplicator = Connection->CreateReplicatorForNewActorChannel(Actor);
    }
    
    // ë³µì œ ìˆ˜í–‰
    if (ActorReplicator.IsValid())
    {
        ActorReplicator->RepLayout->ReplicateProperties(ActorReplicator.Get());
        
        // ì»´í¬ë„ŒíŠ¸ ë³µì œ
        for (UActorComponent* Component : Actor->GetReplicatedComponents())
        {
            TSharedPtr<FObjectReplicator> ComponentReplicator = FindOrCreateReplicator(Component);
            ComponentReplicator->RepLayout->ReplicateProperties(ComponentReplicator.Get());
        }
    }
}
```

```cpp
// íŒ¨í‚· ì „ì†¡ (UNetConnection::FlushNet ê°„ì†Œí™” ë²„ì „)
void UNetConnection::FlushNet()
{
    // íŒ¨í‚· í—¤ë” ì‘ì„±
    WritePacketHeader(SendBuffer);
    
    // íŒ¨í‚· ì •ë³´ ì‘ì„±
    WriteFinalPacketInfo(SendBuffer, FPlatformTime::Seconds());
    
    // íŒ¨í‚· ì¢…ë£Œ ë¹„íŠ¸ ì‘ì„±
    SendBuffer.WriteBit(1);
    
    // íŒ¨í‚· ì „ì†¡
    LowLevelSend(SendBuffer.GetData(), SendBuffer.GetNumBits(), FOutPacketTraits());
    
    // ì‹œí€€ìŠ¤ ë²ˆí˜¸ ì¦ê°€
    PacketNotify.CommitAndIncrementOutSeq();
    OutPacketId++;
    
    // ë²„í¼ ì´ˆê¸°í™”
    InitSendBuffer();
}

// íŒ¨í‚· ìˆ˜ì‹  (ê°„ì†Œí™” ë²„ì „)
void UNetConnection::ReceivedRawPacket(uint8* Data, int32 Count)
{
    // íŒ¨í‚· í•¸ë“¤ëŸ¬ ì²˜ë¦¬
    if (Handler.IsValid())
    {
        const ProcessedPacket ProcessedData = Handler->Incoming(Data, Count);
        Data = ProcessedData.Data;
        Count = ProcessedData.Count;
    }
    
    // íŒ¨í‚· ì²˜ë¦¬
    if (Count > 0)
    {
        FBitReader Reader(Data, Count * 8);
        
        // ë„¤íŠ¸ì›Œí¬ ë²„ì „ ì„¤ì •
        SetNetVersionsOnArchive(Reader);
        
        // íŒ¨í‚· ì²˜ë¦¬
        ReceivedPacket(Reader);
    }
}
```

---

```cpp
void ServerReplicateActors_BuildConsiderList(TArray<FNetworkObjectInfo*>& OutConsiderList, const float ServerTickTime)
{
    int32 NumInitiallyDormant = 0;

    const bool bUseAdaptiveNetFrequency = IsAdaptiveNetUpdateFrequencyEnabled();

    TArray<AActor*> ActorsToRemove;

    for (const TSharedPtr<FNetworkObjectInfo>& ObjectInfo : GetNetworkObjectList().GetActiveObjects())
    {
        FNetworkObjectInfo* ActorInfo = ObjectInfo.Get();
        if (!ActorInfo->bPendingNetUpdate && World->TimeSeconds <= ActorInfo->NextUpdateTime)
        {
            continue;
        }

        AActor* Actor = ActorInfo->Actor;

        if (Actor->GetRemoteRole() == ROLE_None)
        {
            ActorsToRemove.Add(Actor);
            continue;
        }
             
        if (ActorInfo->LastNetReplicateTime == 0)
        {
            ActorInfo->LastNetReplicateTime = World->Timeseconds;
        }

        const float ScaleDownStartTime = 2.0f;
        const float ScaleDownTimeRange = 5.0f;
        const float LastReplicateDelta = World->Timeseconds - ActorInfo->LastNetReplicateTime;
        if (LastReplicateDelta > ScaleDownStartTime)
        {
            //...
        }
    
        if (!ActorInfo->bPendingNetUpdate)
        {
            const float NextUpdateDelta = 1.0f / Actor->NetUpdateFreuqnecy;

            ActorInfo->NextUpdateTime = World->TimeSeconds + NextUpdateDelta + (UpdateDelayRandomStream.FRand() * ServerTickTime);

            ActorInfo->LastNetUpdateTimestamp = ElapsedTime;
        }

        ActorInfo->bPendingNetUpdate = false;

        OutConsiderList.Add(ActorInfo);

        // ì´ë ‡ê²Œ Replication ì²˜ë¦¬
        Actor->CallPreReplication(this);
    }

    for (Actor* Actor : ActorsToRemove)
    {
        RemoveNetworkActor(Actor);
    }
}
```