---
layout: default
title: "(03. PrimitiveScene μ„¤λ… λ° κ΄€λ¦¬ λ°©λ²• μ •λ¦¬λ¦¬)"
parent: "(UE Code-Review π¤–)"
has_children: true
nav_order: 1
permalink: docs/review/ue/ver4/03/PrimitiveScene
---

## ν”„λ¦¬λ―Έν‹°λΈ μ”¬(Primitive Scene)μ΄λ€?

* μ–Έλ¦¬μ–Ό μ—”μ§„μ—μ„ **ν”„λ¦¬λ―Έν‹°λΈ μ”¬**μ€ 3D κ³µκ°„μ— λ λ”λ§λλ” κΈ°λ³Έ κ°μ²΄λ“¤κ³Ό κ·Έ μ •λ³΄λ¥Ό κ΄€λ¦¬ν•λ” μ‹μ¤ν…

* ν”„λ¦¬λ―Έν‹°λΈ μ”¬μ κµ¬μ„± μ”μ†
* ν”„λ¦¬λ―Έν‹°λΈ(Primitive):
    * λ λ”λ§ κ°€λ¥ν• κΈ°λ³Έ κ°μ²΄λ¥Ό μλ―Έ
    * μ–Έλ¦¬μ–Ό μ—”μ§„μ—μ„λ” UPrimitiveComponentμ μΈμ¤ν„΄μ¤λ΅ ν‘ν„
    * μ: μ¤νƒν‹± λ©”μ‹, μ¤μΌλ νƒ λ©”μ‹, νν‹°ν΄ μ‹μ¤ν…, λΌμ΄νΈ λ“±
* ν”„λ¦¬λ―Έν‹°λΈ μ”¬ ν”„λ΅μ‹(Primitive Scene Proxy):
    * κ²μ„ μ¤λ λ“μ UPrimitiveComponentμ— λ€μ‘ν•λ” λ λ”λ§ μ¤λ λ“ κ°μ²΄
    * FPrimitiveSceneProxy ν΄λμ¤λ΅ κµ¬ν„
    * μ‹¤μ  λ λ”λ§μ— ν•„μ”ν• λ°μ΄ν„°λ¥Ό ν¬ν•¨
* νƒ€μ…λ³„λ΅ λ‹¤μ–‘ν• νμƒ ν΄λμ¤κ°€ μμµλ‹λ‹¤:
    * FStaticMeshSceneProxy
    * FSkeletalMeshSceneProxy
    * κΈ°νƒ€ λ‹¤μ–‘ν• ν”„λ΅μ‹ νƒ€μ…λ“¤
* ν”„λ¦¬λ―Έν‹°λΈ μ”¬ μ •λ³΄(Primitive Scene Info):
    * FPrimitiveSceneInfo ν΄λμ¤λ΅ κµ¬ν„
    * ν”„λ¦¬λ―Έν‹°λΈ μ»΄ν¬λ„νΈμ™€ κ·Έ ν”„λ΅μ‹μ— λ€ν• μ°Έμ΅°λ¥Ό ν¬ν•¨
    * μ”¬ λ‚΄μ—μ„ ν”„λ¦¬λ―Έν‹°λΈμ μƒνƒμ™€ μ„μΉλ¥Ό μ¶”μ 
* ν”„λ¦¬λ―Έν‹°λΈ μ”¬μ μ—­ν• 
* λ λ”λ§ λ°μ΄ν„° κ΄€λ¦¬:
    * κ²μ„ μ¤λ λ“μ™€ λ λ”λ§ μ¤λ λ“ κ°„μ λ°μ΄ν„° λ™κΈ°ν™”λ¥Ό μ²λ¦¬
    * ν”„λ¦¬λ―Έν‹°λΈμ λ³€ν™(μ„μΉ, νμ „, ν¬κΈ°), κ²½κ³„ μƒμ, λ¨Έν‹°λ¦¬μ–Ό λ“±μ μ •λ³΄λ¥Ό κ΄€λ¦¬
* λ λ”λ§ μµμ ν™”:
    * κ°™μ€ νƒ€μ…μ ν”„λ¦¬λ―Έν‹°λΈλ“¤μ„ κ·Έλ£Ήν™”ν•μ—¬ λ°°μΉ μ²λ¦¬
    * μ»¬λ§(ν™”λ©΄μ— λ³΄μ΄μ§€ μ•λ” κ°μ²΄ μ μ™Έ)μ„ μν–‰
    * λ λ²¨ μ¤λΈ λ””ν…μΌ(LOD) μ‹μ¤ν…μ„ μ§€μ›
* λ λ”λ§ νμ΄ν”„λΌμΈ μ§€μ›:
    * μ‰μ΄λ”μ— ν•„μ”ν• λ°μ΄ν„°λ¥Ό μ κ³µ
    * κ·Έλ¦Όμ, λΌμ΄ν…, ν¬μ¤νΈ ν”„λ΅μ„Έμ‹± λ“±μ ν¨κ³Όλ¥Ό μ„ν• μ •λ³΄λ¥Ό μ κ³µ
* ν”„λ¦¬λ―Έν‹°λΈ μ”¬μ κµ¬μ΅°

```
Primitives: [SceneInfo1, SceneInfo2, SceneInfo3, ...]
PrimitiveTransforms: [Transform1, Transform2, Transform3, ...]
PrimitiveSceneProxies: [Proxy1, Proxy2, Proxy3, ...]
PrimitiveBounds: [Bounds1, Bounds2, Bounds3, ...]
```

* μ–Έλ¦¬μ–Ό μ—”μ§„μ FScene ν΄λμ¤λ” ν”„λ¦¬λ―Έν‹°λΈ μ”¬ μ •λ³΄λ¥Ό κµ¬μ΅°μ  λ°°μ—΄(SOA, Structure of Arrays) ν•νƒλ΅ κ΄€λ¦¬

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/03.00_01.png"/>
</p>

```cpp
// λ€λµ μ΄λ°μ‹
// FScene::AddPrimitive() λ©”μ„λ“ μμ‹
void FScene::AddPrimitive(UPrimitiveComponent* Primitive)
{
    // μ΄λ―Έ μ²λ¦¬ μ¤‘μΈμ§€ ν™•μΈ
    if (Primitive->SceneProxy && !Primitive->IsRegistered())
    {
        // μƒ FPrimitiveSceneInfo μƒμ„±
        FPrimitiveSceneInfo* PrimitiveSceneInfo = new FPrimitiveSceneInfo(Primitive, this);
        
        // λ λ”λ§ μ¤λ λ“μ— μ¶”κ°€ λ…λ Ή μ „λ‹¬
        FCreateRenderThreadParameters Parameters;
        Parameters.PrimitiveSceneInfo = PrimitiveSceneInfo;
        Parameters.PrimitiveSceneProxy = Primitive->SceneProxy;
        Parameters.RenderMatrix = Primitive->GetRenderMatrix();
        Parameters.WorldBounds = Primitive->Bounds;
        Parameters.LocalBounds = Primitive->CalcBounds(Primitive->GetLocalToWorld());
        Parameters.AttachmentRootPosition = Primitive->GetAttachmentRootPosition();
        
        // λ λ”λ§ μ¤λ λ“μ—μ„ μ‹¤ν–‰λ  μ‘μ—… λ“±λ΅
        ENQUEUE_RENDER_COMMAND(AddPrimitiveCommand)(
            [this, Parameters](FRHICommandListImmediate& RHICmdList)
            {
                // λ λ”λ§ μ¤λ λ“μ—μ„ ν”„λ¦¬λ―Έν‹°λΈ μ¶”κ°€
                AddPrimitiveSceneInfo_RenderThread(Parameters.PrimitiveSceneInfo, Parameters.PreviousTransform);
            }
        );
    }
}
```

---

## ν”„λ¦¬λ―Έν‹°λΈ μ”¬ μ •λ ¬λ°©λ²•

* `FScene::UpdateAllPrimitiveSceneInfos` ν•¨μκ°€ μ–΄λ–»κ² μ”¬μ κµ¬μ΅°μ  λ°°μ—΄(SOA, Structure of Arrays)μ„ μ μ§€ν•λ©΄μ„ μƒλ΅μ΄ ν”„λ¦¬λ―Έν‹°λΈλ¥Ό μ¶”κ°€ν•κ³  μ •λ ¬ν• κΉ?

* μ£Όμ” κ°λ… μ„¤λ…
    * ν”„λ¦¬λ―Έν‹°λΈ μ •λ ¬: μ”¬μ— μ¶”κ°€λ ν”„λ¦¬λ―Έν‹°λΈλ“¤μ€ GetTypeHash()λ¥Ό κΈ°μ¤€μΌλ΅ μ •λ ¬ μ΄λ” κ°™μ€ νƒ€μ…μ ν”„λ¦¬λ―Έν‹°λΈλ“¤μ΄ λ©”λ¨λ¦¬μ—μ„ μ—°μ†μ μΌλ΅ μ„μΉν•λ„λ΅ ν•λ‹¤.
    * νƒ€μ… μ¤ν”„μ…‹ ν…μ΄λΈ”: κ° ν”„λ¦¬λ―Έν‹°λΈ νƒ€μ…μ μ‹μ‘ μΈλ±μ¤λ¥Ό μ¶”μ ν•λ” ν…μ΄λΈ”. μ΄λ¥Ό ν†µν•΄ νΉμ • νƒ€μ…μ ν”„λ¦¬λ―Έν‹°λΈκ°€ λ°°μ—΄μ μ–΄λ””μ„λ¶€ν„° μ‹μ‘ν•λ”μ§€ μ• μ μλ‹¤.
* SOA(Structure of Arrays): λ°μ΄ν„°λ¥Ό μ—¬λ¬ κ°μ λ³‘λ ¬ λ°°μ—΄λ΅ κ΄€λ¦¬ν•λ” λ°©μ‹. μ΄ μ½”λ“μ—μ„λ” Primitives, PrimitiveTransforms, PrimitiveSceneProxies, PrimitiveBounds λ“±μ λ°°μ—΄μ΄ μλ‹¤.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/03.00_02.png"/>
</p>

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/unreal_review_ver4/03.00_03.png"/>
</p>

```cpp
// FScene::UpdateAllPrimitiveSceneInfos ν•¨μ μ •λ¦¬
void FScene::UpdateAllPrimitiveSceneInfos(FRDGBuilder& GraphBuilder, EUpdateAllPrimitiveSceneInfosAsyncOps AsyncOps)
{
    // 1. μƒλ΅ μ¶”κ°€λ ν”„λ¦¬λ―Έν‹°λΈ μ²λ¦¬
    TArray<FPrimitiveSceneInfo*> AddedLocalPrimitiveSceneInfos;
    if (AddedPrimitiveSceneInfos.Num() > 0)
    {
        // 1.1 λ΅μ»¬ λ°°μ—΄λ΅ λ³µμ‚¬
        AddedLocalPrimitiveSceneInfos.Reserve(AddedPrimitiveSceneInfos.Num());
        for (FPrimitiveSceneInfo* SceneInfo : AddedPrimitiveSceneInfos)
        {
            AddedLocalPrimitiveSceneInfos.Add(SceneInfo);
        }
        AddedPrimitiveSceneInfos.Reset();
        
        // 1.2 νƒ€μ… ν•΄μ‹λ΅ μ •λ ¬ (κ°™μ€ νƒ€μ…μ ν”„λ¦¬λ―Έν‹°λΈκ°€ μ—°μ†μ μΌλ΅ μ„μΉν•λ„λ΅)
        AddedLocalPrimitiveSceneInfos.Sort(FPrimitiveArraySortKey());
        
        // 1.3 μ”¬μ SOA λ°°μ—΄ ν™•μ¥
        int32 NumToAdd = AddedLocalPrimitiveSceneInfos.Num();
        Primitives.Reserve(Primitives.Num() + NumToAdd);
        PrimitiveTransforms.Reserve(PrimitiveTransforms.Num() + NumToAdd);
        PrimitiveSceneProxies.Reserve(PrimitiveSceneProxies.Num() + NumToAdd);
        PrimitiveBounds.Reserve(PrimitiveBounds.Num() + NumToAdd);
        
        // 1.4 μƒ ν”„λ¦¬λ―Έν‹°λΈλ¥Ό λ°°μ—΄ λμ— μ¶”κ°€
        int32 FirstNewPrimitiveIndex = Primitives.Num();
        for (FPrimitiveSceneInfo* SceneInfo : AddedLocalPrimitiveSceneInfos)
        {
            Primitives.Add(SceneInfo);
            PrimitiveTransforms.Add(SceneInfo->Proxy->GetLocalToWorld());
            PrimitiveSceneProxies.Add(SceneInfo->Proxy);
            PrimitiveBounds.Add(SceneInfo->Proxy->GetBounds());
            
            // μΈλ±μ¤ μ—…λ°μ΄νΈ
            SceneInfo->PackedIndex = Primitives.Num() - 1;
        }
        
        // 1.5 νƒ€μ…λ³„λ΅ μ •λ ¬ (TypeOffsetTable μ‚¬μ©)
        for (int32 InfoIndex = AddedLocalPrimitiveSceneInfos.Num() - 1; InfoIndex >= 0; --InfoIndex)
        {
            FPrimitiveSceneInfo* SceneInfo = AddedLocalPrimitiveSceneInfos[InfoIndex];
            SIZE_T TypeHash = SceneInfo->Proxy->GetTypeHash();
            
            // νƒ€μ… μ¤ν”„μ…‹ ν…μ΄λΈ”μ—μ„ ν•΄λ‹Ή νƒ€μ… μ°ΎκΈ°
            int32 TypeIndex = -1;
            for (int32 i = 0; i < TypeOffsetTable.Num(); ++i)
            {
                if (TypeOffsetTable[i].PrimitiveSceneProxyType == TypeHash)
                {
                    TypeIndex = i;
                    break;
                }
            }
            
            // νƒ€μ…μ΄ μ—†μΌλ©΄ μƒλ΅ μ¶”κ°€
            if (TypeIndex == -1)
            {
                FTypeOffsetTableEntry NewEntry;
                NewEntry.PrimitiveSceneProxyType = TypeHash;
                NewEntry.Offset = FirstNewPrimitiveIndex + InfoIndex;
                TypeOffsetTable.Add(NewEntry);
                continue;
            }
            
            // νƒ€μ…μ΄ μμΌλ©΄ ν•΄λ‹Ή νƒ€μ…μ μμ—­μΌλ΅ μ¤μ™‘
            int32 SourceIndex = FirstNewPrimitiveIndex + InfoIndex;
            int32 DestIndex = TypeOffsetTable[TypeIndex].Offset++;
            
            if (SourceIndex != DestIndex)
            {
                // SOAμ λ¨λ“  λ°°μ—΄μ—μ„ μ¤μ™‘ μν–‰
                Swap(Primitives[SourceIndex], Primitives[DestIndex]);
                Swap(PrimitiveTransforms[SourceIndex], PrimitiveTransforms[DestIndex]);
                Swap(PrimitiveSceneProxies[SourceIndex], PrimitiveSceneProxies[DestIndex]);
                Swap(PrimitiveBounds[SourceIndex], PrimitiveBounds[DestIndex]);
                
                // μΈλ±μ¤ μ—…λ°μ΄νΈ
                Primitives[SourceIndex]->PackedIndex = SourceIndex;
                Primitives[DestIndex]->PackedIndex = DestIndex;
            }
            
            // μ΄ν›„ νƒ€μ…λ“¤μ μ¤ν”„μ…‹ μ—…λ°μ΄νΈ
            for (int32 i = TypeIndex + 1; i < TypeOffsetTable.Num(); ++i)
            {
                TypeOffsetTable[i].Offset++;
            }
        }
    }
    
    // 2. μ΄κΈ°ν™” λ‹¨κ³„λ³„ SceneInfo λ¶„λ¥
    TArray<FPrimitiveSceneInfo*, SceneRenderingAllocator>& SceneInfosWithAddToScene = 
        *GraphBuilder.AllocateObject<TArray<FPrimitiveSceneInfo*, SceneRenderingAllocator>>();
    TArray<FPrimitiveSceneInfo*, SceneRenderingAllocator>& SceneInfosWithStaticDrawListUpdate = 
        *GraphBuilder.AllocateObject<TArray<FPrimitiveSceneInfo*, SceneRenderingAllocator>>();
    
    // 2.1 ν ν•¨μ μ •μ
    const auto QueueAddToScene = [&](FPrimitiveSceneInfo* SceneInfo) -> bool
    {
        if (!SceneInfo->bPendingAddToScene)
        {
            SceneInfo->bPendingAddToScene = true;
            SceneInfosWithAddToScene.Push(SceneInfo);
            return true;
        }
        return false;
    };
    
    const auto QueueAddStaticMeshes = [&](FPrimitiveSceneInfo* SceneInfo)
    {
        if (!SceneInfo->bPendingAddStaticMeshes)
        {
            SceneInfo->bPendingAddStaticMeshes = 1;
            SceneInfosWithStaticDrawListUpdate.Push(SceneInfo);
            PrimitivesNeedingStaticMeshUpdate[SceneInfo->PackedIndex] = false;
            return true;
        }
        return false;
    };
    
    // 2.2 μƒλ΅ μ¶”κ°€λ ν”„λ¦¬λ―Έν‹°λΈ νμ— μ¶”κ°€
    for (FPrimitiveSceneInfo* SceneInfo : AddedLocalPrimitiveSceneInfos)
    {
        QueueAddToScene(SceneInfo);
        QueueAddStaticMeshes(SceneInfo);
    }
    
    // 3. λ³€ν™μ΄ μ—…λ°μ΄νΈλ ν”„λ¦¬λ―Έν‹°λΈ μ²λ¦¬
    if (UpdatedTransforms.Num() > 0)
    {
        for (const auto& UpdatedTransform : UpdatedTransforms)
        {
            FPrimitiveSceneProxy* SceneProxy = UpdatedTransform.Key;
            const FUpdateTransformCommand& Command = UpdatedTransform.Value;
            
            // ν”„λ΅μ‹μ λ³€ν™ μ—…λ°μ΄νΈ
            SceneProxy->UpdateTransform(Command.LocalToWorld, Command.WorldBounds, Command.LocalBounds, Command.AttachmentRootPosition);
            
            // μ”¬μ SOA λ°°μ—΄ μ—…λ°μ΄νΈ
            int32 ProxyIndex = SceneProxy->GetPrimitiveSceneInfo()->PackedIndex;
            if (ProxyIndex >= 0 && ProxyIndex < Primitives.Num())
            {
                PrimitiveTransforms[ProxyIndex] = Command.LocalToWorld;
                PrimitiveBounds[ProxyIndex] = Command.WorldBounds;
            }
        }
        UpdatedTransforms.Reset();
    }
    
    // 4. μ”¬μ— ν”„λ¦¬λ―Έν‹°λΈ μ¶”κ°€ (AddToScene λ‹¨κ³„)
    if (SceneInfosWithAddToScene.Num() > 0)
    {
        FPrimitiveSceneInfo::AddToScene(this, SceneInfosWithAddToScene);
    }
    
    // 5. μ¤νƒν‹± λ©”μ‹ λ“λ΅μ° λ¦¬μ¤νΈ μ—…λ°μ΄νΈ (StaticDrawListUpdate λ‹¨κ³„)
    if (SceneInfosWithStaticDrawListUpdate.Num() > 0)
    {
        // μ¤νƒν‹± λ©”μ‹ μΊμ‹± λ° λ“λ΅μ° μ»¤λ§¨λ“ μƒμ„±
        for (FPrimitiveSceneInfo* SceneInfo : SceneInfosWithStaticDrawListUpdate)
        {
            SceneInfo->CacheMeshDrawCommands(GraphBuilder);
        }
    }
    
    // 6. λΉ„λ™κΈ° μ‘μ—… μ²λ¦¬ (ν•„μ”ν• κ²½μ°)
    if (AsyncOps != EUpdateAllPrimitiveSceneInfosAsyncOps::None)
    {
        // λΉ„λ™κΈ° μ‘μ—… μ„¤μ • λ° μ‹¤ν–‰
        // ...
    }
}
```