---
layout: default
title: "(17. FMemory)"
parent: "(UE Code-Review ğŸ¤–)"
has_children: true
nav_order: 2
permalink: docs/review/ue/ver4/17/FMemory
---

## FMemoryë€?

* FMemoryëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ì—ì„œ ì €ìˆ˜ì¤€ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ìœ„í•œ í•µì‹¬ í´ë˜ìŠ¤
* í”Œë«í¼ ë…ë¦½ì ì¸ ë©”ëª¨ë¦¬ í• ë‹¹, í•´ì œ, ë³µì‚¬, ë¹„êµ ë“±ì˜ ê¸°ëŠ¥ì„ ì œê³µ

```cpp
// ë©”ëª¨ë¦¬ í• ë‹¹ ì˜ˆì‹œ
void* Buffer = FMemory::Malloc(1024);
if (Buffer != nullptr)
{
    // ë©”ëª¨ë¦¬ 0ìœ¼ë¡œ ì´ˆê¸°í™”
    FMemory::Memzero(Buffer, 1024);
    
    // ë©”ëª¨ë¦¬ í•´ì œ
    FMemory::Free(Buffer);
    Buffer = nullptr;
}

// ë°°ì—´ í• ë‹¹ ë° ë³µì‚¬ ì˜ˆì‹œ
int32 SourceArray[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int32* DestArray = (int32*)FMemory::Malloc(sizeof(int32) * 10);

// ë©”ëª¨ë¦¬ ë³µì‚¬
FMemory::Memcpy(DestArray, SourceArray, sizeof(int32) * 10);

// ë©”ëª¨ë¦¬ ë¹„êµ
bool bIsEqual = FMemory::Memcmp(SourceArray, DestArray, sizeof(int32) * 10) == 0;

// ë©”ëª¨ë¦¬ í•´ì œ
FMemory::Free(DestArray);

// ë¬¸ìì—´ ì¡°ì‘ ì˜ˆì‹œ
FString SourceString = TEXT("Hello World");
TCHAR* Buffer = (TCHAR*)FMemory::Malloc(sizeof(TCHAR) * (SourceString.Len() + 1));

// ë¬¸ìì—´ ë³µì‚¬
FMemory::Memcpy(Buffer, *SourceString, sizeof(TCHAR) * (SourceString.Len() + 1));

// ë©”ëª¨ë¦¬ í•´ì œ
FMemory::Free(Buffer);

// ì¬í• ë‹¹ ì˜ˆì‹œ
void* InitialBuffer = FMemory::Malloc(512);
void* ReallocatedBuffer = FMemory::Realloc(InitialBuffer, 1024);
FMemory::Free(ReallocatedBuffer);
```

---

## std:: new, deleteê°€ ìˆëŠ”ë° ì™œ í•„ìš”í• ê¹Œ?

### std:: new, deleteì˜ í•œê³„

```cpp
// std::newëŠ” ë©”ëª¨ë¦¬ ë¶€ì¡± ì‹œ ì˜ˆì™¸ë¥¼ ë˜ì§
try {
    int* ptr = new int[1000000000];  // ë©”ëª¨ë¦¬ ë¶€ì¡± ì‹œ std::bad_alloc ì˜ˆì™¸
} catch (std::bad_alloc& e) {
    // ì˜ˆì™¸ ì²˜ë¦¬ í•„ìš”
}

// FMemoryëŠ” nullptr ë°˜í™˜ (ì˜ˆì™¸ ì—†ìŒ)
void* ptr = FMemory::Malloc(sizeof(int) * 1000000000);
if (ptr == nullptr) {
    // ê°„ë‹¨í•œ null ì²´í¬ë§Œ í•˜ë©´ ë¨
}
```

```cpp
// std::newëŠ” í”Œë«í¼ë³„ ì •ë ¬ì´ ì¼ê´€ë˜ì§€ ì•ŠìŒ
struct FVector4 {
    float x, y, z, w;  // SIMD ì—°ì‚°ì„ ìœ„í•´ 16ë°”ì´íŠ¸ ì •ë ¬ í•„ìš”
};

// ì´ë ‡ê²Œ í•˜ë©´ ì •ë ¬ì´ ë³´ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
FVector4* vectors = new FVector4[100];

// FMemoryëŠ” í”Œë«í¼ì— ë§ëŠ” ì •ë ¬ ë³´ì¥
FVector4* vectors = (FVector4*)FMemory::Malloc(sizeof(FVector4) * 100);
```

```cpp
// std::newë¡œ í• ë‹¹í•œ ë©”ëª¨ë¦¬ëŠ” ì¶”ì í•˜ê¸° ì–´ë ¤ì›€
class MyClass {
public:
    MyClass() {
        data = new int[1000];  // ì´ê±¸ ì–´ë–»ê²Œ ì¶”ì í•˜ì§€?
    }
    ~MyClass() {
        delete[] data;
    }
private:
    int* data;
};

// FMemoryëŠ” ëª¨ë“  í• ë‹¹ì„ ì¤‘ì•™ì—ì„œ ì¶”ì 
void* ptr = FMemory::Malloc(1000 * sizeof(int));
// ì–¸ë¦¬ì–¼ ì—ë””í„°ì—ì„œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŒ
```

```cpp
// PlayStation 5ì˜ ê²½ìš°
void* gpu_memory = FMemory::Malloc(size, 0, EMallocFlags::GPU);  // GPU ë©”ëª¨ë¦¬ í• ë‹¹
void* cpu_memory = FMemory::Malloc(size, 0, EMallocFlags::CPU);  // CPU ë©”ëª¨ë¦¬ í• ë‹¹

// std::newë¡œëŠ” ì´ëŸ° ì„¸ë°€í•œ ì œì–´ê°€ ë¶ˆê°€ëŠ¥
```

```cpp
// ì–¸ë¦¬ì–¼ì˜ ë©”ëª¨ë¦¬ í’€ë§ ì‹œìŠ¤í…œ
class FMyGameSystem {
    void Initialize() {
        // ë¯¸ë¦¬ í° ë©”ëª¨ë¦¬ ë¸”ë¡ í• ë‹¹
        MemoryPool = FMemory::Malloc(POOL_SIZE);
        
        // ê²Œì„ ì¤‘ì—ëŠ” ì´ í’€ì—ì„œ ë¹ ë¥´ê²Œ í• ë‹¹/í•´ì œ
        FastAllocator.Initialize(MemoryPool, POOL_SIZE);
    }
    
    void* QuickAlloc(size_t size) {
        return FastAllocator.Alloc(size);  // ë§¤ìš° ë¹ ë¦„
    }
};

// std::newëŠ” ë§¤ë²ˆ ì‹œìŠ¤í…œ í˜¸ì¶œ â†’ ëŠë¦¼
```

```cpp
// ì–¸ë¦¬ì–¼ì—ì„œëŠ” ë‘ ê°€ì§€ ë©”ëª¨ë¦¬ ì˜ì—­ì´ ìˆìŒ

// 1. GC ê´€ë¦¬ ì˜ì—­ (UObjectë“¤)
UCLASS()
class AMyActor : public AActor {
    // ìë™ìœ¼ë¡œ GCê°€ ê´€ë¦¬
};

// 2. ìˆ˜ë™ ê´€ë¦¬ ì˜ì—­ (ì„±ëŠ¥ í¬ë¦¬í‹°ì»¬í•œ ë¶€ë¶„)
struct FRenderData {
    float* vertices;
    int* indices;
};

FRenderData* data = (FRenderData*)FMemory::Malloc(sizeof(FRenderData));
// GCê°€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ â†’ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì„±ëŠ¥
```