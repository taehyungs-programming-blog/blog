---
layout: default
title: "(13. FObjectReplicator ì„¤ëª…)"
parent: "(UE Code-Review ğŸ¤–)"
has_children: true
nav_order: 2
permalink: docs/review/ue/ver4/13/FObjectReplicator
---


```cpp
virtual TSharedPtr<FObjectReplicator> CreateReplicatorForNewActorChannel(UObject* Object)
{
    // ìš”ë ‡ê²Œ ìƒì„±ë¨.
    TSharedPtr<FObjectReplicator> NewReplicator = MakeShareable(new FObjectReplicator());
    NewReplicator->InitWithObject(Object, this, true);
    return NewReplicator;
}
```

### FObjectReplicator ëª©ì 

* ê°ì²´ ì†ì„± ì¶”ì : ê°ì²´ì˜ ë³€ê²½ëœ ì†ì„±ì„ ì¶”ì 
* ì†ì„± ë³µì œ: ë³€ê²½ëœ ì†ì„±ì„ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ í´ë¼ì´ì–¸íŠ¸ì— ì „ì†¡
* RPC ì²˜ë¦¬: ì›ê²© í”„ë¡œì‹œì € í˜¸ì¶œ(RPC)ì„ ì²˜ë¦¬

```cpp
// FObjectReplicator ë‚´ë¶€ì—ì„œ ì†ì„± ë³€ê²½ ê°ì§€ ì˜ˆì‹œ
void FObjectReplicator::DetectChangedProperties()
{
    // ë³µì œ ê°€ëŠ¥í•œ ëª¨ë“  ì†ì„±ì„ ìˆœíšŒ
    for (int32 i = 0; i < RepLayout->GetNumProperties(); i++)
    {
        // ì†ì„±ì´ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸
        if (RepLayout->CompareProperties(i, (const uint8*)ObjectClass->GetDefaultObject(), (const uint8*)Object))
        {
            // ë³€ê²½ëœ ì†ì„±ì„ ë§ˆí‚¹
            ChangelistMgr->MarkPropertyDirty(i);
        }
    }
}
```

```cpp
// ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ë¡œ ì†ì„± ë³µì œ ì˜ˆì‹œ
bool FObjectReplicator::ReplicateProperties(FOutBunch& Bunch, FReplicationFlags RepFlags)
{
    bool WroteSomething = false;
    
    // ë³€ê²½ëœ ì†ì„±ì´ ìˆëŠ”ì§€ í™•ì¸
    if (ChangelistMgr->HasChanges())
    {
        // ë³€ê²½ëœ ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        TArray<uint16> ChangedProperties = ChangelistMgr->GetChangedProperties();
        
        // ê° ë³€ê²½ëœ ì†ì„±ì„ ë²ˆì¹˜ì— ê¸°ë¡
        for (uint16 PropertyIndex : ChangedProperties)
        {
            // ì†ì„± ê°’ì„ ë²ˆì¹˜ì— ì§ë ¬í™”
            RepLayout->SendProperty(PropertyIndex, (uint8*)Object, Bunch);
            WroteSomething = true;
        }
    }
    
    return WroteSomething;
}
```

```cpp
// í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ë¡œ RPC í˜¸ì¶œ ì˜ˆì‹œ
bool UPlayerController::ServerMove_Implementation(float TimeStamp, FVector_NetQuantize InAccel, FVector_NetQuantize ClientLoc)
{
    // RPC êµ¬í˜„ ë¡œì§
    Character->MoveCharacter(InAccel);
    
    // ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì˜ ìœ„ì¹˜ ê²€ì¦
    if (FVector::DistSquared(ClientLoc, Character->GetActorLocation()) > ToleranceSquared)
    {
        // í´ë¼ì´ì–¸íŠ¸ ìœ„ì¹˜ ë³´ì •
        ClientAdjustPosition(Character->GetActorLocation(), Character->GetActorRotation());
    }
    
    return true;
}

// ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ë¡œ RPC ì‘ë‹µ ì˜ˆì‹œ
void UPlayerController::ClientAdjustPosition_Implementation(FVector NewLocation, FRotator NewRotation)
{
    // í´ë¼ì´ì–¸íŠ¸ ì¸¡ êµ¬í˜„
    if (Character)
    {
        Character->SetActorLocationAndRotation(NewLocation, NewRotation);
    }
}
```

---

## FObjectReplicator::InitWithObject Initì€ ì–´ë–»ê²Œ í• ê¹Œ?

```cpp
void FObjectReplicator::InitWithObject(UObject* InObject, UNetConnection* InConnection, bool bUseDefaultState = true)
{
    SetObject(InObject);

    ObjectClass = InObject->GetClass();
    Connection = InConnection;
    RemoteFunctions = nullptr;
    bHasReplicatedProperties = false;
    bOpenAckCalled = false;
    RepState = nullptr;
    OwningChannel = nullptr;

    // FRepLayoutì˜ ì„¤ëª…ë„ í•„ìš”í•˜ë‹¤ (ì•„ë˜ ì°¸ê³ )
    RepLayout = Connection->Driver->GetObjectClassRepLayout(ObjectClass);

    uint8* Source = bUseDefaultState ? (uint8*)GetObject()->GetArchetype() : (uint8*)InObject;

    if ((Source == nullptr) && bUseDefaultState)
    {
        if (ObjectClass != nullptr)
        {
            Source = (uint8*)ObjectClass->GetDefaultObject();
        }
        else
        {
            Source = (uint8*)InObject;
        }
    }

    InitRecentProperties(Source);

    Connection->Driver->AllOwnedReplicators.Add(this);
}
```

### FRepLayout

* ì†ì„± ë§¤í•‘: í´ë˜ìŠ¤ì˜ ë³µì œ ê°€ëŠ¥í•œ ì†ì„±ë“¤ì„ ì¶”ì í•˜ê³  ê´€ë¦¬
* íš¨ìœ¨ì ì¸ ì§ë ¬í™”: ë³€ê²½ëœ ì†ì„±ë§Œ ë„¤íŠ¸ì›Œí¬ë¡œ ì „ì†¡í•˜ë„ë¡ ìµœì í™”
* ìƒíƒœ ì¶”ì : ê°ì²´ì˜ ë³µì œ ìƒíƒœë¥¼ ì¶”ì í•˜ì—¬ ë³€ê²½ëœ ë¶€ë¶„ë§Œ ì—…ë°ì´íŠ¸

```cpp
// 1. í”Œë ˆì´ì–´ ìºë¦­í„° í´ë˜ìŠ¤ ì •ì˜ ì˜ˆì‹œ
class ALyraCharacter : public ACharacter
{
    GENERATED_BODY()
    
public:
    // ë„¤íŠ¸ì›Œí¬ë¡œ ë³µì œë  ì†ì„±
    UPROPERTY(Replicated)
    float Health;
    
    UPROPERTY(Replicated)
    int32 AmmoCount;
    
    UPROPERTY(Replicated)
    bool bIsReloading;
    
    // GetLifetimeReplicatedProps í•¨ìˆ˜ êµ¬í˜„
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override
    {
        Super::GetLifetimeReplicatedProps(OutLifetimeProps);
        
        // ë³µì œí•  ì†ì„± ë“±ë¡
        DOREPLIFETIME(ALyraCharacter, Health);
        DOREPLIFETIME(ALyraCharacter, AmmoCount);
        DOREPLIFETIME(ALyraCharacter, bIsReloading);
    }
};

// 2. ì„œë²„ì—ì„œ FRepLayout ì‚¬ìš© ì˜ˆì‹œ (UNetDriver ë‚´ë¶€ êµ¬í˜„ ì¼ë¶€)
void UNetDriver::ReplicateObject(UObject* Object, UNetConnection* Connection)
{
    // ê°ì²´ì˜ í´ë˜ìŠ¤ì— ëŒ€í•œ RepLayout ê°€ì ¸ì˜¤ê¸°
    UClass* Class = Object->GetClass();
    TSharedPtr<FRepLayout> RepLayout = GetObjectClassRepLayout(Class);
    
    // ê°ì²´ì˜ ë³€ê²½ ìƒíƒœ ê´€ë¦¬ì ê°€ì ¸ì˜¤ê¸°
    TSharedPtr<FReplicationChangelistMgr> ChangelistMgr = GetReplicationChangeListMgr(Object);
    
    // ë³€ê²½ëœ ì†ì„± ëª©ë¡ ìƒì„±
    TArray<uint16> ChangedProperties;
    ChangelistMgr->GetChangedProperties(ChangedProperties);
    
    if (ChangedProperties.Num() > 0)
    {
        // ë³€ê²½ëœ ì†ì„±ë§Œ ë„¤íŠ¸ì›Œí¬ë¡œ ì „ì†¡í•˜ê¸° ìœ„í•œ ì¤€ë¹„
        FNetBitWriter Writer(Connection->PackageMap, 0);
        
        // RepLayoutì„ ì‚¬ìš©í•˜ì—¬ ë³€ê²½ëœ ì†ì„±ë§Œ ì§ë ¬í™”
        RepLayout->SendProperties(Object, ChangelistMgr.Get(), Writer, ChangedProperties);
        
        // ì§ë ¬í™”ëœ ë°ì´í„°ë¥¼ ë„¤íŠ¸ì›Œí¬ë¡œ ì „ì†¡
        Connection->SendBunch(Writer);
        
        // ë³€ê²½ ìƒíƒœ ì—…ë°ì´íŠ¸
        ChangelistMgr->MarkPropertyClean(ChangedProperties);
    }
}

// 3. í´ë¼ì´ì–¸íŠ¸ì—ì„œ FRepLayout ì‚¬ìš© ì˜ˆì‹œ (UActorChannel ë‚´ë¶€ êµ¬í˜„ ì¼ë¶€)
void UActorChannel::ProcessBunch(FInBunch& Bunch)
{
    // ì•¡í„° ê°€ì ¸ì˜¤ê¸°
    AActor* Actor = GetActor();
    if (!Actor)
        return;
    
    // ì•¡í„° í´ë˜ìŠ¤ì˜ RepLayout ê°€ì ¸ì˜¤ê¸°
    UClass* Class = Actor->GetClass();
    TSharedPtr<FRepLayout> RepLayout = Connection->Driver->GetObjectClassRepLayout(Class);
    
    // ìˆ˜ì‹ ëœ ë°ì´í„°ì—ì„œ ì†ì„± ì½ê¸°
    FNetBitReader Reader(Connection->PackageMap, Bunch.GetData(), Bunch.GetBitsLeft());
    
    // RepLayoutì„ ì‚¬ìš©í•˜ì—¬ ì†ì„± ì—­ì§ë ¬í™” ë° ê°ì²´ì— ì ìš©
    TArray<uint16> RepNotifies;
    RepLayout->ReceiveProperties(Actor, Reader, RepNotifies);
    
    // RepNotify í•¨ìˆ˜ í˜¸ì¶œ ì²˜ë¦¬
    for (uint16 RepNotifyIndex : RepNotifies)
    {
        const FProperty* Property = RepLayout->GetProperty(RepNotifyIndex);
        FName PropertyName = Property->GetFName();
        
        // RepNotify í•¨ìˆ˜ ì´ë¦„ ìƒì„± (ì˜ˆ: OnRep_Health)
        FName RepNotifyFuncName = FName(*FString::Printf(TEXT("OnRep_%s"), *PropertyName.ToString()));
        
        // RepNotify í•¨ìˆ˜ ì°¾ê¸° ë° í˜¸ì¶œ
        UFunction* RepNotifyFunc = Actor->FindFunction(RepNotifyFuncName);
        if (RepNotifyFunc)
        {
            Actor->ProcessEvent(RepNotifyFunc, nullptr);
        }
    }
}

// 4. ê²Œì„ ì½”ë“œì—ì„œ ì†ì„± ë³€ê²½ ì˜ˆì‹œ
void ALyraCharacter::TakeDamage(float DamageAmount)
{
    if (HasAuthority()) // ì„œë²„ì—ì„œë§Œ ì‹¤í–‰
    {
        // ì†ì„± ë³€ê²½
        Health -= DamageAmount;
        
        // ì†ì„±ì´ ë³€ê²½ë˜ë©´ ìë™ìœ¼ë¡œ FRepLayoutì— ì˜í•´ ì¶”ì ë˜ê³ 
        // ë‹¤ìŒ ë³µì œ ì‚¬ì´í´ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡ë¨
        
        // í•„ìš”í•œ ê²½ìš° ê°•ì œë¡œ ì¦‰ì‹œ ë³µì œ
        ForceNetUpdate();
    }
}
```

* ë³€ìˆ˜ëŠ” ë­ê°€ ìˆì„ê¹Œ?

```cpp
/** 
    * Top Level Layout Commands - ìµœìƒìœ„ ë ˆë²¨ì˜ ë³µì œ ê°€ëŠ¥í•œ í”„ë¡œí¼í‹°ë“¤ì„ ê´€ë¦¬
    * í´ë˜ìŠ¤ì˜ ê° ë³µì œ ê°€ëŠ¥í•œ í”„ë¡œí¼í‹°(UPROPERTY(Replicated))ì— ëŒ€í•œ ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥í•˜ë©°
    * í´ë˜ìŠ¤ì˜ ClassReps ë°°ì—´ê³¼ 1:1 ë§¤í•‘ ê´€ê³„ë¥¼ ê°€ì§
    */
TArray<FRepParentCmd> Parents;

/** 
    * all layout commands - ëª¨ë“  ë³µì œ ëª…ë ¹ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
    * ì‹¤ì œ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒì— ë§ê²Œ ì •ë ¬ëœ ëª¨ë“  í”„ë¡œí¼í‹°(ì¤‘ì²©ëœ êµ¬ì¡°ì²´, ë°°ì—´ ìš”ì†Œ í¬í•¨)ì˜ ëª…ë ¹ ì €ì¥
    * Parentsì™€ 1:N ê´€ê³„ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŒ (í•œ ë¶€ëª¨ í”„ë¡œí¼í‹°ê°€ ì—¬ëŸ¬ ëª…ë ¹ì„ ê°€ì§ˆ ìˆ˜ ìˆìŒ)
    */
TArray<FRepLayoutCmd> Cmds;

/** 
    * converts a relative handle to the appropriate index into the Cmds array
    * ìƒëŒ€ì  í•¸ë“¤ì„ Cmds ë°°ì—´ì˜ ì ì ˆí•œ ì¸ë±ìŠ¤ë¡œ ë³€í™˜
    * í”„ë¡œí¼í‹° í•¸ë“¤ì„ í†µí•´ ë¹ ë¥´ê²Œ í•´ë‹¹ ëª…ë ¹ì„ ì°¾ì„ ìˆ˜ ìˆê²Œ í•¨
    * ë³µì œ ê³¼ì •ì—ì„œ íš¨ìœ¨ì ì¸ í”„ë¡œí¼í‹° ì ‘ê·¼ì„ ìœ„í•œ ì¸ë±ì‹± ì‹œìŠ¤í…œ
    */
TArray<FHandleToCmdIndex> BaseHandleToCmdIndex;

/**
    * ë ˆì´ì•„ì›ƒì˜ íŠ¹ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸
    * ë ˆì´ì•„ì›ƒì´ íŠ¹ë³„í•œ ì²˜ë¦¬ê°€ í•„ìš”í•œ í”„ë¡œí¼í‹°ë¥¼ í¬í•¨í•˜ëŠ”ì§€ í‘œì‹œ
    * ì´ˆê¸°í™” ì „ìš© í”„ë¡œí¼í‹°, ë™ì  ì¡°ê±´ í”„ë¡œí¼í‹° ë“±ì˜ ì¡´ì¬ ì—¬ë¶€ í‘œì‹œ
    */
ERepLayoutFlags Flags;

/**
    * special state tracking for Lifetime Custom Delta Properties:
    * - will only ever be valid if the Layout has Lifetime Custom Delta Properties
    * 
    * ìˆ˜ëª…ì£¼ê¸° ì»¤ìŠ¤í…€ ë¸íƒ€ í”„ë¡œí¼í‹°ë¥¼ ìœ„í•œ íŠ¹ë³„í•œ ìƒíƒœ ì¶”ì 
    * FFastArraySerializerì™€ ê°™ì€ ì»¤ìŠ¤í…€ ë¸íƒ€ ë³µì œë¥¼ ì‚¬ìš©í•˜ëŠ” í”„ë¡œí¼í‹° ê´€ë¦¬
    * ë ˆì´ì•„ì›ƒì— ìˆ˜ëª…ì£¼ê¸° ì»¤ìŠ¤í…€ ë¸íƒ€ í”„ë¡œí¼í‹°ê°€ ìˆëŠ” ê²½ìš°ì—ë§Œ ìœ íš¨
    */
TUniquePtr<struct FLifetimeCustomDeltaState> LifetimeCustomPropertyState;

/** 
    * UClass, UStruct, or UFunction that this FRepLayout represents
    * ì´ FRepLayoutì´ ë‚˜íƒ€ë‚´ëŠ” êµ¬ì¡°ì²´ ì°¸ì¡°
    * ì´ ë ˆì´ì•„ì›ƒì´ ì–´ë–¤ UClass, UStruct ë˜ëŠ” UFunctionì„ ìœ„í•œ ê²ƒì¸ì§€ ì €ì¥
    */
UStruct* Owner;

/** 
    * shared serialization state for a multicast rpc
    * ë©€í‹°ìºìŠ¤íŠ¸ RPCë¥¼ ìœ„í•œ ê³µìœ  ì§ë ¬í™” ìƒíƒœ
    * RPC í˜¸ì¶œ ì‹œ íš¨ìœ¨ì ì¸ ì§ë ¬í™”ë¥¼ ìœ„í•œ ì •ë³´ ì €ì¥
    */
FRepSerializationSharedInfo SharedInfoRPC;

/** 
    * shared comparison to default state for multicast rpc
    * ë©€í‹°ìºìŠ¤íŠ¸ RPCë¥¼ ìœ„í•œ ê¸°ë³¸ê°’ ëŒ€ë¹„ ë³€ê²½ ìƒíƒœ
    * ì–´ë–¤ ë¶€ëª¨ í”„ë¡œí¼í‹°ê°€ ê¸°ë³¸ê°’ì—ì„œ ë³€ê²½ë˜ì—ˆëŠ”ì§€ ì¶”ì 
    */
TBitArray<> SharedInfoRPCParentsChanged;
```

* FRepParentCmdì˜ ì£¼ìš” ì—­í• 
    * ìµœìƒìœ„ ì†ì„± ì¶”ì : UClass, UStruct ë˜ëŠ” UFunctionì˜ ìµœìƒìœ„ ì†ì„±ì„ ì¶”ì 
    * ë³µì œ ì¡°ê±´ ê´€ë¦¬: ì†ì„±ì´ ì–¸ì œ ë³µì œë˜ì–´ì•¼ í•˜ëŠ”ì§€ì— ëŒ€í•œ ì¡°ê±´(ELifetimeCondition)ì„ ê´€ë¦¬
    * RepNotify ì¡°ê±´ ê´€ë¦¬: ì†ì„± ë³€ê²½ ì‹œ ì•Œë¦¼ì„ ë°›ì„ ì¡°ê±´ì„ ê´€ë¦¬
    * í•˜ìœ„ ëª…ë ¹ ë²”ìœ„ ì •ì˜: CmdStartì™€ CmdEndë¥¼ í†µí•´ FRepLayoutCmd ë°°ì—´ì—ì„œ ì´ ë¶€ëª¨ ëª…ë ¹ê³¼ ê´€ë ¨ëœ ëª…ë ¹ì˜ ë²”ìœ„ë¥¼ ì •ì˜

```
ULyraInventoryManagerComponent
  â”œâ”€â”€ bReplicates (FBoolProperty)
  â”œâ”€â”€ bIsActive (FBoolProperty)
  â””â”€â”€ InventoryList (FStructProperty: FLyraInventoryList)
       â””â”€â”€ Entries (FArrayProperty: TArray<FLyraInventoryEntry>)
            â”œâ”€â”€ Instance (TObjectPtr<ULyraInventoryInstance>)
            â””â”€â”€ StackCount (int32)
```

* ìœ„ì™€ ê°™ì€ êµ¬ì¡°ê°€ ìˆì„ ë•Œ:
    * ê° ë³µì œ ê°€ëŠ¥í•œ ì†ì„±(bReplicates, bIsActive, InventoryList)ì— ëŒ€í•´ FRepParentCmdê°€ ìƒì„±ë©
    * ê° FRepParentCmdëŠ” í•´ë‹¹ ì†ì„±ì˜ ë©”ëª¨ë¦¬ ì˜¤í”„ì…‹ì„ ì €ì¥
    * ê° ì†ì„±ì— ëŒ€í•œ ì„¸ë¶€ ì •ë³´ë¥¼ ë‹´ì€ FRepLayoutCmdë“¤ì´ ìƒì„±

```
FRepParentCmd (InventoryList)
  â”œâ”€â”€ Property = FStructProperty(InventoryList)
  â”œâ”€â”€ Offset = 216 (ê°ì²´ ë©”ëª¨ë¦¬ì—ì„œì˜ ìœ„ì¹˜)
  â”œâ”€â”€ CmdStart = 2 (FRepLayoutCmd ë°°ì—´ì—ì„œ ì‹œì‘ ì¸ë±ìŠ¤)
  â””â”€â”€ CmdEnd = 6 (FRepLayoutCmd ë°°ì—´ì—ì„œ ë ì¸ë±ìŠ¤)

FRepLayoutCmd[2] (Entries ë°°ì—´)
  â”œâ”€â”€ Type = DynamicArray
  â”œâ”€â”€ Property = FArrayProperty(Entries)
  â”œâ”€â”€ Offset = 488
  â””â”€â”€ RelativeHandle = 3

FRepLayoutCmd[3] (Instance ì†ì„±)
  â”œâ”€â”€ Type = PropertyObject
  â”œâ”€â”€ Property = TObjectPtr<ULyraInventoryInstance>
  â”œâ”€â”€ Offset = 16 (ë°°ì—´ ìš”ì†Œ ë‚´ì—ì„œì˜ ì˜¤í”„ì…‹)
  â””â”€â”€ RelativeHandle = 1

FRepLayoutCmd[4] (StackCount ì†ì„±)
  â”œâ”€â”€ Type = PropertyInt
  â”œâ”€â”€ Property = int32
  â”œâ”€â”€ Offset = 24 (ë°°ì—´ ìš”ì†Œ ë‚´ì—ì„œì˜ ì˜¤í”„ì…‹)
  â””â”€â”€ RelativeHandle = 2
```

---

```cpp
TSharedPtr<FRepLayout> GetObjectClassRepLayout(UClass* Class)
{
    TSharedPtr<FRepLayout>* RepLayoutPtr = RepLayoutMap.Find(Class);
    if (!RepLayoutPtr)
    {
        // haker: Flags is 'ECreateRepLayoutFlags::None' except for special case
        // - see MaySendProperties() breifly
        // - see FRepLayout::CreateFromClass(goto 007: ServerCreateObjectReplicator)
        ECreateRepLayoutFlags Flags = MaySendProperties() ? ECreateRepLayoutFlags::MaySendProperties : ECreateRepLayoutFlags::None;
        RepLayoutPtr = &RepLayoutMap.Add(Class, FRepLayout::CreateFromClass(Class, ServerConnection, Flags));
    }
    return *RepLayoutPtr;
}
```

---

## FObjectReplicator::InitFromClass Initì€ ì–´ë–»ê²Œ í• ê¹Œ2?

```cpp
void InitFromClass(UClass* InObjectClass, const UNetConnection* ServerConnection, const ECreateRepLayoutFlags Flags)
{
    const bool bIsObjectActor = InObjectClass->IsChildOf(AActor::StaticClass());
    if (bIsObjectActor)
    {
        Flags |= ERepLayoutFlags::IsActor;
    }

    int32 RelativeHandle = 0;
    int32 LastOffset = INDEX_NONE;
    int32 HighestCustomDeltaRepIndex = INDEX_NONE;
    TMap<int32, TArray<FRepLayoutCmd>> TempNetSerializeLayouts;

    InObjectClass->SetUpRuntimeReplicationData();
    Parents.Empty(InObjectClass->ClassReps.Num());

    
    for (int32 i = 0; i < InObjectClass->ClassReps.Num(); ++i)
    {
        FProperty* Propety = InObjectClass->ClassReps[i].Property;
        const int32 ArrayIdx = InObjectClass->ClassReps[i].Index;
        check(Property->PropertyFlags & CPF_Net);

        const int32 ParentHandle = AddParentProperty(Parents, Property, ArrayIdx);
        check(ParentHandle == i);
        check(Parents[i].Property->RepIndex + Parents[i].ArrayIndex == i);

        const int32 ParentOffset = Property->ElementSize * ArrayIdx;


        FInitFromPropertySharedParams SharedParams
        {
            /*Cmds=*/Cmds,
            /*ServerConnection=*/ServerConnection,
            /*ParentIndex=*/ParentHandle,
            /*Parent=*/Parents[ParentHandle],
            /*bHasObjectProperties=*/false,
            /*bHasNetSerializeProperties=*/false,
            /*NetSerializeLayouts=*/nullptr,
        };

        FInitFromPropertyStackParams StackParams
        {
            /*Property=*/Property,
            /*Offset=*/ParentOffset,
            /*RelativeHandle=*/RelativeHandle,
            /*ParentChecksum=*/0,
            /*StaticArrayIndex=*/ArrayIdx,
        };

        Parents[ParentHandle].CmdStart = Cmds.Num();
        {
            RelativeHandle = InitFromProperty_r<ERepBuildType::Class>(SharedParams, StackParams);
        }
        Parents[ParentHandle].CmdEnd = Cmds.Num();
        Parents[ParentHandle].Flags |= ERepParentFlags::IsConditional;
        Parents[ParentHandle].Offset = GetOffsetForProperty<ERepBuildType::Class>(*Property) + ParentOffset;

        if (Parents[i].CmdEnd > Parents[i].CmdStart)
        {
            check(Cmds[Parents[i].CmdStart].Offset >= LastOffset);
            LastOffset = Cmds[Parents[i].CmdStart].Offset;
        }

        SetupRepStructFlags(Parents[ParentHandle], /*bSkipCustomDeltaCheck=*/false);

        if (Property->GetPropertyFlags() & CPF_Config)
        {
            Parents[ParentHandle].Flags |= ERepParentFlags::IsConfig;
        }

        if (EnumHasAnyFlags(Parents[ParentHandle].Flags, ERepParentFlags::IsCustomDelta))
        {
            HighestCustomDeltaRepIndex = ParentHandle;
        }

        if (SharedParams.bHasNetSerializeProperties)
        {
            Parents[ParentHandle].Flags |= ERepParentFlags::HasNetSerializeProperties;
        }
        if (SharedParams.bHasObjectProperties)
        {
            Parents[ParentHandle].Flags |= ERepParentFlags::HasObjectProperties;
        }
    }
}
```