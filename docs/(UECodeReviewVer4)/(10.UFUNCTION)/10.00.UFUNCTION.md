---
layout: default
title: "(10. UFUNCTION)"
parent: "(UE Code-Review ğŸ¤–)"
has_children: true
nav_order: 2
permalink: docs/review/ue/ver4/10/UFUNCTION
---

## UFUNCTION

* `UFUNCTION`ë¥¼ ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸í–ˆë‹¤ ê°€ì •í•´ë³´ì.
* ì–´ë–»ê²Œ ë™ì‘ë ê¹Œ?

```cpp
UFUNCTION(BlueprintCallable, Category="Game")
virtual void InitializeHUDForPlayer(APlayerController* NewPlayer);
```

* ë¹Œë“œ ê³¼ì •ì—ì„œ UHT(ì–¸ë¦¬ì–¼ í—¤ë” íˆ´)ëŠ” UFUNCTION ë§¤í¬ë¡œë¥¼ ë°œê²¬í•˜ê³  ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤
    * í•¨ìˆ˜ ë“±ë¡ ì •ë³´ ìƒì„±: í•¨ìˆ˜ ì´ë¦„, íŒŒë¼ë¯¸í„° ì •ë³´ ë“±ì„ í¬í•¨í•œ ë©”íƒ€ë°ì´í„° ìƒì„±
    * ë¦¬í”Œë ‰ì…˜ ë°ì´í„° ìƒì„±: ëŸ°íƒ€ì„ì— í•¨ìˆ˜ë¥¼ ì°¾ê³  í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ì •ë³´ ìƒì„±
    * ì‹¤í–‰ í•¨ìˆ˜ ìƒì„±: `exec` ì ‘ë‘ì‚¬ê°€ ë¶™ì€ í•¨ìˆ˜ ìƒì„± (ex. `execInitializeHUDForPlayer`)

```cpp
//  ì–¸ë¦¬ì–¼ í—¤ë” íˆ´(UHT)ì—ì„œ ìƒì„±í•´ ì£¼ëŠ” ì½”ë“œ

// í•¨ìˆ˜ í˜¸ì¶œì„ ìœ„í•œ ì´ë¦„ ì •ì˜
static FName NAME_AGameModeBase_InitializeHUDForPlayer = FName(TEXT("InitializeHUDForPlayer"));

// íŒŒë¼ë¯¸í„° êµ¬ì¡°ì²´ ì •ì˜
struct GameModeBase_eventInitializeHUDForPlayer_Parms
{
    APlayerController* NewPlayer;
};

// ë¸”ë£¨í”„ë¦°íŠ¸ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ í•¨ìˆ˜ ë˜í¼
void AGameModeBase::InitializeHUDForPlayer(APlayerController* NewPlayer)
{
    GameModeBase_eventInitializeHUDForPlayer_Parms Parms;
    Parms.NewPlayer = NewPlayer;
    ProcessEvent(FindFunctionChecked(NAME_AGameModeBase_InitializeHUDForPlayer), &Parms);
}

// ì‹¤í–‰ í•¨ìˆ˜ ì •ì˜ (ìŠ¤í¬ë¦½íŠ¸ VMì—ì„œ í˜¸ì¶œë¨)
DEFINE_FUNCTION(AGameModeBase::execInitializeHUDForPlayer)
{
    P_GET_OBJECT(APlayerController, Z_Param_NewPlayer);
    P_FINISH;
    P_NATIVE_BEGIN;
    P_THIS->InitializeHUDForPlayer_Implementation(Z_Param_NewPlayer);
    P_NATIVE_END;
}
```

### ëŸ°íƒ€ì„ ì‹¤í–‰ íë¦„ì€?

* ë¸”ë£¨í”„ë¦°íŠ¸ì—ì„œ í•¨ìˆ˜ í˜¸ì¶œ ì‹œ â†’ InitializeHUDForPlayer ë˜í¼ í•¨ìˆ˜ í˜¸ì¶œ
* ë˜í¼ í•¨ìˆ˜ëŠ” ProcessEventë¥¼ í†µí•´ í•¨ìˆ˜ ì‹¤í–‰ ìš”ì²­
* ì–¸ë¦¬ì–¼ ì—”ì§„ VMì€ execInitializeHUDForPlayer í•¨ìˆ˜ë¥¼ ì°¾ì•„ í˜¸ì¶œ
* execInitializeHUDForPlayerëŠ” íŒŒë¼ë¯¸í„°ë¥¼ ì²˜ë¦¬í•˜ê³  ì‹¤ì œ êµ¬í˜„ í•¨ìˆ˜ í˜¸ì¶œ
* ìµœì¢…ì ìœ¼ë¡œ InitializeHUDForPlayer_Implementation ë˜ëŠ” ì›ë˜ êµ¬í˜„ í•¨ìˆ˜ ì‹¤í–‰
* ì´ëŸ¬í•œ ë³µì¡í•œ ê³¼ì •ì€ ëª¨ë‘ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë˜ë¯€ë¡œ ê°œë°œìëŠ” UFUNCTION ë§¤í¬ë¡œë§Œ ì¶”ê°€í•˜ë©´ ëœë‹¤.!

---

## ì–¸ë¦¬ì–¼ ì—”ì§„ VM

* ì–¸ë¦¬ì–¼ ì—”ì§„ VM(ê°€ìƒ ë¨¸ì‹ )ì€ ë¸”ë£¨í”„ë¦°íŠ¸ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ë‚´ë¶€ ì‹œìŠ¤í…œ

* ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì—”ì§„:
    *ë¸”ë£¨í”„ë¦°íŠ¸ ë¹„ì£¼ì–¼ ìŠ¤í¬ë¦½íŒ…ìœ¼ë¡œ ë§Œë“  ì½”ë“œë¥¼ ì‹¤í–‰í•˜ëŠ” ì¸í„°í”„ë¦¬í„°
    * C++ë¡œ ì‘ì„±ëœ ë„¤ì´í‹°ë¸Œ ì½”ë“œì™€ ë¸”ë£¨í”„ë¦°íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ê°„ì˜ ìƒí˜¸ì‘ìš©ì„ ê´€ë¦¬
* ë°”ì´íŠ¸ì½”ë“œ ì²˜ë¦¬:
    * ë¸”ë£¨í”„ë¦°íŠ¸ëŠ” ì»´íŒŒì¼ ì‹œ ì¤‘ê°„ ë°”ì´íŠ¸ì½”ë“œ í˜•íƒœë¡œ ë³€í™˜
    * VMì€ ì´ ë°”ì´íŠ¸ì½”ë“œë¥¼ í•´ì„í•˜ê³  ì‹¤í–‰
* ìŠ¤íƒ ê¸°ë°˜ ì‹¤í–‰:
    * FFrameì´ë¼ëŠ” ìŠ¤íƒ í”„ë ˆì„ì„ ì‚¬ìš©í•˜ì—¬ í•¨ìˆ˜ í˜¸ì¶œê³¼ íŒŒë¼ë¯¸í„°ë¥¼ ê´€ë¦¬
    * ì½”ë“œì—ì„œ ë³¸ FFrame& Stack íŒŒë¼ë¯¸í„°ê°€ ì´ë¥¼ ë‚˜íƒ€ëƒ„
* í•¨ìˆ˜ ë””ìŠ¤íŒ¨ì¹˜:
    * ProcessEvent í•¨ìˆ˜ë¥¼ í†µí•´ í•¨ìˆ˜ í˜¸ì¶œì„ ì²˜ë¦¬
    * ì ì ˆí•œ exec í•¨ìˆ˜ë¥¼ ì°¾ì•„ í˜¸ì¶œí•©ë‹ˆë‹¤.

### VMê³¼ C++ ì½”ë“œì˜ ì—°ê²° ë°©ë²•?

* UFUNCTION ë§¤í¬ë¡œ:
    * C++ í•¨ìˆ˜ë¥¼ VMì— ë…¸ì¶œì‹œí‚¤ëŠ” ì—­í• 
    * VMì´ C++ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆê²Œ í•¨
* exec í•¨ìˆ˜:
    * VMì´ ì§ì ‘ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜
    * íŒŒë¼ë¯¸í„°ë¥¼ ìŠ¤íƒì—ì„œ ì¶”ì¶œí•˜ê³  ì‹¤ì œ C++ êµ¬í˜„ì„ í˜¸ì¶œ
* ProcessEvent:
    * ëª¨ë“  ìŠ¤í¬ë¦½íŠ¸ í•¨ìˆ˜ í˜¸ì¶œì€ ê²°êµ­ ProcessEventë¥¼ í†µí•´ ì²˜ë¦¬
    * í•¨ìˆ˜ ì´ë¦„ì„ ê¸°ë°˜ìœ¼ë¡œ ì ì ˆí•œ í•¨ìˆ˜ë¥¼ ì°¾ì•„ ì‹¤í–‰
* ì‹¤ì œ ë™ì‘ ì˜ˆì‹œ
    * ë¸”ë£¨í”„ë¦°íŠ¸ì—ì„œ InitializeHUDForPlayer í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´:
    * VMì€ NAME_AGameModeBase_InitializeHUDForPlayer ì´ë¦„ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ ì°¾ëŠ”ë‹¤
    * ProcessEventë¥¼ í˜¸ì¶œí•˜ì—¬ í•¨ìˆ˜ ì‹¤í–‰ì„ ìš”ì²­
    * VMì€ execInitializeHUDForPlayer í•¨ìˆ˜ë¥¼ ì°¾ì•„ í˜¸ì¶œ
    * execInitializeHUDForPlayerëŠ” ìŠ¤íƒì—ì„œ íŒŒë¼ë¯¸í„°ë¥¼ ì¶”ì¶œí•˜ê³  ì‹¤ì œ C++ êµ¬í˜„ì„ í˜¸ì¶œ
    * ì´ VM ì‹œìŠ¤í…œ ë•ë¶„ì— ë¸”ë£¨í”„ë¦°íŠ¸ ì‚¬ìš©ìëŠ” C++ ì½”ë“œë¥¼ ì§ì ‘ ì‘ì„±í•˜ì§€ ì•Šê³ ë„ ì—”ì§„ì˜ ëª¨ë“  ê¸°ëŠ¥ì„ í™œìš©

---

## VMì— ì˜í•´ í˜¸ì¶œëœ execí•¨ìˆ˜ê°€ ProcessEventì„ í†µí•´ í˜¸ì¶œë˜ëŠ” ê³¼ì • ì •ë¦¬

### (ì‚¬ì „ì§€ì‹) GetFunctionCallspaceì— ëŒ€í•´ ìš°ì„  ì„¤ëª…

```cpp
namespace FunctionCallspace
{
    enum Type
    {
        Absorbed = 0x0, // í•¨ìˆ˜ í˜¸ì¶œ ë¬´ì‹œ
        Remote = 0x1,   // ì›ê²© ë¨¸ì‹ ì—ì„œ ì‹¤í–‰
        Local = 0x2,    // ë¡œì»¬ì—ì„œ ì‹¤í–‰
    };
};
```

### (ì‚¬ì „ì§€ì‹) FVirtualStackAllocator

* `FVirtualStackAllocator`ëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ì—ì„œ í•¨ìˆ˜ í˜¸ì¶œ ì‹œ í•„ìš”í•œ ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ ë©”ëª¨ë¦¬ í• ë‹¹ì

* ì„ì‹œ ë©”ëª¨ë¦¬ í• ë‹¹:
    * í•¨ìˆ˜ í˜¸ì¶œ ì‹œ í•„ìš”í•œ íŒŒë¼ë¯¸í„°ì™€ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ìœ„í•œ ë©”ëª¨ë¦¬ ê³µê°„ì„ í• ë‹¹
    * í•¨ìˆ˜ ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´ ì´ ë©”ëª¨ë¦¬ëŠ” ìë™ìœ¼ë¡œ í•´ì œë©
* ìŠ¤íƒ ê¸°ë°˜ ë©”ëª¨ë¦¬ ê´€ë¦¬:
    * ì¼ë°˜ì ì¸ C++ ìŠ¤íƒê³¼ ìœ ì‚¬í•˜ê²Œ ì‘ë™í•˜ì§€ë§Œ, ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ VMì— ìµœì í™”
    * í•¨ìˆ˜ í˜¸ì¶œ ê¹Šì´ê°€ ê¹Šì–´ì§ˆ ë•Œ íš¨ìœ¨ì ì¸ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ì œê³µ
* ìŠ¤ë ˆë“œ ì•ˆì „ì„±:
    * GetThreadSingleton()ì„ í†µí•´ ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ë…ë¦½ì ì¸ í• ë‹¹ìë¥¼ ì‚¬ìš©
    * ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ì‘ë™í•©ë‹ˆë‹¤.

* Ex. `FVirtualStackAllocator* VirtualStackAllocator = FBlueprintContext::GetThreadSingleton()->GetVirtualStackAllocator();`

```cpp
// 1. í˜„ì¬ ìŠ¤ë ˆë“œì˜ ê°€ìƒ ìŠ¤íƒ í• ë‹¹ì ê°€ì ¸ì˜¤ê¸°
FVirtualStackAllocator* VirtualStackAllocator = FBlueprintContext::GetThreadSingleton()->GetVirtualStackAllocator();

// 2. í•¨ìˆ˜ ì‹¤í–‰ì— í•„ìš”í•œ ë©”ëª¨ë¦¬ í• ë‹¹ (íŒŒë¼ë¯¸í„°ì™€ ë¡œì»¬ ë³€ìˆ˜ìš©)
uint8* Frame = (uint8*)UE_VSTACK_ALLOC_ALIGNED(VirtualStackAllocator, Function->PropertiesSize, Function->GetMinAlignment());

// 3. ë¡œì»¬ ë³€ìˆ˜ ì˜ì—­ ì´ˆê¸°í™” (0ìœ¼ë¡œ ì„¤ì •)
const int32 NonParmsPropertiesSize = Function->PropertiesSize - Function->ParmsSize;
if (NonParmsPropertiesSize)
{
    FMemory::Memzero(Frame + Function->ParmsSize, NonParmsPropertiesSize);
}

// 4. íŒŒë¼ë¯¸í„° ë³µì‚¬
if (Function->ParmsSize)
{
    FMemory::Memcpy(Frame, Parms, Function->ParmsSize);
}

// 5. í•¨ìˆ˜ ì‹¤í–‰ì„ ìœ„í•œ ìŠ¤íƒ í”„ë ˆì„ ìƒì„±
FFrame NewStack(this, Function, Frame, NULL, Function->ChildProperties);

// 6. í•¨ìˆ˜ ì‹¤í–‰
Function->Invoke(this, NewStack, ReturnValueAddress);

// 7. í•¨ìˆ˜ ì¢…ë£Œ í›„ ë©”ëª¨ë¦¬ëŠ” ìë™ìœ¼ë¡œ í•´ì œë¨ (ëª…ì‹œì  í•´ì œ ì½”ë“œ ì—†ìŒ)
```

### ì‹¤ì œ ProcessEventì˜ ì²˜ë¦¬

```cpp
virtual void ProcessEvent(UFunction* Function, void* Parms)
{
    if ((Function->FunctionFlags & FUNC_Native) != 0)
    {
        // GetFunctionCallspace: íŠ¹ì • í•¨ìˆ˜ í˜¸ì¶œì´ ì–´ë””ì—ì„œ ì‹¤í–‰ë˜ì–´ì•¼ í•˜ëŠ”ì§€ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
        int32 FunctionCallSpace = GetFunctionCallspace(Function, NULL);
        if (FunctionCallSpace & FunctionCallspace::Remote)
        {
            CallRemoteFunction(Function, Params, NULL, NULL);
        }

        // ë¡œì»¬ì˜ ê²½ìš° ë¬´ì‹œ
        if ((FunctionCallSpace & FunctionCallspace::Local) == 0)
        {
            return;
        }
    }

    {
        FVirtualStackAllocator* VirtualStackAllocator = FBlueprintContext::GetThreadSingleton()->GetVirtualStackAllocator();
        uint8* Frame = (uint8*)UE_VSTACK_ALLOC_ALIGNED(VirtualStackAllocator, Function->PropertiesSize, Function->GetMinAlignment());
        {
            // zero the local property memory
            const int32 NonParmsPropertiesSize = Function->PropertiesSize - Function->ParmsSize;
            if (NonParmsPropertiesSize)
            {
                FMemory::Memzero(Frame + Function->ParmsSize, NonParmsPropertiesSize);
            }
        }

        // initialize the parameter properties
        if (Function->ParmsSize)
        {
            FMemory::Memcpy(Frame, Parms, Function->ParmsSize);
        }

        // create a new local execution stack
        // haker: we are not going to look through the detail of FFrame initialization:
        // - just note that FFrame has function-pointer(Function:UFunction) and Frame(parameters' storage) and ChildProperties(kind of lambda capture)
        FFrame NewStack(this, Function, Frame, NULL, Function->ChildProperties);

        // call native function or UObject::ProcessInternal
        // haker: now we call UFunction::Invoke()
        // - see UFunction::Invoke(goto 011: ServerProcessEvent)
        const bool bHasReturnParam = Function->ReturnValueOffset != MAX_uint16;
        uint8* ReturnValueAddress = bHasReturnParam ? ((uint8*)Parms + Function->ReturnValueOffset) : nullptr;
        Function->Invoke(this, NewStack, ReturnValueAddress);
    }
}
```

---

## UFunctionì— êµ¬í˜„ëœ Unreal Reflection System

* UFunctionì˜ ìƒì† êµ¬ì¡°:
    * UObject â†’ UField â†’ UStruct â†’ UFunction ìˆœìœ¼ë¡œ ìƒì†
    * ì´ ìƒì† êµ¬ì¡°ë¥¼ í†µí•´ ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ë¦¬í”Œë ‰ì…˜ ì‹œìŠ¤í…œì´ êµ¬í˜„
* ì—­í• :
    * ë¦¬í”Œë ‰ì…˜ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” í´ë˜ìŠ¤
    * ë„¤íŠ¸ì›Œí¬ ë³µì œ(Replication)ê°€ ê°€ëŠ¥í•œ í•¨ìˆ˜ì™€ ë¸”ë£¨í”„ë¦°íŠ¸(Kismet)ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•œ í•¨ìˆ˜ì— ëŒ€í•œ ì •ë³´ë¥¼ ë‹´ê³  ìˆëŠ”ë‹¤.
* ì£¼ìš” ë©¤ë²„ ë³€ìˆ˜:
    * `FunctionFlags`: í•¨ìˆ˜ì˜ íŠ¹ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸ë“¤ (ë„¤íŠ¸ì›Œí¬ ê´€ë ¨, ë¸”ë£¨í”„ë¦°íŠ¸ ê´€ë ¨ ë“±)
    * `NumParms`: í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ ê°œìˆ˜
    * `ParmsSize`: ë§¤ê°œë³€ìˆ˜ì˜ ì´ ë©”ëª¨ë¦¬ í¬ê¸°
    * `Func`: ì‹¤ì œ C++ í•¨ìˆ˜ í¬ì¸í„° (FNativeFuncPtr íƒ€ì…)

### FNativeFuncPtrì˜ êµ¬ì„± ìš”ì†Œ

```cpp
void (*FNativeFuncPtr)(UObject* Context, FFrame& TheStack, RESULT_DECL)
```

* `UObject* Context`: í•¨ìˆ˜ê°€ ì†í•œ ê°ì²´ ì¸ìŠ¤í„´ìŠ¤
    * ë©¤ë²„ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ í•„ìš”í•œ ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë‚˜íƒ€ëƒ„
* `FFrame& TheStack`: í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤íƒ ì •ë³´
    * í•¨ìˆ˜ í˜¸ì¶œì˜ ë²”ìœ„(ìŠ¤ì½”í”„)ë¥¼ ë‚˜íƒ€ëƒ„
    * ì¤‘ì²©ëœ í•¨ìˆ˜ í˜¸ì¶œì—ì„œ ì´ì „ í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ë³µêµ¬í•˜ëŠ” ë° ì‚¬ìš©
* `RESULT_DECL`: ë°˜í™˜ê°’ì„ ìœ„í•œ ë§¤ê°œë³€ìˆ˜
    * RPCëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë°˜í™˜ê°’ì´ ì—†ì§€ë§Œ, í•„ìš”í•œ ê²½ìš° ì´ë¥¼ í†µí•´ ë°˜í™˜ê°’ì„ ì „ë‹¬

```
//
//     UObject                                                                                                                                                                                                              
//        â–²                                                                                                                                                                                                                 
//        â”‚inherits                                â”Œâ”€â”€â”€â”€â”€â”€1. this implements inheritance:                                                                                                                                   
//        â”‚                                        â”‚         e.g.                                                                                                                                                           
//     UField                                      â”‚                struct A {}                                                                                                                                             
//        â–²                                        â”‚                                                                                                                                                                        
//        â”‚inherits                                â”‚                struct B : public A {}                                                                                                                                  
//        â”‚                                        â”‚                                                                                                                                                                        
//     UStruct                                     â”‚             ***B::StaticClass().SuperStruct == A::StaticClass()                                                                                                                        
//       â”‚                                         â”‚                                                                                                                                                                        
//       â”œâ”€â”€SuperStruct:TObjectPtr<UStruct> â—„â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€2. this implements member variables:                                                                                                                              
//       â”‚                                           â”‚       e.g.                                                                                                                                                           
//       â””â”€â”€PropertyLink:FProperty*â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              struct A {        A:UStruct                                                                                                                             
//        â–²                                                           int A;          â”‚                                                                                                                                     
//        â”‚inherits                                                   float B;        â””â”€â”€PropertyLink:FProperty:                                                                                                            
//        â”‚                                                         };                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                                                            
//     UFunction                                                                        â”‚ A:FIntProperty â—„â”€â”€â”¤ B:FFloatProperty â”‚                                                                                            
//       â”‚                                                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                                                            
//       â”œâ”€â”€FunctionFlags: EFunctionFlags â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€3.special flags for UFunction:                                                        
//       â”‚                                                                                                                              from this flags, we can define the type of UFunction:                               
//       â”œâ”€â”€NumParms:uint8                                                                                                                                                                                                  
//       â”‚                                                                                                                                e.g. FUNC_Native                                                                  
//       â”œâ”€â”€ParmsSize:uint16                                                                                                                   FUNC_Netâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                       
//       â”‚                                                                                                                                     FUNC_NetReiable      â”‚                                                       
//       â””â”€â”€Func:FNativeFuncPtr                                                                                                                FUNC_NetMulticast    â”œâ”€â”€all related networking, RPC(Remote Procedural Call)  
//               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                                                                FUNC_NetClient       â”‚                                                       
//                 == void(*FNativeFuncPtr)(UObject* Context, FFrame& TheStack, RESULT_DECL)                                                   FUNC_NetServerâ”€â”€â”€â”€â”€â”€â”€â”˜                                                       
//                                                            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                                 ...                                                                          
//                                                             function's stack scope      
```

```cpp
class UFunction : public UStruct
{
    void Invoke(UObject* Obj, FFrame& Stack, RESULT_DECL)
    {
        return (*Func)(Obj, Stack, RESULT_PARAM);
    }

    /** EFunctionFlags set defined for this function */
    EFunctionFlags FunctionFlags;

    /** number of parameters total */
    uint8 NumParms;
    /** total size of parameters in memory */
    uint16 ParmsSize;
    /** memory offset of return value property */
    uint16 ReturnValueOffset;

    /** C++ function this is bound to */
    FNativeFuncPtr Func;
};

```

