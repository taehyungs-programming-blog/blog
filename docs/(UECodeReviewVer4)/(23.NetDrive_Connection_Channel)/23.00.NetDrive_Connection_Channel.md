---
layout: default
title: "(23. NetDrive, Connection, Channel ê´€ê³„)"
parent: "(UE Code-Review ğŸ¤–)"
has_children: true
nav_order: 3
permalink: docs/review/ue/ver4/23/NetDrive_Connection_Channel
---

## ìƒí˜¸ ì†Œìœ  ê´€ê³„ ë‹¤ì´ì–´ê·¸ë¨

```
World
â””â”€â”€ UNetDriver (UIpNetDriver)
    â”œâ”€â”€ ClientConnections: TArray<UNetConnection*>
    â”‚   â”œâ”€â”€ UIpConnection (Client1)
    â”‚   â”‚   â”œâ”€â”€ Channels[0]: UControlChannel*
    â”‚   â”‚   â”œâ”€â”€ Channels[1]: UActorChannel* (PlayerController)
    â”‚   â”‚   â”œâ”€â”€ Channels[2]: UActorChannel* (Pawn)
    â”‚   â”‚   â””â”€â”€ Channels[N]: UActorChannel* (ê¸°íƒ€ ì•¡í„°ë“¤)
    â”‚   â”‚
    â”‚   â””â”€â”€ UIpConnection (Client2)
    â”‚       â”œâ”€â”€ Channels[0]: UControlChannel*
    â”‚       â””â”€â”€ Channels[...]: UActorChannel*
    â”‚
    â””â”€â”€ ServerConnection: UNetConnection* (í´ë¼ì´ì–¸íŠ¸ì—ì„œë§Œ)
        â”œâ”€â”€ Channels[0]: UControlChannel*
        â”œâ”€â”€ Channels[1]: UActorChannel* (PlayerController)
        â””â”€â”€ Channels[...]: UActorChannel*
```

---

## í´ë˜ìŠ¤ ìƒì† ê´€ê³„

```
// ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë²„ ê³„ì¸µ
UObject
â””â”€â”€ UNetDriver (ì¶”ìƒ í´ë˜ìŠ¤)
    â””â”€â”€ UIpNetDriver (IP/UDP êµ¬í˜„)

// ë„¤íŠ¸ì›Œí¬ ì—°ê²° ê³„ì¸µ  
UObject
â””â”€â”€ UNetConnection (ì¶”ìƒ í´ë˜ìŠ¤)
    â””â”€â”€ UIpConnection (IP/UDP êµ¬í˜„)

// ì±„ë„ ê³„ì¸µ
UObject
â””â”€â”€ UChannel (ì¶”ìƒ í´ë˜ìŠ¤)
    â”œâ”€â”€ UControlChannel (ì œì–´ ë©”ì‹œì§€)
    â”œâ”€â”€ UActorChannel (ì•¡í„° ë³µì œ)
    â””â”€â”€ UVoiceChannel (ìŒì„± í†µì‹ )
```

---

## Example

```cpp
// Unreal Engine ë„¤íŠ¸ì›Œí‚¹ ì‹œìŠ¤í…œì˜ ì†Œìœ  ê´€ê³„ ì˜ˆì‹œ

#pragma once

// ===== 1. UNetDriver (ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë²„) =====
class UNetDriver : public UObject
{
public:
    // ì„œë²„ì—ì„œ: ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ ì—°ê²°ë“¤ì„ ì†Œìœ 
    // í´ë¼ì´ì–¸íŠ¸ì—ì„œ: ë¹ˆ ë°°ì—´
    TArray<UNetConnection*> ClientConnections;
    
    // ì„œë²„ì—ì„œ: nullptr
    // í´ë¼ì´ì–¸íŠ¸ì—ì„œ: ì„œë²„ì™€ì˜ ì—°ê²°ì„ ì†Œìœ 
    UNetConnection* ServerConnection;
    
    // ì›”ë“œ ì°¸ì¡°
    UWorld* World;
    
    // ë„¤íŠ¸ì›Œí¬ ì•Œë¦¼ ì¸í„°í˜ì´ìŠ¤
    FNetworkNotify* Notify;
    
    // ì—°ê²° í´ë˜ìŠ¤ íƒ€ì… (ë³´í†µ UIpConnection)
    TSubclassOf<UNetConnection> NetConnectionClass;

    // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¶”ê°€ (ì„œë²„ì—ì„œë§Œ)
    virtual void AddClientConnection(UNetConnection* NewConnection)
    {
        if (NewConnection)
        {
            ClientConnections.Add(NewConnection);
            // ì—°ê²°ì— ë“œë¼ì´ë²„ ì„¤ì •
            NewConnection->Driver = this;
        }
    }
    
    // ëª¨ë“  ì—°ê²°ì— íŒ¨í‚· ë¸Œë¡œë“œìºìŠ¤íŠ¸
    virtual void BroadcastToClients(FOutBunch& Bunch)
    {
        for (UNetConnection* Connection : ClientConnections)
        {
            if (Connection && Connection->State == USOCK_Open)
            {
                Connection->SendRawBunch(Bunch, false);
            }
        }
    }
};

// ===== 2. UIpNetDriver (IP íŠ¹í™” ë“œë¼ì´ë²„) =====
class UIpNetDriver : public UNetDriver
{
public:
    // UDP ì†Œì¼“ (ì„œë²„ ë¦¬ìŠ¨ìš© ë˜ëŠ” í´ë¼ì´ì–¸íŠ¸ ë©”ì¸ ì†Œì¼“)
    TSharedPtr<FSocket> SocketPrivate;
    
    // ë¡œì»¬ ì£¼ì†Œ ì •ë³´
    TSharedPtr<FInternetAddr> LocalAddr;
    
    // ì—°ê²° ì—†ëŠ” íŒ¨í‚· ì²˜ë¦¬ê¸° (í•¸ë“œì…°ì´í¬ìš©)
    TUniquePtr<PacketHandler> ConnectionlessHandler;
    
    // ì£¼ì†Œ í•´ê²° ì‹œìŠ¤í…œ
    TPimplPtr<FNetDriverAddressResolution> Resolver;
    
    // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ë§µ (ì£¼ì†Œ -> ì—°ê²°)
    TMap<TSharedRef<const FInternetAddr>, UNetConnection*> MappedClientConnections;

    // íŒ¨í‚· ìˆ˜ì‹  ë° ì²˜ë¦¬
    virtual void TickDispatch(float DeltaTime) override
    {
        // ëª¨ë“  ìˆ˜ì‹  íŒ¨í‚· ì²˜ë¦¬
        for (FPacketIterator It(this); It; ++It)
        {
            FReceivedPacketView ReceivedPacket;
            if (It.GetCurrentPacket(ReceivedPacket))
            {
                UNetConnection* Connection = FindOrCreateConnection(ReceivedPacket);
                if (Connection)
                {
                    // ì—°ê²°ì˜ íŒ¨í‚· ì²˜ë¦¬ ë©”ì„œë“œ í˜¸ì¶œ
                    Connection->ReceivedRawPacket(
                        ReceivedPacket.DataView.GetData(),
                        ReceivedPacket.DataView.NumBytes()
                    );
                }
            }
        }
    }
};

// ===== 3. UNetConnection (ë„¤íŠ¸ì›Œí¬ ì—°ê²°) =====
class UNetConnection : public UObject
{
public:
    // ì´ ì—°ê²°ì´ ì†í•œ ë„¤íŠ¸ì›Œí¬ ë“œë¼ì´ë²„
    UNetDriver* Driver;
    
    // ì±„ë„ ë°°ì—´ - ì¸ë±ìŠ¤ë¡œ ê´€ë¦¬ (ì±„ë„ ID = ë°°ì—´ ì¸ë±ìŠ¤)
    TArray<UChannel*> Channels;
    
    // ì—´ë¦° ì±„ë„ë“¤ì˜ ë§µ (ë¹ ë¥¸ ê²€ìƒ‰ìš©)
    TMap<int32, UChannel*> OpenChannels;
    
    // ì—°ê²° ìƒíƒœ
    EConnectionState State;
    
    // íŒ¨í‚· ì‹œí€€ìŠ¤ ê´€ë¦¬
    int32 InPacketId;    // ìˆ˜ì‹  íŒ¨í‚· ID
    int32 OutPacketId;   // ì†¡ì‹  íŒ¨í‚· ID
    
    // ì‹ ë¢°ì„± ìˆëŠ” ì „ì†¡ ë²„í¼
    TArray<FOutBunch> OutReliable;
    
    // í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ (ê²Œì„ ë¡œì§ ì—°ê²°ì )
    APlayerController* PlayerController;

    // ì±„ë„ ìƒì„± ë° ê´€ë¦¬
    virtual UChannel* CreateChannelByName(const FName& ChName, EChannelCreateFlags CreateFlags, int32 ChannelIndex = INDEX_NONE)
    {
        UChannel* NewChannel = nullptr;
        
        // ì±„ë„ íƒ€ì…ì— ë”°ë¥¸ ìƒì„±
        if (ChName == NAME_Control)
        {
            NewChannel = NewObject<UControlChannel>(this);
        }
        else if (ChName == NAME_Actor)
        {
            NewChannel = NewObject<UActorChannel>(this);
        }
        else if (ChName == NAME_Voice)
        {
            NewChannel = NewObject<UVoiceChannel>(this);
        }
        
        if (NewChannel)
        {
            // ì±„ë„ ì¸ë±ìŠ¤ í• ë‹¹
            if (ChannelIndex == INDEX_NONE)
            {
                ChannelIndex = FindAvailableChannelIndex();
            }
            
            // ì±„ë„ ì´ˆê¸°í™”
            NewChannel->Connection = this;
            NewChannel->ChIndex = ChannelIndex;
            NewChannel->ChName = ChName;
            
            // ë°°ì—´ì— ì¶”ê°€ (í•„ìš”ì‹œ í¬ê¸° í™•ì¥)
            if (Channels.Num() <= ChannelIndex)
            {
                Channels.SetNum(ChannelIndex + 1);
            }
            Channels[ChannelIndex] = NewChannel;
            
            // ë§µì—ë„ ì¶”ê°€
            OpenChannels.Add(ChannelIndex, NewChannel);
        }
        
        return NewChannel;
    }
    
    // ì±„ë„ ì°¾ê¸°
    virtual UChannel* FindChannel(int32 ChannelIndex)
    {
        if (Channels.IsValidIndex(ChannelIndex))
        {
            return Channels[ChannelIndex];
        }
        return nullptr;
    }
    
    // ì•¡í„° ì±„ë„ ì°¾ê¸°
    virtual UActorChannel* FindActorChannelRef(const AActor* Actor)
    {
        for (UChannel* Channel : OpenChannels)
        {
            if (UActorChannel* ActorChannel = Cast<UActorChannel>(Channel))
            {
                if (ActorChannel->Actor == Actor)
                {
                    return ActorChannel;
                }
            }
        }
        return nullptr;
    }
    
    // íŒ¨í‚· ìˆ˜ì‹  ì²˜ë¦¬
    virtual void ReceivedRawPacket(uint8* Data, int32 Count)
    {
        // íŒ¨í‚· íŒŒì‹±
        FBitReader Reader(Data, Count * 8);
        
        while (!Reader.AtEnd())
        {
            // ë²ˆì¹˜(Bunch) ìˆ˜ì‹ 
            FInBunch Bunch(this);
            if (Bunch.ReceivedNextBunch(Reader))
            {
                // ì±„ë„ ì°¾ê¸°
                UChannel* Channel = FindChannel(Bunch.ChIndex);
                if (!Channel && Bunch.bOpen)
                {
                    // ìƒˆ ì±„ë„ ìƒì„±
                    Channel = CreateChannelByName(Bunch.ChName, CHCREATE_Default, Bunch.ChIndex);
                }
                
                if (Channel)
                {
                    // ì±„ë„ì—ì„œ ë²ˆì¹˜ ì²˜ë¦¬
                    Channel->ReceivedBunch(Bunch);
                }
            }
        }
    }
};

// ===== 4. UIpConnection (IP íŠ¹í™” ì—°ê²°) =====
class UIpConnection : public UNetConnection
{
public:
    // ê°œë³„ ì—°ê²°ìš© UDP ì†Œì¼“ (ì£¼ì†Œ í•´ê²° í›„ ìƒì„±)
    TSharedPtr<FSocket> SocketPrivate;
    
    // ì›ê²© ì£¼ì†Œ (ìƒëŒ€ë°©ì˜ IP:Port)
    TSharedPtr<FInternetAddr> RemoteAddr;
    
    // ë¡œì»¬ ì£¼ì†Œ
    TSharedPtr<FInternetAddr> LocalAddr;
    
    // ì—°ê²°ë³„ ì£¼ì†Œ í•´ê²° ì‹œìŠ¤í…œ
    TUniquePtr<FNetConnectionAddressResolution> Resolver;

    // ì›ê²© ì—°ê²° ì´ˆê¸°í™” (ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìƒì„±ì‹œ)
    virtual void InitRemoteConnection(UNetDriver* InDriver, FSocket* InSocket, const FURL& InURL, const FInternetAddr& InRemoteAddr, EConnectionState InState)
    {
        // ê¸°ë³¸ ì´ˆê¸°í™”
        Driver = InDriver;
        State = InState;
        
        // ì£¼ì†Œ ì„¤ì •
        RemoteAddr = InDriver->GetSocketSubsystem()->CreateInternetAddr();
        RemoteAddr->SetIp(InRemoteAddr.GetIp());
        RemoteAddr->SetPort(InRemoteAddr.GetPort());
        
        // ë¡œì»¬ ì£¼ì†Œ ì„¤ì •
        LocalAddr = InDriver->GetSocketSubsystem()->CreateInternetAddr();
        InSocket->GetAddress(*LocalAddr);
        
        // ì†Œì¼“ ì„¤ì • (ì£¼ì†Œ í•´ê²° í›„)
        SocketPrivate = MakeShareable(InSocket);
        
        // ê¸°ë³¸ ì±„ë„ë“¤ ìƒì„±
        CreateInitialChannels();
    }
    
    // ë¡œì»¬ ì—°ê²° ì´ˆê¸°í™” (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„œë²„ ì—°ê²° ìƒì„±ì‹œ)
    virtual void InitLocalConnection(UNetDriver* InDriver, FSocket* InSocket, const FURL& InURL, EConnectionState InState)
    {
        Driver = InDriver;
        State = InState;
        
        // ì„œë²„ ì£¼ì†Œ ì„¤ì •
        RemoteAddr = InDriver->GetSocketSubsystem()->CreateInternetAddr();
        bool bIsValid = false;
        RemoteAddr->SetIp(*InURL.Host, bIsValid);
        RemoteAddr->SetPort(InURL.Port);
        
        // ê¸°ë³¸ ì±„ë„ë“¤ ìƒì„± (ì•„ì§ ì†Œì¼“ì€ ì„¤ì • ì•ˆë¨ - ì£¼ì†Œ í•´ê²° ëŒ€ê¸°)
        CreateInitialChannels();
    }

private:
    void CreateInitialChannels()
    {
        // ì œì–´ ì±„ë„ ìƒì„± (í•­ìƒ ì¸ë±ìŠ¤ 0)
        UControlChannel* ControlChannel = Cast<UControlChannel>(
            CreateChannelByName(NAME_Control, CHCREATE_Default, 0)
        );
    }
};

// ===== 5. UChannel (ì±„ë„ ê¸°ë³¸ í´ë˜ìŠ¤) =====
class UChannel : public UObject
{
public:
    // ì´ ì±„ë„ì´ ì†í•œ ì—°ê²°
    UNetConnection* Connection;
    
    // ì±„ë„ ì¸ë±ìŠ¤ (ì—°ê²° ë‚´ì—ì„œ ê³ ìœ )
    int32 ChIndex;
    
    // ì±„ë„ ì´ë¦„/íƒ€ì…
    FName ChName;
    
    // ì±„ë„ ìƒíƒœ
    EChannelState State;
    
    // ì‹ ë¢°ì„± ìˆëŠ” ì „ì†¡ì„ ìœ„í•œ ì‹œí€€ìŠ¤ ê´€ë¦¬
    int32 NumInRec;    // ìˆ˜ì‹  ì‹œí€€ìŠ¤
    int32 NumOutRec;   // ì†¡ì‹  ì‹œí€€ìŠ¤

    // ë²ˆì¹˜ ìˆ˜ì‹  ì²˜ë¦¬ (íŒŒìƒ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„)
    virtual void ReceivedBunch(FInBunch& Bunch) {}
    
    // ë²ˆì¹˜ ì†¡ì‹ 
    virtual FPacketIdRange SendBunch(FOutBunch* Bunch, bool Merge)
    {
        return Connection->SendRawBunch(*Bunch, Merge);
    }
    
    // ì±„ë„ ë‹«ê¸°
    virtual void Close(EChannelCloseReason Reason)
    {
        if (Connection)
        {
            Connection->OpenChannels.Remove(ChIndex);
            if (Connection->Channels.IsValidIndex(ChIndex))
            {
                Connection->Channels[ChIndex] = nullptr;
            }
        }
        State = CHSTATE_Closed;
    }
};

// ===== 6. UControlChannel (ì œì–´ ì±„ë„) =====
class UControlChannel : public UChannel
{
public:
    // ì œì–´ ë©”ì‹œì§€ ì²˜ë¦¬
    virtual void ReceivedBunch(FInBunch& Bunch) override
    {
        // ì œì–´ ë©”ì‹œì§€ íƒ€ì… ì½ê¸°
        uint8 MessageType;
        Bunch << MessageType;
        
        switch (MessageType)
        {
            case NMT_Hello:         // ì´ˆê¸° ì—°ê²° ìš”ì²­
                HandleHelloMessage(Bunch);
                break;
            case NMT_Challenge:     // ì¸ì¦ ì±Œë¦°ì§€
                HandleChallengeMessage(Bunch);
                break;
            case NMT_Login:         // ë¡œê·¸ì¸ ìš”ì²­
                HandleLoginMessage(Bunch);
                break;
            case NMT_Welcome:       // ì„œë²„ í™˜ì˜ ë©”ì‹œì§€
                HandleWelcomeMessage(Bunch);
                break;
            case NMT_Join:          // ê²Œì„ ì°¸ê°€
                HandleJoinMessage(Bunch);
                break;
        }
    }

private:
    void HandleLoginMessage(FInBunch& Bunch)
    {
        // í”Œë ˆì´ì–´ ì •ë³´ ì½ê¸°
        FString PlayerName;
        FString UniqueId;
        Bunch << PlayerName << UniqueId;
        
        // í”Œë ˆì´ì–´ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„± ë° ì„¤ì •
        if (Connection->Driver->Notify)
        {
            Connection->PlayerController = Connection->Driver->Notify->NotifyAcceptingConnection();
            if (Connection->PlayerController)
            {
                Connection->PlayerController->NetConnection = Connection;
            }
        }
    }
};

// ===== 7. UActorChannel (ì•¡í„° ì±„ë„) =====
class UActorChannel : public UChannel
{
public:
    // ì´ ì±„ë„ì´ ë‹´ë‹¹í•˜ëŠ” ì•¡í„°
    AActor* Actor;
    
    // ë³µì œ ìƒíƒœ ì¶”ì 
    TMap<FName, FPropertyState> PropertyStates;
    
    // RPC í˜¸ì¶œ ê¸°ë¡
    TArray<FRPCCall> RecentRPCs;

    // ì•¡í„° ì„¤ì •
    virtual void SetChannelActor(AActor* InActor)
    {
        Actor = InActor;
        if (Actor)
        {
            Actor->NetDriverName = Connection->Driver->NetDriverName;
            Actor->SetNetConnection(Connection);
        }
    }
    
    // ì•¡í„° ë°ì´í„° ë³µì œ
    virtual void ReplicateActor()
    {
        if (!Actor || !Connection)
            return;
            
        FOutBunch Bunch(this, false);
        
        // ì•¡í„° í´ë˜ìŠ¤ ì •ë³´ ì „ì†¡ (ì²« ë³µì œì‹œ)
        if (!Actor->bNetStartup)
        {
            Bunch << Actor->GetClass();
            Actor->bNetStartup = true;
        }
        
        // í”„ë¡œí¼í‹° ë³µì œ
        for (UProperty* Property : Actor->GetClass()->GetReplicatedProperties())
        {
            if (ShouldReplicateProperty(Property))
            {
                SerializeProperty(Bunch, Property);
            }
        }
        
        // RPC ì „ì†¡
        for (const FRPCCall& RPC : RecentRPCs)
        {
            SerializeRPC(Bunch, RPC);
        }
        
        // ë²ˆì¹˜ ì „ì†¡
        if (Bunch.GetNumBits() > 0)
        {
            SendBunch(&Bunch, true);
        }
    }
    
    // ë²ˆì¹˜ ìˆ˜ì‹  ì²˜ë¦¬
    virtual void ReceivedBunch(FInBunch& Bunch) override
    {
        // ì•¡í„° ìƒì„± (í´ë¼ì´ì–¸íŠ¸ì—ì„œ)
        if (!Actor && Bunch.bOpen)
        {
            UClass* ActorClass;
            Bunch << ActorClass;
            
            if (ActorClass)
            {
                Actor = Connection->Driver->World->SpawnActor(ActorClass);
                SetChannelActor(Actor);
            }
        }
        
        if (Actor)
        {
            // í”„ë¡œí¼í‹° ì—…ë°ì´íŠ¸
            DeserializeProperties(Bunch);
            
            // RPC ì²˜ë¦¬
            DeserializeRPCs(Bunch);
        }
    }

private:
    bool ShouldReplicateProperty(UProperty* Property)
    {
        // ë³µì œ ì¡°ê±´ í™•ì¸ (ë”í‹° ì²´í¬, ê´€ë ¨ì„± ë“±)
        return true; // ê°„ë‹¨íˆ í•­ìƒ ë³µì œ
    }
};

// ===== 8. ì‚¬ìš© ì˜ˆì‹œ =====

// ì„œë²„ ì´ˆê¸°í™” ì˜ˆì‹œ
void InitializeGameServer()
{
    // 1. NetDriver ìƒì„±
    UIpNetDriver* NetDriver = NewObject<UIpNetDriver>();
    
    // 2. ì„œë²„ ë¦¬ìŠ¨ ì‹œì‘
    FURL ServerURL;
    ServerURL.Port = 7777;
    FString Error;
    
    if (NetDriver->InitListen(nullptr, ServerURL, false, Error))
    {
        UE_LOG(LogNet, Log, TEXT("Server listening on port 7777"));
        
        // 3. ì›”ë“œì— NetDriver í• ë‹¹
        GetWorld()->SetNetDriver(NetDriver);
    }
}

// í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì˜ˆì‹œ
void ConnectToGameServer()
{
    // 1. NetDriver ìƒì„±
    UIpNetDriver* NetDriver = NewObject<UIpNetDriver>();
    
    // 2. ì„œë²„ ì—°ê²°
    FURL ConnectURL;
    ConnectURL.Host = TEXT("127.0.0.1");
    ConnectURL.Port = 7777;
    FString Error;
    
    if (NetDriver->InitConnect(nullptr, ConnectURL, Error))
    {
        // 3. ServerConnectionì´ ìë™ ìƒì„±ë¨
        UIpConnection* ServerConn = Cast<UIpConnection>(NetDriver->ServerConnection);
        if (ServerConn)
        {
            UE_LOG(LogNet, Log, TEXT("Connected to server"));
            
            // 4. ì œì–´ ì±„ë„ì´ ìë™ ìƒì„±ë˜ì–´ í•¸ë“œì…°ì´í¬ ì§„í–‰
            UControlChannel* ControlChannel = Cast<UControlChannel>(ServerConn->FindChannel(0));
        }
    }
}

// ì•¡í„° ë³µì œ ì˜ˆì‹œ
void ReplicatePlayerToClients(APlayerController* Player)
{
    UIpNetDriver* NetDriver = Cast<UIpNetDriver>(GetWorld()->GetNetDriver());
    if (!NetDriver) return;
    
    // ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ í”Œë ˆì´ì–´ ì•¡í„° ë³µì œ
    for (UNetConnection* Connection : NetDriver->ClientConnections)
    {
        if (Connection && Connection->State == USOCK_Open)
        {
            // ì•¡í„° ì±„ë„ ìƒì„± ë˜ëŠ” ì°¾ê¸°
            UActorChannel* ActorChannel = Connection->FindActorChannelRef(Player);
            if (!ActorChannel)
            {
                // ìƒˆ ì•¡í„° ì±„ë„ ìƒì„±
                ActorChannel = Cast<UActorChannel>(
                    Connection->CreateChannelByName(NAME_Actor, CHCREATE_Default)
                );
                ActorChannel->SetChannelActor(Player);
            }
            
            // ì•¡í„° ë°ì´í„° ë³µì œ
            ActorChannel->ReplicateActor();
        }
    }
}
```
