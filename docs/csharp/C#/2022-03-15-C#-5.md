---
layout: default
title: "(ì˜ˆì „ìë£Œ) 5. ê¸°íƒ€ ë¬¸ë²•"
parent: (C#)
grand_parent: C#
nav_order: 99
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## var / object, Generic(ì¼ë°˜í™”)

* `var` : ì»´íŒŒì¼ëŸ¬ê°€ ì•Œì•„ì„œ ì»´íŒŒì¼ íƒ€ì„ì— ë³€ìˆ˜ì§€ì •
* `object` : C#ì˜ **ìµœìƒìœ„ ê°ì²´**ëŠ” objectì´ê³  int, floatë“± ëª¨ë‘ objectë¡œ êµ¬í˜„ë˜ì–´ ìˆìŒ. ë”°ë¼ì„œ ëª¨ë‘ objectë¡œ ë°›ì„ ìˆ˜ ìˆë‹¤. ë‹¨, objectëŠ” **ì°¸ì¡°í˜•**ìœ¼ë¡œë§Œ ë™ì‘í•¨ì„ ì£¼ì˜
    * ëª¨ë“  ë³€ìˆ˜ë¥¼ objectë¡œ ì‚¬ìš©í•˜ë©´ ë ê¹Œ? -> í˜•ë³€í™˜(boxing/unboxing)ê³¼ì •ì´ í•„ìš”í•˜ê¸°ì— overheadê°€ ë°œìƒí•˜ê²Œ ë¨ìœ¼ë¡œ ë¹„ì¶”ì²œ.

```csharp
object obj = 3;
int n = (int)obj;
```

ğŸ’ ì´ì œ ì¼ë°˜í™”ì— ëŒ€í•´ ì•Œì•„ë³´ì.<br>
ğŸ’ C++ì˜ Templateì´ë¼ ì´í•´í•˜ë©´ ëœë‹¤.

```csharp
class MyClass<T>
{
    T[] arr = new T[10];
}

MyClass<int> mcInt = new MyClass<int>();
```

```csharp
// í•¨ìˆ˜ë„ ì¼ë°˜í™”ê°€ ê°€ëŠ¥í•˜ë‹¤.
static void Test<T>(int i)
{

}
```

```csharp
// whereì„ í†µí•´ ì¼ë°˜í™”ì˜ ì¡°ê±´ì„ ì§€ì •ê°€ëŠ¥
class MyClass<T> where T : new()        // ìƒì„±ìë¥¼ ë¬´ì¡°ê±´ í¬í•¨í•´ë‹¬ë¼
class MyClass<T> where T : int          // intí˜•ìœ¼ë¡œ í•´ë‹¬ë¼
{
    // ...
}
```

---

## ì¶”ìƒí´ë˜ìŠ¤, interface

```csharp
class Monster
{
    public virtual void Shout() {}  // ì´ í•¨ìˆ˜ì˜ êµ¬í˜„ì„ ê°•ì œí•˜ê³  ì‹¶ë‹¤ë©´?
}

class Orc : Monster
{
    public override void Shout() {}
}
```

```csharp
abstract class Monster
{
    public abstract void Shout();   // í•¨ìˆ˜ì˜ êµ¬í˜„ì„ ê°•ì œí•œë‹¤.
}

class Orc : Monster
{
    public override void Shout() {}
}
```

```csharp
abstract class Flyable
{
    public abstract void Fly();
}

class Orc : Monster, Flyable        // Error - C#ì€ ë‹¤ì¤‘ìƒì†ì´ ë¶ˆê°€ëŠ¥
{
    public override void Shout() {}
    public override void Fly() {}
}
```

```csharp
// ì¸í„°í˜ì´ìŠ¤ë¡œ ë‹¤ì¤‘ìƒì†ì²˜ëŸ¼ êµ¬í˜„ì´ ê°€ëŠ¥í•´ ì§„ë‹¤.
interface iFlyable
{
    void Fly();
}

class Orc : Monster, iFlyable
{
    public override void Shout() {}
    public void Fly() {}
}

// (ì¥ì ) ì¸í„°í˜ì´ìŠ¤ë¡œ ì˜¤ë¸Œì íŠ¸ë¥¼ ë°›ì„ ìˆ˜ ìˆìŒ.
iFlyable flyable = new Orc();
```

---

## Property

```csharp
class Knight
{
    public int hp;  // publicì€ ì€ë‹‰ì„±ì— ìœ„í—˜!
}
```

```csharp
class Knight
{
    protected int hp;

    public int Hp
    {
        get { return hp; }
        set { hp = value; }
        // private set { hp = value; }  // ì ‘ê·¼ì§€ì •ì ì„ ì–¸ê°€ëŠ¥.
    }
}


Knight k = new Knight();

Knight.Hp = 100;
int h = Knight.Hp;
```

```csharp
// ë” í¸í•œê²Œ í•´ë³´ì
class Knight
{
    // ìœ„ì™€ ì™„ì „íˆ ë™ì¼í•œ í‘œí˜„
    public int Hp { get; set; }
    public int Hp { get; set; } = 100;  // ì´ˆê¸°í™” ë¬¸ë²•ë„ ì‚¬ìš©ê°€ëŠ¥.
}
```
---

## Delegate

ğŸ’ ì¼ì¢…ì˜ Call-Backì´ë¼ ìƒê°í•˜ì

```csharp
static void ButtonPressed()
{
    // ë²„íŠ¼ì´ í´ë¦­ë˜ì—ˆìŒì„ ë‹¤ë¥¸ê³³ì— ì•Œë¦¬ê³  ì‹¶ë‹¤.(Call-Back)
}
```

```csharp
static void ButtonPressed(/* Function */) // ì•Œë¦¼ì„ ë°›ì„ í•¨ìˆ˜ë¥¼ ì…ë ¥ë°›ê³ ,
{
    // ë²„íŠ¼í´ë¦­ì‹œ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” êµ¬ì¡°ë¡œ êµ¬í˜„í•´ë³´ì.
    // Call Function
}
```

```csharp
// delegate êµ¬í˜„
delegate int OnClicked();

static int TestDel()
{
    Console.WriteLine("hello");
    return 0;
}

static void ButtonPressed(OnClicked click)
{
    click();
}

// ì´ë ‡ê²Œ ì‚¬ìš©ê°€ëŠ¥.
ButtonPressed(TestDel);
```

```csharp
// ì´ëŸ°ê¸°ëŠ¥ë„ ê°€ëŠ¥
delegate int OnClicked();

static int TestDel()
{
    Console.WriteLine("hello");
    return 0;
}

static int TestDel2()
{
    Console.WriteLine("hello2");
    return 0;
}

static void ButtonPressed(OnClicked click)
{
    click();
}

OnClicked c = new OnClicked(TestDel);
c += TestDel2;
ButtonPressed(c);   // TestDel, TestDel2 ëª¨ë‘ í˜¸ì¶œë¨.
```

---

## Event

```csharp
// delegateë„ ì´ëŸ° ë¬¸ì œê°€ ìˆë‹¤.
delegate int OnClicked();

static int TestDel()
{
    Console.WriteLine("hello");
    return 0;
}

OnClicked c = new OnClicked(TestDel);
c();    // ì´ëŸ°ì‹ì˜ í˜¸ì¶œë„ ê°€ëŠ¥í•˜ë‹¤
// ì›í–ˆë˜ ê²ƒì€ ButtonPressedë‚´ì—ì„œ í˜¸ì¶œë˜ëŠ”ê²ƒì¸ë° ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì´ë‹¤.
```

```csharp
class InputManager
{
    public void Update()
    {
        if(Console.KeyAvailable == false)
            return;

        ConsoleKeyInfo info = Console.ReadKey();
        if(info.Key == ConsoleKey.A)
        {
            // í‚¤ ì…ë ¥ì„ í†µë³´í•œë‹¤. -> ì´ê±¸ ì–´ë–»ê²Œ í†µë³´í•  ê²ƒì¸ê°€?
        }
    }
}
```

```csharp
// delegateí™œìš©

class InputManager
{
    public delegate void OnInputKey();
    public event OnInputKey InputKey;

    public void Update()
    {
        if(Console.KeyAvailable == false)
            return;

        ConsoleKeyInfo info = Console.ReadKey();
        if(info.Key == ConsoleKey.A)
        {
            InputKey();
        }
    }
}

// ...

static void OnInputTest()
{
    Console.WriteLine("Input Received");
}


static void Main(string[] args)
{
    InputManager in = new InputManager();
    in.InputKey += OnInputTest;
    in.OnInputKey();    // Error - ê°•ì œ í˜¸ì¶œì€ ë¶ˆê°€ëŠ¥.

    while(true)
    {
        in.Update();
    }
}
```

---

## Lambda

```csharp
delegate bool ItemSelector(Item item);

static Item FindItem(ItemSelector selector) { /**/ }

// Lambda Function
Item item = FindItem((Item item) => { return item.ItemType == ItemType.Weapon; });

// ì¬í™œìš©ë„ ê°€ëŠ¥
ItemSelector s = new ItemSelector((Item item) => { return item.ItemType == ItemType.Weapon; });
Item item = FindItem(s);
```

```csharp
// ì´ëŸ°ì‹ìœ¼ë¡œ ì“¸ ìˆ˜ë„ ìˆë‹¤.
delegate Return MyFunc<T, Return>(T item);

static Item FindItem(MyFunc<Item, bool> s) { /**/ }
```

```csharp
// C#ì—ì„œ ë¯¸ë¦¬ ì§€ì›í•´ ì¤Œ -> Func
    // delegateë¥¼ ì§ì ‘ ì§€ì ‘ ì„ ì–¸í•˜ì§€ ì•Šì•„ë„ ì´ë¯¸ ë§Œë“¤ì–´ ë‘ 
        // ë°˜í™˜ì´ ìˆëŠ” ê²½ìš° -> Func
        // ì—†ëŠ” ê²½ìš° -> Action
static Item FindItem(Func<Item, bool> s) { /**/ }
```

---

## Exception

```csharp
try
{
    throw;
}
catch ( /* Exception ì¢…ë¥˜ */ ) {}
catch (Exception e)
{

}
finally
{

}
```

---

## Reflection

```csharp
class Monster
{
    public int hp;
    protected int attact;

    void Attack() {}
}

Monster monster = new Monster();
var type = monster.GetType();      // ìµœìƒìœ„ ê°ì²´ objectì— GetTypeì„ ë¯¸ë¦¬ ë§Œë“¤ì–´ ë‘ .

// í´ë˜ìŠ¤ ë‚´ë¶€ì •ë³´ë¥¼ ëŸ°íƒ€ì„ì— í™•ì¸í•˜ëŠ” ê²ƒì„ Reflectionì´ë¼ í•œë‹¤. ë°©ë²•ì€ ì•„ë˜ì™€ ê°™ë‹¤.
var fields = type.GetFields(System.Relfaection.BindingFlags.Public);

foreach(FieldInfo field in fields)
{
    Console.WriteLine(field);
}
```

```csharp
class Important : System.Attribute
{
    public string message;

    Important(string m) { this.message = m; }
}

class Monster
{
    // ì»´íŒŒì¼ëŸ¬ê°€ ëŸ°íƒ€ì„ì— ì²´í¬í• ìˆ˜ ìˆëŠ” ì£¼ì„ì´ ëœë‹¤.
    [Important("Very Important")]
    public int hp;
}

var fields = type.GetFields(System.Relfaection.BindingFlags.Public);

foreach(FieldInfo field in fields)
{
    Console.WriteLine(field.GetCustomAttributes()); // Very Important
}
```

---

## Nullable

```csharp
class Monster
{
    // ...
}

static Monster FindMonster(int id)
{
    // for~~
    return null;    // null ë¦¬í„´ì„ í†µí•´ ì—†ë‹¤ë¥¼ ì•Œë ¤ì¤„ ìˆ˜ ìˆë‹¤.
}
```

```csharp
static int Find()
{
    // intí˜•ì€ ì—†ë‹¤ë¥¼ ì–´ë–»ê²Œ í‘œí˜„í• ê¹Œ?
    return 0;
}

int? num = null;    // int? ìœ¼ë¡œ nullë¡œ ì‚¬ìš©ì´ ê°€ëŠ¥í•¨ì„ ì•Œë¦°ë‹¤.

if ( num.HasValue ) {} // null ì²´í¬ ë°©ë²•
if ( num != null ) {}
int b = num ?? 0; // null ì´ë©´ 0ì„ ë„£ì–´ë‹¬ë¼
```

```csharp
// ì¶”ê°€
Monster m = null;

int? id = m?.Id; // mì´ nullì´ ì•„ë‹ˆë©´ idë¥¼ ë°›ì•„ì™€ ë‹¬ë¼
```