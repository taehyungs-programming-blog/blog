---
layout: default
title: "12. atomic"
parent: (Concurrency)
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* `mutex` : **OS**ì—ì„œ ì œê³µí•˜ëŠ” ë™ê¸°í™” ë„êµ¬
* `atomic` : **CPU**ì—ì„œ ì œê³µí•˜ëŠ” ë™ê¸°í™” ë„êµ¬

```cpp
#include <iostream>
#include <thread>

long x = 0;

void foo()
{
    for(int i = 0; i < 100000; ++i)
    {
        ++x;
    }
}

int main()
{
    std::thread t1(foo);
    std::thread t2(foo);
    std::thread t3(foo);
    // 300000ì´ ê²°ê³¼ë¡œ ë‚˜ì˜¤ê²Œ ë ê¹Œ?
    // nope! ìŠ¤ë ˆë“œ ì„¸ì´í”„í•˜ì§€ ëª»í•˜ë‹¤
    t1.join();
    t2.join();
    t3.join();
}
```

```cpp
// ...

void foo()
{
    for(int i = 0; i < 100000; ++i)
    {
        // ê¸°ê²Œì–´ë¡œ ë³´ìë©´ ì•„ë˜ì™€ ê°™ë‹¤
        __asm
        {
            lock inc x
        }
    }
}

// ...
```

```cpp
#include <iostream>
#include <thread>
#include <windows.h>

long x = 0;

void foo()
{
    for(int i = 0; i < 100000; ++i)
    {
        InterlockedIncrement(&x);   // windowsì—ì„œ ì§€ì›í•´ì£¼ëŠ” í•¨ìˆ˜
        /*  // ì•„ë˜ì™€ ë™ì¼í•œ í‘œí˜„
        __asm
        {
            lock inc x
        }
        */
    }
}
```

```cpp
// C++ í‘œì¤€ì—ì„œë„ ì§€ì›í•œë‹¤.

#include <iostream>
#include <thread>
#include <atomic>

std::atomic<long> x{0}; // ì›ìì—°ì‚°ì´ ê°€ëŠ¥í•˜ê²Œ í•´ì¤€ë‹¤

void foo()
{
    for(int i = 0; i < 100000; ++i)
    {
        ++x;
    }
}

int main()
{
    std::thread t1(foo);
    std::thread t2(foo);
    std::thread t3(foo);
    t1.join();
    t2.join();
    t3.join();
}
```

```cpp
// ...

std::atomic<int> x{0};

void foo()
{
    for(int i = 0; i < 100000; ++i)
    {
        // ++x;
        x.fetch_add(1); // ê¸°ëŠ¥ì€ ìœ„ì™€ ë™ì¼, ë©”ëª¨ë¦¬ ìˆœì„œë¥¼ ì˜µì…˜ìœ¼ë¡œ ë„£ì„ìˆ˜ ìˆìŒ
        // x.fetch_add(1, std::memory_order_relaxed);   // ë©”ëª¨ë¦¬ ìˆœì„œì— ëŒ€í•œ ì„¤ëª…ì€ ë‹¤ìŒì—
    }
}

// ...
```

---

## lock-free

* OSì˜ ë™ê¸°í™” ë„êµ¬(mutex)ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ 
* CPU Levelì˜ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•´ ë™ê¸°í™” ì§„í–‰

```cpp
#include <iostream>
#include <thread>
#include <atomic>

struct Point { int x, y; }
struct Point3D { int x, y, z; }

std::atomic<int> at1;
// ì‚¬ìš©ìê°€ ë§Œë“  êµ¬ì¡°ì²´ë„ lock-freeë¡œ ë™ì‘ê°€ëŠ¥í• ê¹Œ
std::atomic<Point> at2;
std::atomic<Point3D> at3;

int main()
{
    ++at1;

    std::cout << at1.is_lock_free() << std::endl;       // okay
    std::cout << at2.is_lock_free() << std::endl;       // okay
    std::cout << at3.is_lock_free() << std::endl;       // fail - 64bitsë¥¼ ë„˜ì–´ê°€ê¸°ì— lock-freeë¡œ ë™ì‘í• ìˆœ ì—†ê³ , ê·¸ë˜ë„ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œë ¤ë©´ spin-lockì„ ì‚¬ìš©
}
```

```cpp
#include <iostream>
#include <atomic>

struct Point
{
    int x, y;
    Point() = default;

    Point(const Point&) {}  // Error - loadì‹œì— ë³µì‚¬ìƒì„±ì´ ë˜ì–´ì•¼í•˜ëŠ”ë° ê·¸ëŸ¼ atomicì„ ìœ ì§€í•  ìˆ˜ ì—†ë‹¤
    // ë§Œì•½ ë³µì‚¬ìƒì„±ìê°€ ì—†ë‹¤ë©´ ì—ëŸ¬ê°€ ì—†ì–´ì§„ë‹¤
};

std::atomic<Point> pt;

int main()
{
    Point ret = pt.load();
}
```

---

```cpp
#include <iostream>
#include <atomic>
#include <thread>
#include <mutex>

std::mutex m;

bool use_flag = false;

void work()
{
    //m.lock();
    // mutexë¥¼ ì“°ì§€ë§ê³  boolì„ ì´ìš©í• ìˆœ ì—†ì„ê¹Œ? -> busy waiting(í˜¹ì€ spin-lock)
        // busy waiting
            // sleepì„ í•˜ì§€ì•Šê³  ë£¨í”„ë¥¼ ëŒë©´ì„œ ëŒ€ê¸°
            // CPUìì›ì„ ê³„ì† ë‚­ë¹„í•˜ê¸°ì— ì¼ë°˜ì ìœ¼ë¡œ ì¢‹ì§€ëŠ” ì•ŠìŒ
            // ë‹¨, ê³µìœ ìì›ì„ ì°¸ì¡°í•˜ëŠ”ì‹œê°„ì´ ì§€ê·¹íˆ ì‘ì„ê²½ìš° ì˜¤íˆë ¤ ì¢‹ìŒ.(lockë³´ë‹¤ ë¹ ë¦„)

    while(use_flag);
    usg_flag = true;    // ì‚¬ìš©ì¤‘
    std::cout << "start. using shared resource" << std::endl;
    std::cout << "end. using shared resource" << std::endl;
    usg_flag = false;   // ì´ê²Œ ë©€í‹°ìŠ¤ë ˆë“œì— ì„¸ì´í”„í• ê¹Œ? -> ëŠë‚Œìƒ ì„¸ì´í”„ì§€ ì•ŠìŒ
    //m.unlock();
}

int main()
{
    std::jthread t1(work), t2(work);
}
```

ğŸ¦„ í•´ê²°í•´ë³´ì

* `std::atomic_flag`ë¥¼ ì´ìš©í•  ì˜ˆì •ì´ê³ 
    * ë™ì‘ì€ `std::atomic<bool>`ê³¼ ê±°ì˜ ìœ ì‚¬í•œë°
    * lock-free(CPU ëª…ë ¹ì—ì„œ ë™ê¸°í™” ì§€ì›)ì„ ì§€ì›í•˜ê³ 
    * ìµœì†Œì˜ ë©¤ë²„í•¨ìˆ˜ë¥¼ ì œê³µí•˜ê¸°ì— ì‹¤ìˆ˜ê°€ ì ë‹¤(store, loadì—†ìŒ)

```cpp
#include <iostream>
#include <atomic>
#include <thread>

// std::atomic_flag flag = ATOMIC_FLAG_INIT;
// C++20ì´í›„ì—ëŠ” ì´ˆê¸°í™”ë¥¼ êµ³ì´ í•˜ì§€ì•Šì•„ë„ ë¨
std::atomic_flag flag;  // falseë¡œ ì´ˆê¸°í™” ëœë‹¤.

void work()
{
    while(flag.test_and_set());
    usg_flag = true;
    std::cout << "start. using shared resource" << std::endl;
    std::cout << "end. using shared resource" << std::endl;
    flag.clear();   // flag = false
}

int main()
{
    std::jthread t1(work), t2(work);
}
```

---

## Example

```cpp
#include <iostream>
#include <atomic>
#include <thread>

class spinlock
{
    std::atomic_flag flag;
public:
    void lock() {while(flag.test_and_set());}
    void unlock() {flag.clear();}
};
spinlock spin;

void work()
{
    spin.lock();
    std::cout << "start. using shared resource" << std::endl;
    std::cout << "end. using shared resource" << std::endl;
    spin.unlock();
}
```

---

## atomic_ref(C++20)

```cpp
#include <iostream>
#include <atomic>
#include <thread>

struct Machine
{
    int data{0};
    int count{0};
};
Machine m;

void foo()
{
    // ë ˆí¼ëŸ°ìŠ¤ì²˜ëŸ¼ ë™ì‘í•˜ì§€ë§Œ ì•„í† ë¯¹
    std::atomic_ref<int> cnt{m.count};
    for(int i = 0; i < 1000000; i++)
    {
        //++(m.count);
        ++cnt;
    }
}

int main()
{
    {
        std::jthread t1(foo), t2(foo), t3(foo);
    }
    std::cout << m.count << std::endl;
}
```