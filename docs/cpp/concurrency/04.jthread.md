---
layout: default
title: "4. jthread"
parent: (Concurrency)
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ¦„ ê¸°ì¡´ threadì˜ ë¬¸ì œì ??

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std::literals;

void foo(int a, double d)
{
    std::cout << "start foo" << std::endl;
    std::this_thread::sleep_for(2s);
    std::cout << "finish foo" << std::endl;
}

int main()
{
    std::thread t(foo, 10, 3.4);
    t.join();
    // ë°˜ë“œì‹œ join, detachë¥¼ í•´ì•¼í•œë‹¤. -> ì†Œë©¸ìì—ì„œ ìë™ìœ¼ë¡œ joiní•˜ê²Œ í•´ì¤€ë‹¤ë©´??
}
```

```cpp
// ì´ë ‡ê²Œ í•´ê²°í•˜ê³¤ í–ˆë‹¤.
class mythread
{
    std::thread th;
public:
    template<typename F, typename ... ARGS>
    explicit mythread(F&& f, ARGS&& . args) : th(std::forward<F>(f), std::forward<ARGS>(args)...) {}
    
    ~mythread()
    {
        if(th.joinable())
            th.join();
    }
};
```

---

ğŸ¦„ ì´ê±¸ í‘œì¤€(C++20)ì—ì„œ ì§€ì›í•´ì¤Œ

```cpp
int main()
{
    std::jthread f(foo, 10, 3.4);
}
```

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std::literals;

void foo(int a, double d)
{
    for(int i = 0; i < 10; i++)
    {
        std::this_thread::sleep_for(500ms);
        std::cout << "foo : " << i << std::endl;
    }
}

void goo(std::stop_token token)
{
    for(int i = 0; i < 10; i++)
    {
        if(token.stop_requested())
        {
            std::cout << "ì¤‘ì§€ìš”ì²­" << std::endl;
            return;
        }
        std::this_thread::sleep_for(500ms);
        std::cout << "goo : " << i << std::endl;
    }
}

int main()
{
    std::jthread j1(foo);
    std::jthread j2(goo);
    std::this_thread::sleep_for(2s);

    // ì¤‘ì§€ìš”ì²­
    j1.request_stop();
    j2.request_stop();
}
```