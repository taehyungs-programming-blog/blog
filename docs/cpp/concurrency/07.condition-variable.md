---
layout: default
title: "7. condition variable"
parent: (Concurrency)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std::literals;

std::mutex m;
int shared_data = 0;

void consumer()
{
    // ì½ëŠ”ë‹¤
    std::lock_guard<std::mutex> lg(m);
    std::cout << "consume : " << shared_data << std::endl;
}

void producer()
{
    // ì“´ë‹¤
    std::lockguard<std::mutex> lg(m);
    shared_data = 100;
    std::cout << "produce : " << shared_data << std::endl;
}

int main()
{
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}

// ë§Œì•½ ì“°ê¸°ì „ì— ì½ëŠ” ê²½ìš°ê°€ ë°œìƒí•œë‹¤ë©´??
// ë°ì´í„°ê°€ ì¨ì§€ê³  ì½ê²Œ ë§Œë“¤ì–´ë³´ì
```

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
#include <condition_variable>
using namespace std::literals;

std::mutex m;
std::condition_variable cv;
int shared_data = 0;

void consumer()
{
    // std::lock_guard<std::mutex> lg(m);
    std::unique_lock<std::mutex> ul(m); // condition variableì€ unique_lockë§Œ ì§€ì›ë¨
    cv.wait(ul);    // waitì— ë“¤ì–´ê°€ë©´ lockì„ í’€ê³  ëŒ€ê¸°, ì‹ í˜¸ê°€ ì˜¤ë©´ ë‹¤ì‹œ lockì„ ê±¸ê³  ì•„ë˜ë¼ì¸ìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.
    std::cout << "consume : " << shared_data << std::endl;
}

void producer()
{
    {
        std::lockguard<std::mutex> lg(m);
        shared_data = 100;
        std::cout << "produce : " << shared_data << std::endl;
        // ì´ê±´ í•˜ë‚˜ì˜ íŒì¸ë° lockì„ í’€ê³  notify_oneì„ ì£¼ëŠ”ê²Œ ì‹ í˜¸ë¥¼ ë°”ë¡œ ë°›ì„ìˆ˜ ìˆì–´ì„œ ì†ë„ì—ì„œ ì¢‹ë‹¤
    }
    cv.notify_one();
}

int main()
{
    std::thread t1(producer);
    std::thread t2(consumer);
    t1.join();
    t2.join();
}
```

ğŸ¦„ ë˜ ë‹¤ë¥¸ ë¬¸ì œ ?

```cpp
void consumer()
{
    std::this_thread::sleep_for(200ms);
    std::unique_lock<std::mutex> ul(m);
    cv.wait(ul);        // 2. notifyë¥¼ ê¸°ë‹¤ë¦¬ê²Œ ë˜ë©´ì„œ ë¬´í•œì • ê¸°ë‹¤ë¦¬ê²Œ ëœë‹¤.
    std::cout << "consume : " << shared_data << std::endl;
}

void producer()
{
    {
        std::lockguard<std::mutex> lg(m);
        shared_data = 100;
        std::cout << "produce : " << shared_data << std::endl;
    }
    cv.notify_one();    // 1. notifyë¥¼ ë¨¼ì €ì£¼ê³ 
}
```

```cpp
std::mutex m;
std::condition_variable cv;
bool data_ready = false;
int shared_data = 0;

//...

void consumer()
{
    std::this_thread::sleep_for(200ms);
    std::unique_lock<std::mutex> ul(m);
    cv.wait(ul, []() { return data_ready; });
    std::cout << "consume : " << shared_data << std::endl;
}

void producer()
{
    {
        std::lockguard<std::mutex> lg(m);
        shared_data = 100;
        data_ready = true;
        std::cout << "produce : " << shared_data << std::endl;
    }
    cv.notify_one();
}
```

```cpp
// ë°©ë²• 2

std::mutex m;
std::condition_variable cv;
bool data_ready = false;
bool data_process = false;
int shared_data = 0;

//...

void consumer()
{
    std::unique_lock<std::mutex> ul(m);
    cv.wait(ul, []() { return data_ready; });
    std::cout << "consume : " << shared_data << std::endl;

    // ë°ì´í„°ê°€ ì˜ ë“¤ì–´ì™”ìŒì„ ì•Œë¦°ë‹¤
    data_process = true;
    ul.unlock();
    cv.notify_one();
}

void producer()
{
    {
        std::lockguard<std::mutex> lg(m);
        shared_data = 100;
        data_ready = true;
        std::cout << "produce : " << shared_data << std::endl;
    }
    cv.notify_one();

    std::unique_lock<std::mutex> ul(m);
    cv.wait(ul, [](){return data_process;});
}
```