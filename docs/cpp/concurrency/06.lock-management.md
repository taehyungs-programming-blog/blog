---
layout: default
title: "6. lock management"
parent: (Concurrency)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ¦„ `lock_guard`ì˜ í•„ìš”ì„±

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <exception>

std::mutex m;

void goo()
{
    m.lock();
    std::cout << "using shared data" << std::endl;
    throw std::exception();
    // m.unlock();
    // ì‹¤ìˆ˜ë¡œ unlockì„ í•˜ì§€ì•Šì•˜ë‹¤ë©´?
    // í˜¹ì€ lockì´í›„ì— exceptionì´ ë°œìƒí•˜ë‹¤ë©´?

    // -> ì‚¬ìš©ìê°€ unlockí•˜ê²Œ í•˜ì§€ë§ì
}

void foo()
{
    try
    {
        goo();
    }
    catch(...)
    {
        std::cout << "catch exception" << std::endl;
    }
}

int main()
{
    std::thread t1(foo);
    std::thread t2(foo);
    t1.join();
    t2.join();
}
```

```cpp
void goo()
{
    std::lock_guard<std::mutex> lg(m);
    std::cout << "using shared data" << std::endl;
    throw std::exception(); // ì˜ˆì™¸ë°œìƒì‹œ ì§€ì—­ë³€ìˆ˜ëŠ” ì•ˆì „í•˜ê²Œ í•´ì œê°€ ë˜ê¸°ì— unlockì´ í˜¸ì¶œë˜ê²Œ ëœë‹¤.
}
```

---

## `unique_lock`

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std::literals;

std::mutex m1, m2, m3;
std::timed_mutex tm1, tm2, tm3;

int main()
{
    std::unique_lock<std::mutex> u1;
    std::unique_lock<std::mutex> u2(m1);                    // m1.lock()ì„ í•´ë‹¬ë¼

    std::unique_lock<std::mutex> u3(m2, std::try_to_lock);  // m2.try_lock()ì„ í•´ë‹¬ë¼

    if(u3.owns_lock())
        std::cout << "acquire lock" << std::endl;
    else
        std::cout << "fail lock" << std::endl;

    m3.lock();
    std::unique_lock<std::mutex> u4(m3, std::adopt_lock);   // ì´ë¯¸ lockì„ íšë“í•œ ë®¤í…ìŠ¤ ê´€ë¦¬

    std::unique_lock<std::mutex> u5(tm1, std::defer_lock);  // ë‚˜ì¤‘ì— lockì„ í˜¸ì¶œì˜ˆì •
    auto ret = u5.try_lock_for(2s);

    std::unique_lock<std::mutex> u6(tm2, 2s);   // tm2.try_lock_for() ì‚¬ìš©
    std::unique_lock<std::mutex> u7(tm3, std::chrono::steady_clock::now() + 2s);
    // tm3.try_lock_until() ì‚¬ìš©
}
```

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std::literals;

std::timed_mutex m;

int main()
{
    std::unique_lock<std::timed_mutex> u1;
    std::unique_lock<std::timed_mutex> u2(m);

    u1 = u2;            // Error - ë³µì‚¬ ìƒì„±ì ì§€ì›ì•ˆí•¨
    u1 = std::move(u2); // Okay

    std::cout << u1.owns_lock() << std::endl;   // 1

    if(u1)
        std::cout << "acquire" << std::endl;
    
    u1.unlock();

    std::cout << u1.owns_lock() << std::endl;   // 0

    if(u1.try_lock_for(2s))
    {
        // ..
        u1.unlock();
    }

    u1.release();   // unlockì€ í•˜ì§€ì•Šê³  mutexì™€ ì—°ê²°ë§Œ ëŠëŠ”ë‹¤
}
```

---

## scoped_lock

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
using namespace std::literals;

struct Account
{
    std::mutex m;
    int money = 100;
};

void transfer(Account& acc1, Acount& acc2, int cnt)
{
    // ë°ë“œë½ì— ê±¸ë¦¬ê²Œëœë‹¤.
    acc1.m.lock();
    std::this_thread::sleep_for(10ms);
    acc2.m.lock();
    acc1.money -= cnt;
    acc2.money += cnt;
    std::cout << "finish transfer" << std::endl;
    acc2.m.unlock();
    acc1.m.unlock();
}

int main()
{
    Acount kim, lee;
    
    std::thread t1(transfer, std::ref(kim), std::ref(lee), 5);
    std::thread t2(transfer, std::ref(lee), std::ref(kim), 5);
    t1.join();
    t2.join();
}
```

```cpp
// í•´ê²°í•´ë³´ì(í•´ê²°ë°©ë²•ì€ ì„¸ ê°€ì§€)

// ...

void transfer(Account& acc1, Acount& acc2, int cnt)
{
    // (1) std::lock : ë°ë“œë½íšŒí”¼ê¸°ìˆ ì„ í†µí•´ ì—¬ëŸ¬ê°œì˜ mutexë¥¼ ì•ˆì „í•˜ê²Œ lock
    std::lock(acc1.m, acc2.m);

    // (2) ë½ê°€ë“œë¥¼ ì“°ê³ ì‹¶ë‹¤ë©´ ì•„ë˜ì²˜ëŸ¼ std::adopt_lockë¥¼ ì˜µì…˜ìœ¼ë¡œ ë„£ì
    // std::lock_guard<std::mutex> lg1(acc1.m, std::adopt_lock);
    // std::lock_guard<std::mutex> lg2(acc2.m, std::adopt_lock);

    // (3) (C++17) scopred_lock
    // std::scopred_lock lg(acc1.m,, acc2.m);

    acc1.money -= cnt;
    acc2.money += cnt;
    std::cout << "finish transfer" << std::endl;
    acc2.m.unlock();
    acc1.m.unlock();
}

// ...
```

---

## shared_lock

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <string_view>
using namespace std::literals;

std::shared_mutex m;
int share_data = 0;

void Writer()
{
    while(1)
    {
        m.lock();
        share_data = share_data + 1;
        std::cout << "Writer : " << share_data << std::endl;
        std::this_thread::sleep_for(1s);
        m.unlock();
        std::this_thread::sleep_for(10ms);
    }
}

void Reader(std::string_view name)
{
    while(1)
    {
        // ë½ê°€ë“œë¡œ ì²˜ë¦¬í•´ë³´ì
        m.lock_shared();
        std::cout << "Reader(" << name << ") : " << share_data << std::endl;
        std::this_thread::sleep_for(500ms);
        m.unlock_shared();
        std::this_thread::sleep_for(10ms);
    }
}

int main()
{
    std::thread t1(Writer);
    std::thread t2(Reader, "A");
    std::thread t3(Reader, "B");
    std::thread t4(Reader, "C");
    t1.join();
    t2.join();
    t3.join();
    t4.join();
}
```

```cpp
// ...

void Reader(std::string_view name)
{
    while(1)
    {
        std::shared_lock<std:shared_mutex> lg(m);
        std::cout << "Reader(" << name << ") : " << share_data << std::endl;
        std::this_thread::sleep_for(10ms);
    }
}

// ...
```