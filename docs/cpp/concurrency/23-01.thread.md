---
layout: default
title: "1. (2023) Thread ì‹¤í–‰"
parent: (Concurrency)
grand_parent: (C++)
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [ì°¸ê³  ì‚¬ì´íŠ¸ ğŸŒ](https://github.com/kasunindikaliyanage/cpp_concurrency_masterclass)

## Thread ì‹¤í–‰í•˜ê¸°

* ì„¸ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ì‹¤í–‰ê°€ëŠ¥

```cpp
#include <iostream>
#include <thread>

// ë°©ë²•1. - í•¨ìˆ˜ ë„£ê¸°
void func1()
{
	std::cout << "Hello from function \n";
}

// ë°©ë²•2. - class ë„£ê¸°
class my_class {

public:
	void operator()()
	{
		std::cout << "hello from the class with function call operator \n";
	}
};

int main()
{
	std::thread thread1(func1);

	my_class mc;
	std::thread thread2(mc);

	// ë°©ë²•3. lambda
	std::thread thread3([] {
		std::cout << "hello from the lambda \n";
		});

    // join - threadëŒ€ê¸°
	thread1.join();
	thread2.join();
	thread3.join();

    // detach - threadë¥¼ ë³„ë„ë¡œ ìƒê°
    thread1.detach();
	thread2.detach();
	thread3.detach();

	std::cout << "This is main thread \n";
}
```

---

## ë§¤ê°œë³€ìˆ˜ ë„£ê¸°

```cpp
#include <iostream>
#include <thread>
#include <chrono>

// 1. ë³µì‚¬
void func_1(int x, int y)
{
	std::cout << " X + Y = " << x + y << std::endl;
}

void run_code1()
{
	int p = 9;
	int q = 8;

	std::thread thread_1(func_1, p, q);

	thread_1.join();
}


// 2. ì°¸ì¡°
void func_2(int& x)
{
	while (true)
	{
		std::cout << "Thread_1 x value : " << x << std::endl;
		std::this_thread::sleep_for(std::chrono::milliseconds(1000));
	}
}

void run_code2()
{
	int x = 9;
	std::cout << "Main thread current value of X is : " << x << std::endl;
	std::thread thread_1(func_2, std::ref(x));
	std::this_thread::sleep_for(std::chrono::milliseconds(5000));

	x = 15;
	std::cout << "Main thread X value changed to : " << x << std::endl;
	thread_1.join();
}


int main()
{
	run_code1();
	//run_code2();
}
```

* ì—¬ê¸°ì„œ í—·ê°ˆë¦´ ë§Œí•œ ë¶€ë¶„ì€ ë‹¤ë¥¸ê±´ ì•„ë‹ˆê³  `std::ref(x)`
    * ì°¸ì¡°ì˜ wrapperë¼ ìƒê°í•˜ì
    * ì¼ë°˜ì ìœ¼ë¡  ì˜ ì‚¬ìš©ë˜ì§€ ì•Šê³  ì°¸ì¡°í˜•ì„ ê°•ì œí•˜ê³ ì í• ë•Œ ì‚¬ìš©ëœë‹¤. (threadì˜ ë§¤ê°œë³€ìˆ˜)

```cpp
// Ex
#include <iostream>
#include <functional>

void update_value(std::reference_wrapper<int> ref_val) {
    ref_val.get() = 20;  // get()ì„ ì‚¬ìš©í•˜ì—¬ ì°¸ì¡°ì— ì ‘ê·¼í•©ë‹ˆë‹¤.
}

int main() {
    int x = 10;
    // update_value(x);  // ì´ ì½”ë“œëŠ” ì»´íŒŒì¼ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
    update_value(std::ref(x));  // std::refë¥¼ ì‚¬ìš©í•˜ì—¬ xì˜ ì°¸ì¡°ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.
    std::cout << x << std::endl;  // ì¶œë ¥: 20
    return 0;
}
```

---

## Example

```cpp
int  main()
{
	int result = 0;
	std::vector<int> vec(10000);
	for (int i = 0; i < 10000; i++)
		vec[i] = 2;

        // parallel_accumulateë¼ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ 
        // std::vectorì˜ intë¥¼ ëª¨ë‘ ë”í•˜ëŠ” multithread í•¨ìˆ˜ë¥¼ ë§Œë“œë ¤í•œë‹¤
	parallel_accumulate(vec.begin(), vec.end(), result);

	std::cout << "final result = " << result << std::endl;
}
```

```cpp
// êµ¬í˜„

#pragma once

#include <thread>
#include <numeric>
#include <algorithm>
#include <vector>
#include <functional>

template<typename iterator, typename T>
void accumulate(iterator first, iterator last, T& val)
{
	val = std::accumulate(first, last, val);
}

template<typename iterator, typename T>
void parallel_accumulate(iterator start, iterator end, T& ref)
{
	unsigned MIN_BLOCK_SIZE = 1000;

	unsigned distance = std::distance(start, end);
	unsigned allowed_threads_by_elements = (distance + 1) / MIN_BLOCK_SIZE;
	unsigned allowed_threads_by_hardware = std::thread::hardware_concurrency();

	if (allowed_threads_by_hardware < 1)
		allowed_threads_by_hardware = 2;

	unsigned allowed_threads = std::min(allowed_threads_by_elements,
		allowed_threads_by_hardware);

	unsigned block_size = (distance + 1) / allowed_threads;

	std::vector<T> results(allowed_threads);
	std::vector<std::thread> threads(allowed_threads - 1);

	iterator last;
	for (unsigned i = 0; i < allowed_threads - 1; i++)
	{
		last = start;
		std::advance(last, block_size);
		threads[i] = std::thread(accumulate<iterator, T>, start, last,
			std::ref(results[i]));
		start = last;
	}

	results[allowed_threads - 1] =
		std::accumulate(start, end, results[allowed_threads - 1]);

	for_each(threads.begin(), threads.end(), std::mem_fn(&std::thread::join));
	ref = std::accumulate(results.begin(), results.end(), ref);
}
```

* ë‹¤ë¥¸ê±° ë³´ë‹¤ `std::mem_fn(&std::thread::join)`ì´ê²Œ ë­”ê°€ í—·ê°ˆë¦¬ëŠ”ë°
    * `std::mem_fn` - ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì½œ í•´ì£¼ì„¸ìš”
    * `std::thread::join` - joinì´ë¼ëŠ” ë©¤ë²„ í•¨ìˆ˜ìš”! ì´ ë§ì„


