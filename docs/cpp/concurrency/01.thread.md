---
layout: default
title: "1. Thread"
parent: (Concurrency)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [ì›ë³¸ ğŸŒ](https://easycoding-7.github.io/blog/cpp/concurrency-new/2/#/)

## thread ë§Œë“¤ê¸°

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std::literals;

void foo()
{
    for(int i = 0; i < 10; i++)
    {
        std::cout << "foo : " << i << std::endl;
        std::this_thread::sleep_for(100ms);
    }
}

int main()
{
    // ê°ì²´ ìƒì„±ì´ ê³§ ìŠ¤ë ˆë“œ ìƒì„±ì´ ëœë‹¤.
    std::thread t(&foo);
    t.join();   // OR t.detach();
}
```

---

## ë§¤ê°œë³€ìˆ˜ ë„˜ê¸°ê¸°

```cpp
#include <iostream>
#include <thread>
#include <string>

void f1() {}
void f2(int a, double d) {}
void f3(int a, int& b, std::string&& s) { b = 100; }

int main()
{
    int n = 0;
    std::string s = "hello";

    std::thread t1(&f1);
    std::thread t2(&f2, 10, 3.4);
    std::thread t3(&f3, 10, std::ref(n), std::move(s)); // ê·¸ëƒ¥ nìœ¼ë¡œ ë„˜ê¸°ë©´ ì•ˆë¨ì„ ê¸°ì–µ
    t1.join();
    t2.join();
    t3.join();

    std::cout << s << std::endl;    // ""
    std::cout << n << std::endl;    // 100
}
```

---

## callable object ì •ë¦¬

```cpp
#include <iostream>
#include <thread>

void foo(int a, double d) {}

struct Machine
{
    void Run(int a, double d) {}
};

struct Work
{
    void operator()(int a, double b) const {}
};

int main()
{
    Machine m;
    Work w;

    std::thread t1(&foo, 1, 3.4);                           // ì¼ë°˜í•¨ìˆ˜
    std::thread t2(&Machine::Run, &m, 1, 3.4);              // ë§´ë²„í•¨ìˆ˜
    std::thread t3(w, 1, 3.4);                              // í•¨ìˆ˜ê°ì²´
    std::thread t4([]{std::cout << "lambda" << std::endl;}) // ëŒë‹¤
    t1.join();
    t2.join();
    t3.join();
    t4.join();
}
```

---

## ref

```cpp
#include <iostream>
#include <functional>

void foo(int& a) { a = 200; }

template<typename T> void call_foo(T arg)
{
    foo(arg);
}

int main()
{
    int n = 0;

    call_foo(std::ref(n)); 

    std::cout << n << std::endl;    // 200
    // ì´ê²Œ ì–´ë–»ê²Œ ê°€ëŠ¥í•˜ì§€?
}
```

---

## thread copy, move

```cpp
#include <thread>

void foo() {}
void goo() {}

int main()
{
    std::thread t1(&foo);
    std::thread t2(&goo);

    t1.swap(t2);
    // t1 : goo / t2 : foo ì‹¤í–‰

    std::thread t3 = t1;    // Error
    std::thread t4 = std::move(t1); 

    //t1.join();
    t2.join();
    t3.join();
}
```

---

## ìœ ìš©í•œ thread í•¨ìˆ˜

### `native_handle_type`

```cpp
#include <iostream>
#include <thread>
#include <windows.h>
#include <chrono>
using namespace std::literals;

void foo()
{
    // threadì˜ í•¸ë“¤ ì–»ê¸°
    auto tid = std::this_thread::get_id();
    auto handle = GetCurrentThread();
    std::this_thread::sleep_for(1s);
    std::cout << GetThreadPriority(handle) << std::endl;
}

int main()
{
    std::thread t(&foo);
    std::thread::native_handle_type h = t.native_handle();  // OSì˜ ìŠ¤ë ˆë“œ í•¸ë“¤ ë°˜í™˜

    std::cout << "ID : " << t.get_id() << std::endl;
    std::cout << "handle : " << h << std::endl;

    std::this_thread::sleep_for(100ms);
    // threadì˜ ìš°ì„ ìˆœìœ„ ë³€ê²½
    SetThreadPriority(h, THREAD_PRIORITY_TIME_CRITICAL);
    t.join();
}
```

---

### `hardware_concurrency()`

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std::literals;

void foo()
{
    std::cout << std::this_thread::get_id() << std::endl;
}

int main()
{
    int n = std::thread::hardware_concurrency();    // CPUê°€ ì§€ì›í•˜ëŠ” threadê°œìˆ˜
    std::cout << n << std::endl;

    std::thread t(&foo);
    std::this_thread::sleep_for(1s);

    std::thread::id tid = t.get_id();
    std::cout << tid << std::endl;
    t.join();
}
```

---

### `get_id()`

```cpp
#include <iostream>
#include <thread>

int main()
{
    // í˜„ threadì˜ idê°’ì„ ë°˜í™˜
    std::cout << std::this_thread::get_id() << std::endl;

    std::thread::id tid1 = std::this_thread::get_id();
    std::thread::id tid2 = std::this_thread::get_id();

    // std::this_thread::get_id()ì˜ ë¦¬í„´ì´ intê°’ì´ ì•„ë‹ˆë¼ std::thead::idë¼ëŠ” ê°’
    // ì•„ë˜ì™€ ê°™ì´ ë¹„êµì—°ì‚°ë„ ê°€ëŠ¥
    // ë‹¨, ì •ìˆ˜ë³€í™˜ì€ ë¶ˆê°€ëŠ¥!
    tid1 == tid2;
    tid1 < tid2;

    // keyê°’ìœ¼ë¡œ ì‚¬ìš©ì´ ê°€ëŠ¥
    std::hash<std::thread:id> h;

    std::cout << h(tid1) << std::endl;
}
```

---

### `sleep()`

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std::literals;

int main()
{
    // sleep_for() : ì´ ì‹œê°„ ë™ì•ˆ ë©ˆì¶°ì£¼ì„¸ìš”
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::this_thread::sleep_for(3s);
    std::this_thread::sleep_for(3);

    // sleep_until() : ì´ ì‹œê°„ ê¹Œì§€ ë©ˆì¶°ì£¼ì„¸ìš”
    std::chrono::time_point tp1 = std::chrono::steady_clock::now(); // í˜„ì¬ì‹œê°„
    std::this_thread::sleep_until(tp1 + 2000ms);

    auto tp2 = createDataTime(2021, 4, 11, 12, 39, 00); // íŠ¹ì •ë‚ ìì— ê¹¨ìš°ë ¤ë©´
    std::this_thread::sleep_until(tp2);
}
```

---

### `yield()`

```cpp
#include <iostream>
#include <thread>
#include <chrono>
using namespace std::literals;

void mysleep(std::chrono::microseconds us)
{
    auto target = std::chrono::high_resolution_clock::now() + us;

    while(std::chrono::high_resolution_clock::now() < target)
        std::this_thread::yield();
        // í˜„ì¬ ìŠ¤ë ˆë“œì˜ ì‹¤í–‰íë¦„ì„ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ë„˜ê¸´ë‹¤
}

int main()
{
    mysleep(10ms);
}
```

---

