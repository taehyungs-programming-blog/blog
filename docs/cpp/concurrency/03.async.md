---
layout: default
title: "3. std::async"
parent: (Concurrency)
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## C++ì—ì„œëŠ” Threadë¥¼ ë§Œë“œëŠ” ì„¸ ê°€ì§€ ë°©ë²•ì´ ì¡´ì¬í•œë‹¤.

1. `std::thread`
2. `std:jthread` (C++20)
3. `std::async` ğŸ‘ˆ ì´ê±¸ ì•Œì•„ë³´ì.

---

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <future>
using namespace std::literals;

int add(int a, int b)
{
    std::this_thread::sleep_for(2s);
    return a+b;
}

int main()
{
    // add(10, 20);                                   // ë™ê¸°
    std::future<int> ft = std::async(add, 10, 20);    // ë¹„ë™ê¸°

    int ret = ft.get();
    std::cout << "result : " << ret << std::endl;
}
```

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <future>
using namespace std::literals;

int add(int a, int b)
{
    std::cout << "add : " << std::this_thread::get_id() << std::endl;
    std::this_thread::sleep_for(2s);
    return a+b;
}

int main()
{
    // std::launch::async : ë¹„ë™ê¸°ë¡œ ë§Œë“¤ì–´ ì£¼ì„¸ìš”
    std::future<int> ft = std::async(std::launch::async, add, 10, 20);

    // std::launch::deferred : ì§€ì—°ëœ ì‹¤í–‰ìœ¼ë¡œ ë§Œë“¤ì–´ ì£¼ì„¸ìš”(getì—ì„œ ì‹¤í–‰í•´ ì£¼ì„¸ìš”)
    std::future<int> ft = std::async(std::launch::deferred, add, 10, 20);

    // std::launch::async | std::launch::deferred : ë¹„ë™ê¸° ì§€ì—°ëœ ì‹¤í–‰ìœ¼ë¡œ í•´ì£¼ì„¸ìš”
    std::future<int> ft = std::async(std::launch::async | std::launch::deferred, add, 10, 20);

    // í™˜ê²½ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤(ëŒ€ë¶€ë¶„ì€ ì§€ì—°ëœ ì‹¤í–‰ì— ë¹„ë™ê¸°)
    std::future<int> ft = std::async(add, 10, 20);

    std::cout << "continue main : " << std::this_thread::get_id() << std::endl;
    std::this_thread::sleep_for(2s);
    int ret = ft.get();
    std::cout << "result : " << ret << std::endl;
}
```

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <future>
using namespace std::literals;

int add(int a, int b)
{
    std::cout << "start add" << std::endl;
    std::this_thread::sleep_for(2s);
    std::cout << "finish add" << std::endl;
    return a+b;
}

int main()
{
    std::future<int> ft = std::async(std::launch::async, add, 10, 20);

    std::cout << "continue main" << std::endl;

    // int ret = ft.get();
    // getì„ í˜¸ì¶œì•ˆí•œë‹¤ë©´
    // addëŠ” í˜¸ì¶œì´ ë˜ì§€ ì•Šì„ê¹Œ??
    // Nope! -> futureì˜ ì†Œë©¸ìì—ì„œ getì´ ìë™í˜¸ì¶œë˜ì–´ addê°€ í˜¸ì¶œë˜ê²Œ ëœë‹¤.
}
```

---

## ì—¬ê¸°ì„œ ë“œëŠ” ì˜ë¬¸? thread + detachë‘ ë­ê°€ ë‹¤ë¥´ì§€?

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <chrono>

int calculate_value() {
    std::cout << "ì‘ì—… ì‹œì‘ (async)" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "ì‘ì—… ì™„ë£Œ (async)" << std::endl;
    return 42;
}

int main() {
    std::cout << "ë©”ì¸ í•¨ìˆ˜ ì‹œì‘" << std::endl;
    
    // std::async ì‚¬ìš©
    std::future<int> future_result = std::async(std::launch::async, calculate_value);
    
    std::cout << "ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰ ì¤‘..." << std::endl;
    
    // ê²°ê³¼ ê°€ì ¸ì˜¤ê¸° (í•„ìš”ì‹œ ëŒ€ê¸°)
    int result = future_result.get();
    std::cout << "ê²°ê³¼: " << result << std::endl;
    
    std::cout << "ë©”ì¸ í•¨ìˆ˜ ì¢…ë£Œ" << std::endl;
    return 0;
}
```

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>

std::mutex cout_mutex;

void calculate_value_thread() {
    {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "ì‘ì—… ì‹œì‘ (thread+detach)" << std::endl;
    }
    
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    {
        std::lock_guard<std::mutex> lock(cout_mutex);
        std::cout << "ì‘ì—… ì™„ë£Œ (thread+detach)" << std::endl;
    }
    
    // ë°˜í™˜ê°’ì„ ë©”ì¸ ìŠ¤ë ˆë“œì— ì „ë‹¬í•  ë°©ë²•ì´ ì—†ìŒ
}

int main() {
    std::cout << "ë©”ì¸ í•¨ìˆ˜ ì‹œì‘" << std::endl;
    
    // thread+detach ì‚¬ìš©
    std::thread worker_thread(calculate_value_thread);
    worker_thread.detach();
    
    std::cout << "ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰ ì¤‘..." << std::endl;
    
    // ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ë°©ë²•ì´ ì—†ìŒ
    // ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë˜ë©´ í”„ë¡œê·¸ë¨ì´ ëë‚  ìˆ˜ ìˆìŒ
    
    // ë°ëª¨ë¥¼ ìœ„í•´ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ì ì‹œ ëŒ€ê¸°
    std::this_thread::sleep_for(std::chrono::seconds(3));
    
    std::cout << "ë©”ì¸ í•¨ìˆ˜ ì¢…ë£Œ" << std::endl;
    return 0;
}
```

### ì£¼ìš” ì°¨ì´ì 

* ê²°ê³¼ ë°˜í™˜:
    * `std::async`: future ê°ì²´ë¥¼ í†µí•´ ë¹„ë™ê¸° ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ë°›ì„ ìˆ˜ ìˆë‹¤.
    * `thread+detach`: ë¶„ë¦¬ëœ ìŠ¤ë ˆë“œì—ì„œ ê²°ê³¼ë¥¼ **ì§ì ‘ ë°›ì„ ë°©ë²•ì´ ì—†ë‹¤.** ê³µìœ  ë³€ìˆ˜ë‚˜ ì½œë°± ë“± ë³„ë„ì˜ ë©”ì»¤ë‹ˆì¦˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
* ìˆ˜ëª… ê´€ë¦¬:
    * `std::async`: future ê°ì²´ê°€ ì†Œë©¸ë  ë•Œ ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ìë™ìœ¼ë¡œ ëŒ€ê¸°(launch::async ì‚¬ìš© ì‹œ).
    * `thread+detach`: ìŠ¤ë ˆë“œê°€ ë¶„ë¦¬ë˜ë©´ ë©”ì¸ í”„ë¡œê·¸ë¨ê³¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰ë˜ë©°, ë©”ì¸ í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë˜ë©´ ë¶„ë¦¬ëœ ìŠ¤ë ˆë“œë„ ê°•ì œ ì¢…ë£Œë  ìˆ˜ ìˆë‹¤.
* ì˜ˆì™¸ ì²˜ë¦¬:
    * `std::async`: ë¹„ë™ê¸° ì‘ì—…ì—ì„œ ë°œìƒí•œ ì˜ˆì™¸ê°€ `future.get()` í˜¸ì¶œ ì‹œ ë©”ì¸ ìŠ¤ë ˆë“œë¡œ ì „íŒŒ.
    * `thread+detach`: ë¶„ë¦¬ëœ ìŠ¤ë ˆë“œì—ì„œ ë°œìƒí•œ ì˜ˆì™¸ëŠ” ë©”ì¸ ìŠ¤ë ˆë“œë¡œ ì „íŒŒë˜ì§€ ì•Šê³ , í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ìˆ˜ ìˆë‹¤.
* ìŠ¤ë ˆë“œ í’€ ì‚¬ìš©:
    * `std::async`: êµ¬í˜„ì— ë”°ë¼ ìŠ¤ë ˆë“œ í’€ì„ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ íš¨ìœ¨ì ì¸ ìŠ¤ë ˆë“œ ê´€ë¦¬ê°€ ê°€ëŠ¥.
    * `thread+detach`: í•­ìƒ ìƒˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ë¯€ë¡œ ë§ì€ ì‘ì—…ì„ ì‹¤í–‰í•  ë•Œ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
