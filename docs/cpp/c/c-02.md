---
layout: default
title: "02. 실수형과 부동소수점 오차"
parent: "(C)"
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 부동소수점 오차

* `float`(단정도, 32bits)
    * 유효 자릿수 - 소수점 이하 **6자리**
    * 이제 연산에선 `float`을 쓰지 않는 추세, 해상도가 너무낮음
* `double`(배정도, 64bits)
    * 유효 자릿수 - 소수점 이하 **15자리**
* `long double`(특수정도, 79bits)
    * 대부분 컴파일러에서 double로 자동변환됨
* **부동소수점으로 비교연산을 하면 위험할 수 있음**

---

* 일단, 단정도(float), 배정도(double)모두 지수, 가수 형태로 표현함을 기억하자
* 그리고 그 표현법은 아래와 같이 나뉜다

## float(단정도 형식)

```
| S | 8 bit 지수 | 23 bit 가수 |
```

```cpp
float fdata = 123.125F;
printf("%f\n", fdata);  // 0x42f64000
// 0x42f64000를 위 대로 뜯어서 분석해야함.
```

### **IEEE 754** 에 의한 float 형식변환

* 123.125F를 형변환하려 한다
    * **부호** - 양수이기에 부호비트는 0
    * **상수** - 123은 `1111 011` -> 그냥 2진수로 만들면 됨
    * **소수** - 0.125는 001 -> 0.125 * 2 = 0.25 (정수자리 0) -> 0.25 * 2 = 0.5 (정수자리 0) -> 0.5 * 2 = 1 (정수자리 1) -> 0.0 * 2 = 0
    * 여기까지하면 -> `1111 011(상수) . 001(소수)` 가 된다.
    * .을 올리면 `1.111011001`이되고 왼쪼으로 6칸을 옮겼기에 `2^6`이 된다.(부동소수점이라 불리는 이유)
    * **지수자리 표현** - 여기서 끝이 아닌게 옮겨진 지수 **6**에 **Bias 127**을 더하면(Bias는 단정도, 배정도에 따라 다름) 133이 되며
    * 133을 2진수로 변환시 `1000 0101`로 8bit지수자리 표현
    * **가수자리 표현** - `1.111011001`에서 `1.`을 빼고 `111011001`의 오른쪽에 0을 채워 23비트(가수)로 만들시 `1110 1100 1000 0000 0000 000`
    * 부호 + 지수부 + 가수부 모두 합칠시 -> `0 1000 0101 1110 1100 1000 0000 0000 000`가 된다
    * 마지막으로 Little Ending은 뒤집어주면 끝!

---

## double(배정도 형식)

* 계산법은 단정도와 동일하고 아래 bit, Bias가 달라진다

```
| S | 11 bit 지수 | 52 bit 가수 |
```