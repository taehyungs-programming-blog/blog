---
layout: default
title: "3. WebCam rgb로 뽑아 출력하기"
parent: (DShow)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get This Code 🌎](https://github.com/EasyCoding-7/dshow-basic/tree/main/dshow-basic-4)

😺 WebCam정보를 이미지 프로세싱 등을 위해 rgb로 뽑아야 하는 경우가 있다. 해당 경우의 Example 코드이다.

* [SampleGrabber Example Github 🌍](https://github.com/chuckfairy/node-webcam/blob/master/src/bindings/CommandCam/CommandCam.cpp)

---

## 실패기

😺 꼭 안봐도 됨.

```cpp
// dshow-basic-2.cpp : 애플리케이션에 대한 진입점을 정의합니다.
//

#include "stdafx.h"
#include "framework.h"
#include "dshow-basic-2.h"
#include "qedit.h"
#include <wingdi.h>

#pragma warning(disable: 4996)
#define MAX_LOADSTRING 100

// Playback
IGraphBuilder* pGraphBuilder = NULL;
ICaptureGraphBuilder2* pCaptureGraphBuilder2 = NULL;
IMediaControl* pMediaControl = NULL;
IMediaEventEx* pEvent = NULL;
ISampleGrabber* pGrabber = NULL;
IBaseFilter* pDeviceFilter = NULL;
IAMStreamConfig* pStreamConfig = NULL;
BYTE *pBuffer = NULL;
BYTE* videoCaps = NULL;
AM_MEDIA_TYPE** mediaTypeArray = NULL;

// Device selection
ICreateDevEnum* pCreateDevEnum = NULL;
IEnumMoniker* pEnumMoniker = NULL;
IMoniker* pMoniker = NULL;
ULONG nFetched = 0;

BOOL StartCapture(void);

// 전역 변수:
HWND hWnd;
HINSTANCE hInst;                                // 현재 인스턴스입니다.
WCHAR szTitle[MAX_LOADSTRING];                  // 제목 표시줄 텍스트입니다.
WCHAR szWindowClass[MAX_LOADSTRING];            // 기본 창 클래스 이름입니다.

// 이 코드 모듈에 포함된 함수의 선언을 전달합니다:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int, HWND&);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
HRESULT WriteBitmap(PCWSTR pszFileName, BITMAPINFOHEADER* pBMI, size_t cbBMI, BYTE* pData, size_t cbData);

void CheckError(HRESULT r) {
    if (FAILED(r)) {
        printf("FAILED : %x\n", r);
    }
    else if (SUCCEEDED(r)) {
        printf("SUCCEEDED\n");
    }
}

static inline bool PinIsDirection(IPin* pin, PIN_DIRECTION dir)
{
    if (!pin)
        return false;

    PIN_DIRECTION pinDir;
    return SUCCEEDED(pin->QueryDirection(&pinDir)) && pinDir == dir;
}

static inline bool PinNameIs(IPin* pin, const wchar_t* name)
{
    if (!pin)
        return false;
    if (!name)
        return true;

    PIN_INFO pinInfo;

    if (FAILED(pin->QueryPinInfo(&pinInfo)))
        return false;

    if (pinInfo.pFilter)
        pinInfo.pFilter->Release();

    return wcscmp(name, pinInfo.achName) == 0;
}

bool GetPinByName(IBaseFilter* filter, PIN_DIRECTION dir, const wchar_t* name,
    IPin** pin)
{
    ComPtr<IPin> curPin;
    ComPtr<IEnumPins> pinsEnum;
    ULONG num;

    if (!filter)
        return false;
    if (FAILED(filter->EnumPins(&pinsEnum)))
        return false;

    while (pinsEnum->Next(1, &curPin, &num) == S_OK) {
        if (PinIsDirection(curPin, dir) && PinNameIs(curPin, name)) {
            *pin = curPin.Detach();
            return true;
        }
    }

    return false;
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    int ret = -1;

    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    __try
    {
        UNREFERENCED_PARAMETER(hPrevInstance);
        UNREFERENCED_PARAMETER(lpCmdLine);

        // TODO: 여기에 코드를 입력합니다.

        // 전역 문자열을 초기화합니다.
        LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
        LoadStringW(hInstance, IDC_DSHOWBASIC2, szWindowClass, MAX_LOADSTRING);
        MyRegisterClass(hInstance);

        // 애플리케이션 초기화를 수행합니다:
        if (!InitInstance(hInstance, nCmdShow, hWnd))
        {
            return FALSE;
        }

        HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_DSHOWBASIC2));

        MSG msg;

        ret = StartCapture();

        // 기본 메시지 루프입니다:
        while (GetMessage(&msg, nullptr, 0, 0))
        {
            if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        ret = (int)msg.wParam;
    }
    __finally
    {
        // make sure to release everything at the end
        // regardless of what's happening
        // CloseGraph(g_hWnd);
        CoUninitialize();
    }

    return ret;
}


BOOL StartCapture(void)
{
    // Create CreateDevEnum to list device
    CheckError(CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (PVOID*)&pCreateDevEnum));
    CheckError(pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnumMoniker, 0));

    pEnumMoniker->Reset();

    // Find desired device
    while (pEnumMoniker->Next(1, &pMoniker, &nFetched) == S_OK)
    {
        IPropertyBag* pPropertyBag;
        TCHAR devname[256];

        // bind to IPropertyBag
        HRESULT hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropertyBag);

        if (FAILED(hr))
        {
            pMoniker->Release();
            continue;
        }

        VARIANT varName;
        VariantInit(&varName);
        hr = pPropertyBag->Read(L"DevicePath", &varName, 0);

        if (FAILED(hr))
        {
            pMoniker->Release();
            pPropertyBag->Release();
            continue;
        }

        char devicePath[256] = "";

        wcstombs(devicePath, varName.bstrVal, 256);

        
        // if (strcmp(devicePath, deviceId) == 0)
        {
            // deviceId 체크없이 무조건 bind
            // Bind Moniker to Filter
            pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&pDeviceFilter);

            break;
        }
        

        pMoniker->Release();
        pPropertyBag->Release();
    }

    if (pDeviceFilter == NULL) return FALSE;

    // Create sample grabber
    IBaseFilter* pGrabberF = NULL;
    CheckError(CoCreateInstance(CLSID_SampleGrabber, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)&pGrabberF));
    CheckError(pGrabberF->QueryInterface(IID_ISampleGrabber, (void**)&pGrabber));

    // Create FilterGraph
    CheckError(CoCreateInstance(CLSID_FilterGraph,NULL,CLSCTX_INPROC,IID_IGraphBuilder,(LPVOID*)&pGraphBuilder));

    // create CaptureGraphBuilder2
    CheckError(CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC, IID_ICaptureGraphBuilder2, (LPVOID*)&pCaptureGraphBuilder2));

    // set FilterGraph
    CheckError(pCaptureGraphBuilder2->SetFiltergraph(pGraphBuilder));

    // get MediaControl interface
    CheckError(pGraphBuilder->QueryInterface(IID_IMediaControl, (LPVOID*)&pMediaControl));

    pGraphBuilder->QueryInterface(IID_PPV_ARGS(&pEvent));

    // Add filters
    CheckError(pGraphBuilder->AddFilter(pDeviceFilter, L"Device Filter"));
    CheckError(pGraphBuilder->AddFilter(pGrabberF, L"Sample Grabber"));

    // Set sampe grabber options
    AM_MEDIA_TYPE mt;
    ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
    mt.majortype = MEDIATYPE_Video;
    mt.subtype = MEDIASUBTYPE_RGB32; //MEDIASUBTYPE_RGB24
    CheckError(pGrabber->SetMediaType(&mt));

    CheckError(pGrabber->SetOneShot(FALSE));
    CheckError(pGrabber->SetBufferSamples(TRUE));

    // Get stream config interface
    CheckError(pCaptureGraphBuilder2->FindInterface(NULL, &MEDIATYPE_Video, pDeviceFilter, IID_IAMStreamConfig, (void**)&pStreamConfig));

    RECT rect;
    GetWindowRect(hWnd, &rect);

    int _width = (rect.right - rect.left);
    int _height = (rect.bottom - rect.top);

    int streamCapsCount = 0;
    int capsSize = -1;
    int bestFit = -1;
    int bestFitPixelDiff = 1000000000;
    int desiredPixelCount = _width * _height;
    int bestFitWidth = 0, bestFitHeight = 0;

    float desiredAspectRatio = (float)_width / (float)_height;

    CheckError(pStreamConfig->GetNumberOfCapabilities(&streamCapsCount, &capsSize));
    
    videoCaps = (BYTE*)malloc(capsSize * streamCapsCount);
    mediaTypeArray = (AM_MEDIA_TYPE**)malloc(sizeof(AM_MEDIA_TYPE*) * streamCapsCount);

    for (int i = 0; i < streamCapsCount; i++)
    {
        CheckError(pStreamConfig->GetStreamCaps(i, &mediaTypeArray[i], videoCaps + capsSize * i));

        VIDEO_STREAM_CONFIG_CAPS* currentVideoCaps = (VIDEO_STREAM_CONFIG_CAPS*)(videoCaps + capsSize * i);

        int closestWidth = MAX(currentVideoCaps->MinOutputSize.cx, MIN(currentVideoCaps->MaxOutputSize.cx, _width));
        int closestHeight = MAX(currentVideoCaps->MinOutputSize.cy, MIN(currentVideoCaps->MaxOutputSize.cy, _height));

        int pixelDiff = abs(desiredPixelCount - closestWidth * closestHeight);

        if (pixelDiff < bestFitPixelDiff && abs(desiredAspectRatio - (float)closestWidth / (float)closestHeight) < 0.1f)
        {
            bestFit = i;
            bestFitPixelDiff = pixelDiff;
            bestFitWidth = closestWidth;
            bestFitHeight = closestHeight;
        }
    }

    if (bestFit == -1) return FALSE;

    AM_MEDIA_TYPE* mediaType;
    CheckError(pStreamConfig->GetFormat(&mediaType));

    VIDEOINFOHEADER* videoInfoHeader = (VIDEOINFOHEADER*)mediaType->pbFormat;
    videoInfoHeader->bmiHeader.biWidth = bestFitWidth;
    videoInfoHeader->bmiHeader.biHeight = bestFitHeight;
    //mediaType->subtype = MEDIASUBTYPE_RGB32;
    CheckError(pStreamConfig->SetFormat(mediaType));

    // Connect pins
    IPin* pDeviceOut = NULL, * pGrabberIn = NULL;

    if (GetPinByName(pDeviceFilter, PINDIR_OUTPUT, 0, &pDeviceOut) && GetPinByName(pGrabberF, PINDIR_INPUT, 0, &pGrabberIn))
    {
        CheckError(pGraphBuilder->Connect(pDeviceOut, pGrabberIn));
    }
    else
    {
        return FALSE;
    }


    // start playing
    CheckError(pMediaControl->Run());
    CheckError(pGrabber->GetConnectedMediaType(&mt));

    // Set dimensions
    _width = bestFitWidth;
    _height = bestFitHeight;


    // Find the required buffer size.
    long cbBuffer = _width * _height * 4;
    CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, NULL));
    
    pBuffer = (BYTE*)CoTaskMemAlloc(cbBuffer);
    if (!pBuffer)
    {
        return FALSE;
    }

    CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, (long*)pBuffer));
    

    // Examine the format block.
    if ((mt.formattype == FORMAT_VideoInfo) &&
        (mt.cbFormat >= sizeof(VIDEOINFOHEADER)) &&
        (mt.pbFormat != NULL))
    {
        VIDEOINFOHEADER* pVih = (VIDEOINFOHEADER*)mt.pbFormat;

        CheckError(WriteBitmap(L"./test.bmp", &pVih->bmiHeader,
            mt.cbFormat - SIZE_PREHEADER, pBuffer, cbBuffer));
    }
    else
    {
        // Invalid format.
        return FALSE;
    }

    //FreeMediaType(mt);

    

    // Allocate pixel buffer
    //pPixelBuffer = (unsigned*)malloc(_width * _height * 4);


    //return TRUE;

    // Release objects
    free(videoCaps);
    videoCaps = NULL;
    free(mediaTypeArray);
    mediaTypeArray = NULL;


    pStreamConfig->Release();
    pStreamConfig = NULL;
    pGraphBuilder->Release();
    pGraphBuilder = NULL;
    pEnumMoniker->Release();
    pEnumMoniker = NULL;
    pCreateDevEnum->Release();
    pCreateDevEnum = NULL;

    return TRUE;
}

//
//  함수: MyRegisterClass()
//
//  용도: 창 클래스를 등록합니다.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DSHOWBASIC2));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_DSHOWBASIC2);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&wcex);
}

//
//   함수: InitInstance(HINSTANCE, int)
//
//   용도: 인스턴스 핸들을 저장하고 주 창을 만듭니다.
//
//   주석:
//
//        이 함수를 통해 인스턴스 핸들을 전역 변수에 저장하고
//        주 프로그램 창을 만든 다음 표시합니다.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow, HWND& hWnd)
{
   hInst = hInstance; // 인스턴스 핸들을 전역 변수에 저장합니다.

   hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  함수: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  용도: 주 창의 메시지를 처리합니다.
//
//  WM_COMMAND  - 애플리케이션 메뉴를 처리합니다.
//  WM_PAINT    - 주 창을 그립니다.
//  WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    long cbBuffer;

    switch (message)
    {
    case IDM_CAPTURE:
        // Set sampe grabber options
        AM_MEDIA_TYPE mt;
        ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
        mt.majortype = MEDIATYPE_Video;
        mt.subtype = MEDIASUBTYPE_RGB32; //MEDIASUBTYPE_RGB24
        CheckError(pGrabber->SetMediaType(&mt));

        CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, NULL));
        CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, (long*)pBuffer));
        CheckError(pGrabber->GetConnectedMediaType(&mt));

        // Examine the format block.
        if ((mt.formattype == FORMAT_VideoInfo) &&
            (mt.cbFormat >= sizeof(VIDEOINFOHEADER)) &&
            (mt.pbFormat != NULL))
        {
            VIDEOINFOHEADER* pVih = (VIDEOINFOHEADER*)mt.pbFormat;

            CheckError(WriteBitmap(L"./test.bmp", &pVih->bmiHeader,
                mt.cbFormat - SIZE_PREHEADER, pBuffer, cbBuffer));
        }
        break;
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // 메뉴 선택을 구문 분석합니다:
            switch (wmId)
            {
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다...
            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// 정보 대화 상자의 메시지 처리기입니다.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}


// Writes a bitmap file
//  pszFileName:  Output file name.
//  pBMI:         Bitmap format information (including pallete).
//  cbBMI:        Size of the BITMAPINFOHEADER, including palette, if present.
//  pData:        Pointer to the bitmap bits.
//  cbData        Size of the bitmap, in bytes.

HRESULT WriteBitmap(PCWSTR pszFileName, BITMAPINFOHEADER* pBMI, size_t cbBMI,
    BYTE* pData, size_t cbData)
{
    HANDLE hFile = CreateFile(pszFileName, GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, 0, NULL);
    if (hFile == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BITMAPFILEHEADER bmf = { };

    bmf.bfType = *(WORD*)"BM";//0x4D42;//'B' + (256 * (int)'M');
    bmf.bfSize = cbBMI + cbData + sizeof(bmf);
    bmf.bfOffBits = sizeof(bmf) + cbBMI;

    DWORD cbWritten = 0;
    BOOL result = WriteFile(hFile, &bmf, sizeof(bmf), &cbWritten, NULL);
    if (result)
    {
        result = WriteFile(hFile, pBMI, cbBMI, &cbWritten, NULL);
    }
    if (result)
    {
        result = WriteFile(hFile, pData, cbData, &cbWritten, NULL);
    }

    HRESULT hr = result ? S_OK : HRESULT_FROM_WIN32(GetLastError());

    CloseHandle(hFile);

    return hr;
}
```

```cpp
// qedit.h

#ifndef __qedit_h__
#define __qedit_h__

///////////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////////

interface
	ISampleGrabberCB
	:
	public IUnknown
{
	virtual STDMETHODIMP SampleCB(double SampleTime, IMediaSample* pSample) = 0;
	virtual STDMETHODIMP BufferCB(double SampleTime, BYTE* pBuffer, long BufferLen) = 0;
};

///////////////////////////////////////////////////////////////////////////////////

static
const
IID IID_ISampleGrabberCB = { 0x0579154A, 0x2B53, 0x4994, { 0xB0, 0xD0, 0xE7, 0x73, 0x14, 0x8E, 0xFF, 0x85 } };

///////////////////////////////////////////////////////////////////////////////////

interface
	ISampleGrabber
	:
	public IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetOneShot(BOOL OneShot) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetMediaType(const AM_MEDIA_TYPE* pType) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType(AM_MEDIA_TYPE* pType) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetBufferSamples(BOOL BufferThem) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer(long* pBufferSize, long* pBuffer) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetCurrentSample(IMediaSample** ppSample) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetCallback(ISampleGrabberCB* pCallback, long WhichMethodToCallback) = 0;
};

///////////////////////////////////////////////////////////////////////////////////

static
const
IID IID_ISampleGrabber = { 0x6B652FFF, 0x11FE, 0x4fce, { 0x92, 0xAD, 0x02, 0x66, 0xB5, 0xD7, 0xC7, 0x8F } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_SampleGrabber = { 0xC1F400A0, 0x3F08, 0x11d3, { 0x9F, 0x0B, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_NullRenderer = { 0xC1F400A4, 0x3F08, 0x11d3, { 0x9F, 0x0B, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_VideoEffects1Category = { 0xcc7bfb42, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_VideoEffects2Category = { 0xcc7bfb43, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_AudioEffects1Category = { 0xcc7bfb44, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_AudioEffects2Category = { 0xcc7bfb45, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

#endif
```