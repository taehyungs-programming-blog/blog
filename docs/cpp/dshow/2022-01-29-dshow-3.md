---
layout: default
title: "3. WebCam rgbÎ°ú ÎΩëÏïÑ Ï∂úÎ†•ÌïòÍ∏∞"
parent: (DShow)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get This Code üåé](https://github.com/EasyCoding-7/dshow-basic/tree/main/dshow-basic-4)

üò∫ WebCamÏ†ïÎ≥¥Î•º Ïù¥ÎØ∏ÏßÄ ÌîÑÎ°úÏÑ∏Ïã± Îì±ÏùÑ ÏúÑÌï¥ rgbÎ°ú ÎΩëÏïÑÏïº ÌïòÎäî Í≤ΩÏö∞Í∞Ä ÏûàÎã§. Ìï¥Îãπ Í≤ΩÏö∞Ïùò Example ÏΩîÎìúÏù¥Îã§.

* [SampleGrabber Example Github üåç](https://github.com/chuckfairy/node-webcam/blob/master/src/bindings/CommandCam/CommandCam.cpp)

---

## Ïã§Ìå®Í∏∞

üò∫ Íº≠ ÏïàÎ¥êÎèÑ Îê®.

```cpp
// dshow-basic-2.cpp : Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏóê ÎåÄÌïú ÏßÑÏûÖÏ†êÏùÑ Ï†ïÏùòÌï©ÎãàÎã§.
//

#include "stdafx.h"
#include "framework.h"
#include "dshow-basic-2.h"
#include "qedit.h"
#include <wingdi.h>

#pragma warning(disable: 4996)
#define MAX_LOADSTRING 100

// Playback
IGraphBuilder* pGraphBuilder = NULL;
ICaptureGraphBuilder2* pCaptureGraphBuilder2 = NULL;
IMediaControl* pMediaControl = NULL;
IMediaEventEx* pEvent = NULL;
ISampleGrabber* pGrabber = NULL;
IBaseFilter* pDeviceFilter = NULL;
IAMStreamConfig* pStreamConfig = NULL;
BYTE *pBuffer = NULL;
BYTE* videoCaps = NULL;
AM_MEDIA_TYPE** mediaTypeArray = NULL;

// Device selection
ICreateDevEnum* pCreateDevEnum = NULL;
IEnumMoniker* pEnumMoniker = NULL;
IMoniker* pMoniker = NULL;
ULONG nFetched = 0;

BOOL StartCapture(void);

// Ï†ÑÏó≠ Î≥ÄÏàò:
HWND hWnd;
HINSTANCE hInst;                                // ÌòÑÏû¨ Ïù∏Ïä§ÌÑ¥Ïä§ÏûÖÎãàÎã§.
WCHAR szTitle[MAX_LOADSTRING];                  // Ï†úÎ™© ÌëúÏãúÏ§Ñ ÌÖçÏä§Ìä∏ÏûÖÎãàÎã§.
WCHAR szWindowClass[MAX_LOADSTRING];            // Í∏∞Î≥∏ Ï∞Ω ÌÅ¥ÎûòÏä§ Ïù¥Î¶ÑÏûÖÎãàÎã§.

// Ïù¥ ÏΩîÎìú Î™®ÎìàÏóê Ìè¨Ìï®Îêú Ìï®ÏàòÏùò ÏÑ†Ïñ∏ÏùÑ Ï†ÑÎã¨Ìï©ÎãàÎã§:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int, HWND&);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);
HRESULT WriteBitmap(PCWSTR pszFileName, BITMAPINFOHEADER* pBMI, size_t cbBMI, BYTE* pData, size_t cbData);

void CheckError(HRESULT r) {
    if (FAILED(r)) {
        printf("FAILED : %x\n", r);
    }
    else if (SUCCEEDED(r)) {
        printf("SUCCEEDED\n");
    }
}

static inline bool PinIsDirection(IPin* pin, PIN_DIRECTION dir)
{
    if (!pin)
        return false;

    PIN_DIRECTION pinDir;
    return SUCCEEDED(pin->QueryDirection(&pinDir)) && pinDir == dir;
}

static inline bool PinNameIs(IPin* pin, const wchar_t* name)
{
    if (!pin)
        return false;
    if (!name)
        return true;

    PIN_INFO pinInfo;

    if (FAILED(pin->QueryPinInfo(&pinInfo)))
        return false;

    if (pinInfo.pFilter)
        pinInfo.pFilter->Release();

    return wcscmp(name, pinInfo.achName) == 0;
}

bool GetPinByName(IBaseFilter* filter, PIN_DIRECTION dir, const wchar_t* name,
    IPin** pin)
{
    ComPtr<IPin> curPin;
    ComPtr<IEnumPins> pinsEnum;
    ULONG num;

    if (!filter)
        return false;
    if (FAILED(filter->EnumPins(&pinsEnum)))
        return false;

    while (pinsEnum->Next(1, &curPin, &num) == S_OK) {
        if (PinIsDirection(curPin, dir) && PinNameIs(curPin, name)) {
            *pin = curPin.Detach();
            return true;
        }
    }

    return false;
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    int ret = -1;

    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    __try
    {
        UNREFERENCED_PARAMETER(hPrevInstance);
        UNREFERENCED_PARAMETER(lpCmdLine);

        // TODO: Ïó¨Í∏∞Ïóê ÏΩîÎìúÎ•º ÏûÖÎ†•Ìï©ÎãàÎã§.

        // Ï†ÑÏó≠ Î¨∏ÏûêÏó¥ÏùÑ Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.
        LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
        LoadStringW(hInstance, IDC_DSHOWBASIC2, szWindowClass, MAX_LOADSTRING);
        MyRegisterClass(hInstance);

        // Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï¥àÍ∏∞ÌôîÎ•º ÏàòÌñâÌï©ÎãàÎã§:
        if (!InitInstance(hInstance, nCmdShow, hWnd))
        {
            return FALSE;
        }

        HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_DSHOWBASIC2));

        MSG msg;

        ret = StartCapture();

        // Í∏∞Î≥∏ Î©îÏãúÏßÄ Î£®ÌîÑÏûÖÎãàÎã§:
        while (GetMessage(&msg, nullptr, 0, 0))
        {
            if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        ret = (int)msg.wParam;
    }
    __finally
    {
        // make sure to release everything at the end
        // regardless of what's happening
        // CloseGraph(g_hWnd);
        CoUninitialize();
    }

    return ret;
}


BOOL StartCapture(void)
{
    // Create CreateDevEnum to list device
    CheckError(CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (PVOID*)&pCreateDevEnum));
    CheckError(pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEnumMoniker, 0));

    pEnumMoniker->Reset();

    // Find desired device
    while (pEnumMoniker->Next(1, &pMoniker, &nFetched) == S_OK)
    {
        IPropertyBag* pPropertyBag;
        TCHAR devname[256];

        // bind to IPropertyBag
        HRESULT hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropertyBag);

        if (FAILED(hr))
        {
            pMoniker->Release();
            continue;
        }

        VARIANT varName;
        VariantInit(&varName);
        hr = pPropertyBag->Read(L"DevicePath", &varName, 0);

        if (FAILED(hr))
        {
            pMoniker->Release();
            pPropertyBag->Release();
            continue;
        }

        char devicePath[256] = "";

        wcstombs(devicePath, varName.bstrVal, 256);

        
        // if (strcmp(devicePath, deviceId) == 0)
        {
            // deviceId Ï≤¥ÌÅ¨ÏóÜÏù¥ Î¨¥Ï°∞Í±¥ bind
            // Bind Moniker to Filter
            pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&pDeviceFilter);

            break;
        }
        

        pMoniker->Release();
        pPropertyBag->Release();
    }

    if (pDeviceFilter == NULL) return FALSE;

    // Create sample grabber
    IBaseFilter* pGrabberF = NULL;
    CheckError(CoCreateInstance(CLSID_SampleGrabber, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)&pGrabberF));
    CheckError(pGrabberF->QueryInterface(IID_ISampleGrabber, (void**)&pGrabber));

    // Create FilterGraph
    CheckError(CoCreateInstance(CLSID_FilterGraph,NULL,CLSCTX_INPROC,IID_IGraphBuilder,(LPVOID*)&pGraphBuilder));

    // create CaptureGraphBuilder2
    CheckError(CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC, IID_ICaptureGraphBuilder2, (LPVOID*)&pCaptureGraphBuilder2));

    // set FilterGraph
    CheckError(pCaptureGraphBuilder2->SetFiltergraph(pGraphBuilder));

    // get MediaControl interface
    CheckError(pGraphBuilder->QueryInterface(IID_IMediaControl, (LPVOID*)&pMediaControl));

    pGraphBuilder->QueryInterface(IID_PPV_ARGS(&pEvent));

    // Add filters
    CheckError(pGraphBuilder->AddFilter(pDeviceFilter, L"Device Filter"));
    CheckError(pGraphBuilder->AddFilter(pGrabberF, L"Sample Grabber"));

    // Set sampe grabber options
    AM_MEDIA_TYPE mt;
    ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
    mt.majortype = MEDIATYPE_Video;
    mt.subtype = MEDIASUBTYPE_RGB32; //MEDIASUBTYPE_RGB24
    CheckError(pGrabber->SetMediaType(&mt));

    CheckError(pGrabber->SetOneShot(FALSE));
    CheckError(pGrabber->SetBufferSamples(TRUE));

    // Get stream config interface
    CheckError(pCaptureGraphBuilder2->FindInterface(NULL, &MEDIATYPE_Video, pDeviceFilter, IID_IAMStreamConfig, (void**)&pStreamConfig));

    RECT rect;
    GetWindowRect(hWnd, &rect);

    int _width = (rect.right - rect.left);
    int _height = (rect.bottom - rect.top);

    int streamCapsCount = 0;
    int capsSize = -1;
    int bestFit = -1;
    int bestFitPixelDiff = 1000000000;
    int desiredPixelCount = _width * _height;
    int bestFitWidth = 0, bestFitHeight = 0;

    float desiredAspectRatio = (float)_width / (float)_height;

    CheckError(pStreamConfig->GetNumberOfCapabilities(&streamCapsCount, &capsSize));
    
    videoCaps = (BYTE*)malloc(capsSize * streamCapsCount);
    mediaTypeArray = (AM_MEDIA_TYPE**)malloc(sizeof(AM_MEDIA_TYPE*) * streamCapsCount);

    for (int i = 0; i < streamCapsCount; i++)
    {
        CheckError(pStreamConfig->GetStreamCaps(i, &mediaTypeArray[i], videoCaps + capsSize * i));

        VIDEO_STREAM_CONFIG_CAPS* currentVideoCaps = (VIDEO_STREAM_CONFIG_CAPS*)(videoCaps + capsSize * i);

        int closestWidth = MAX(currentVideoCaps->MinOutputSize.cx, MIN(currentVideoCaps->MaxOutputSize.cx, _width));
        int closestHeight = MAX(currentVideoCaps->MinOutputSize.cy, MIN(currentVideoCaps->MaxOutputSize.cy, _height));

        int pixelDiff = abs(desiredPixelCount - closestWidth * closestHeight);

        if (pixelDiff < bestFitPixelDiff && abs(desiredAspectRatio - (float)closestWidth / (float)closestHeight) < 0.1f)
        {
            bestFit = i;
            bestFitPixelDiff = pixelDiff;
            bestFitWidth = closestWidth;
            bestFitHeight = closestHeight;
        }
    }

    if (bestFit == -1) return FALSE;

    AM_MEDIA_TYPE* mediaType;
    CheckError(pStreamConfig->GetFormat(&mediaType));

    VIDEOINFOHEADER* videoInfoHeader = (VIDEOINFOHEADER*)mediaType->pbFormat;
    videoInfoHeader->bmiHeader.biWidth = bestFitWidth;
    videoInfoHeader->bmiHeader.biHeight = bestFitHeight;
    //mediaType->subtype = MEDIASUBTYPE_RGB32;
    CheckError(pStreamConfig->SetFormat(mediaType));

    // Connect pins
    IPin* pDeviceOut = NULL, * pGrabberIn = NULL;

    if (GetPinByName(pDeviceFilter, PINDIR_OUTPUT, 0, &pDeviceOut) && GetPinByName(pGrabberF, PINDIR_INPUT, 0, &pGrabberIn))
    {
        CheckError(pGraphBuilder->Connect(pDeviceOut, pGrabberIn));
    }
    else
    {
        return FALSE;
    }


    // start playing
    CheckError(pMediaControl->Run());
    CheckError(pGrabber->GetConnectedMediaType(&mt));

    // Set dimensions
    _width = bestFitWidth;
    _height = bestFitHeight;


    // Find the required buffer size.
    long cbBuffer = _width * _height * 4;
    CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, NULL));
    
    pBuffer = (BYTE*)CoTaskMemAlloc(cbBuffer);
    if (!pBuffer)
    {
        return FALSE;
    }

    CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, (long*)pBuffer));
    

    // Examine the format block.
    if ((mt.formattype == FORMAT_VideoInfo) &&
        (mt.cbFormat >= sizeof(VIDEOINFOHEADER)) &&
        (mt.pbFormat != NULL))
    {
        VIDEOINFOHEADER* pVih = (VIDEOINFOHEADER*)mt.pbFormat;

        CheckError(WriteBitmap(L"./test.bmp", &pVih->bmiHeader,
            mt.cbFormat - SIZE_PREHEADER, pBuffer, cbBuffer));
    }
    else
    {
        // Invalid format.
        return FALSE;
    }

    //FreeMediaType(mt);

    

    // Allocate pixel buffer
    //pPixelBuffer = (unsigned*)malloc(_width * _height * 4);


    //return TRUE;

    // Release objects
    free(videoCaps);
    videoCaps = NULL;
    free(mediaTypeArray);
    mediaTypeArray = NULL;


    pStreamConfig->Release();
    pStreamConfig = NULL;
    pGraphBuilder->Release();
    pGraphBuilder = NULL;
    pEnumMoniker->Release();
    pEnumMoniker = NULL;
    pCreateDevEnum->Release();
    pCreateDevEnum = NULL;

    return TRUE;
}

//
//  Ìï®Ïàò: MyRegisterClass()
//
//  Ïö©ÎèÑ: Ï∞Ω ÌÅ¥ÎûòÏä§Î•º Îì±Î°ùÌï©ÎãàÎã§.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_DSHOWBASIC2));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_DSHOWBASIC2);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&wcex);
}

//
//   Ìï®Ïàò: InitInstance(HINSTANCE, int)
//
//   Ïö©ÎèÑ: Ïù∏Ïä§ÌÑ¥Ïä§ Ìï∏Îì§ÏùÑ Ï†ÄÏû•ÌïòÍ≥† Ï£º Ï∞ΩÏùÑ ÎßåÎì≠ÎãàÎã§.
//
//   Ï£ºÏÑù:
//
//        Ïù¥ Ìï®ÏàòÎ•º ÌÜµÌï¥ Ïù∏Ïä§ÌÑ¥Ïä§ Ìï∏Îì§ÏùÑ Ï†ÑÏó≠ Î≥ÄÏàòÏóê Ï†ÄÏû•ÌïòÍ≥†
//        Ï£º ÌîÑÎ°úÍ∑∏Îû® Ï∞ΩÏùÑ ÎßåÎì† Îã§Ïùå ÌëúÏãúÌï©ÎãàÎã§.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow, HWND& hWnd)
{
   hInst = hInstance; // Ïù∏Ïä§ÌÑ¥Ïä§ Ìï∏Îì§ÏùÑ Ï†ÑÏó≠ Î≥ÄÏàòÏóê Ï†ÄÏû•Ìï©ÎãàÎã§.

   hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  Ìï®Ïàò: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  Ïö©ÎèÑ: Ï£º Ï∞ΩÏùò Î©îÏãúÏßÄÎ•º Ï≤òÎ¶¨Ìï©ÎãàÎã§.
//
//  WM_COMMAND  - Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î©îÎâ¥Î•º Ï≤òÎ¶¨Ìï©ÎãàÎã§.
//  WM_PAINT    - Ï£º Ï∞ΩÏùÑ Í∑∏Î¶ΩÎãàÎã§.
//  WM_DESTROY  - Ï¢ÖÎ£å Î©îÏãúÏßÄÎ•º Í≤åÏãúÌïòÍ≥† Î∞òÌôòÌï©ÎãàÎã§.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    long cbBuffer;

    switch (message)
    {
    case IDM_CAPTURE:
        // Set sampe grabber options
        AM_MEDIA_TYPE mt;
        ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
        mt.majortype = MEDIATYPE_Video;
        mt.subtype = MEDIASUBTYPE_RGB32; //MEDIASUBTYPE_RGB24
        CheckError(pGrabber->SetMediaType(&mt));

        CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, NULL));
        CheckError(pGrabber->GetCurrentBuffer(&cbBuffer, (long*)pBuffer));
        CheckError(pGrabber->GetConnectedMediaType(&mt));

        // Examine the format block.
        if ((mt.formattype == FORMAT_VideoInfo) &&
            (mt.cbFormat >= sizeof(VIDEOINFOHEADER)) &&
            (mt.pbFormat != NULL))
        {
            VIDEOINFOHEADER* pVih = (VIDEOINFOHEADER*)mt.pbFormat;

            CheckError(WriteBitmap(L"./test.bmp", &pVih->bmiHeader,
                mt.cbFormat - SIZE_PREHEADER, pBuffer, cbBuffer));
        }
        break;
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Î©îÎâ¥ ÏÑ†ÌÉùÏùÑ Íµ¨Î¨∏ Î∂ÑÏÑùÌï©ÎãàÎã§:
            switch (wmId)
            {
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: Ïó¨Í∏∞Ïóê hdcÎ•º ÏÇ¨Ïö©ÌïòÎäî Í∑∏Î¶¨Í∏∞ ÏΩîÎìúÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§...
            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

// Ï†ïÎ≥¥ ÎåÄÌôî ÏÉÅÏûêÏùò Î©îÏãúÏßÄ Ï≤òÎ¶¨Í∏∞ÏûÖÎãàÎã§.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}


// Writes a bitmap file
//  pszFileName:  Output file name.
//  pBMI:         Bitmap format information (including pallete).
//  cbBMI:        Size of the BITMAPINFOHEADER, including palette, if present.
//  pData:        Pointer to the bitmap bits.
//  cbData        Size of the bitmap, in bytes.

HRESULT WriteBitmap(PCWSTR pszFileName, BITMAPINFOHEADER* pBMI, size_t cbBMI,
    BYTE* pData, size_t cbData)
{
    HANDLE hFile = CreateFile(pszFileName, GENERIC_WRITE, 0, NULL,
        CREATE_ALWAYS, 0, NULL);
    if (hFile == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BITMAPFILEHEADER bmf = { };

    bmf.bfType = *(WORD*)"BM";//0x4D42;//'B' + (256 * (int)'M');
    bmf.bfSize = cbBMI + cbData + sizeof(bmf);
    bmf.bfOffBits = sizeof(bmf) + cbBMI;

    DWORD cbWritten = 0;
    BOOL result = WriteFile(hFile, &bmf, sizeof(bmf), &cbWritten, NULL);
    if (result)
    {
        result = WriteFile(hFile, pBMI, cbBMI, &cbWritten, NULL);
    }
    if (result)
    {
        result = WriteFile(hFile, pData, cbData, &cbWritten, NULL);
    }

    HRESULT hr = result ? S_OK : HRESULT_FROM_WIN32(GetLastError());

    CloseHandle(hFile);

    return hr;
}
```

```cpp
// qedit.h

#ifndef __qedit_h__
#define __qedit_h__

///////////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////////

interface
	ISampleGrabberCB
	:
	public IUnknown
{
	virtual STDMETHODIMP SampleCB(double SampleTime, IMediaSample* pSample) = 0;
	virtual STDMETHODIMP BufferCB(double SampleTime, BYTE* pBuffer, long BufferLen) = 0;
};

///////////////////////////////////////////////////////////////////////////////////

static
const
IID IID_ISampleGrabberCB = { 0x0579154A, 0x2B53, 0x4994, { 0xB0, 0xD0, 0xE7, 0x73, 0x14, 0x8E, 0xFF, 0x85 } };

///////////////////////////////////////////////////////////////////////////////////

interface
	ISampleGrabber
	:
	public IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE SetOneShot(BOOL OneShot) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetMediaType(const AM_MEDIA_TYPE* pType) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetConnectedMediaType(AM_MEDIA_TYPE* pType) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetBufferSamples(BOOL BufferThem) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetCurrentBuffer(long* pBufferSize, long* pBuffer) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetCurrentSample(IMediaSample** ppSample) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetCallback(ISampleGrabberCB* pCallback, long WhichMethodToCallback) = 0;
};

///////////////////////////////////////////////////////////////////////////////////

static
const
IID IID_ISampleGrabber = { 0x6B652FFF, 0x11FE, 0x4fce, { 0x92, 0xAD, 0x02, 0x66, 0xB5, 0xD7, 0xC7, 0x8F } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_SampleGrabber = { 0xC1F400A0, 0x3F08, 0x11d3, { 0x9F, 0x0B, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_NullRenderer = { 0xC1F400A4, 0x3F08, 0x11d3, { 0x9F, 0x0B, 0x00, 0x60, 0x08, 0x03, 0x9E, 0x37 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_VideoEffects1Category = { 0xcc7bfb42, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_VideoEffects2Category = { 0xcc7bfb43, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_AudioEffects1Category = { 0xcc7bfb44, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

static
const
CLSID CLSID_AudioEffects2Category = { 0xcc7bfb45, 0xf175, 0x11d1, { 0xa3, 0x92, 0x0, 0xe0, 0x29, 0x1f, 0x39, 0x59 } };

///////////////////////////////////////////////////////////////////////////////////

#endif
```