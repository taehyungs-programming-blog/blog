---
layout: default
title: "10. PageHeap Debugging"
parent: "(Windows Debugging)"
grand_parent: "(C++)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* PageHeap은 Windows OS에서 제공하는 메모리 디버깅 기능
* 힙 메모리 오버런(Heap Corruption) 버그를 실시간으로 탐지할 수 있는 강력한 도구

## PageHeap란?

PageHeap은 메모리를 할당할 때 특별한 방식으로 메모리를 배치하여 경계 침범(boundary violation)을 즉시 감지할 수 있게 한다

### 동작 원리

1. **Page 경계 정렬**: 메모리를 할당할 때 요청한 사이즈의 경계를 page 경계에 일치시킵니다.
2. **보호 페이지 설정**: 경계의 뒷 페이지는 접근 금지(No Access)로 설정됩니다.
3. **즉시 예외 발생**: Write 작업 중 메모리 경계를 넘어가면 쓰기 금지 page에 쓰기를 시도하므로 CPU가 예외를 발생시킵니다.

### PageHeap 활성화 시 메모리 구조

```
[보호 페이지 4KB] [할당된 메모리] [보호 페이지 4KB]
   (No Access)     (Read/Write)      (No Access)
```

메모리 할당 시 앞뒤로 4KB 보호 페이지가 추가되어, 경계를 벗어난 접근을 즉시 탐지할 수 있습니다.

## Debugger Tools 다운로드

PageHeap을 사용하기 위해서는 Windows Debugging Tools가 필요합니다.

**다운로드 링크**: [https://learn.microsoft.com/ko-kr/windows-hardware/drivers/debugger/debugger-download-tools](https://learn.microsoft.com/ko-kr/windows-hardware/drivers/debugger/debugger-download-tools)

## GFlags를 사용한 PageHeap 활성화 방법

GFlags는 Windows Debugging Tools에 포함된 도구로, PageHeap을 활성화할 수 있습니다.

### 방법 1: GUI 사용

1. **GFlags 실행**: 관리자 권한으로 `gflags.exe` 실행
2. **Image File 탭 선택**
3. **실행 파일 이름 입력**: 디버깅할 `.exe` 파일명 입력 (예: `MyApp.exe`)
4. **Enable page heap 체크**: "Enable page heap" 옵션 선택
5. **적용**: Apply 버튼 클릭

### 방법 2: 명령줄 사용

```cmd
# Full PageHeap 활성화
gflags /p /enable MyApp.exe /full

# Standard PageHeap 활성화
gflags /p /enable MyApp.exe

# PageHeap 비활성화
gflags /p /disable MyApp.exe
```

### Full PageHeap vs Standard PageHeap

- **Full PageHeap**: 모든 힙 할당에 대해 보호 페이지 적용 (메모리 사용량 높음)
- **Standard PageHeap**: 일부 힙 할당에만 적용 (메모리 사용량 낮음)

## Release 빌드 vs Debug 빌드

### Release 빌드에서 유용한 이유

- Release 빌드 테스트에서 특히 유용합니다.
- Release 빌드에서는 `CrtCheckMemory()`를 사용할 수 없으므로, PageHeap이 대안이 됩니다.

### Debug 빌드에서의 제한사항

- Debug 빌드에서는 완벽하지 않을 수 있습니다.
- Debug 빌드의 CRT heap은 디버그용으로 경계 범위 뒤에 추가적인 패턴 영역을 두기 때문입니다.
- 이로 인해 실제 경계 침범이 보호 페이지에 도달하기 전에 패턴 영역에 먼저 닿을 수 있습니다.

## 최적화 On/Off 방법

특정 코드 영역에서 컴파일러 최적화를 제어해야 할 경우 다음 pragma를 사용합니다:

```cpp
// 최적화 비활성화
#pragma optimize("gpsy", off)

// 여기에 최적화를 원하지 않는 코드 작성
void SomeFunction() {
    // ...
}

// 최적화 다시 활성화
#pragma optimize("gpsy", on)
```

### 최적화 플래그 설명

- **g**: 전역 최적화
- **p**: 정밀한 부동소수점 연산
- **s**: 크기 최적화 선호
- **y**: 프레임 포인터 생략

## 장점과 단점

### 장점

✅ **실시간 탐지**: 실시간으로 Heap Corruption 버그를 잡아낼 수 있다

✅ **성능 오버헤드 최소화**: 읽고 쓰는 비용 자체에는 추가적인 성능 저하가 없다

✅ **즉시 크래시**: 버그 발생 시점에 즉시 예외가 발생하여 디버깅이 용이

### 단점

❌ **메모리 소비**: 앞뒤로 4KB 페이지를 추가 할당해야 하므로 메모리를 상당히 소모

❌ **32비트 제약**: 32 bits 프로세스에서는 메모리 주소 공간이 부족

❌ **할당 성능**: 메모리 할당 코드에 대해서는 추가 메모리 할당에 의한 런타임 성능 저하

## 사용 시나리오

### 권장 사용 케이스

- Release 빌드의 메모리 버그 디버깅
- 간헐적으로 발생하는 힙 오버런 버그 추적
- 메모리 경계 침범 문제 진단

### 주의사항

- 개발 및 테스트 환경에서만 사용
- 프로덕션 환경에서는 비활성화
- 메모리가 충분한 환경에서 사용
- 64비트 애플리케이션에서 더 효과적

## 예제: PageHeap으로 버그 탐지

```cpp
void BuggyFunction() {
    char* buffer = new char[10];
    
    // 버그: 경계를 넘어선 쓰기
    buffer[10] = 'X';  // PageHeap 활성화 시 즉시 예외 발생!
    
    delete[] buffer;
}
```

PageHeap이 활성화되어 있으면 `buffer[10]` 접근 시 즉시 Access Violation 예외가 발생하여 버그 위치를 정확히 파악할 수 있습니다.
