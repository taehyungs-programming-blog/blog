---
layout: default
title: "11. Address Sanitizer"
parent: "(Windows Debugging)"
grand_parent: "(C++)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 1️⃣ Address Sanitizer란?

Address Sanitizer는 **메모리 오류를 실시간으로 감지**하는 개발 도구

```
🔍 핵심 특징
├─ 컴파일러 + Runtime Library 기능 활용
├─ OS 기능이 아님 (Windows, Mac, Linux 모두 지원)
└─ Heap corruption 등 잘못된 메모리 사용 즉시 감지
```

---

## 2️⃣ 동작 원리 (Shadow Memory)

### 📊 메모리 매핑 구조

```
┌─────────────────────────────────────┐
│      실제 Heap 메모리               │
├─────────────────────────────────────┤
│  [Block0]  [Block1]  [Block2] ...  │
│  8 bytes   8 bytes   8 bytes        │
└─────────────────────────────────────┘
          ↓ 8:1 매핑
┌─────────────────────────────────────┐
│      Shadow Memory (1/8 크기)       │
├─────────────────────────────────────┤
│  [0x00]   [0x00]    [0xFF] ...     │
│  1 byte   1 byte    1 byte         │
└─────────────────────────────────────┘
```

### 🎯 Shadow Byte 의미

```
┌────────────┬──────────────────────────────────────┐
│ 값         │ 의미                                 │
├────────────┼──────────────────────────────────────┤
│ 0x00       │ 8바이트 모두 접근 가능               │
│ 0x01~0x07  │ 1~7바이트만 접근 가능 (나머지는 ❌) │
│ 음수값     │ 접근 불가능 (런타임 컨텍스트 정보)  │
│ (예: 0xF9) │                                      │
└────────────┴──────────────────────────────────────┘
```

---

## 3️⃣ 메모리 접근 검증 프로세스

### 🔄 단계별 동작

```
1. 메모리 접근 시도
   ↓
2. 해당 주소의 Shadow Byte 조회
   ↓
3. Shadow Byte 값 확인
   ├─ 0x00? → ✅ 모든 바이트 접근 가능
   ├─ 0x01~0x07? → ⚠️ 일부 바이트만 접근 가능
   └─ 음수? → ❌ 접근 불가 → 에러 보고
   ↓
4. 접근 허용 여부 결정
```

### 💻 코드 레벨 예시

```c
// 원본 코드
int* ptr = (int*)malloc(4);
int value = ptr[5];  // ❌ 범위 초과 접근

// ASan이 자동으로 추가한 검사 (컴파일 시)
int* ptr = (int*)malloc(4);
__asan_check_access(ptr, 20);  // 20 = 5 * 4바이트
/*
ptr[5]는 실제로 얼마나 떨어진 주소일까?

ptr의 타입: int* (4바이트)
ptr[5] = ptr + (5 × sizeof(int))
       = ptr + (5 × 4)
       = ptr + 20바이트

따라서 __asan_check_access(ptr, 20)은
"ptr로부터 20바이트 떨어진 곳에 접근하려고 하는데, 
 이게 허락된 메모리 범위 내에 있나?"를 체크
*/
int value = ptr[5];
```

---

## 4️⃣ _CrtCheckMemory와의 비교

| 기능 | Address Sanitizer | _CrtCheckMemory |
|------|-------------------|-----------------|
| **감지 시점** | 🚀 즉시 (버그 발생 시) | 🐢 수동 호출 시에만 |
| **플랫폼** | Windows, Mac, Linux | Windows만 |
| **오버헤드** | 중간 수준 | 낮음 |
| **설정** | 컴파일러 플래그 | 코드 수정 필요 |

**⭐ ASan의 장점**: 버그가 발생하는 **정확한 시점**에 감지!

---

## 5️⃣ 검출 가능한 에러

```
✅ ASan이 감지할 수 있는 버그
├─ Buffer Overflow (범위 초과 접근)
├─ Use After Free (해제된 메모리 접근)
├─ Double Free (이중 해제)
├─ Memory Leak (메모리 누수)
├─ Heap Corruption
└─ Stack Overflow

📚 전체 목록: https://learn.microsoft.com/en-us/cpp/sanitizers/asan
```

---

## 6️⃣ 장점 ✨

```
📈 실시간 감지
   └─ 메모리 버그가 발생하는 그 순간 포착

💾 효율적인 메모리 사용
   └─ Shadow Memory 오버헤드가 크지 않음 (~1/8 크기)

⚙️ 설정이 간단
   └─ 컴파일러 플래그만 추가하면 됨 (-fsanitize=address)
```

---

## 7️⃣ 단점 ⚠️

```
🐢 성능 저하
   └─ 모든 메모리 접근마다 Shadow Byte 체크
   └─ Debug vs Release 성능: 75% 이상 차이 가능

🔴 외부 코드 호환성 문제
   └─ Template 라이브러리 등과 컴파일 실패 가능
   └─ 써드파티 DLL과 충돌 가능
```

---

## 8️⃣ 실무 최적화 전략

### 📌 성능 저하 해결

```
1️⃣ 코드 최적화 (필수)
   - Debug 빌드 성능을 Release 대비 75% 이상 유지
   - 핫스팟 코드 프로파일링
   - 불필요한 메모리 할당 제거

2️⃣ DLL 분할 (중요)
   ┌──────────────────────────────┐
   │  메인 애플리케이션           │
   │  (ASan 활성화) ✅            │
   └──────────────────────────────┘
                ↓
   ┌──────────────────────────────┐
   │  성능이 중요한 DLL           │
   │  (ASan 비활성화) ❌          │
   └──────────────────────────────┘
   
   → 부분적으로 ASan 적용 가능

3️⃣ 테스트 전략
   - 단위 테스트: ASan 활성화 (상세 검사)
   - 부하 테스트: ASan 비활성화 (성능 평가)
```

### 💡 구체적 구성 예시

```bash
# 컴파일 명령어
cl /fsanitize=address /Zi /D_DEBUG debug.cpp

# 또는 Visual Studio 프로젝트
# 프로젝트 속성 → C/C++ → 일반 
# → Sanitizers → Address Sanitizer (ASan) 활성화
```

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/windbg/01-11-01-windbg.png"/>
</p>

---

## 9️⃣ 워크플로우 요약

```
┌─────────────┐
│ 소스 코드   │
└─────────────┘
      ↓
┌──────────────────────────────┐
│ 컴파일러                      │
│ (ASan 플래그 활성화)         │
│ → Shadow Byte 검사 코드 삽입  │
└──────────────────────────────┘
      ↓
┌──────────────────────────────┐
│ 실행 시 Runtime Library       │
│ • Shadow Memory 관리          │
│ • 접근 권한 체크              │
│ • 에러 발생 시 즉시 보고      │
└──────────────────────────────┘
      ↓
┌──────────────────────────────┐
│ 메모리 버그 감지 ✅           │
│ (문제 해결 후 재컴파일)      │
└──────────────────────────────┘
```

---

## 🎯 언제 사용할까?

| 상황 | 추천 |
|------|------|
| 개발 및 디버깅 | ✅✅✅ 필수 |
| 통합 테스트 | ✅✅ 권장 |
| 성능 테스트 | ⚠️ 선택 (성능 저하) |
| 출시 빌드 | ❌ 비활성화 |

---

## 📚 참고 자료

- [MSVC ASan 공식 문서](https://learn.microsoft.com/en-us/cpp/sanitizers/asan)
- Compiler: `-fsanitize=address` (GCC/Clang)
- Visual Studio: 프로젝트 속성에서 ASan 활성화

---

## 참고) Shadow Byte 추가 설명

## 1️⃣ 기본 시나리오: 메모리 할당

```c
#include <stdlib.h>

int main() {
    // 16바이트(2개 8바이트 블록) 할당
    char* buffer = (char*)malloc(16);
    buffer[0] = 'A';   // 접근 1
    buffer[15] = 'Z';  // 접근 2
    buffer[20] = 'X';  // 접근 3 ← ❌ 범위 초과!
    
    free(buffer);
    buffer[5] = 'B';   // 접근 4 ← ❌ Use After Free!
    
    return 0;
}
```

---

## 2️⃣ 메모리 레이아웃과 Shadow 상태

### 📍 할당 직후 상태

```
실제 Heap Memory (16바이트):
┌──────────────────────────────────┐
│ Block0 (8바이트)  │ Block1 (8바이트) │
├────┬────┬────┬───┼────┬────┬────┬───┤
│ 0  │ 1  │ 2  │ 3 │ 4  │ 5  │ 6  │ 7 │
├────┼────┼────┼───┼────┼────┼────┼───┤
│ 'A'│    │    │   │    │    │    │'Z'│
├────┴────┴────┴───┼────┴────┴────┴───┤
│ 접근 가능         │ 접근 가능        │
└───────────────────┴─────────────────┘

Shadow Memory (2바이트):
┌──────────┬──────────┐
│ Sh[0]    │ Sh[1]    │
├──────────┼──────────┤
│  0x00    │  0x00    │
│(8/8 OK)  │(8/8 OK)  │
└──────────┴──────────┘
```

### 🔍 각 접근 시점별 Shadow Byte 상태

#### ✅ 접근 1: `buffer[0] = 'A'` (정상)

```
요청: 주소 0x1000 (Block0의 byte 0) 접근

단계 1: Shadow Memory 주소 계산
Shadow_Address = 0x1000 / 8 = 0x200

단계 2: Shadow Byte 읽기
Shadow_Byte = Memory[0x200] = 0x00

단계 3: 접근 검증
Access_Offset = 0 (byte 0)
Check: Access_Offset < Shadow_Byte
       0 < 0xFF? → 아니, 다시 생각해보자
       Shadow_Byte == 0x00? → ✅ YES!
       
결론: ✅ 접근 허용
```

#### ✅ 접근 2: `buffer[15] = 'Z'` (정상)

```
요청: 주소 0x100F (Block1의 byte 7) 접근

단계 1: Shadow Memory 주소 계산
Shadow_Address = 0x100F / 8 = 0x200 + 1 = 0x201

단계 2: Shadow Byte 읽기
Shadow_Byte = Memory[0x201] = 0x00

단계 3: 접근 검증
Access_Offset = 7 (byte 7, Block1 내에서)
Check: Shadow_Byte == 0x00? → ✅ YES!

결론: ✅ 접근 허용
```

#### ❌ 접근 3: `buffer[20] = 'X'` (범위 초과)

```
요청: 주소 0x1014 (할당 범위 외) 접근

단계 1: Shadow Memory 주소 계산
Shadow_Address = 0x1014 / 8 = 0x202 (또는 redzone)

단계 2: Shadow Byte 읽기
Shadow_Byte = Memory[0x202] = 0xF9  ← Redzone 마커!

단계 3: 접근 검증
Shadow_Byte == 0xF9 (음수값)?
또는 Shadow_Byte != 0x00 && Shadow_Byte != 0x01~0x07?

결론: ❌ 에러 보고!
ERROR: heap-buffer-overflow on address 0x1014
```

#### ❌ 접근 4: `buffer[5] = 'B'` (Use After Free)

```
free() 호출 후:

Shadow Memory 상태 변경:
┌──────────┬──────────┐
│ Sh[0]    │ Sh[1]    │
├──────────┼──────────┤
│  0xFD    │  0xFD    │
│(freed!)  │(freed!)  │
└──────────┴──────────┘

요청: 주소 0x1005 접근

단계 1: Shadow Memory 주소 계산
Shadow_Address = 0x1005 / 8 = 0x200

단계 2: Shadow Byte 읽기
Shadow_Byte = Memory[0x200] = 0xFD  ← Freed 마커!

단계 3: 접근 검증
Shadow_Byte == 0xFD (음수값)?  → ✅ YES!

결론: ❌ 에러 보고!
ERROR: heap-use-after-free on address 0x1005
```

---

## 3️⃣ Shadow Byte 값 상세 해석

### 📋 Shadow Byte 테이블

```
┌─────────────┬─────────────────────────────────────┐
│ Shadow Byte │ 의미 및 동작                        │
├─────────────┼─────────────────────────────────────┤
│ 0x00        │ 모든 8바이트 접근 가능              │
│             │ 모든 offset (0~7) 허용              │
│             │ → ✅ 접근 허용                      │
├─────────────┼─────────────────────────────────────┤
│ 0x01        │ 첫 1바이트만 접근 가능              │
│             │ offset 0만 허용, 1~7은 ❌           │
│             │ (마지막 7바이트는 redzone)         │
├─────────────┼─────────────────────────────────────┤
│ 0x03        │ 첫 3바이트만 접근 가능              │
│             │ offset 0,1,2만 허용, 3~7은 ❌      │
├─────────────┼─────────────────────────────────────┤
│ 0x07        │ 첫 7바이트만 접근 가능              │
│             │ offset 0~6만 허용, 7은 ❌           │
├─────────────┼─────────────────────────────────────┤
│ 0xFA        │ 할당되지 않은 메모리 (redzone)     │
│ (음수)      │ 모든 접근 ❌                        │
├─────────────┼─────────────────────────────────────┤
│ 0xFB        │ 스택 메모리 redzone                │
│ (음수)      │ 모든 접근 ❌                        │
├─────────────┼─────────────────────────────────────┤
│ 0xFD        │ Free된 메모리 (Heap freed)          │
│ (음수)      │ 모든 접근 ❌ → Use-After-Free 감지 │
└─────────────┴─────────────────────────────────────┘
```

---

## 4️⃣ 실제 검증 로직 (의사 코드)

```c
// ASan Runtime이 메모리 접근할 때마다 실행하는 코드
bool asan_check_access(void* addr, size_t size) {
    // 1. 접근 주소에서 shadow byte 주소 계산
    void* shadow_addr = GET_SHADOW_ADDRESS(addr);
    
    // 2. Shadow byte 읽기
    uint8_t shadow_byte = *(uint8_t*)shadow_addr;
    
    // 3. 접근 범위 내 모든 바이트에 대해 검증
    for (size_t i = 0; i < size; i++) {
        uint8_t offset_in_block = (addr + i) % 8;
        
        // Shadow byte 해석
        if (shadow_byte == 0x00) {
            // ✅ 모든 8바이트 접근 가능
            continue;  
        } 
        else if (shadow_byte > 0 && shadow_byte <= 7) {
            // 일부 바이트만 접근 가능
            if (offset_in_block >= shadow_byte) {
                // ❌ 접근 불가
                report_error("Heap buffer overflow", addr);
                return false;
            }
        }
        else if (shadow_byte < 0) {
            // 음수 = redzone, freed memory 등
            report_error("Heap redzone/use-after-free", addr);
            return false;
        }
    }
    
    return true;  // ✅ 모든 바이트 접근 가능
}
```

---

## 5️⃣ 부분 할당 예시 (Shadow Byte = 0x05)

```c
// 5바이트만 필요한 경우
struct Data {
    int value;      // 4바이트
    char flag;      // 1바이트 (총 5바이트)
};  // 8바이트 블록 내에서 3바이트는 사용 안 함

Data* d = (Data*)malloc(sizeof(Data));

메모리 레이아웃:
┌─────────────────────┬───────────┐
│ 0 1 2 3 4 5 6 7     │           │
├─────────────────────┤           │
│ [int value] [flag]  │ (unused)  │
│ 4바이트    1바이트  │ 3바이트   │
└─────────────────────┴───────────┘

Shadow Byte = 0x05 (5바이트 사용 가능)

✅ d->value 접근 (offset 0~3)  → 허용
✅ d->flag 접근 (offset 4)     → 허용
❌ redzone 접근 (offset 5~7)   → 거부!
```

---

## 6️⃣ 런타임 에러 메시지 예시

```
=================================================================
==12345==ERROR: AddressSanitizer: heap-buffer-overflow on 
unknown address 0x602000000014 (pc 0x00000047d3c5 T=0)
READ of size 1 at 0x602000000014 thread T0
    #0 0x47d3c4 in main /path/to/file.cpp:10:20
    #1 0x7ffff6e3e082 in __libc_start_main (/lib64/libc.so.6+0x24082)

Address 0x602000000014 is 4 bytes inside a 4-byte region
[0x602000000010, 0x602000000014)
allocated here:
    #0 0x47d0d0 in malloc (/path/to/libasan.so.5+0xe90d0)
    #1 0x47d234 in main /path/to/file.cpp:8:20

SUMMARY: AddressSanitizer: heap-buffer-overflow 
/path/to/file.cpp:10:20 in main
==12345==ABORTING
=================================================================
```

---

## 7️⃣ Shadow Byte 상태 변이도

```
메모리 생명주기 동안 Shadow Byte의 변화:

┌─────────────┐
│   미할당    │
│ Sh = 0xFA   │ (redzone)
└─────────────┘
       ↓
┌─────────────┐
│   malloc    │ ← Shadow Byte 설정
└─────────────┘
       ↓
┌─────────────┐
│   사용 중    │
│ Sh = 0x00   │ (또는 0x01~0x07)
│ (읽기/쓰기)  │
└─────────────┘
       ↓
┌─────────────┐
│    free     │ ← Shadow Byte 변경
└─────────────┘
       ↓
┌─────────────┐
│  해제됨      │
│ Sh = 0xFD   │ (freed memory)
│ ❌ 접근 금지 │
└─────────────┘
```

---

## 8️⃣ 성능 특성

```
Shadow Memory 오버헤드:
- 원본 메모리: 1MB
- Shadow Memory: 1MB / 8 = 128KB

메모리 접근당 비용:
┌──────────────────────────┐
│ 1. Shadow 주소 계산      │ ~5 CPU cycles
│ 2. Shadow byte 읽기      │ ~3 CPU cycles  
│ 3. 접근 검증 로직        │ ~10 CPU cycles
│ 4. 에러 처리 (필요시)    │ ~1000+ cycles
├──────────────────────────┤
│ 총 오버헤드: 18~30 cycles│
└──────────────────────────┘

→ 정상 접근: 빠름
→ 에러 감지: 느리지만 프로그램 중단 (어차피 버그)
```
