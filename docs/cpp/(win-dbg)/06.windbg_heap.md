---
layout: default
title: "06. heap 이란?"
parent: "(Windows Debugging)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# Heap 메모리 구조

## Heap이란?

* Heap은 프로그램이 **동적으로 메모리를 할당**하는 데 사용하는 메모리 영역. 
* 스택(Stack)과 달리 런타임에 크기가 결정되며, 프로그래머가 명시적으로 할당(`malloc`, `new`)하고 해제(`free`, `delete`) 필요

## Heap이 필요한 이유

### OS의 메모리 할당 비효율성

- **OS는 4KB 단위로 메모리를 할당**합니다
- 1byte 단위의 작은 메모리 할당에는 너무 비효율적
- `VirtualAlloc`과 같은 시스템 콜은 **매우 느림** (커널 모드 전환 필요)

### Heap의 해결책

```
┌─────────────────────────────────────┐
│  OS로부터 큰 블록 할당 (예: 1MB)    │
├─────────────────────────────────────┤
│  User Mode에서 작은 단위로 분할     │
│  ┌────┐ ┌──────┐ ┌───┐ ┌─────────┐ │
│  │ 8B │ │ 16B  │ │4B │ │  Free   │ │
│  └────┘ └──────┘ └───┘ └─────────┘ │
└─────────────────────────────────────┘
```

1. OS로부터 **덩어리 블록의 메모리**를 미리 받아놓음
2. 그 안에서 **작은 단위로 쪼개서 할당** (User Mode에서 처리)
3. 시스템 콜 횟수를 줄여 성능 향상

## Heap 블록 병합 (Coalescing)

메모리를 해제할 때 인접한 빈 블록과 병합하여 단편화(Fragmentation)를 방지

### 병합 전
```
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│Used │ │Free │ │Free │ │Used │
│ 8B  │ │ 4B  │ │ 8B  │ │ 16B │
└─────┘ └─────┘ └─────┘ └─────┘
```

### 병합 후
```
┌─────┐ ┌─────────────┐ ┌─────┐
│Used │ │    Free     │ │Used │
│ 8B  │ │    12B      │ │ 16B │
└─────┘ └─────────────┘ └─────┘
```

## Heap의 Linked-List 구조

Heap은 내부적으로 **Linked-List**로 빈 블록들을 관리

### 기본 구조

```c
typedef struct HeapBlock {
    size_t size;              // 블록 크기
    struct HeapBlock* next;   // 다음 빈 블록 포인터
    int is_free;              // 할당 여부
} HeapBlock;
```

### Heap 메모리 레이아웃

```
Heap 시작
  ↓
┌──────────────────┐
│ Header (메타데이터) │ ← size, next, is_free
├──────────────────┤
│   User Data      │ ← 실제 할당된 공간
├──────────────────┤
│ Header           │
├──────────────────┤
│   User Data      │
└──────────────────┘
```

## Heap 충돌 (Heap Collision) 예시

### 시나리오: Free List 손상

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // 첫 번째 할당
    char* buffer1 = (char*)malloc(16);
    printf("Buffer1: %p\n", buffer1);
    
    // 두 번째 할당
    char* buffer2 = (char*)malloc(16);
    printf("Buffer2: %p\n", buffer2);
    
    // 세 번째 할당
    char* buffer3 = (char*)malloc(16);
    printf("Buffer3: %p\n", buffer3);
    
    // buffer1 해제 (Free List에 추가됨)
    free(buffer1);
    
    // ⚠️ 버퍼 오버플로우: buffer2의 범위를 넘어서 씀
    // buffer3의 헤더 메타데이터를 덮어씀
    strcpy(buffer2, "AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBB"); // 32바이트 작성
    
    // buffer3 해제 시 손상된 메타데이터로 인해 충돌 발생
    free(buffer3); // ❌ Heap Corruption!
    
    return 0;
}
```

### 충돌 발생 과정

#### 1. 정상 상태
```
┌─────────────────┐
│ Block1 (freed)  │ ← Free List Head
│ next → NULL     │
├─────────────────┤
│ Block2 (used)   │
│ data: "Hello"   │
├─────────────────┤
│ Block3 (used)   │
│ size: 16        │
└─────────────────┘
```

#### 2. 버퍼 오버플로우 발생
```
┌─────────────────┐
│ Block1 (freed)  │
├─────────────────┤
│ Block2 (used)   │
│ data: "AAAA..." │ ← 32바이트 작성
├─AAAAAAAA────────┤ ← Block3의 헤더 손상!
│ Block3 (used)   │
│ size: 0x41414141│ ← 'AAAA'로 덮어씀
└─────────────────┘
```

#### 3. free(buffer3) 호출 시
```
Heap Manager가 Block3의 손상된 헤더를 읽음
  ↓
잘못된 next 포인터를 따라감
  ↓
❌ Segmentation Fault
❌ Double Free
❌ Use After Free
```

### 실제 충돌 유형

#### Use After Free
```c
char* ptr = malloc(16);
free(ptr);
strcpy(ptr, "Hello"); // ❌ 해제된 메모리 사용
```

#### Double Free
```c
char* ptr = malloc(16);
free(ptr);
free(ptr); // ❌ 같은 블록을 두 번 해제
// Free List가 순환 참조를 형성할 수 있음
```

#### Heap Overflow로 인한 충돌
```c
char* ptr1 = malloc(8);
char* ptr2 = malloc(8);

// ptr1에 16바이트 작성 → ptr2의 헤더 손상
memcpy(ptr1, "AAAAAAAAAAAAAAAA", 16);

free(ptr2); // ❌ 손상된 메타데이터로 충돌
```

## Heap 보호 기법

### 1. Guard Pages
```
┌─────────────┐
│ Guard Page  │ ← 접근 시 즉시 예외 발생
├─────────────┤
│ Heap Block  │
├─────────────┤
│ Guard Page  │
└─────────────┘
```

### 2. Canary Values
```c
struct HeapBlock {
    size_t magic;        // 0xDEADBEEF
    size_t size;
    // ... data ...
    size_t end_magic;    // 0xDEADBEEF
};
// 해제 시 magic 값 검증
```

### 3. ASLR (Address Space Layout Randomization)
- Heap 시작 주소를 무작위화하여 공격 난이도 증가

## 디버깅 팁

### Valgrind 사용
```bash
valgrind --leak-check=full ./program
```

### AddressSanitizer (ASan)
```bash
gcc -fsanitize=address -g program.c
./a.out
```

### Visual Studio의 Heap 검증
```c
#include <crtdbg.h>
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
```
