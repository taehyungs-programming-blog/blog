---
layout: default
title: "21. lambda"
parent: (C++)
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ¹ ë„ˆë¬´ ê¸°ì´ˆë³´ë‹¨ ëª°ëë˜ ë‚´ìš©ìœ„ì£¼ë¡œ ì •ë¦¬ í•¨.

## closure object

* **closure object** : ëŒë‹¤ í‘œí˜„ì‹ì˜ ë™ì‘ ì›ë¦¬ì— í•´ë‹¹í•œë‹¤. ëŒë‹¤ê°€ ì‘ì„±ë˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” closure objectë¥¼ ìƒì„±í•´ ì¤€ë‹¤.

```cpp
sort(x, x+10, [](int a, int b){ return a < b; });

// ì»´íŒŒì¼ëŸ¬ëŠ” ì•„ë˜ì™€ ê°™ì€ closure objectë¥¼ ìƒì„±í•´ ì¤€ë‹¤.
    // ì •í™•í•œ ëª¨ì–‘ ì•„ë˜ì™€ ê°™ì´ ê°„ë‹¨í•˜ì§„ ì•Šê³  ì¢€ ë” ë³µì¡í•¨.
class ClosureType
{
public:
    bool operator()(int a, int b) const
    {
        return a < b;
    }
};
```

---

## lambdaì˜ typeì¡°ì‚¬

```cpp
// ë™ì¼í•´ ë³´ì´ëŠ” ë‘ lambda ê³¼ì—° typeë„ ë™ì¼í• ê¹Œ?
auto f1 = [](int a, int b) { return a + b; }
auto f2 = [](int a, int b) { return a + b; }

// ê²°ë¡ ì€ typeì€ ë‹¤ë¦„
    // C++ ê·œì •ìƒ ëª¨ë“  lambdaì˜ typeì€ ìœ ë‹ˆí¬í•˜ë‹¤
cout << typeid(f1).name() << endl;
cout << typeid(f2).name() << endl;

// ë”°ë¼ì„œ, ì´ëŸ°ì—°ì‚°ë¶ˆê°€
f2 = [](int a, int b) { return a + b; }
```

---

## lambdaëŠ” ë­˜ë¡œ ë°›ì„ ìˆ˜ ìˆì„ê¹Œ?

```cpp
// ì„¸ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ë°›ì„ ìˆ˜ ìˆìŒ.
auto f1 = [](int a , int b) { return a + b; }
int(*f2)(int, int) = [](int a, int b) { return a + b; }
function<int(int, int)> f3 = [](int a, int b) { return a + b; }

// inlineì¹˜í™˜ì´ ë ê¹Œ?
f1(1, 2);   // ok - inlineì¹˜í™˜ ì§€ì› - functorì´ê¸°ì— ê°€ëŠ¥í•˜ë‹¤
f2(1, 2);   // nope - í•¨ìˆ˜í¬ì¸í„°ëŠ” inlineì¹˜í™˜ ë¯¸ ì§€ì›(í•¨ìˆ˜í¬ì¸í„°ëŠ” ê°€ë¦¬í‚¤ëŠ” í•¨ìˆ˜ê°€ ë‹¬ë¼ì§ˆìˆ˜ ìˆê¸°ì—)
f3(1, 2);   // nope - ìœ„ì™€ê°™ì€ì´ìœ 
```

---

## lambdaì˜ ë¦¬í„´íƒ€ì… ì§€ì •

```cpp
// suffix return typeì´ë¼ í•œë‹¤
auto f1 = [](int a, int b) -> int { return a + b; }
```

---

## Capture Variable

ğŸ¹ ì—­ì‹œ ë„ˆë¬´ ì‰¬ìš´ ë‚´ìš©ì€ ìƒëµí•¨. ëª°ëë˜ ë¶€ë¶„ ìœ„ì£¼ë¡œ ì •ë¦¬

```cpp
int g = 10;

int main()
{
    int v1 = 0;

    auto f1 = [](int a) { 
        return a + g; // ë‚´ë¶€ì—ì„œ ì „ì—­ë³€ìˆ˜ gì— ì ‘ê·¼ì´ ê°€ëŠ¥í• ê¹Œ?
                      // ok - ì „ì—­ì€ ì ‘ê·¼ì´ ê°€ëŠ¥, closureë¼ëŠ” ê°ì²´ë‚´ë¶€ì—ì„œ í˜¸ì¶œë˜ê¸°ì— ê°€ëŠ¥
    }

    auto f2 = [](int a) { 
        return a + v1; // ë‚´ë¶€ì—ì„œ ì§€ì—­ë³€ìˆ˜ì— ì ‘ê·¼ì´ ê°€ëŠ¥í• ê¹Œ?
                       // error - ì§€ì—­ì€ ì ‘ê·¼ì´ ë¶ˆê°€ëŠ¥, closureê¸°ì¤€ì—ì„  v1ì„ ëª¨ë¥¸ë‹¤.
    }

    // ì§€ì—­ë³€ìˆ˜ì— ì ‘ê·¼í•˜ê³  ì‹¶ë‹¤ë©´ ì§€ì—­ë³€ìˆ˜ Captureë¥¼ ì‚¬ìš©í•´ì•¼í•œë‹¤.
    auto f3 = [v1](int a) { return a + v1; }

    auto f4 = [v1](int a) mutable { 
            v1 = 10;        // mutableì„ ë¶™ì´ë©´ v1ì„ ìˆ˜ì •ê°€ëŠ¥í•´ì§€ëŠ”ë°
                            // clousuer ê°ì²´ì˜ operator()() const ì†ì„±ì„ ì œê±°í•´ ì£¼ê¸°ë•Œë¬¸ì´ë‹¤.
                            // ë‹¨, v1ì„ ìˆ˜ì •í–ˆë‹¤ í•˜ë”ë¼ë„ ë³µì‚¬ë³¸ì´ ìˆ˜ì •ë˜ê¸°ì— v1ìì²´ê°€ ìˆ˜ì •ë˜ì§„ ì•ŠëŠ”ë‹¤
            return a + v1; 
        }
}
```

```cpp
string s = "hello";
auto f11 = [s1 = move(s)]() {};

unique_ptr<int> p(new int);
// auto f12 = [p]() {} // Error - unique_ptr ìº¡ì²˜ë¶ˆê°€
auto f12 = [p = move(p)]() {}
```

```cpp
class Test
{
    int data = 0;
public:
    void foo()
    {
        auto f = [this]() { data = 10; }    // ok

        // C++17 ë¶€í„° thisì˜ ë³µì‚¬ë³¸ì„ ìº¡ì³ê°€ëŠ¥
        auto f2 = [*this]() mutable { data = 10; } // ok - dataì—ëŠ” ì˜í–¥ì„ ì•ˆì¤Œ
    }
}
```

---

## C++20ì—ì„œì˜ Lambda

1. **í…œí”Œë¦¿** ì‚¬ìš© ê°€ëŠ¥
2. **í‰ê°€ ë˜ì§€ ì•Šì€ í‘œí˜„ì‹** ì‚¬ìš© ê°€ëŠ¥
3. **ë””í´íŠ¸ ìƒì„±ì, ëŒ€ì… ì—°ì‚°ì** ì‚¬ìš© ê°€ëŠ¥
4. ì•”ì‹œì  this ìº¡ì³ê°€ deprecated ë¨
5. **Parameter pack** ìº¡ì³ ê°€ëŠ¥

### í…œí”Œë¦¿ ì‚¬ìš© ê°€ëŠ¥

```cpp
// ëŒë‹¤ì˜ ë§¤ê°œë³€ìˆ˜ë¡œ doubleì´ ì˜¨ë‹¤ë©´?
auto add1 = [](int  a, int  b) {return a + b;};
```

```cpp
// í  ... a, bê°€ ë‘˜ ë‹¤ doubleì´ë©´ double / intë©´ int ì˜€ìœ¼ë©´ í•˜ëŠ”ë°?
auto add2 = [](auto a, auto b) {return a + b;};
```

```cpp
auto add3 = [](auto a, decltype(a) b) {return a + b;};
// std::cout << add3(1,   2.2) << std::endl; // 3 - ì´ê±¸ ì—ëŸ¬ë¡œ ë¦¬í„´í•˜ê²Œ í•˜ê³ ì‹¶ì€ë°??
    // -> templateì˜ í•„ìš”ì„±
```

```cpp
#include <iostream>

auto add1 = [](auto a, auto b) {return a + b;};         // C++14
auto add2 = []<typename T>(T a, T b) {return a + b;};   // C++20

// ì´ëŸ° í‘œí˜„ë„ ê°€ëŠ¥í•˜ë‹¤
auto add3 = []<typename T1, typename T2>(T1 a, T1 b, T2 c) {return a + b + c;}; // C++20

int main()
{
    std::cout << add1(1,   2)   << std::endl; // 3
    std::cout << add1(1.1, 2.2) << std::endl; // 3.3
    std::cout << add1(1,   2.2) << std::endl; // 3.2

    std::cout << add2(1,   2)   << std::endl; // 3
    std::cout << add2(1.1, 2.2) << std::endl; // 3.3
//    std::cout << add2(1,   2.2) << std::endl; // error.

// ìë£Œí˜•ì„ ì§ì ‘ì§€ì •í•˜ê² ë‹¤ê³  ì•„ë˜ì²˜ëŸ¼ ì“°ë©´ ì—ëŸ¬ë‚¨.
//   std::cout << add2<int>(1,   2.2) << std::endl; // error.

// ìë£Œí˜•ì„ ì§€ì •í•˜ê³  ì‹¶ë‹¤ë©´ì•„ë˜ì²˜ëŸ¼ í•  ê²ƒ
   add2.operator()<int>(1, 2.2); // ok
}
```

---

### í‰ê°€ ë˜ì§€ ì•Šì€ í‘œí˜„ì‹ ì‚¬ìš© ê°€ëŠ¥

* **í‰ê°€ ë˜ì§€ ì•Šì€ í‘œí˜„ì‹(unevaluated expression)** : ì‹¤í–‰ ì‹œê°„ì— ì‹¤í–‰ë˜ì§€ ì•Šê³ , ì»´íŒŒì¼ ì‹œê°„ì—ë§Œ ì‚¬ìš©ë˜ëŠ” í‘œí˜„ì‹
    * ëŒ€í‘œì ìœ¼ë¡œ ì•„ë˜ì™€ ê°™ì€ í•¨ìˆ˜ê°€ í‰ê°€ ë˜ì§€ ì•Šì€ í‘œí˜„ì‹ ì´ë‹¤.
    * `sizeof`
    * `decltype`
    * `typeid`
    * `nocept`

```cpp
#include <iostream>
#include <memory>

int add(int a, int b); // { return a + b;}

int main()
{
    std::cout << sizeof(int)  << std::endl;  // 4

    // sizeof(í•¨ìˆ˜í˜¸ì¶œì‹) : ë¦¬í„´ íƒ€ì…ì˜ í¬ê¸°
        // sizeofë„ í‰ê°€ ë˜ì§€ ì•Šì€ í‘œí˜„ì‹ìœ¼ë¡œ ì»´íŒŒì¼ íƒ€ì„ì— ê²°ì •ëœë‹¤.
    std::cout << sizeof( add(1, 2) ) << std::endl; // 4

    decltype( add(1,2) ) n;  // int n

    // í‰ê°€ë˜ì§€ ì•Šì€ í‘œí˜„ì‹ ì•ˆì— ëŒë‹¤ë¥¼ ì“¸ ìˆ˜ìˆì„ê¹Œ? -> C++20ë¶€í„° ê°€ëŠ¥
    std::cout << sizeof( [](int a, int b) {return a + b;} ) << std::endl;  // C++17.. error. C++20 ok
                            // 1 - ë¦¬í„´í˜•ì˜ í¬ê¸°

    std::cout << sizeof( [](int a, int b) {return a + b;}(1,2) ) << std::endl; // 4 - í˜¸ì¶œ ê²°ê³¼ì˜ í¬ê¸°

    // ì•„ë˜ì™€ ê°™ì€ ì„ ì–¸ì´ ê°€ëŠ¥í•œì´ìœ ê°€
        // unique_ptrì˜ ë‘ ë²ˆì§¸ ì¸ìë¡œ ì‚­ì œìì˜ íƒ€ì…ì„ ë„£ì–´ì•¼í•˜ëŠ”ë°
        // ëŒë‹¤ì˜ ê²½ìš° íƒ€ì…ì´ë„ê²Œ ê°œë°œìê°€ ë„£ì„ìˆ˜ ì—†ìŒ.
        // ëŒë‹¤ê°€ í‰ê°€ë˜ì§€ ì•Šì€ í‘œí˜„ì‹ì„ ëŒë‹¤ì— ì“¸ìˆ˜ì—†ì—ˆë˜ C++20ì´ì „ì€ ì•„ë˜ì™€ ê°™ì€ í‘œí˜„ì´ ë¶ˆê°€ëŠ¥.
    std::unique_ptr<int, decltype( [](int* p) { delete p; }) > up( new int );
}
```

---

### ë””í´íŠ¸ ìƒì„±ì, ëŒ€ì… ì—°ì‚°ì ì‚¬ìš© ê°€ëŠ¥

```cpp
#include <iostream>

int main()
{
    int v1 = 10;

    auto f1 = [v1](int a, int b) {return a + b;};

                            // C++11 ~ C++17     C++ 20
    decltype(f1) f2;        // Error               Error
    decltype(f1) f3 = f1;   // OK                  OK
    f3 = f1;                // Error               Error

/*
    auto f1 = [](int a, int b) {return a + b;};
                            // C++11 ~ C++17     C++ 20
    decltype(f1) f2;        // Error               OK
    decltype(f1) f3 = f1;   // OK                  OK
    f3 = f1;                // Error               OK
*/
   
}
```

---

### ì•”ì‹œì  this ìº¡ì³ê°€ deprecated ë¨

```cpp
#include <iostream>
#include <functional>

struct Sample
{
	int value = 0;

	auto foo()
	{
		int n = 10;

        // [=] => [=, this]
		//auto f = [=](int a) { return a + n + value; };        
        //auto f = [=, this](int a) { return a + n + value; };        
    
        auto f = [=, *this](int a) { return a + n + value; };        
        
        std::cout << sizeof(f) << std::endl; // 8
		
        return f;
	}

};
std::function<int(int)> f;

void goo()
{
	Sample s;
	f = s.foo();
    std::cout << f(10) << std::endl;
}
int main() 
{
     goo(); 
     //....
     std::cout << f(10) << std::endl;
}
```

---

### Parameter pack ìº¡ì³ ê°€ëŠ¥

```cpp
#include <iostream>

// Capture Parameter pack by value.
template<typename ... Args> auto f1(Args&&... args)
{
	return [...args = std::forward<Args>(args)](){ (std::cout << ... << args); };
}

// Capture Parameter pack by reference.
template<typename ... Args> auto f2(Args&&... args)
{
	return[&...args = std::forward<Args>(args)](){ (std::cout << ... << args); };
}

int main()
{
	f1(1, 2, 3, 4, 5)();

	std::cout << std::endl;

	int a = 1, b = 2, c = 3;
	f2(a, b, c)();
}
```