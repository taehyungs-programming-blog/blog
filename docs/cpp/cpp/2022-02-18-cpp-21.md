---
layout: default
title: "21. lambda"
parent: (C++)
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

🐹 너무 기초보단 몰랐던 내용위주로 정리 함.

## closure object

* **closure object** : 람다 표현식의 동작 원리에 해당한다. 람다가 작성되면 컴파일러는 closure object를 생성해 준다.

```cpp
sort(x, x+10, [](int a, int b){ return a < b; });

// 컴파일러는 아래와 같은 closure object를 생성해 준다.
    // 정확한 모양 아래와 같이 간단하진 않고 좀 더 복잡함.
class ClosureType
{
public:
    bool operator()(int a, int b) const
    {
        return a < b;
    }
};
```

---

## lambda의 type조사

```cpp
// 동일해 보이는 두 lambda 과연 type도 동일할까?
auto f1 = [](int a, int b) { return a + b; }
auto f2 = [](int a, int b) { return a + b; }

// 결론은 type은 다름
    // C++ 규정상 모든 lambda의 type은 유니크하다
cout << typeid(f1).name() << endl;
cout << typeid(f2).name() << endl;

// 따라서, 이런연산불가
f2 = [](int a, int b) { return a + b; }
```

---

## lambda는 뭘로 받을 수 있을까?

```cpp
// 세 가지 방법으로 받을 수 있음.
auto f1 = [](int a , int b) { return a + b; }
int(*f2)(int, int) = [](int a, int b) { return a + b; }
function<int(int, int)> f3 = [](int a, int b) { return a + b; }

// inline치환이 될까?
f1(1, 2);   // ok - inline치환 지원 - functor이기에 가능하다
f2(1, 2);   // nope - 함수포인터는 inline치환 미 지원(함수포인터는 가리키는 함수가 달라질수 있기에)
f3(1, 2);   // nope - 위와같은이유
```

---

## lambda의 리턴타입 지정

```cpp
// suffix return type이라 한다
auto f1 = [](int a, int b) -> int { return a + b; }
```

---

## Capture Variable

🐹 역시 너무 쉬운 내용은 생략함. 몰랐던 부분 위주로 정리

```cpp
int g = 10;

int main()
{
    int v1 = 0;

    auto f1 = [](int a) { 
        return a + g; // 내부에서 전역변수 g에 접근이 가능할까?
                      // ok - 전역은 접근이 가능, closure라는 객체내부에서 호출되기에 가능
    }

    auto f2 = [](int a) { 
        return a + v1; // 내부에서 지역변수에 접근이 가능할까?
                       // error - 지역은 접근이 불가능, closure기준에선 v1을 모른다.
    }

    // 지역변수에 접근하고 싶다면 지역변수 Capture를 사용해야한다.
    auto f3 = [v1](int a) { return a + v1; }

    auto f4 = [v1](int a) mutable { 
            v1 = 10;        // mutable을 붙이면 v1을 수정가능해지는데
                            // clousuer 객체의 operator()() const 속성을 제거해 주기때문이다.
                            // 단, v1을 수정했다 하더라도 복사본이 수정되기에 v1자체가 수정되진 않는다
            return a + v1; 
        }
}
```

```cpp
string s = "hello";
auto f11 = [s1 = move(s)]() {};

unique_ptr<int> p(new int);
// auto f12 = [p]() {} // Error - unique_ptr 캡처불가
auto f12 = [p = move(p)]() {}
```

```cpp
class Test
{
    int data = 0;
public:
    void foo()
    {
        auto f = [this]() { data = 10; }    // ok

        // C++17 부터 this의 복사본을 캡쳐가능
        auto f2 = [*this]() mutable { data = 10; } // ok - data에는 영향을 안줌
    }
}
```