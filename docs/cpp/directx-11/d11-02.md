---
layout: default
title: "02. MVP(Model View Projection)"
parent: "(DirectX 11 ğŸŒŸ)"
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Clone Code ğŸŒ](https://github.com/EasyCoding-7/DirectX11-Examples/tree/2/2_MVP)

```cpp
void ExampleApp::Render() {

    // ...

    // Renderì˜ ê³¼ì •ì—ì„œ ConstantBufferë¥¼ ë„˜ê¸°ê²Œ ëœë‹¤.
    m_context->VSSetConstantBuffers(0, 1, m_constantBuffer.GetAddressOf());
```

* ëŒ€ëµ Constant Bufferì— ë„£ëŠ” ë°©ë²•ì€ ì•„ë˜ì™€ ê°™ìŒ

```cpp
// ì´ ì˜ˆì œì—ì„œ ConstantBufferë¡œ ë³´ë‚¼ ë°ì´í„°
struct ModelViewProjectionConstantBuffer {
    Matrix model;
    Matrix view;
    Matrix projection;
};
```

```cpp
template <typename T_DATA>
void UpdateBuffer(const T_DATA &bufferData, ComPtr<ID3D11Buffer> &buffer) {
    D3D11_MAPPED_SUBRESOURCE ms;
    m_context->Map(buffer.Get(), NULL, D3D11_MAP_WRITE_DISCARD, NULL, &ms);
    memcpy(ms.pData, &bufferData, sizeof(bufferData));
    m_context->Unmap(buffer.Get(), NULL);
}
```

---

* ê·¸ë˜ì„œ ì˜¤ëŠ˜ í•˜ê³ ì í•˜ëŠ”ê²ƒì€?

* ConstantBufferì— ë„£ì„ Model, View, Projectionì„ ì–´ë–»ê²Œ ë„£ëŠ”ì§€, ì™œ ë„£ëŠ”ì§€??

```cpp
void ExampleApp::Update(float dt) {

    using namespace DirectX;

    // ëª¨ë¸ì˜ ë³€í™˜
    m_constantBufferData.model =
        Matrix::CreateScale(m_modelScaling) * Matrix::CreateRotationY(m_modelRotation.y) *
        Matrix::CreateRotationX(m_modelRotation.x) * Matrix::CreateRotationZ(m_modelRotation.z) *
        Matrix::CreateTranslation(m_modelTranslation);
    m_constantBufferData.model = m_constantBufferData.model.Transpose();

    // ì‹œì  ë³€í™˜
    // m_constantBufferData.view = XMMatrixLookAtLH(m_viewEye, m_viewFocus, m_viewUp);
    m_constantBufferData.view = XMMatrixLookToLH(m_viewEyePos, m_viewEyeDir, m_viewUp);
    m_constantBufferData.view = m_constantBufferData.view.Transpose();

    // í”„ë¡œì ì…˜
    // m_aspect = AppBase::GetAspectRatio(); // <- GUIì—ì„œ ì¡°ì ˆ
    if (m_usePerspectiveProjection) {
        m_constantBufferData.projection = XMMatrixPerspectiveFovLH(
            XMConvertToRadians(m_projFovAngleY), m_aspect, m_nearZ, m_farZ);
    } else {
        m_constantBufferData.projection =
            XMMatrixOrthographicOffCenterLH(-m_aspect, m_aspect, -1.0f, 1.0f, m_nearZ, m_farZ);
    }
    m_constantBufferData.projection = m_constantBufferData.projection.Transpose();

    // Constantë¥¼ CPUì—ì„œ GPUë¡œ ë³µì‚¬
    AppBase::UpdateBuffer(m_constantBufferData, m_constantBuffer);
}
```

---

## Model

* ì‚¬ì‹¤ìƒ Modelì´ ì œì¼ì‰½ë‹¤.
    * SRT(Scale, Rotation, Translation)ì„ ì ìš©

```cpp
// ëª¨ë¸ì˜ ë³€í™˜
m_constantBufferData.model =
    Matrix::CreateScale(m_modelScaling) * Matrix::CreateRotationY(m_modelRotation.y) *
    Matrix::CreateRotationX(m_modelRotation.x) * Matrix::CreateRotationZ(m_modelRotation.z) *
    Matrix::CreateTranslation(m_modelTranslation);
// (TIPS) í•­ìƒ Transposeë¥¼ ì‚¬ìš©í•˜ëŠ”ë° SimpleMathì—ì„  Row Majorë¥¼ ì“°ê³  ShaderëŠ” Column Majorë¥¼ ì“°ê¸° ë•Œë¬¸ì´ë‹¤.
m_constantBufferData.model = m_constantBufferData.model.Transpose();
```

---

## View

* ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ë¥¼ ì§€ì •í•œë‹¤

```cpp
// ì‹œì  ë³€í™˜
    // ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ë¥¼ ë§í•¨
// m_constantBufferData.view = XMMatrixLookAtLH(m_viewEye, m_viewFocus, m_viewUp);
m_constantBufferData.view = XMMatrixLookToLH(m_viewEyePos, m_viewEyeDir, m_viewUp);
m_constantBufferData.view = m_constantBufferData.view.Transpose();
```

---

## Projection

* ì¹´ë©”ë¼ë¡œ ë¶€í„° ì°íŒ í™”ë©´ì„ ì •ì˜í•œë‹¤

```cpp
// í”„ë¡œì ì…˜
// m_aspect = AppBase::GetAspectRatio(); // <- GUIì—ì„œ ì¡°ì ˆ
if (m_usePerspectiveProjection) {
    // Fov(Field Of View) - ì‹œì•¼ê°ì„ ì˜ë¯¸
    m_constantBufferData.projection = XMMatrixPerspectiveFovLH(
        XMConvertToRadians(m_projFovAngleY), m_aspect, m_nearZ, m_farZ);
} else {
    m_constantBufferData.projection =
        XMMatrixOrthographicOffCenterLH(-m_aspect, m_aspect, -1.0f, 1.0f, m_nearZ, m_farZ);
}
m_constantBufferData.projection = m_constantBufferData.projection.Transpose();
```