---
layout: default
title: "09. ì—¬ëŸ¬ Vertexìœ„ì— Texture ê·¸ë¦¬ê¸°(ê²©ì í‰ë©´ ê·¸ë¦¬ê¸°)"
parent: "(DirectX 11 ğŸŒŸ)"
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Clone Code ğŸŒ](https://github.com/EasyCoding-7/DirectX11-Examples/tree/10/10_grid)

```cpp
MeshData GeometryGenerator::MakeGrid(const float width, const float height,
                                     const int numSlices, const int numStacks) {

    // ì•ˆë‚´: ì‹¤ë¦°ë”ì™€ êµ¬ ë§Œë“¤ê¸° ì´í•´ë¥¼ ë•ê¸° ìœ„í•´ í›„ì† ë…¹í™”í•œ ê°•ì˜ì…ë‹ˆë‹¤.

    // x-y í‰ë©´ (z = 0) ìœ„ì— ê²©ì êµ¬ì¡°ë¡œ í‰ë©´ ë§Œë“¤ê¸°
    // ë’¤ì—ì„œ ë³µì¡í•œ ì§€í˜•ìœ¼ë¡œ í™•ì¥

    // 1ë‹¨ê³„: numStacks = 1 ì´ê³  numSlicesë§Œ ê³ ë ¤í•´ì„œ êµ¬í˜„
    // 2ë‹¨ê³„: 2ì°¨ì› ë°”ë‘‘íŒ êµ¬ì¡°

    const float dx = width / numSlices;
    const float dy = height / numSlices;

    MeshData meshData;

    vector<Vertex> &vertices = meshData.vertices;
    vector<uint16_t> &indices = meshData.indices;

    // y = -0.5f * height ì¸ ì ë“¤
    //Vector3 stackStartPoint = Vector3(-0.5f * width, -0.5f * height, 0.0f);
    //for (int i = 0; i <= numSlices; i++) {
    //    Vertex v;

    //    // x-y í‰ë©´ì—ì„œ ì‹œì‘ì ì„ x ë°©í–¥ìœ¼ë¡œ ì´ë™
    //    v.position = Vector3::Transform(
    //        stackStartPoint,
    //        Matrix::CreateTranslation(Vector3(dx * float(i), 0.0f, 0.0f)));

    //    // ì‹œì ì„ í–¥í•˜ëŠ” ë°©í–¥
    //    v.normal = Vector3(0.0f, 0.0f, -1.0f);
    //    v.texcoord = Vector2(float(i) / numSlices, 1.0f);

    //    vertices.push_back(v);
    //}

    Vector3 leftBottom = Vector3(-0.5f * width, -0.5f * height, 0.0f);
    for (int j = 0; j <= numStacks; j++) {
        // ìŠ¤íƒì€ ìœ„ë¡œ ìŒ“ê¸° ë•Œë¬¸ì— y ë°©í–¥ìœ¼ë¡œ ì´ë™
        Vector3 stackStartPoint = Vector3::Transform(
            leftBottom, Matrix::CreateTranslation(Vector3(0.0f, dy * j, 0.0f)));

        for (int i = 0; i <= numSlices; i++) {
            Vertex v;

            // x-y í‰ë©´ì—ì„œ ì‹œì‘ì ì„ x ë°©í–¥ìœ¼ë¡œ ì´ë™
            v.position = Vector3::Transform(
                stackStartPoint,
                Matrix::CreateTranslation(Vector3(dx * float(i), 0.0f, 0.0f)));

            // ì‹œì ì„ í–¥í•˜ëŠ” ë°©í–¥
            v.normal = Vector3(0.0f, 0.0f, -1.0f);
            v.texcoord = Vector2(float(i) / numSlices, 1.0f - float(j) / numStacks);

            vertices.push_back(v);
        }
    }

    cout << vertices.size() << endl;

    //// y = 0.5f * height ì¸ ì ë“¤
    //stackStartPoint = Vector3(-0.5f * width, 0.5f * height, 0.0f);
    //for (int i = 0; i <= numSlices; i++) {
    //    Vertex v;

    //    // x-y í‰ë©´ì—ì„œ ì‹œì‘ì ì„ x ë°©í–¥ìœ¼ë¡œ ì´ë™
    //    v.position = Vector3::Transform(
    //        stackStartPoint,
    //        Matrix::CreateTranslation(Vector3(dx * float(i), 0.0f, 0.0f)));

    //    // ì‹œì ì„ í–¥í•˜ëŠ” ë°©í–¥
    //    v.normal = Vector3(0.0f, 0.0f, -1.0f);
    //    v.texcoord = Vector2(float(i) / numSlices, 1.0f);

    //    vertices.push_back(v);
    //}

    for (int j = 0; j < numStacks; j++) {

        const int offset = (numSlices + 1) * j;

        for (int i = 0; i < numSlices; i++) {

            // ì²«ë²ˆì§¸ ì‚¼ê°í˜•
            indices.push_back(offset + i);
            indices.push_back(offset + i + numSlices + 1);
            indices.push_back(offset + i + 1 + numSlices + 1);

            // ë‘ ë²ˆì§¸ ì‚¼ê°í˜•
            indices.push_back(offset + i);
            indices.push_back(offset + i + 1 + numSlices + 1);
            indices.push_back(offset + i + 1);
        }
    }

    cout << indices.size() << endl;
    for (int i = 0; i < indices.size(); i++) {
        cout << indices[i] << " ";
    }
    cout << endl;

    return meshData;
}
```