---
layout: default
title: "09. ì‹¤ë¦°ë” ê·¸ë¦¬ê¸°"
parent: "(DirectX 11 ğŸŒŸ)"
grand_parent: C++
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Clone Code ğŸŒ](https://github.com/EasyCoding-7/DirectX11-Examples/tree/11/11_cynlinder)


* ì£¼ì˜í•  ì ì€ normal vectorë¥¼ ê³„ì‚°í• ë•Œì´ë‹¤.

```cpp
PixelShaderInput main(VertexShaderInput input)
{
    PixelShaderInput output;
    float4 pos = float4(input.posModel, 1.0f);

    // Normal ë¨¼ì € ë³€í™˜
    float4 normal = float4(input.normalModel, 0.0f);

    // inv transposeë¥¼ ê³±í•´ì¤˜ì•¼í•¨
    output.normalWorld = mul(normal, invTranspose).xyz;

    // ê·¸ëƒ¥ model viewë¥¼ ê³±í•˜ë©´ ì•ˆëœë‹¤.
    //output.normalWorld = mul(normal, model).xyz;
    output.normalWorld = normalize(output.normalWorld);
    
    pos = mul(pos, model);
    
    float t = input.texcoord.x;
    
    pos.xyz += output.normalWorld * t * scale;

    output.posWorld = pos.xyz;
    
    pos = mul(pos, view);
    pos = mul(pos, projection);

    output.posProj = pos;
    output.texcoord = input.texcoord;
    
    output.color = float3(1.0, 1.0, 0.0) * (1.0 - t) + float3(1.0, 0.0, 0.0) * t;

    return output;
}
```

```cpp
MeshData GeometryGenerator::MakeCylinder(const float bottomRadius,
                                         const float topRadius, float height,
                                         int sliceCount) {

    using namespace DirectX;
    using DirectX::SimpleMath::Matrix;
    using DirectX::SimpleMath::Vector3;

    // Texture ì¢Œí‘œê³„ë•Œë¬¸ì— (sliceCount + 1) x 2 ê°œì˜ ë²„í…ìŠ¤ ì‚¬ìš©

    const float dTheta = -XM_2PI / float(sliceCount);

    MeshData meshData;

    vector<Vertex> &vertices = meshData.vertices;

    // ì˜†ë©´ì˜ ë°”ë‹¥ ë²„í…ìŠ¤ë“¤ (ì¸ë±ìŠ¤ 0 ì´ìƒ sliceCount ë¯¸ë§Œ)
    for (int i = 0; i <= sliceCount; i++) {
        Vertex v;

        // TODO: ì‘ì„± (í…ìŠ¤ì¶° ì¢Œí‘œê³„, ë²„í…ìŠ¤ ë…¸ë©€ í•„ìš”)
        v.position =
            Vector3::Transform(Vector3(bottomRadius, -0.5f * height, 0.0f),
                               Matrix::CreateRotationY(dTheta * float(i)));

        std::cout << v.position.x << " " << v.position.z << std::endl;

        v.normal = v.position - Vector3(0.0f, -0.5f * height, 0.0f);
        v.normal.Normalize();
        v.texcoord = Vector2(float(i) / sliceCount, 1.0f);

        vertices.push_back(v);
    }

    // ì˜†ë©´ì˜ ë§¨ ìœ„ ë²„í…ìŠ¤ë“¤ (ì¸ë±ìŠ¤ sliceCount ì´ìƒ 2 * sliceCount ë¯¸ë§Œ)
    for (int i = 0; i <= sliceCount; i++) {
        Vertex v;
        
        // TODO: ì‘ì„± (í…ìŠ¤ì¶° ì¢Œí‘œê³„, ë²„í…ìŠ¤ ë…¸ë©€ í•„ìš”)
        v.position =
            Vector3::Transform(Vector3(topRadius, 0.5f * height, 0.0f),
                               Matrix::CreateRotationY(dTheta * float(i)));

        v.normal = v.position - Vector3(0.0f, 0.5f * height, 0.0f);
        v.normal.Normalize();
        v.texcoord = Vector2(float(i) / sliceCount, 0.0f);

        vertices.push_back(v);
    }

    vector<uint16_t> &indices = meshData.indices;

    for (int i = 0; i < sliceCount; i++) {
        // TODO: ì‚¼ê°í˜• ë‘ ê°œ ì”©
        indices.push_back(i);
        indices.push_back(i + sliceCount + 1);
        indices.push_back(i + 1 + sliceCount +1);

        indices.push_back(i);
        indices.push_back(i+1+sliceCount+1);
        indices.push_back(i+1);
    }

    return meshData;
}
```