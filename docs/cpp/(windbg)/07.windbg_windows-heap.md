---
layout: default
title: "07. windows heap"
parent: "(Windows Debugging)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

### 기본 특징

- **프로세스는 최소한 1개의 Heap을 가진다** - `GetProcessHeap()`으로 접근
- **추가 Heap 생성 가능** - `HeapCreate()`로 생성
- **할당 및 해제**
  - `HeapAlloc()`으로 메모리 할당
  - `HeapFree()`로 메모리 해제
- **할당 전략 분기**
  - 요청받은 사이즈에 따라 LFH(Low Fragmentation Heap), Heap Backend 또는 `VirtualAlloc()` 호출로 분기
- **메모리 정렬**
  - Heap으로 관리되는 메모리(Heap Block)는 **16 bytes align**됨
  - `_HEAP_ENTRY` 및 user 영역 주소는 16 bytes 경계에 정렬됨

---

## HEAP_ENTRY 구조체

### 개요

`_HEAP_ENTRY`는 Heap Block의 메타데이터를 관리하는 핵심 구조체입니다.

### 주요 특징

- **위치**: Heap Block의 가장 앞단에 위치
- **크기**: 구조체 자체는 **16 bytes**
- **역할**:
  - Heap Block의 meta data 저장
  - 실질적으로 **head와 tail 역할을 모두 수행**
  - 앞 block의 사이즈 저장
  - 16 bytes align을 위한 **padding 역할**도 수행

### 구조

```
+------------------+
| _HEAP_ENTRY      |  <- 16 bytes (메타데이터)
| (16 bytes)       |
+------------------+
| User Data        |  <- 사용자가 할당한 데이터
|                  |
+------------------+
```

---

## 16 Bytes Alignment의 이해

### Alignment 규칙

Windows Heap은 성능 최적화를 위해 모든 Heap Block을 **16 bytes 단위로 정렬**합니다.

### 중요한 특징

#### 1. 앞 8 bytes는 사용하지 않음

`_HEAP_ENTRY` 구조체의 **앞 8 bytes**는 Align을 고려하여 **사용하지 않도록 설정**되어 있습니다.

#### 2. 작은 사이즈는 버려짐

16 bytes align을 만족하기 위해 **8 bytes 사이즈를 그냥 버립니다**.

**예시:**
- 사용자가 **6808 bytes** 할당 요청
- 실제로는 **6800 bytes 할당**으로 처리됨
- 8 bytes가 버려지는 것처럼 보이지만 **정상 동작**

#### 3. Overrun이 아님

- 8 bytes Overrun처럼 보이지만 **정상 작동**
- `_HEAP_ENTRY`의 앞 8 bytes가 padding으로 활용되기 때문

### Alignment 계산 예시

```
요청 크기: 100 bytes
_HEAP_ENTRY: 16 bytes
총 필요: 116 bytes

16 bytes align 적용:
→ 128 bytes 할당 (16의 배수)

실제 구조:
[_HEAP_ENTRY: 16] [User Data: 100] [Padding: 12]
```

---

## WinDbg를 이용한 Heap 디버깅

### 1. Heap 목록 확인

프로세스의 모든 Heap을 확인합니다.

```
0:000> !heap -s
```

**출력 예시:**
```
NtGlobalFlag enables following debugging aids for new heaps:
    stack back traces
Heap     Flags   Reserv  Commit  Virt   Free  List   UCR  Virt  Lock  Fast 
00b40000 00000002   1000    2000  1000    14b     2     1     0     0   LFH
00150000 00001002  10000    3000 10000    c7a     3     1     0     0   LFH
```

### 2. 특정 Heap의 상세 정보

```
0:000> !heap -a 00b40000
```

### 3. Heap Block 정보 확인

특정 주소의 Heap Entry를 분석합니다.

```
0:000> dt _HEAP_ENTRY 0x00b40688
```

**출력 예시:**
```
ntdll!_HEAP_ENTRY
   +0x000 UnpackedEntry    : _HEAP_UNPACKED_ENTRY
   +0x000 Size             : 0x0008
   +0x002 Flags            : 0x01
   +0x003 SmallTagIndex    : 0x00
   +0x000 SubSegmentCode   : 0x00010008
   +0x004 PreviousSize     : 0x0005
   +0x006 SegmentOffset    : 0x00
   +0x006 LFHFlags         : 0x00
   +0x007 UnusedBytes      : 0x08
   +0x008 CompactHeader    : 0x00050000`00010008
```

### 4. User 데이터 주소 계산

```
0:000> ? 0x00b40688 + 0x10
Evaluate expression: 11699848 = 00b40698
```

User 데이터는 `_HEAP_ENTRY` 다음(+0x10, 즉 16 bytes 이후)부터 시작합니다.

### 5. Heap Block 덤프

```
0:000> dd 0x00b40688 L8
00b40688  00010008 00050000 41414141 41414141
00b40698  41414141 41414141 42424242 42424242
```

**해석:**
- `00b40688`: `_HEAP_ENTRY` 시작 (16 bytes)
- `00b40698`: User 데이터 시작 (0x41 = 'A', 0x42 = 'B')

### 6. 16 Bytes Alignment 확인

```
0:000> !heap -p -a 0x00b40698
    address 00b40698 found in
    _HEAP @ b40000
      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
        00b40688 0008 0005 [01]   00b40698    00030 - (busy)
```

**분석:**
- `Size`: 0x0008 (16 bytes 단위, 실제 = 0x8 * 16 = 128 bytes)
- `UserSize`: 0x0030 (48 bytes 요청)
- 실제 할당: 128 bytes (16 bytes align)
- Unused: 128 - 48 - 16(HEAP_ENTRY) = 64 bytes

### 7. 6808 Bytes 할당 예시

```
0:000> !heap -p -a <address>
    HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
      <entry>   02a8 0010 [01]   <user>    01a98 - (busy)
```

**계산:**
- `Size`: 0x02a8 (16 bytes 단위)
  - 실제 크기: 0x2a8 * 16 = 0x2a80 = 10880 bytes
- `UserSize`: 0x1a98 = 6808 bytes (요청 크기)
- 실제로는 6800 bytes로 처리됨 (align 때문에 8 bytes 버려짐)

### 8. LFH(Low Fragmentation Heap) 확인

```
0:000> !heap -h 00b40000
```

LFH가 활성화되어 있는지 확인합니다.

---

## 디버깅 Tips

### UnusedBytes 필드 확인

```
0:000> dt _HEAP_ENTRY <address> UnusedBytes
```

이 필드를 통해 얼마나 많은 bytes가 padding으로 사용되었는지 확인할 수 있습니다.

### Heap Corruption 검사

```
0:000> !heap -x <address>
```

특정 주소가 어떤 Heap에 속하는지, corruption이 있는지 검사합니다.

### Page Heap 활성화

더 강력한 디버깅을 위해 Page Heap을 활성화할 수 있습니다:

```
gflags /p /enable <program.exe> /full
```

