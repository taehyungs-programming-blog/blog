---
layout: default
title: "12. windbg + dmp 실전!"
parent: "(Windows Debugging)"
grand_parent: "(C++)"
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 1. Symbol Path 설정

### 1.1 현재 Symbol Path 확인
```
.sympath
```
현재 설정된 심볼 경로를 확인합니다.

### 1.2 Symbol Path 자동 설정
```
.symfix c:\{symbolpath}
```
Microsoft의 기본 심볼 서버를 사용하여 심볼을 자동으로 다운로드합니다.

### 1.3 Symbol Path 추가
```
.sympath+ {추가할 path}
```
기존 심볼 경로에 새로운 경로를 추가합니다.

### 1.4 Source Path 설정
```
.srcpath {source path}
```
소스 코드 경로를 설정합니다. 디버깅 시 원본 소스 코드를 보기 위해 필요합니다.

### 1.5 실행 파일 경로 설정
```
.exepath {exe path}
```
실행 파일의 경로를 설정합니다.

### 1.6 심볼 재로드
```
.reload
```
심볼을 다시 로드합니다. 새로운 경로 설정 후 사용합니다.

---

## 2. 자동 분석

### 2.1 Crash 원인 분석
```
!analyze -v
```
크래시 또는 예외의 원인을 자세히 분석합니다. `-v` 옵션으로 상세 정보를 출력합니다.

---

## 3. UCRT 소스 코드 확인 불가 시 처리

UCRT(Universal C Runtime) 쪽 `free_base.cpp` 같은 코드를 찾을 수 없어 어셈블리 코드로만 표시되는 경우가 있습니다.

### 3.1 UCRT 소스 경로 추가
```
.srcpath+ C:\Program Files (x86)\Windows Kits\10\Source\
```
위 경로를 `.srcpath`에 추가하면 UCRT 소스 코드를 확인할 수 있습니다.

---

## 4. Heap 분석

### 4.1 모든 Heap 정보 확인
```
!heap
```
현재 프로세스의 모든 heap 정보를 출력합니다.

### 4.2 특정 Heap 상세 분석
```
!heap -a {문제가 생긴 heap}
```
특정 heap에 대한 상세한 정보를 분석합니다.

---

## 5. Heap Corruption 디버깅

### 5.1 문제 상황: Free Fill (Tag 0 at ...)

Heap Entry가 손상되었다는 표시입니다. 일반적으로 **OverRun**이 발생했을 가능성이 높습니다.

### 5.2 손상된 블록 앞 조사
```
!heap -a {깨진블록 앞}
```
손상된 블록 이전의 heap 상태를 확인합니다.

---

## 6. CRT 메모리 할당 Hook

### 6.1 _CrtSetAllocHook() 함수
```cpp
_CrtSetAllocHook(HookFunction);
```

**용도:**
- CRT 메모리 할당 함수(`malloc`, `new` 등)가 호출될 때마다 먼저 실행될 hook 함수를 설치합니다
- 특정 사이즈의 메모리를 할당하는 코드 위치를 찾을 때 유용합니다
- Heap corruption 디버깅 시 매우 효과적입니다

**장점:**
- Release Build에서도 할당 지점을 추적할 수 있습니다
- 특정 사이즈 할당 시에만 브레이크포인트를 설정할 수 있습니다

---

## 7. Heap Corruption 디버깅 실전 예시 (Release Build)

### 7.1 시나리오
```
!heap -a {corrupted_heap}
→ "free fill (Tag 0 at ...)" 에러 발생
```

### 7.2 원인 분석 프로세스

**Step 1: Overrun 가능성 확인**
- 손상된 블록 앞의 블록에서 overrun했을 가능성이 높습니다

**Step 2: 앞 블록의 사이즈 확인**
- 손상된 블록의 이전 블록의 할당 요청 사이즈를 확인합니다
- 예: 6800 bytes

**Step 3: Hook 함수로 할당 지점 찾기**
- `_CrtSetAllocHook()`으로 6800 bytes 할당 시 브레이크포인트 설정
- 할당 요청이 발생할 때마다 훅이 실행됩니다

**Step 4: 원인 코드 발견**
```cpp
ITEM* pItemList = new ITEM[100];  // 이 라인에서 6800 bytes 할당
```

### 7.3 구조체 메모리 검증

**Step 1: HEAP_ENTRY 크기 확인**
```
?? sizeof(_HEAP_ENTRY)
→ 16 bytes
```

**Step 2: 구조체 메모리 위치 확인**
```
0x00000259fdc85a60  // 구조체 메모리 시작 주소
```

**Step 3: HEAP_ENTRY를 고려한 실제 데이터 위치**
```
0x00000259fdc85a60 + 0x10(16 bytes) = 0x00000259fdc85a70
```

**Step 4: 구조체 내용 확인**
```
dt ITEM 0x259FDC85A70
```
이 명령어로 ITEM 구조체의 실제 내용을 확인할 수 있습니다.

---

## 8. 디버깅 팁

| 명령어 | 설명 |
|--------|------|
| `!analyze -v` | 자동 분석 (첫 단계) |
| `.reload` | 새 심볼 로드 |
| `!heap -a` | Heap 상세 분석 |
| `dt {구조체} {주소}` | 메모리의 구조체 내용 표시 |
| `!sym noisy` | 심볼 로딩 상태 상세 출력 |

