---
layout: default
title: "08. crt heap"
parent: "(Windows Debugging)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## CRT Heap 개요

Windows 환경에서 C/C++ 프로그램을 개발할 때 일반적으로 Win32 API 위의 C/C++ Runtime Library (CRT)를 사용

- **HeapAlloc()/HeapFree()** 대신 **malloc()/new**를 주로 사용과 같은말.
- **Debug 빌드**에서는 디버깅을 위한 추가 데이터가 메모리 블록의 앞뒤에 붙음
- 메모리 오버런, 언더런, 메모리 누수 등을 탐지하는 데 유용

---

## CRT Heap Block 구조

Debug 빌드에서 메모리를 할당하면 다음과 같은 구조로 메모리가 할당됩니다:

```
┌────────────────────────────┬──────────────────┬─────────────────────┐
│ _CrtMemBlockHeader         │ Requested Size   │ No Man's Land       │
│ (48 bytes)                 │ (User Data)      │ (4 bytes)           │
└────────────────────────────┴──────────────────┴─────────────────────┘
```

### 구조 상세

| 구성 요소 | 크기 | 설명 |
|---------|------|------|
| `_CrtMemBlockHeader` | 48 bytes | 디버그 정보를 담고 있는 헤더 |
| Requested Size | 가변 | 실제 사용자가 요청한 메모리 크기 |
| No Man's Land | 4 bytes | 메모리 오버런 탐지를 위한 가드 영역 |

**총 오버헤드: 52 bytes** (48 + 4)

### _CrtMemBlockHeader 구조체

```cpp
typedef struct _CrtMemBlockHeader
{
    struct _CrtMemBlockHeader* pBlockHeaderNext;
    struct _CrtMemBlockHeader* pBlockHeaderPrev;
    char* szFileName;
    int nLine;
    size_t nDataSize;
    int nBlockUse;
    long lRequest;
    unsigned char gap[no_mans_land_size]; // 4 bytes
} _CrtMemBlockHeader;
```

---

## 메모리 할당 과정

### malloc(6800) 호출 시 실제 할당 과정

```
1. CRT Heap 레벨에서의 계산:
   48 (Header) + 6800 (Requested) + 4 (Gap) = 6852 bytes

2. HeapAlloc() 호출:
   HeapAlloc(6852)

3. Heap Manager 레벨에서의 계산:
   16 (_HEAP_ENTRY) + 6852 = 6868 bytes

4. 16-byte Alignment 적용:
   6868 % 16 ≠ 0
   6868 / 16 = 429.25 → 429 blocks
   429 * 16 = 6864 bytes (실제 할당)

5. 최종 할당:
   6864 bytes
```

### Alignment와 "가짜" Overrun

- **4 bytes 차이**: 6868 bytes 필요 → 6864 bytes 할당
- **Overrun처럼 보이지만 정상**: `_HEAP_ENTRY`의 앞 8 bytes가 Align을 고려하여 사용되지 않도록 설정되어 있음
- **16-byte alignment**를 위해 크기를 내림(round down)하여 할당

---

## WinDbg를 이용한 디버깅

### 1. 기본 Heap 정보 확인

```
0:000> !heap
```

모든 Heap 목록과 기본 정보를 표시합니다.

**출력 예시:**
```
Index   Address  Name      Debugging options enabled
  1:   00a10000                
  2:   00b20000                
  3:   00c30000 CRT           
```

### 2. 특정 Heap 상세 정보

```
0:000> !heap -a 00c30000
```

특정 Heap의 모든 블록 정보를 표시합니다.

### 3. CRT Heap Block 검사

특정 주소의 메모리 블록 구조를 확인:

```
0:000> dt _CrtMemBlockHeader 0x00c30040
```

**출력 예시:**
```
   +0x000 pBlockHeaderNext : 0x00c30100 _CrtMemBlockHeader
   +0x004 pBlockHeaderPrev : 0x00000000 _CrtMemBlockHeader
   +0x008 szFileName       : 0x00401234  "test.cpp"
   +0x00c nLine            : 0n42
   +0x010 nDataSize        : 0x1a90 (6800)
   +0x014 nBlockUse        : 1
   +0x018 lRequest         : 0n1
   +0x01c gap              : [4]  0xfd
```

### 4. 메모리 내용 덤프

```
0:000> db 0x00c30040 L50
```

**출력 예시:**
```
00c30040  00 31 c3 00 00 00 00 00-34 12 40 00 2a 00 00 00  .1......4.@.*...
00c30050  90 1a 00 00 01 00 00 00-01 00 00 00 fd fd fd fd  ................
00c30060  [User Data Start]
```

### 5. malloc() 호출 추적

```
0:000> bp msvcr120d!malloc
0:000> g

Breakpoint 0 hit
0:000> k
```

**출력 예시:**
```
ChildEBP RetAddr  
0019ff20 00401234 msvcr120d!malloc
0019ff40 00401456 test!main+0x34
0019ff80 7c817077 test!__tmainCRTStartup+0x150
```

### 6. HeapAlloc() 확인

```
0:000> bp ntdll!RtlAllocateHeap
0:000> g

Breakpoint 1 hit
0:000> dd esp L4
```

**출력 예시:**
```
0019fee0  00401245  00c30000  00000000  00001abc
          [RetAddr] [HeapHandle][Flags]  [Size=6844]
```

### 7. 메모리 누수 탐지

프로그램 종료 전 모든 할당된 블록 확인:

```
0:000> !heap -l
```

**출력 예시:**
```
Heap Address      Bytes Allocated
00c30000              6864
    00c30040         6800  (test.cpp:42)
```

### 8. 오버런/언더런 검사

No Man's Land 영역 확인:

```
0:000> db 0x00c30040+30+1a90 L4
```

정상적인 경우 `fd fd fd fd`가 표시되어야 합니다.

**오버런 발생 시:**
```
00c31ad0  41 41 41 41  ; 오버런으로 인해 변경됨
```

### 9. 실제 디버깅 시나리오

#### 시나리오: malloc(6800) 추적

```
0:000> bp test!main
0:000> g

0:000> p  ; malloc(6800) 호출까지 진행
0:000> p
eax=00c30070  ; 반환된 포인터 (헤더 이후 주소)

0:000> ? eax-30  ; 헤더 시작 주소 계산
Evaluate expression: 12648512 = 00c30040

0:000> dt _CrtMemBlockHeader 00c30040
   +0x010 nDataSize : 0x1a90 (6800)

0:000> !heap -x eax  ; 실제 heap 블록 찾기
Entry     User      Heap      Segment       Size  PrevSize  Unused    Flags
00c30030  00c30040  00c30000  00c30000      1ad0        10         8  busy 

0:000> ? 1ad0
Evaluate expression: 6864 = 00001ad0

; 6864 bytes = 16 (_HEAP_ENTRY) + 6848 (실제 사용)
; 16-byte aligned
```

---

## 디버깅 팁

### 유용한 명령어 요약

| 명령어 | 설명 |
|-------|------|
| `!heap` | 모든 Heap 목록 표시 |
| `!heap -a [address]` | 특정 Heap의 모든 블록 표시 |
| `!heap -x [address]` | 특정 주소가 속한 Heap 블록 찾기 |
| `!heap -l` | 메모리 누수 검사 |
| `dt _CrtMemBlockHeader [addr]` | CRT 헤더 구조체 표시 |
| `db [address] L[length]` | 메모리 내용 바이트 단위로 표시 |

