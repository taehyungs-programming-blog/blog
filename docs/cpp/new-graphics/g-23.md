---
layout: default
title: "23. Frustum Culling"
parent: "(GraphicsğŸŒ )"
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/18)

## Frustum Culling

ğŸ˜º ì§€ê¸ˆê¹Œì§€ëŠ” Meshë¥¼ ë§Œë“¤ê¸°ë§Œ í•˜ë©´ ë¬´ì¡°ê±´ ê·¸ë¦¬ê³  ìˆë‹¤. ì§€ê¸ˆë¶€í„° **Frustum Culling**ì„ í†µí•´ ê·¸ë¦´ë†ˆ ì•ˆê·¸ë¦´ë†ˆ êµ¬ë¶„í•´ì£¼ëŠ” ê¸°ëŠ¥ì´ë¼ ìƒê°í•˜ë©´ ë˜ê² ë‹¤.

---

ğŸ˜º ê·¸ëŸ¼ ì–´ë–¤ ê¸°ì¤€ì—ì„œ Frustum Cullingì„ ì§„í–‰í•´ì•¼ í• ê¹Œ?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-22-1.png"/>
</p>

ğŸ˜º ìœ„ ê·¸ë¦¼ê³¼ ê°™ì´ ì¹´ë©”ë¼ì— ì°í Meshë¥¼ ì§€ì •í›„ ê° ë©´ì„ ê¸°ì¤€ìœ¼ë¡œ **ë‚´ë¶€ì— ì†í•´ìˆëŠ”ì§€ ì™¸ë¶€ì— ìˆëŠ”ì§€** íŒë³„í•˜ë©´ ëœë‹¤.

ğŸ˜º **ë‚´ë¶€ì— ì†í•´ìˆëŠ”ì§€ ì™¸ë¶€ì— ìˆëŠ”ì§€** íŒë³„ì„ ìœ„í•´ ëŠë‚Œì ì¸ ëŠë‚Œìœ¼ë¡œ ë‚´ì (ìˆ˜ì§ì„ ì„ ê¸‹ëŠ”ë‹¤)ì„ í•˜ë©´ ë êº¼ ê°™ì€ë° ... ìì„¸í•œ ìˆ˜ì‹ì˜ ì •ì˜ë¥¼ ë³´ì

---

ğŸ˜º ì²˜ìŒìœ¼ë¡œ 3ì°¨ì› í‰ë©´ì˜ ì‹ì„ ì•„ë˜ì™€ ê°™ì´ ì •ì˜í•´ë³´ì. `ax + by + cz + d = 0`

ğŸ˜º 3ì°¨ì› í‰ë©´ì˜ Normal Vector(í‰ë©´ì— ìˆ˜ì§ì¸ ë²¡í„°)ëŠ” N(a, b, c)ê°€ ë˜ë©°, dì˜ ê²½ìš° ì›ì ì—ì„œ í‰ë©´ê¹Œì§€ì˜ ê±°ë¦¬ê°€ ëœë‹¤.(ì´ê±´ ìˆ˜í•™ì ì¸ ë¶€ë¶„ì´ê¸°ì— ë°›ì•„ë“¤ì¼ ê²ƒ)

> ì¦ëª…ì„ í•´ë³´ìë©´ í•œ í‰ë©´ìœ„ì˜ ë‘ ì  `A(x1, y1, z1), B(x2, y2, z2)`ê³¼ <br>
> Normal Vector Nì„ ë‚´ì ì‹œ 0ì´ ë˜ë©´ `N(a, b, c)`ê°€ Normal Vectorì„ì´ ì¦ëª…ì´ ëœë‹¤.<br>
> `AB = (x2 - x1, y2 - y1, z2 - z1), N(a, b, c)`ë¥¼ ë‚´ì í•´ë³´ì. (í¬ê²Œ ì¤‘ìš”í•˜ì§„ ì•Šê¸°ì— ê¼­ ì´í•´ê°€ ë˜ì§€ ì•Šì•„ë„ ë¨.)

```
AB * N = a(x2 - x1) + b(y2 - y1) + c(z2 - z1)
AB * N = (ax2+by2+cz2) - (ax1+by1+cz1)
// ax2+by2+cz2+d = 0
// ax1+by1+cz1+d = 0
// ì´ê¸°ì—
// ax2+by2+cz2 = -d
// ax1+by1+cz1 = -d
AB * N = 0      // ì¦ëª… ë!
```

ğŸ˜º ì´ê±¸ë¡œ ë­˜ êµ¬í• ìˆ˜ ìˆì„ê¹Œ?

```
    \
     A1(x, y, z)
      \
     / \
  d /   \
   /     \
 O        \
           \
```

* `OA1 * N` (ë²¡í„° OA1ê³¼ Normal Vector Nì˜ ë‚´ì )ì€ `d`(í‰ë©´ê³¼ Oê³¼ì˜ ê±°ë¦¬)ê°€ ëœë‹¤. ê·¸ëŸ¼ í‰ë©´ìœ„ì˜ ì ì´ ì•„ë‹ˆë¼ ì¢€ ë” ê°€ê¹Œìš´ ì  `A2`ì˜ ë‚´ì ì€?

```
                  \
  A2(x2, y2 z2)   A1(x, y, z)   <- í‰ë©´ìœ„ì˜ ì ì´ ì•„ë‹ˆë¼ ë‹¤ë¥¸ ì  A2
                    \
                     \
                      \
                       \
     O                  \
                         \
```

* `(x2)x + (y2)y + (z2)z + d < 0`ì´ ë˜ê²Œ ëœë‹¤. ë§Œì•½ í‰ë©´ë³´ë‹¤ ë©€ë‹¤ë©´ `(x2)x + (y2)y + (z2)z + d > 0`

---

ğŸ˜º **(ê²°ë¡ )** ì´ì œ ì¹´ë©”ë¼ë·°ì˜ ê° í‰ë©´(6ê°œ)ì˜ Normal Vectorë¥¼ êµ¬í•œ í›„ ë‚´ì í•´ì„œ 0ë³´ë‹¤ í°ì§€ ì‘ì€ì§€ êµ¬í•˜ë©´ ì¹´ë©”ë¼ì— ì°íˆëŠ” ì˜ì—­ë‚´ì— ìˆëŠ”ì§€ ì™¸ë¶€ì— ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆë‹¤.

ğŸ˜º êµ¬í˜„ì€ ì–´ë–»ê²Œ í• ê¹Œ? ì¼ë‹¨ ìš°ë¦¬ê°€ ì•Œê³ ìˆëŠ” ì¹´ë©”ë¼ì˜ ì¢Œí‘œëŠ” Projection ì¢Œí‘œì—ì„œ x, yê°€ `-1 ~ 1`, depthê°€ `0 ~ 1`ì‚¬ì´ ì„ì„ ì•ˆë‹¤. Projectionì„ ì•Œê¸°ì— Viewì¢Œí‘œê³„ë¡œ ë³€í™˜ í›„ Worldì¢Œí‘œê³„ë¡œ ë‹¤ì‹œ ë³€í™˜í•˜ë©´ Worldì¢Œí‘œê³„ì—ì„œ ì¹´ë©”ë¼ì˜ ì°íˆëŠ” ì˜ì—­ì„ êµ¬í• ìˆ˜ ìˆê²Œ ë˜ê³  ì¹´ë©”ë¼ì— ì°íˆëŠ” ì˜ì—­ë‚´ì— ìˆëŠ” Meshë§Œ ê·¸ë ¤ì£¼ê²Œ ë³€ê²½í•˜ë©´ ëœë‹¤.

```cpp
#pragma once

enum PLANE_TYPE : uint8
{
    // ì¹´ë©”ë¼ë¡œ ì°íˆëŠ” ì—¬ì„¯ í‰ë©´ì— ëŒ€í•œ ë‚´ì ì„ êµ¬í•´ì•¼ í•œë‹¤.
	PLANE_FRONT,
	PLANE_BACK,
	PLANE_UP,
	PLANE_DOWN,
	PLANE_LEFT,
	PLANE_RIGHT,

	PLANE_END
};

class Frustum
{
public:
	void FinalUpdate();

    // ê·¸ë ¤í•  í‰ë©´ ë‚´ë¶€ì— ìˆëŠ”ì§€ í™•ì¸
	bool ContainsSphere(const Vec3& pos, float radius);

private:
	array<Vec4, PLANE_END> _planes;
};
```

```cpp
void Frustum::FinalUpdate()
{
	// Projection -> View -> World ì„ í•´ì•¼í•˜ê¸°ì—
	// View Inverse Matrix, Projection Inverse Matrixê°€ í•„ìš”í•˜ë‹¤
	Matrix matViewInv = Camera::S_MatView.Invert();
	Matrix matProjectionInv = Camera::S_MatProjection.Invert();
	Matrix matInv = matProjectionInv * matViewInv;

	vector<Vec3> worldPos =
	{
		::XMVector3TransformCoord(Vec3(-1.f, 1.f, 0.f), matInv),		// 0
		::XMVector3TransformCoord(Vec3(1.f, 1.f, 0.f), matInv),			// 1
		::XMVector3TransformCoord(Vec3(1.f, -1.f, 0.f), matInv),		// 2
		::XMVector3TransformCoord(Vec3(-1.f, -1.f, 0.f), matInv),		// 3
		::XMVector3TransformCoord(Vec3(-1.f, 1.f, 1.f), matInv),		// 4
		::XMVector3TransformCoord(Vec3(1.f, 1.f, 1.f), matInv),			// 5
		::XMVector3TransformCoord(Vec3(1.f, -1.f, 1.f), matInv),		// 6
		::XMVector3TransformCoord(Vec3(-1.f, -1.f, 1.f), matInv)		// 7

		/*
        // ì‹œê³„ë°©í–¥ìœ¼ë¡œ ì¢Œí‘œë¥¼ ë„£ìŒì„ ì£¼ëª©
		      (4)------------(5)
	  	     /              /|
            /		       / |
		 (0)------------ (1) |
		   |              |  /(6)
		   |              | /
		   |              |/
          (3)------------(2)

            ** --> ì˜¤ë¥¸ìª½ì´  x **

                ^
             ** | ìœ„ê°€ y **

            ** ê¹Šì´ê°€ z **

		*/
	};

    // XMPlaneFromPoints - ì  ì„¸ê°œë¥¼ ë„£ê³  í‰ë©´ì„ ë§Œë“¤ì–´ ë‹¬ë¼
	_planes[PLANE_FRONT] = ::XMPlaneFromPoints(worldPos[0], worldPos[1], worldPos[2]);  // ì‹œê³„ ë°©í–¥
	_planes[PLANE_BACK] = ::XMPlaneFromPoints(worldPos[4], worldPos[7], worldPos[5]);   // ë°˜ì‹œê³„ ë°©í–¥
	_planes[PLANE_UP] = ::XMPlaneFromPoints(worldPos[4], worldPos[5], worldPos[1]);     // ì‹œê³„ ë°©í–¥(CW)
	_planes[PLANE_DOWN] = ::XMPlaneFromPoints(worldPos[7], worldPos[3], worldPos[6]);   // ë°˜ì‹œê³„ ë°©í–¥(CCW)
	_planes[PLANE_LEFT] = ::XMPlaneFromPoints(worldPos[4], worldPos[0], worldPos[7]);   // ì‹œê³„ ë°©í–¥
	_planes[PLANE_RIGHT] = ::XMPlaneFromPoints(worldPos[5], worldPos[6], worldPos[1]);  // ë°˜ì‹œê³„ ë°©í–¥(CCW)
}

bool Frustum::ContainsSphere(const Vec3& pos, float radius)
{
	for (const Vec4& plane : _planes)
	{
		// n = (a, b, c)
		Vec3 normal = Vec3(plane.x, plane.y, plane.z);

		// ax + by + cz + d > radius
		if (normal.Dot(pos) + plane.w > radius)
			return false;
	}

	return true;
}
```

```cpp
void Camera::Render()
{
	shared_ptr<Scene> scene = GET_SINGLE(SceneManager)->GetActiveScene();

	// TODO : Layer êµ¬ë¶„
	const vector<shared_ptr<GameObject>>& gameObjects = scene->GetGameObjects();

	for (auto& gameObject : gameObjects)
	{
		if (gameObject->GetMeshRenderer() == nullptr)
			continue;

        // Frustumì„ ì ìš©í•˜ì§€ ë§ì•„ì•¼ í•  objectë„ ì¡´ì¬í•œë‹¤(skybox)
		if (gameObject->GetCheckFrustum())
		{
            // ëœë”ë§ í• ì§€ ë§ì§€ ê²°ì •
			if (_frustum.ContainsSphere(
				gameObject->GetTransform()->GetWorldPosition(),
				gameObject->GetTransform()->GetBoundingSphereRadius()) == false)
			{
				continue;
			}
		}

		gameObject->GetMeshRenderer()->Render();
	}
}
```