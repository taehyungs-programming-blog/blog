---
layout: default
title: "08. Depth Stencil View"
parent: "(GraphicsğŸŒ )"
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/8)


## ìš©ì–´ì„¤ëª…

* **Depth** : ë§ ê·¸ëŒ€ë¡œ ê¹Šì´
* **Stencil** : 
    * íŒì— êµ¬ë©ì„ ëš«ê³  ì‰í¬ë¥¼ í†µê³¼ì‹œì¼œ ì°ì–´ë‚´ëŠ” ê³µíŒí™” ê¸°ë²•ì„ ì˜ë¯¸
    * íŠ¹ì • Stencil ê°’ì— ë”°ë¼ í”½ì…€ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ê² ë‹¤ ì´ëŸ° ì²˜ë¦¬ê°€ ê°€ëŠ¥
        * ì˜ˆë¥¼ ë“¤ì–´ Stencil ê°’ì´ 5ì¸ pixelì€ íŠ¹ì •ìƒ‰ì„ ì…íˆê² ë‹¤. ì´ëŸ° ì—°ì‚°ì´ ê°€ëŠ¥í•´ì§„ë‹¤.
    * ì•Œì•„ë§Œ ë‘ì, ê°•ì¢Œì—ì„œ ì“°ì§„ ì•Šì„ ê²ƒ
* **Depth Stencil View** : Depthì™€ Stencilì˜ í‘œí˜„ì„ ì–´ë–»ê²Œ í•  ê²ƒì¸ê°€?

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-8-1.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>

ğŸ˜º ì˜ˆë¥¼ë“¤ì–´ ìœ„ ê·¸ë¦¼ê³¼ ê°™ì€ ê±´ë¬¼ì´ ìˆì„ë•Œ ì‹¤ì œë¡œ ì–´ë–»ê²Œ ê·¸ë ¤ë‚´ì•¼í•˜ëŠ”ì§€ì— ëŒ€í•œ Viewë¼ê³  ì´í•´í•˜ì

ğŸ˜º í•˜ë‹¤ ë” ì¶”ê°€í•˜ìë©´ ì›ê·¼ë²•ì„ í‘œí˜„í•˜ëŠ” ì¢‹ì€ ë°©ë²•ì´ depthë¡œ í‘œí˜„í•˜ëŠ” ê²ƒì´ë‹¤.

ğŸ˜º Rendering Pipelineì—ì„œ ë³´ìë©´ ë§ˆì§€ë§‰ Output mergeë‹¨ê³„ì—ì„œ Depth-stencil viewì™€ Render-target viewë¥¼ ì“´ë‹¤.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-8-3.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>

### ë‚˜ì˜¨ê¹€ì— ì ê¹ ë³µìŠµ **Render-target view**

* [ì´ì „ê°•](https://taehyungs-programming-blog.github.io/blog/docs/cpp/directx/2022-01-24-directx-2/#descriptorheaprender-target-view)ì—ì„œ DX11 ì´ìƒë¶€í„° RTV(RenderTargetView), DSV(DepthStencilView), CBV(ConstantBufferView), SRV(ShaderResourceView), UAV(UnorderedAccessView)ë¥¼ ì „ë¶€ DescriptorHeapì—ì„œ ê´€ë¦¬í•˜ë©°
* SwapChainê³¼ DescriptorHeapì„ SwapChainìœ¼ë¡œ í†µí•©í–ˆë˜ê²ƒì´ ê¸°ì–µ ë‚  ê²ƒì´ë‹¤.
* ë§ë¡œí•˜ë©´ ì—­ì‹œ ì´í•´ê°€ ì•ˆë˜ë‹ˆ, ëŒ€ëµ ì½”ë“œë¡œ ë³´ìë©´ ...

```cpp
class SwapChain
{
public:
	void Init(const WindowInfo& info, ComPtr<ID3D12Device> device, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);
	void Present();
	void SwapIndex();

	ComPtr<IDXGISwapChain> GetSwapChain() { return _swapChain; }
	ComPtr<ID3D12Resource> GetRenderTarget(int32 index) { return _rtvBuffer[index]; }

	ComPtr<ID3D12Resource> GetBackRTVBuffer() { return _rtvBuffer[_backBufferIndex]; }
	D3D12_CPU_DESCRIPTOR_HANDLE GetBackRTV() { return _rtvHandle[_backBufferIndex]; }

private:
	void CreateSwapChain(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);
	void CreateRTV(ComPtr<ID3D12Device> device);

private:
    // SwapChain
	ComPtr<IDXGISwapChain>	_swapChain;
	
    // RenderTargetView
	ComPtr<ID3D12Resource>			_rtvBuffer[SWAP_CHAIN_BUFFER_COUNT];
	ComPtr<ID3D12DescriptorHeap>	_rtvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE		_rtvHandle[SWAP_CHAIN_BUFFER_COUNT];

	uint32					_backBufferIndex = 0;
};
```

```cpp
void SwapChain::CreateSwapChain(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
	_swapChain.Reset();

	DXGI_SWAP_CHAIN_DESC sd;
	sd.BufferDesc.Width = static_cast<uint32>(info.width); // ë²„í¼ì˜ í•´ìƒë„ ë„ˆë¹„
	sd.BufferDesc.Height = static_cast<uint32>(info.height); // ë²„í¼ì˜ í•´ìƒë„ ë†’ì´
	sd.BufferDesc.RefreshRate.Numerator = 60; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
	sd.BufferDesc.RefreshRate.Denominator = 1; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // ë²„í¼ì˜ ë””ìŠ¤í”Œë ˆì´ í˜•ì‹
	sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	sd.SampleDesc.Count = 1; // ë©€í‹° ìƒ˜í”Œë§ OFF
	sd.SampleDesc.Quality = 0;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // í›„ë©´ ë²„í¼ì— ë Œë”ë§í•  ê²ƒ 
	sd.BufferCount = SWAP_CHAIN_BUFFER_COUNT; // ì „ë©´+í›„ë©´ ë²„í¼
	sd.OutputWindow = info.hwnd;		// Presentë¥¼ í˜¸ì¶œì‹œ ì´ í•¸ë“¤ì— ê·¸ë ¤ì¤€ë‹¤.
	sd.Windowed = info.windowed;
	sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; // ì „ë©´ í›„ë©´ ë²„í¼ êµì²´ ì‹œ ì´ì „ í”„ë ˆì„ ì •ë³´ ë²„ë¦¼
	sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	dxgi->CreateSwapChain(cmdQueue.Get(), &sd, &_swapChain);

    // SwapChainì˜ Bufferê°€ _rtvBufferì´ë‹¤
	for (int32 i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
		_swapChain->GetBuffer(i, IID_PPV_ARGS(&_rtvBuffer[i]));
        /*
            ië²ˆì§¸ ë°±ë²„í¼ë¥¼ ì£¼ì„¸ìš”.
            HRESULT GetBuffer(
                    UINT   Buffer,
            [in]  REFIID riid,
            [out] void   **ppSurface
            );
        */
}
```

ğŸ˜º ì—¬ê¸°ê¹Œì§€í•˜ë©´ SwapChainì„ ìƒì„±í–ˆê³ , _rtvBufferë¼ëŠ” ë²„í¼ì— SwapChainì˜ ë°±ë²„í¼ ì£¼ì†Œë¥¼ ë„£ì–´ë‘ .

```cpp
void SwapChain::CreateRTV(ComPtr<ID3D12Device> device)
{
	int32 rtvHeapSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	D3D12_DESCRIPTOR_HEAP_DESC rtvDesc;
	rtvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDesc.NumDescriptors = SWAP_CHAIN_BUFFER_COUNT;
	rtvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	rtvDesc.NodeMask = 0;

	device->CreateDescriptorHeap(&rtvDesc, IID_PPV_ARGS(&_rtvHeap));

	D3D12_CPU_DESCRIPTOR_HANDLE rtvHeapBegin = _rtvHeap->GetCPUDescriptorHandleForHeapStart();

	for (int i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
	{
        // CD3DX12_CPU_DESCRIPTOR_HANDLE : init RenderTargetView Sturct
		_rtvHandle[i] = CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeapBegin, i * rtvHeapSize);
		device->CreateRenderTargetView(_rtvBuffer[i].Get(), nullptr, _rtvHandle[i]);

        /*
            HRESULT CreateRenderTargetView(
            [in]            ID3D11Resource                      *pResource,
            [in, optional]  const D3D11_RENDER_TARGET_VIEW_DESC *pDesc,
            [out, optional] ID3D11RenderTargetView              **ppRTView
            );
        */
	}
}
```

ğŸ˜º ì—¬ê¸°ê¹Œì§€í•˜ë©´ DescriptorHeapì„ ìƒì„±í•˜ê³  DescritorHeapì„ í†µí•´ RenderTargetViewë¥¼ ìƒì„±(í•¸ë“¤ ë°›ì•„ì˜´)

```cpp
void CommandQueue::RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect)
{
	//...

	// Specify the buffers we are going to render to.
	D3D12_CPU_DESCRIPTOR_HANDLE backBufferView = _swapChain->GetBackRTV();
	_cmdList->ClearRenderTargetView(backBufferView, Colors::LightSteelBlue, 0, nullptr);

	D3D12_CPU_DESCRIPTOR_HANDLE depthStencilView = GEngine->GetDepthStencilBuffer()->GetDSVCpuHandle();
	_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, &depthStencilView);

	_cmdList->ClearDepthStencilView(depthStencilView, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}
```

ğŸ˜º RenderTargetView(í•¸ë“¤)ë¥¼ í†µí•´ ì–´ë–»ê²Œ ê·¸ë ¤ë‹¬ë¼ ëª…ë ¹.

---

### ë‹¤ì‹œ ì‹œì‘...

ğŸ˜º ì°¸ê³ ë¡œ í˜„ì¬ëŠ” posì •ë³´ì— ì„¸ ë²ˆì§¸ ê°’ì´ depthì´ë‚˜ ì“°ì´ì§€ëŠ” ì•Šê³ ìˆë‹¤.

```cpp
void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);

	vector<Vertex> vec(4);
	vec[0].pos = Vec3(-0.5f, 0.5f, 0.5f);	// ì„¸ ë²ˆì§¸ floatì´ depthê°’
	vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);
	vec[0].uv = Vec2(0.f, 0.f);

	// ...
```

```
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
	// Vertext Shaderì—ì„œ depthê°’ì„ ë¬´ì¡°ê±´ 1ë¡œ ë§Œë“¤ê³  ìˆë‹¤.
    // ë”°ë¼ì„œ posì— depthë¥¼ ëª‡ìœ¼ë¡œ ì£¼ë“  ë³€í™”ê°€ì—†ë‹¤
    output.pos += offset0;
    output.color = input.color;
    output.uv = input.uv;

    return output;
}
```

---

## ì ê¹ ë³µìŠµ

ğŸ˜º í…ŒìŠ¤íŠ¸ ì¤€ë¹„ë¥¼ ìœ„í•´ì„œ ë„¤ëª¨ë¥¼ ë‘ ê°œ ê·¸ë ¤ë³´ì

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-8-2.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>

ğŸ˜º ì•„ë˜ì²˜ëŸ¼ ìˆ˜ì •í•˜ë©´ ë˜ëŠ”ë° ì´ì¯¤ë˜ë©´... í—·ê°ˆë¦¬ë‹ˆ ë³µìŠµì‚¼ì•„ ë‹¤ì‹œ ì •ë¦¬í•´ë³´ê² ë‹¤.

```cpp
void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();

	{
		Transform t;

        // t.offset == vec4
		t.offset = Vec4(0.25f, 0.25f, 0.2f, 0.f);

        // meshì— transform ì„ ì–¸
		mesh->SetTransform(t);

        // meshì— texture ì„ ì–¸
		mesh->SetTexture(texture);

		mesh->Render();
	}

	{
		Transform t;
		t.offset = Vec4(0.f, 0.f, 0.3f, 0.f);
		mesh->SetTransform(t);
		mesh->SetTexture(texture);
		mesh->Render();
	}

	GEngine->RenderEnd();
}
```

```cpp
void Mesh::Render()
{
    // ì‚¼ê°í˜•ìœ¼ë¡œ ê·¸ë¦´ì˜ˆì •
	CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    // Input Assembleì—ì„œ VertextBufferë¥¼ ì”ë‹ˆë‹¤.
	CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)

    // Input Assembleì—ì„œ IndexBufferë„ ì”ë‹ˆë‹¤
	CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));

        // GPUë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ì˜¬ë¦¬ê³ 
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);
		GEngine->GetTableDescHeap()->SetSRV(_tex->GetCpuHandle(), SRV_REGISTER::t0);
	}

    // ë ˆì§€ìŠ¤í„°ì— ì˜¬ë ¤ë‹¬ë¼ ìš”ì²­
	GEngine->GetTableDescHeap()->CommitTable();
	CMD_LIST->DrawIndexedInstanced(_indexCount, 1, 0, 0, 0);
}
```

---

## DepthStencilBufferë¥¼ ë§Œë“¤ì–´ ë³´ì

```cpp
#pragma once

class DepthStencilBuffer
{
public:
	void Init(const WindowInfo& window, DXGI_FORMAT dsvFormat = DXGI_FORMAT_D32_FLOAT /*Depthìš©ë„ë¡œ 32ë¹„íŠ¸ ì“°ê² ë‹¤*/);

	D3D12_CPU_DESCRIPTOR_HANDLE	GetDSVCpuHandle() { return _dsvHandle; }
	DXGI_FORMAT GetDSVFormat() { return _dsvFormat; }

private:
	// Depth Stencil View
	ComPtr<ID3D12Resource>				_dsvBuffer;
	ComPtr<ID3D12DescriptorHeap>		_dsvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE			_dsvHandle = {};
	DXGI_FORMAT							_dsvFormat = {};
};
```

```cpp
void DepthStencilBuffer::Init(const WindowInfo& window, DXGI_FORMAT dsvFormat)
{
	_dsvFormat = dsvFormat;

	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT);

	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Tex2D(_dsvFormat, window.width, window.height);
	desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;   // DepthStencilë¡œ ì“°ê² ë‹¤

    // DepthStencilì„ 1.0ìœ¼ë¡œ ë°€ê»€ë° ì´ê±¸ ì„ ì–¸ì‹œ ë¹ ë¥´ê²Œ 1.0ìœ¼ë¡œ ì´ˆê¸°í™” ê°€ëŠ¥.
	D3D12_CLEAR_VALUE optimizedClearValue = CD3DX12_CLEAR_VALUE(_dsvFormat, 1.0f, 0);

	DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		&optimizedClearValue,
		IID_PPV_ARGS(&_dsvBuffer));

    // Viewë¥¼ ë§Œë“ ë‹¤(Heapì„ ë§Œë“¤ê³  Heapì„ í†µí•´ Viewë¥¼ ë§Œë“¦)
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc = {};
	heapDesc.NumDescriptors = 1;
	heapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	heapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;

	DEVICE->CreateDescriptorHeap(&heapDesc, IID_PPV_ARGS(&_dsvHeap));

	_dsvHandle = _dsvHeap->GetCPUDescriptorHandleForHeapStart();
	DEVICE->CreateDepthStencilView(_dsvBuffer.Get(), nullptr, _dsvHandle);
}
```

```cpp
void CommandQueue::RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect)
{
	// ...

	// DepthStencil
	D3D12_CPU_DESCRIPTOR_HANDLE depthStencilView = GEngine->GetDepthStencilBuffer()->GetDSVCpuHandle();
	_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, &depthStencilView);

	// DepthStencilì„ ê¸°ë³¸ì ìœ¼ë¡œ 1ë¡œ ë°€ì–´ì¤Œ
	_cmdList->ClearDepthStencilView(depthStencilView, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}
```

```cpp
void Shader::Init(const wstring& path)
{
	CreateVertexShader(path, "VS_Main", "vs_5_0");
	CreatePixelShader(path, "PS_Main", "ps_5_0");

	D3D12_INPUT_ELEMENT_DESC desc[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 28, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	};

	_pipelineDesc.InputLayout = { desc, _countof(desc) };
	_pipelineDesc.pRootSignature = ROOT_SIGNATURE.Get();

	_pipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	_pipelineDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);

	// DepthStencilì„ ì“´ë‹¤ê³  ì„ ì–¸
	_pipelineDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT);

	_pipelineDesc.SampleMask = UINT_MAX;
	_pipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	_pipelineDesc.NumRenderTargets = 1;
	_pipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
	_pipelineDesc.SampleDesc.Count = 1;

	// DepthStencil Formatë„ ë°›ì•„ì˜¨ë‹¤.
    /* DXGI_FORMAT dsvFormat = DXGI_FORMAT_D32_FLOAT (Depthë¡œë§Œ 32ë¹„íŠ¸ ì‚¬ìš©) */
	_pipelineDesc.DSVFormat = GEngine->GetDepthStencilBuffer()->GetDSVFormat();

	DEVICE->CreateGraphicsPipelineState(&_pipelineDesc, IID_PPV_ARGS(&_pipelineState));
}
```

---

## pipelineì— depthstencilì„ ì“´ë‹¤ê³  ì„ ì–¸í•œ ê²ƒ ê¹Œì§€ëŠ” ì´í•´í–ˆëŠ”ë°...

ğŸ˜º ì‰ì´ë”ì—ì„œ depthê°’ì´ ë­”ì§€ ì•Œê³  depthëŒ€ë¡œ ê·¸ë¦°ë‹¨ ë§ì¸ê°€?

* [ì°¸ê³  SV_Position ì´ë€ ğŸŒ](https://smilejsu.tistory.com/2404)

```
struct VS_OUT
{
    // posì •ë³´ëŠ” SV_Position(System-Value Position)ì´ë‹¤.
    float4 pos : SV_Position;
    float4 color : COLOR;
    float2 uv : TEXCOORD;
};

// ì´ê²Œ ë‹¤ì‹œ ìƒê°í•´ë³´ë©´ ì‹ ê¸°í•œê²Œ
// VS_OUTì´ë¼ëŠ” êµ¬ì¡°ì²´ëŠ” ê°œë°œìê°€ ì„ ì–¸í•œ êµ¬ì¡°ì²´ì¸ë°
// VS_OUTìœ¼ë¡œ ë¦¬í„´ ë°›ìœ¼ë©´ Vertext Bufferì—ì„œ ì•Œì•„ì„œ ê·¸ë ¤ì¤€ë‹¤ëŠ”ê²Œ ì•„ì£¼ ì‹ ê¸°í•˜ë‹¤?
// VS_OUTê°’ì¤‘ ë­˜ x, y, depth, color ... ìœ¼ë¡œ í• ê²ƒì¸ê°€?

// SV_Positionì„ í†µí•´ì„œ ì‰ì´ë”ê°€ x, y, depthë¥¼ ì•ˆë‹¤ ì •ë„ë¡œ ë°›ì•„ë“¤ì´ì
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
    output.pos += offset0;
    output.color = input.color;
    output.uv = input.uv;

    return output;
}
```

---

* í…ŒìŠ¤íŠ¸

```cpp
void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();

	{
		Transform t;
		// 3ë²ˆì§¸ ì¸ìê°€ depthì´ê³  ì´ˆê¸°ê°’ì´ 0.5ì´ë‹¤.
		// ì•„ë˜ì™€ ê°™ì€ ê²½ìš°ëŠ” 0.7ì´ ë˜ê² ì§€?
		t.offset = Vec4(0.25f, 0.25f, 0.2f, 0.f);
		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	}

	{
		Transform t;
		// ì•„ë˜ëŠ” 0.5ì´ë˜ë©° ì•„ë˜ ë„¤ëª¨ê°€ ì•ìœ¼ë¡œ ë‚˜ì˜¤ê²Œ ëœë‹¤(ê°€ìš´ë° ë„¤ëª¨)
		t.offset = Vec4(0.f, 0.f, 0.0f, 0.f);
		mesh->SetTransform(t);

		mesh->SetTexture(texture);

		mesh->Render();
	}


	GEngine->RenderEnd();
}
```