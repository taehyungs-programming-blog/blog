---
layout: default
title: "34. Picking"
parent: "(GraphicsğŸŒ )"
grand_parent: C++
nav_order: 4
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/27)

## ì´ë¡ 

* **Picking** - DirectXë¡œ ë§Œë“¤ì–´ì§„ GameObjectì— í´ë¦­ì²˜ë¦¬ë¥¼ ë°›ê²Œ í•˜ê³ ì‹¶ë‹¤
    * ì‚¬ì‹¤ DirectX Presentë˜ëŠ” í™”ë©´ì€ ê·¸ëƒ¥ ì´ë¯¸ì§€ì¼ë¿ì¸ë° ì–´ë–»ê²Œ Inputì´ë²¤íŠ¸ë¥¼ ë°›ì„ê¹Œ?
    * íŒíŠ¸) í™”ë©´ì— ì¼ì¢…ì˜ ë ˆì´ì €ë¥¼ ìœë‹¤.(**Ray Casting**) ë ˆì´ì €ë¥¼ ë§ìœ¼ë©´ Hit ì²˜ë¦¬!

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-34-1.jpg"/>
</p>

* í™”ë©´ì— ê·¸ë ¤ì§€ëŠ” ì ˆì°¨ë¥¼ ë‹¤ì‹œ ìƒê°í•´ ë³´ë©´
    * Object Space(Local Space) - ë¬¼ì²´ ìì²´ì  ìœ„ì¹˜
    * World Space - ì›”ë“œì—ì„œì˜ ìœ„ì¹˜
    * Eye Space(Camera Space) - ì¹´ë©”ë¼ê°€ ì°ëŠ” ìœ„ì¹˜
    * Clip Space(Projection Space) - í™”ë©´ì— ì–´ë–»ê²Œ ë³´ì¼ì§€ ê²°ì •
    * Screen Space(View Space) - í™”ë©´ì— ë³´ì—¬ì§ˆ ë¹„ë¥ ë¡œ ë³€ê²½

* ì! ì´ì œ ë§ˆìš°ìŠ¤ í´ë¦­ì„ ë°›ì„ì‹œ ê±°ê¾¸ë¡œ ì˜¬ë¼ê°€ë©´ ëœë‹¤.(ë§ì€ ì‰½ë‹¤)

---

### View to Projection Space

```
-----------------
|               |
|               |
|               | height (h)
|               |
|               |
-----------------
     width (w)
```

```
x = (2*x)/w - 1
y = -(2*y)/h + 1
```

---

### Projection to Camera Space

```
x = x * r*tan(a/2)
y = y * tan(a/2)
```

* Projection Matrixê°€

```
1/(r*tan(a/2))  1           1   1
1               1/tan(a/2)  1   1
1               1           A   1
1               1           B   0
```

* ì´ê¸°ì— ì•„ë˜ì™€ ê°™ì´ í‘œí˜„ì´ ê°€ëŠ¥í•˜ë‹¤.

```
x = x * r*tan(a/2) = x / P(0,0)
y = y * tan(a/2) = y / P(1,1)
```

```cpp
shared_ptr<GameObject> SceneManager::Pick(int32 screenX, int32 screenY)
{
	shared_ptr<Camera> camera = GetActiveScene()->GetMainCamera();

	float width = static_cast<float>(GEngine->GetWindow().width);
	float height = static_cast<float>(GEngine->GetWindow().height);

	Matrix projectionMatrix = camera->GetProjectionMatrix();

	// ViewSpaceì—ì„œ Picking ì§„í–‰
	float viewX = (+2.0f * screenX / width - 1.0f) / projectionMatrix(0, 0);
	float viewY = (-2.0f * screenY / height + 1.0f) / projectionMatrix(1, 1);
```

---

### Camera to World Space

* ì—¬ê¸°ê°€ ì§„ì§œ ì¶©ëŒíŒì •ì´ë‹¤.
    * ì‚¬ì‹¤ ì•„ë˜ì˜ ì¦ëª…ì€ ê·¸ë¦¬ ì˜ë¯¸ì—†ìŒ **DirectXì— í•¨ìˆ˜**ê°€ ìˆìŒ
    * ì €ë ‡ê²Œ êµ¬í•œë‹¤ê³ ë§Œ ì•Œì•„ë‘ì.

```
// ì›ì„ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ê°€ëŠ¥

| p - c | = d
// p - ì›ì˜ ì„ì˜ì˜ ì (í˜„ì¬ëŠ” ì›ì˜ í‘œë©´ì— ë§ì„ ê²½ìš°ë¥¼ ê°€ì •)
// c - ì›ì 
// d - ë°˜ì§€ë¦„

r = q + tu
// r - ray(ì§ì„ ì„ ì˜ë¯¸)
// q - ì„ì˜ì˜ ì 
// u - ë°©í–¥ì„±ì„ ì˜ë¯¸ ìƒìˆ˜ të§Œí¼ ë°©í–¥ì„±ì„ ê°–ëŠ” ë¹›ì„ ì˜ë¯¸í•œë‹¤.
```

```
// ì›ì˜ ì„ì˜ì˜ ì  pë¥¼ rë¡œ ëŒ€ì²´í•´ ë³´ë©´

| q + tu - c | = d
d^2 = (q - c + tu) * (q - c + tu)
    = (m*m) + (t*2m*u) + (t^2*u*u)

// ì´ë ‡ê²Œ ì •ë¦¬ê°€ëŠ¥
(u*u)*t^2 + (2*m*u)*t + (m*m-d^2) = 0

a = (u*u)
b = (2*m*u)
c = (m*m-d^2)
```

* ìš°ë¦° `y = ax^2 + bx + c`ì¼ë•Œ 
    * ê·¼ì´ 2ê°œ, 1ê°œ ì¼ë•Œ rayê°€ ì ‘í•¨ì„ ì•Œê³ 
    * ê·¼ì´ 1ê°œì¼ë•Œ rayê°€ ì ‘í•˜ì§€ ì•ŠìŒì„ ì•ˆë‹¤.

```cpp
shared_ptr<GameObject> SceneManager::Pick(int32 screenX, int32 screenY)
{
	shared_ptr<Camera> camera = GetActiveScene()->GetMainCamera();

	float width = static_cast<float>(GEngine->GetWindow().width);
	float height = static_cast<float>(GEngine->GetWindow().height);

	Matrix projectionMatrix = camera->GetProjectionMatrix();

	// ViewSpaceì—ì„œ Picking ì§„í–‰
	float viewX = (+2.0f * screenX / width - 1.0f) / projectionMatrix(0, 0);
	float viewY = (-2.0f * screenY / height + 1.0f) / projectionMatrix(1, 1);

	Matrix viewMatrix = camera->GetViewMatrix();
	Matrix viewMatrixInv = viewMatrix.Invert();

	auto& gameObjects = GET_SINGLE(SceneManager)->GetActiveScene()->GetGameObjects();

	float minDistance = FLT_MAX;
	shared_ptr<GameObject> picked;

	for (auto& gameObject : gameObjects)
	{
		if (gameObject->GetCollider() == nullptr)
			continue;

		// ViewSpaceì—ì„œì˜ Ray ì •ì˜
		Vec4 rayOrigin = Vec4(0.0f, 0.0f, 0.0f, 1.0f);
            // ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ê°€ 0, 0, 0ì´ê¸°ì— 
		Vec4 rayDir = Vec4(viewX, viewY, 1.0f, 0.0f);
            // rayì˜ ë°©í–¥ì„±

		// WorldSpaceì—ì„œì˜ Ray ì •ì˜
		rayOrigin = XMVector3TransformCoord(rayOrigin, viewMatrixInv);
		rayDir = XMVector3TransformNormal(rayDir, viewMatrixInv);
		rayDir.Normalize();

		// WorldSpaceì—ì„œ ì—°ì‚°
		float distance = 0.f;
		if (gameObject->GetCollider()->Intersects(rayOrigin, rayDir, OUT distance) == false)
			continue;

		if (distance < minDistance)
		{
			minDistance = distance;
			picked = gameObject;
		}
	}

	return picked;
}
```

---

## ê·¸ ì™¸ì˜ êµ¬í˜„

```cpp
enum class ColliderType
{
	Sphere,
};

class BaseCollider : public Component
{
public:
	BaseCollider(ColliderType colliderType);
	virtual ~BaseCollider();

	virtual bool Intersects(Vec4 rayOrigin, Vec4 rayDir, OUT float& distance) = 0;

private:
	ColliderType _colliderType = {};
};
```

```cpp
bool SphereCollider::Intersects(Vec4 rayOrigin, Vec4 rayDir, OUT float& distance)
{
	return _boundingSphere.Intersects(rayOrigin,        // ê´‘ì„ ì˜ ì‹œì‘ì 
                                        rayDir,         // ê´‘ì„ ì˜ ë°©í–¥
                                        OUT distance);  // ì¶©ëŒì´ ëë‹¤ë©´ distanceê°€ ë“¤ì–´ì˜´
}
```