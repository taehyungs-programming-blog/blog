---
layout: default
title: 4. Range
parent: (C++20)
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º ì°¸ê³  C#ì˜ LINQì™€ ìœ ì‚¬í•œ ë¬¸ë²•ì´ë‹¤.

```cpp
#include <ranges>

// ...

vector<int> v1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

vector<int> v2;
// ì§ìˆ˜ë¥¼ ì¶”ì¶œí•´ì„œ
for (int n : v1)
    if (n % 2 == 0)
        v2.push_back(n);

// ì¶”ì¶œëœ ì§ìˆ˜ì— 2ë¥¼ ê³±í•´ì¤˜ ë³´ì.
for (int& n : v2)
    n = n * 2;

/*
ì‚¬ì‹¤ ìˆœíšŒëŠ” ìœ„ ë°©ë²•ë³´ë‹¤ ì•„ë˜ ë°©ë²•ì„ ë” ì„ í˜¸í•¨(ì‹œê°„ë‚˜ë©´ ì°¾ì•„ë³¼ ê²ƒ)
std::for_each();
std::find_if();
std::any_of();
*/
```

ğŸ˜º ì´ê±¸ ì¢€ ë” ê°„ë‹¨íˆ rangeë¥¼ ì¨ì„œ í•´ê²°í•´ ë³´ì

```cpp
auto results = v1   // v1ì—ì„œ
                | std::views::filter([](int n) { return n % 2 == 0; })  // ë¥¼ í•„í„°í•´ë‹¬ë¼
                | std::views::transform([](int n) { return n * 2; });   // ê·¸ë¦¬ê³  ê·¸ ê²°ê³¼ì— ì²˜ë¦¬í•´ ë‹¬ë¼

// ê²°ê³¼ ì¶œë ¥
for (auto n : results)
	cout << n << " ";
```

ğŸ˜º í¬ê²Œ range, viewë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆëŠ”ë°

* Range : Rangeë€ ìˆœíšŒí•  ìˆ˜ ìˆëŠ” ì•„ì´í…œ ê·¸ë£¹ (ex. STL Container)
* View : Rangeì— ëŒ€í•´ì„œ ì ìš©í•  ìˆ˜ ìˆëŠ” ì—°ì‚°

ğŸ˜º View ì¤‘ ì£¼ìš”í•œ ë…€ì„ë“¤ (ëª¨ë‘ ì•”ê¸°í•  í•„ìš”ëŠ” ì—†ê³  ëŒ€ì¶© ì´ëŸ°ê²Œ ìˆë‹¤ê³  ì•Œì•„ë‘ì)

* `std::views::all`		
* `std::ranges::filter_view` / `std::views::filter` ğŸ‘‰ ì¡°ê±´ ë§Œì¡±í•˜ëŠ”ê±° ì¶”ì¶œ
* `std::ranges::transform_view` / `std::views::transform` ğŸ‘‰ ê° ìš”ì†Œë¥¼ ë³€í™˜
* `std::ranges::take_view` / `std::views::take` ğŸ‘‰ nê°œ ìš”ì†Œë¥¼ ì¶”ì¶œ
* `std::ranges::take_while_view` / `std::views::take_while` ğŸ‘‰ ì¡°ê±´ ë§Œì¡±í•  ë•Œê¹Œì§€ ìš”ì†Œ ì¶”ì¶œ
* `std::ranges::drop_view` / `std::views::drop` ğŸ‘‰ nê°œ ìš”ì†Œë¥¼ ìŠ¤í‚µ
* `std::ranges::drop_while_view` / `std::views::drop_while` ğŸ‘‰ ì¡°ê±´ ë§Œì¡±í•  ë•Œê¹Œì§€ ìš”ì†Œ ìŠ¤í‚µ
* `std::ranges::join_view` / `std::views::join` ğŸ‘‰ view ë¥¼ ë³‘í•©
* `std::ranges::split_view` / `std::views::split` ğŸ‘‰ split
* `std::ranges::reverse_view` / `std::views::reverse` ğŸ‘‰ ì—­ìˆœì„œë¡œ ìˆœíšŒ
* `std::ranges::elements_view` / `std::views::elements` ğŸ‘‰ íŠœí”Œì˜ në²ˆì§¸ ìš”ì†Œë¥¼ ëŒ€ìƒìœ¼ë¡œ view ìƒì„±
* `std::ranges::keys_view` / `std::views::keys` ğŸ‘‰ pair-like valueì˜ ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ ëŒ€ìƒìœ¼ë¡œ view ìƒì„±
* `std::ranges::values_view` / `std::views::values` ğŸ‘‰ pair-like valueì˜ ë‘ë²ˆì§¸ ìš”ì†Œë¥¼ ëŒ€ìƒìœ¼ë¡œ view ìƒì„±

```cpp
auto results2 = v1 | std::views::filter([](int n) { return n % 2 == 0; })
                | std::views::transform([](int n) { return n * 2; })
                | std::views::take(3);      // 3ê°œë§Œ ì¶”ì¶œ

for (auto n : results2)
    cout << n << " ";
```

ğŸ˜º ì´ëŸ°ê²ƒë„ ëœë‹¤.

```cpp
// ê¸°ì¡´ì˜ sortë°©ë²•
// std::sort(v1.begin(), v1.end());

// rangeì˜ sortë°©ë²•
std::ranges::sort(v1);
```

```cpp
// structì˜ ì •ë ¬ì„ ì´ëŸ°ì‹ìœ¼ë¡œ ê°€ëŠ¥
struct Knight
{
    std::string		name;
    int				id;
};

vector<Knight> knights =
{
    { "Rookiss", 1},
    { "Faker", 2},
    { "Dopa", 3},
    { "Deft", 4},
};

std::ranges::sort(knights, {}, &Knight::name); // ascending by name	
std::ranges::sort(knights, std::ranges::greater(), &Knight::name); // descending by name	
std::ranges::sort(knights, {}, &Knight::id); // ascending by id	
std::ranges::sort(knights, std::ranges::greater(), &Knight::id); // ascending by id
```

```cpp
// mapì—ë„ ì‚¬ìš©ê°€ëŠ¥
map<string, int> m =
{
    { "Rookiss", 1},
    { "Faker", 2},
    { "Dopa", 3},
    { "Deft", 4},
};

// keyë§Œ ì¶”ì¶œ
for (const auto& name : std::views::keys(m) | std::views::reverse)
    cout << name << endl;
```

ğŸ˜º ì¢€ ë” ê·¹ì ì¸ ì˜ˆì œë¥¼ ë³´ìë©´

```cpp
// 0~100 ì‚¬ì´ì˜ ìˆ«ìì¤‘ ì†Œìˆ˜ì¸ 5ê°œì˜ ìˆ«ìë¥¼ ì¶”ì¶œí•˜ë¼?

auto isPrime = [](int num)
{
    if (num <= 1)
        return false;

    for (int n = 2; n*n <= num; n++)
        if (num % n == 0)
            return false;

    return true;
};

std::vector<int> v3;
// std::views::iota(a, b) : aë¶€í„° ì‹œì‘í•´ì„œ 1ì”© ì¦ê°€ bê°œë¥¼ ë§Œë“¤ì–´ì¤Œ
for (int n : std::views::iota(0, 100) | std::views::filter(isPrime) | std::views::take(5))
{
    v3.push_back(n);
}
```

```cpp
template<std::ranges::input_range Range>
requires std::ranges::view<Range>
// std::ranges::view_interface -> ì»¤ìŠ¤í…€ ë·°ë¥¼ ë§Œë“¤ê² ë‹¤
class ContainerView : public std::ranges::view_interface<ContainerView<Range>>
{
public:
	ContainerView() = default;

	constexpr ContainerView(Range r) : _range(std::move(r)), _begin(std::begin(r)), _end(std::end(r))
	{

	}

	constexpr auto begin() const { return _begin; }
	constexpr auto end() const { return _end; }

private:
	Range _range;
	std::ranges::iterator_t<Range> _begin;
	std::ranges::iterator_t<Range> _end;
};

template<typename Range>
ContainerView(Range&& range) -> ContainerView<std::ranges::views::all_t<Range>>;

// ...

// ì»¤ìŠ¤í…€ ë·° (std::ranges::view_interface)
std::vector<int> myVec{1,2,3,4,5};
auto myView = ContainerView(myVec);

for (auto n : myView)
{
    cout << n << endl;
}
```