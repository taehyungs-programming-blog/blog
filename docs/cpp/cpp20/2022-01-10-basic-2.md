---
layout: default
title: 2. Concept
parent: (C++20)
grand_parent: C++
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º C#ì—ëŠ” ì•„ë˜ì™€ ê°™ì€ Template ë¬¸ë²•ì´ ì¡´ì¬í•œë‹¤

```C#
namespace CSharp
{
	class GameObject
	{
		public int id;
	}

	class Knight : GameObject
	{
		
	}

	class Orc : GameObject
	{

	}

	class Program
	{
        // whereì„ ì„ ì–¸í•¨ìœ¼ë¡œì„œ GameObject ì´ì™¸ì˜ ë‹¤ë¥¸ íƒ€ì…ì´ì˜¤ë©´ ì—ëŸ¬ê°€ ë¦¬í„´ëœë‹¤.
		static void TestObject<T>(T obj) where T : GameObject
		{
			int id = obj.id;
		}

		static void Main(string[] args)
		{
			TestObject<Knight>(new Knight());
			//TestObject<int>(3);       // Error
		}
	}
}
```

ğŸ˜º C++ì—ì„œë„ ë™ì¼í•œ ë¬¸ë²•ì  í‘œí˜„ì´ ê°€ëŠ¥í• ê¹Œ??

ğŸ™€ C++20 ì´ì „ì—ëŠ” ë¶ˆê°€ëŠ¥í–ˆì—ˆë‹¤. í•˜ì§€ë§Œ C++20 ë¶€í„° Conceptì˜ ë“±ì¥ìœ¼ë¡œ ë„¤ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ê°€ëŠ¥í•´ì¡Œë‹¤!

```cpp
// 1) Requires Clause(ì ˆ)
template<typename T>
requires std::integral<T>       // ì •ìˆ˜ë§Œ ë°›ê³  ì‹¶ë‹¤
void TestConcept1(T number)
{
	cout << number << endl;
}
```

```cpp
    // 1)ê³¼ í¬ê²Œ ë‹¤ë¥¼ê²Œ ì—†ìŒ, ë‹¤ìˆœíˆ ë’¤ì— ë¶™ëŠ” ì°¨ì´ë¿ 
// 2) Trailing Requires Clause (ë’¤ì— ë¶™ëŠ”~)
template<typename T>
void TestConcept2(T number) requires std::integral<T>
{
	cout << number << endl;
}
```

```cpp
// 3) Constrained Template Parameter (ê°•ìš”ëœ)
template<std::integral T>
void TestConcept3(T number)
{
	cout << number << endl;
}
```

```cpp
// 4) Abbreviated Function Template
void TestConcept4(std::integral auto number)
{
	cout << number << endl;
}
```

ğŸ˜º ê·¸ëŸ¼ `std::integral`ë§ê³  ë§ì´ì“¸ ê²ƒ ê°™ì€ conceptë“¤ì´ ë³„ë„ë¡œ ìˆì„ê¹Œ?

ğŸ™€ ì—„ì²­ ë§ìŒ ... ëª¨ë‘ ì™¸ìš¸ìˆ˜ëŠ” ì—†ê³  í•„ìš”í• ë•Œë§ˆë‹¤ ê²€ìƒ‰í•´ ë³´ì.

* ì–¸ì–´ ê´€ë ¨
    * same_as
    * derived_from
    * convertible_to
    * common_reference_with
    * common_with
    * assignable_from
    * swappable

* ì‚°ìˆ  ê´€ë ¨
    * integral
    * signed integral
    * unsigned_integral
    * floating_point

* ìƒëª…ì£¼ê¸° ê´€ë ¨
    * destructible
    * constructible_from
    * default_constructible
    * move_constructible
    * copy_constructible

* ë¹„êµ ê´€ë ¨
    * equality_comparable
    * totally_ordered

* ì˜¤ë¸Œì íŠ¸ ê´€ë ¨
    * movable
    * copyable
    * semiregular
    * regular

* í˜¸ì¶œ(Callable) ê´€ë ¨
    * invocable
    * regular_invocable
    * predicate

* ë°˜ë³µì ê´€ë ¨
    * input_iterator
    * output_iterator
    * forward_iterator
    * bidirectional_iterator
    * random_access_iterator (***)
    * contiguous_iterator

* ì•Œê³ ë¦¬ì¦˜/ë²”ìœ„ ê´€ë ¨
    * permutable
    * mergeable
    * sortable
    * ranges::input_range
    * ranges::random_access_range

ğŸ˜º ëŒ€ì¶©ì•Œê² ê³ . C#ì—ì„œ í–ˆë˜ê²ƒì„ C++ë¡œ ë§Œë“¤ì–´ë³´ìë©´?

```cpp
class GameObject
{

};

class Knight : public GameObject
{

};

template<typename T>
requires std::derived_from<T, GameObject>   // TëŠ” GameObjectì—ì„œ ìƒì†ì´ ë˜ì—ˆë‚˜ìš”?
void TestObj(T* obj)
{

}

// ...

TestObj(new Knight);
//TestObj(new int);     // Error
```

ğŸ˜º í ... ì˜ˆì œê°€ ì¢€ ë¶€ì¡±í•œë° í•˜ë‚˜ë§Œ ë” ë³´ì

```cpp
// ë‚˜ë§Œì˜ conceptì„ ë§Œë“¤ì—ˆë‹¤. TëŠ” integerê°€ ì•„ë‹ˆë©° GameObjectë¡œ ë¶€í„° ìƒì†ë˜ì–´ì•¼ í•´!
template<typename T>
concept MyConcept = !std::is_integral_v<T> && std::derived_from<T, GameObject>;
```

```cpp
// a + bê°€ ê°€ëŠ¥í•´ì•¼í•´
template<typename T>
concept Addable = requires (T a, T b)
{
	a + b;
};
```

```cpp
// ==ê³¼ !=ì„ ì§€ì›í•´ì•¼í•´
template<typename T>
concept Equality = requires(T a, T b)
{
	{ a == b } -> std::convertible_to<bool>;
	{ a != b } -> std::convertible_to<bool>;
};
```

```cpp
template<typename T>
concept Integral = std::is_integral_v<T>;

// intì´ë©° signedì¸ì§€?
template<typename T>
concept SignedInt = Integral<T> && std::is_signed_v<T>;
```

ğŸ™€ ì´ê±° ë„ˆë¬´... ë‚œí•´í•œë°??? ì‚¬ì‹¤ Conceptì„ ì“°ëŠ”ê²Œ ë§ëŠ” ë°©ë²•ì¸ì§€ëŠ” ì˜ ëª¨ë¥´ê² ìŒ. ì˜¤íˆë ¤ ì½”ë“œì˜ ê°€ë…ì„±ì„ ë–¨ì–´ëœ¨ë¦¬ëŠ” ì¼ì´ë ì§€ë„?