---
layout: default
title: 2. Concept
parent: (C++20)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º C#ì—ëŠ” ì•„ë˜ì™€ ê°™ì€ Template ë¬¸ë²•ì´ ì¡´ì¬í•œë‹¤

```
namespace CSharp
{
	class GameObject
	{
		public int id;
	}

	class Knight : GameObject
	{
		
	}

	class Orc : GameObject
	{

	}

	class Program
	{
        // whereì„ ì„ ì–¸í•¨ìœ¼ë¡œì„œ GameObject ì´ì™¸ì˜ ë‹¤ë¥¸ íƒ€ì…ì´ì˜¤ë©´ ì—ëŸ¬ê°€ ë¦¬í„´ëœë‹¤.
		static void TestObject<T>(T obj) where T : GameObject
		{
			int id = obj.id;
		}

		static void Main(string[] args)
		{
			TestObject<Knight>(new Knight());
			//TestObject<int>(3);       // Error
		}
	}
}
```

* **Concept** : íƒ€ì…ì´ ê°€ì ¸ì•¼í•˜ëŠ” ìš”êµ¬ì¡°ê±´ì„ ì •ì˜ í•˜ëŠ” ë¬¸ë²•

ğŸ˜º C++ì—ì„œë„ ë™ì¼í•œ ë¬¸ë²•ì  í‘œí˜„ì´ ê°€ëŠ¥í• ê¹Œ??

ğŸ™€ C++20 ì´ì „ì—ëŠ” ë¶ˆê°€ëŠ¥í–ˆì—ˆë‹¤. í•˜ì§€ë§Œ C++20 ë¶€í„° Conceptì˜ ë“±ì¥ìœ¼ë¡œ ë„¤ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ê°€ëŠ¥í•´ì¡Œë‹¤!

```cpp
// 1) Requires Clause(ì ˆ)
template<typename T>
requires std::integral<T>       // ì •ìˆ˜ë§Œ ë°›ê³  ì‹¶ë‹¤
void TestConcept1(T number)
{
	cout << number << endl;
}
```

```cpp
    // 1)ê³¼ í¬ê²Œ ë‹¤ë¥¼ê²Œ ì—†ìŒ, ë‹¤ìˆœíˆ ë’¤ì— ë¶™ëŠ” ì°¨ì´ë¿ 
// 2) Trailing Requires Clause (ë’¤ì— ë¶™ëŠ”~)
template<typename T>
void TestConcept2(T number) requires std::integral<T>
{
	cout << number << endl;
}
```

```cpp
// 3) Constrained Template Parameter (ê°•ìš”ëœ)
template<std::integral T>
void TestConcept3(T number)
{
	cout << number << endl;
}
```

```cpp
// 4) Abbreviated Function Template
void TestConcept4(std::integral auto number)
{
	cout << number << endl;
}
```

ğŸ˜º ê·¸ëŸ¼ `std::integral`ë§ê³  ë§ì´ì“¸ ê²ƒ ê°™ì€ conceptë“¤ì´ ë³„ë„ë¡œ ìˆì„ê¹Œ?

ğŸ™€ ì—„ì²­ ë§ìŒ ... ëª¨ë‘ ì™¸ìš¸ìˆ˜ëŠ” ì—†ê³  í•„ìš”í• ë•Œë§ˆë‹¤ ê²€ìƒ‰í•´ ë³´ì.

* ì–¸ì–´ ê´€ë ¨
    * same_as
    * derived_from
    * convertible_to
    * common_reference_with
    * common_with
    * assignable_from
    * swappable

* ì‚°ìˆ  ê´€ë ¨
    * integral
    * signed integral
    * unsigned_integral
    * floating_point

* ìƒëª…ì£¼ê¸° ê´€ë ¨
    * destructible
    * constructible_from
    * default_constructible
    * move_constructible
    * copy_constructible

* ë¹„êµ ê´€ë ¨
    * equality_comparable
    * totally_ordered

* ì˜¤ë¸Œì íŠ¸ ê´€ë ¨
    * movable
    * copyable
    * semiregular
    * regular

* í˜¸ì¶œ(Callable) ê´€ë ¨
    * invocable
    * regular_invocable
    * predicate

* ë°˜ë³µì ê´€ë ¨
    * input_iterator
    * output_iterator
    * forward_iterator
    * bidirectional_iterator
    * random_access_iterator (***)
    * contiguous_iterator

* ì•Œê³ ë¦¬ì¦˜/ë²”ìœ„ ê´€ë ¨
    * permutable
    * mergeable
    * sortable
    * ranges::input_range
    * ranges::random_access_range

ğŸ˜º ëŒ€ì¶©ì•Œê² ê³ . C#ì—ì„œ í–ˆë˜ê²ƒì„ C++ë¡œ ë§Œë“¤ì–´ë³´ìë©´?

```cpp
class GameObject
{

};

class Knight : public GameObject
{

};

template<typename T>
requires std::derived_from<T, GameObject>   // TëŠ” GameObjectì—ì„œ ìƒì†ì´ ë˜ì—ˆë‚˜ìš”?
void TestObj(T* obj)
{

}

// ...

TestObj(new Knight);
//TestObj(new int);     // Error
```

ğŸ˜º í ... ì˜ˆì œê°€ ì¢€ ë¶€ì¡±í•œë° í•˜ë‚˜ë§Œ ë” ë³´ì

```cpp
// ë‚˜ë§Œì˜ conceptì„ ë§Œë“¤ì—ˆë‹¤. TëŠ” integerê°€ ì•„ë‹ˆë©° GameObjectë¡œ ë¶€í„° ìƒì†ë˜ì–´ì•¼ í•´!
template<typename T>
concept MyConcept = !std::is_integral_v<T> && std::derived_from<T, GameObject>;
```

```cpp
// a + bê°€ ê°€ëŠ¥í•´ì•¼í•´
template<typename T>
concept Addable = requires (T a, T b)
{
	a + b;
};
```

```cpp
// ==ê³¼ !=ì„ ì§€ì›í•´ì•¼í•´ And boolë¡œ ë³€í™˜ì´ ê°€ëŠ¥í•´ì•¼í•´
template<typename T>
concept Equality = requires(T a, T b)
{
	{ a == b } -> std::convertible_to<bool>;
	{ a != b } -> std::convertible_to<bool>;
};
```

```cpp
template<typename T>
concept Integral = std::is_integral_v<T>;

// intì´ë©° signedì¸ì§€?
template<typename T>
concept SignedInt = Integral<T> && std::is_signed_v<T>;
```

ğŸ™€ ì´ê±° ë„ˆë¬´... ë‚œí•´í•œë°??? ì‚¬ì‹¤ Conceptì„ ì“°ëŠ”ê²Œ ë§ëŠ” ë°©ë²•ì¸ì§€ëŠ” ì˜ ëª¨ë¥´ê² ìŒ. ì˜¤íˆë ¤ ì½”ë“œì˜ ê°€ë…ì„±ì„ ë–¨ì–´ëœ¨ë¦¬ëŠ” ì¼ì´ë ì§€ë„?

---

## Example

```cpp
#include <concepts>

// íƒ€ì…ì´ ê°€ì ¸ì•¼í•˜ëŠ” ìš”êµ¬ì¡°ê±´ì„ ì •ì˜
template<typename T>
concept GreaterThan4 = sizeof(T) >= 4;

// requires : GreaterThan4ë¼ëŠ” ìš”êµ¬ì¡°ê±´ì„ ìš”ì²­. ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ë§Œ ì´ í…œí”Œë¦¿ì„ ì‚¬ìš©ê°€ëŠ¥
template<typename T> requires GreaterThan4<T>
void foo(T arg)
{
}

int main()
{
    int i = 10;
    short s = 10;
    double d = 3.4;

    foo(i);     // ok
    foo(s);     // error - shortëŠ” 4ë°”ì´íŠ¸ë³´ë‹¤ ì‘ë‹¤
    foo(d);     // ok
}
```

### Example2

```cpp
double gcd2(double a, double b) { return 0; }

template<typename T> 
T gcd2(T a, T b) { return b == 0 ? a : gcd2(b, a % b); }

int main()
{
    gcd2(4.2, 2.1);  // gcd2 doubleì„ í˜¸ì¶œ
    gcd2(4, 2);      // templateì„ ì´ìš©í•´ intë²„ì „ gcd2ë¥¼ ë§Œë“¦
    gcd2(4.f, 2.f);  // gcd2 doubleì„ ì‚¬ìš©í–ˆìœ¼ë©´ í•˜ëŠ”ë° templateì„ ì´ìš©í•´ float ë²„ì „ gcd2ë¥¼ ë§Œë“ ë‹¤
    // ê°œì„ í•´ë³´ì
}
```

```cpp
double gcd2(double a, double b) { return 0; }

// ì˜¤ì§ intë§Œ ë§Œë“¤ìˆ˜ìˆê²Œ ë§Œë“ ë‹¤.(ì–´ë ¤ìš° ë§ë¡œ SFINAE(Substitution Failure Is Not An Error) ë”±íˆ ì•Œ í•„ìš”ëŠ” ì—†ë‹¤.)
template<typename T> requires std::is_integral_v<T>
T gcd2(T a, T b) { return b == 0 ? a : gcd2(b, a % b); }
```

### Example3

```cpp
#include <iostream>
#include <type_traits>

// íƒ€ì…ì— ë”°ë¥¸ ì˜¤ë²„ë¡œë”©
void foo(int n)    {}
void foo(double d) {}

// "ê°€ìƒí•¨ìˆ˜ê°€ ìˆëŠ” íƒ€ì…" ê³¼ "ì—†ëŠ” íƒ€ì…" ì— ë”°ë¥¸ ì˜¤ë²„ë¡œë”©.

template<typename T> requires std::is_polymorphic_v<T>
void goo( const T& a )
{
    std::cout << "has virtual" << std::endl;
}

template<typename T> requires (!std::is_polymorphic_v<T>)
void goo( const T& a )
{
    std::cout << "no virtual" << std::endl;
}

int main()
{
    goo(10);        // no virtual
    goo(std::cout); // has virtual

}
```

---

## ì¡°ê¸ˆ ì •ë¦¬í•´ ë³´ìë©´

* **Requires Clauses(Require ì ˆ)**
    * í…œí”Œë¦¿ ì¸ìê°€ ê°€ì ¸ì•¼ í•˜ëŠ” ì œì•½ì˜ ì¡°ê±´ì„ í‘œê¸°ê°€ëŠ¥
    * ì¡°ê±´ì„ ì¶©ì¡±ì‹œì—ë§Œ í•¨ìˆ˜ê°€ ìƒì„±ëœë‹¤.
* ì¥ì 
    * ë§Œì•½ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í• ì‹œ ì½ê¸° **ì¢‹ì€ ì—ëŸ¬ ë©”ì‹œì§€**ê°€ ì¶œë ¥ëœë‹¤.
    * ì¹˜í™˜ ì‹¤íŒ¨ëŠ” ì—ëŸ¬ê°€ ì•„ë‹ˆë‹¤(**SFINAE**) ê·œì¹™ì´ ì ìš©ëœë‹¤.
    * ì¡°ê±´ì— ë”°ë¥¸ **í•¨ìˆ˜ ì˜¤ë²„ë¡œë”©**ì´ ê°€ëŠ¥í•´ ì§„ë‹¤.

### ë§Œì•½ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í• ì‹œ ì½ê¸° ì¢‹ì€ ì—ëŸ¬ ë©”ì‹œì§€ê°€ ì¶œë ¥ëœë‹¤.

```cpp
// ì—¬ê¸°ì„œ ì—ëŸ¬ë°œìƒì‹œ (doubleí˜• gcdê°€ ì—†ë‹¤ê³ )ì»´íŒŒì¼ ì—ëŸ¬ë°œìƒ
template<typename T> requires std::is_integral_v<T>
T gcd( T a, T b )
{
    std::cout << "requires" << std::endl;
    return b == 0 ? a : gcd(b, a % b);
}

double gcd(double a, double b)  // ì—¬ê¸°ì„œ ì—ëŸ¬ë°œìƒì‹œ (a % b ì—°ì‚°ë¶ˆê°€)ì»´íŒŒì¼ ì—ëŸ¬ë°œìƒ
{
    std::cout << "double" << std::endl;
    return b == 0 ? a : gcd(b, a % b);
}

int main()
{
    gcd(18, 24);
    gcd(3.4, 3.2);
    gcd(1.2f, 2.3f); // float
}
```

### ì¹˜í™˜ ì‹¤íŒ¨ëŠ” ì—ëŸ¬ê°€ ì•„ë‹ˆë‹¤(SFINAE) ê·œì¹™ì´ ì ìš©ëœë‹¤.

```cpp
template<typename T> T gcd( T a, T b )
{
    std::cout << "template" << std::endl;
    return b == 0 ? a : gcd(b, a % b);
}

double gcd(double a, double b)
{
    std::cout << "double" << std::endl;
    return b == 0 ? a : gcd(b, a % b);
}

int main()
{
    gcd(18, 24);
    gcd(3.4, 3.2);
    gcd(1.2f, 2.3f); // Error ë°œìƒ - floatì´ê¸°ì— templateì„ í†µí•´ gcdë¥¼ ìƒì„±
                     // ê·¸ëŸ°ë° double ë²„ì „ì˜ gcdë¥¼ ì‚¬ìš©í•˜ë©´ ë˜ì§€ì•Šë‚˜? -> ì´ê²Œ ê°€ëŠ¥
}
```

```cpp
// ì—¬ê¸°ì„œ integeralë§Œ ë°›ê¸°ì—
template<typename T> requires std::is_integral_v<T>
T gcd( T a, T b )
{
    std::cout << "requires" << std::endl;
    return b == 0 ? a : gcd(b, a % b);
}

// floatë„ ì—¬ê¸°ë¡œ ë“¤ì–´ì˜¤ê²Œ ëœë‹¤.
double gcd(double a, double b)
{
    std::cout << "double" << std::endl;
    return b == 0 ? a : gcd(b, a % b);
}

// ì¹˜í™˜ì— ì‹¤íŒ¨í•˜ê³ , doubleë¡œ ê°€ë©° ì´ë¥¼ ì¹˜í™˜ ì‹¤íŒ¨ëŠ” ì—ëŸ¬ê°€ ì•„ë‹ˆë‹¤(SFINAE) ë¼ê³ í•œë‹¤.
```

* Substitution Failture Is Not An Error(SFINAE)

### ì¡°ê±´ì— ë”°ë¥¸ í•¨ìˆ˜ ì˜¤ë²„ë¡œë”©ì´ ê°€ëŠ¥í•´ ì§„ë‹¤.

```cpp
// ê¸°ì¡´ì˜ ì˜¤ë²„ë¡œë”©
void foo(int a) {}
void foo(double a) {}
void foo(double a, double b) {}

// ì¸ìì˜ íƒ€ì…ì´ë‚˜ ê°œìˆ˜ê°€ ë‹¤ë¥´ë©´ ì˜¤ë²„ë¡œë”©ì´ ê°€ëŠ¥.
```

```cpp
// ì¡°ê±´(require)ì— ë”°ë¼ ì˜¤ë²„ë¡œë”©ì´ ê°€ëŠ¥í• ê¹Œ?

#include <iostream>

template<typename T> 
concept Concept1 = sizeof(T) > 1;

template<typename T>   
concept Concept2 = sizeof(T) > 1 && sizeof(T) < 8;

template<typename T> requires Concept1<T> 
void foo(T a) { std::cout << "1" << std::endl; }

template<typename T> requires Concept2<T>
void foo(T a) { std::cout << "2" << std::endl;}

int main()
{
    foo(3); // int
}
```

```cpp
// Example

#include <iostream>
#include <type_traits>

// íƒ€ì…ì— ë”°ë¥¸ ì˜¤ë²„ë¡œë”©
void foo(int n)    {}
void foo(double d) {}

// "ê°€ìƒí•¨ìˆ˜ê°€ ìˆëŠ” íƒ€ì…" ê³¼ "ì—†ëŠ” íƒ€ì…" ì— ë”°ë¥¸ ì˜¤ë²„ë¡œë”©.

template<typename T> requires std::is_polymorphic_v<T>
void goo( const T& a )
{
    std::cout << "has virtual" << std::endl;
}

template<typename T> requires (!std::is_polymorphic_v<T>)
void goo( const T& a )
{
    std::cout << "no virtual" << std::endl;
}

int main()
{
    goo(10);        // no virtual
    goo(std::cout); // has virtual

}
```
