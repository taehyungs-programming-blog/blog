---
layout: default
title: 5. Coroutine
parent: (C++20)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## coroutine이란?

```

Foo() --------> void Foo()
                    |
                    |
                    |
        <모든 Foo의 동작을 마치고>
                    |
<------------------- <다시 main으로 돌아간다.>

* 이런 루틴(routine)을 sub-routine이라한다.

```

```

Foo() --------> void Foo()
                    |
                    |
<-------------------
|
|
-------------------->
                    |
                    |
<-------------------

* 중간중간 main으로 다시 돌아가며 마치 협업을 하듯 함수를 호출한다.
* 이런 루틴(routine)을 co-routine이라 한다.

```

## coroutine의 필요성

😺 Coroutine은 보통 어디에 쓰일까?

```cpp
void VeryDifficultFunction()
{
    for(int i = 0; i < 100000; i++)
    {
        //... 무거운 작업을 반복적으로 하는 함수
    }
}
// 이렇게 한 번 부르기도 부담스러운 함수가 존재한다고 할때
VeryDifficultFunction();
// 이 함수가 하나의 Thread를 점유하는 것은 부담스러운 일 일수있다.
    // 여기서 아이디어가 나오는데 매우 무거운 함수를 나눠서 실행할 수 있다면??
    // 100000번을 함수 내부에서 돌아야하는데 1000번씩 나눠서 돌릴수 없나?
```

😺 기존 C++에서는 불가능! But Coroutine(C++20)에서는 가능해졌다<br>
😸 그런데 이런 경우가 많이 있는가?? 좀 더 효율적인 예제는 없나?

```cpp
void KillMonster()
{
    /*
        몬스터 처치시 아래의 과정이 필요하다
        1. 몬스터 처치
        2. 아이템 획득시 DB에 처리요청 <-- 여기가 매우 느림
        3. 아이템 생성 및 인벤토리 추가
    */

    // * 아이템 획득시 DB에 처리요청
    // 이 과정을 Coroutine으로 처리하고자 하는데 자세한것은 뒤에서 설명
}
```

---

## coroutine의 종류

😺 그럼 coroutine을 어떻게 쓰는지 살펴보자.

* coroutine은 아래 세 함수 중 하나라도 사용할 경우 coroutine이 된다.
    - `co_return`
    - `co_yield`
    - `co_await`
* 하나하나 살펴보자면

### co_return

```cpp
// coroutine으로 리턴을 하면 coroutine이 될까?
void HelloCoroutine()
{
    // 이렇게 사용하면 coroutine이 되는 것인가?
    co_return;  // Error! - 현재 리턴형이 void인데
                // coroutine을 쓰기 위해선 coroutine 구조체를 리턴해야함
}
```

😺 ?!?! 무슨소리지? - 아직 C++20의 coroutine이 그리 완벽하지 못하다. C++20에서 요구하는 coroutine의 형태로 만들어서 사용해야 한다...;<br>
😺 그럼 **coroutine 구조체**를 만들어 보자

```cpp
#include <coroutine>

// ...

struct CoroutineObject
{
    /*
        * promise 객체는 다음과 같은 인터페이스를 제공해야 함
            * 요구하는 인터페이스의 경우는 co_return, co_yield, co_await에 따라 다르기에 그때그때 에러뜨는것을 보고 만들면 된다.

        - get_return_object : 코루틴 객체를 반환 (resumable object)
        - return_value(val) : `co_return XXX;` 으로 리턴할 변수를 담는 함수.
        - return_void() : `co_return;` 리턴이 void일 경우 처리할 부분을 담는 함수.
        - yield_value(val) : `co_yield XXX;` 으로 잠시 보유할 변수를 담는 함수.
        - initial_suspend() : 코루틴이 실행 전에 중단/연기될 수 있는지
        - final_suspend() : 코루틴이 종료 전에 중단/연기될 수 있는지
        - unhandled_exception() : 예외 처리시 호출됨
    */

    // 내부에 struct promise_type를 무조건 포함해야한다.
    struct promise_type
    {
        CoroutineObject get_return_object() { return {}; }
        std::suspend_never initial_suspend() const noexcept { return {}; }
        std::suspend_never final_suspend() const noexcept { return {}; }
        void return_void() { }
        void unhandled_exception() { }
    };
};

// ...

CoroutineObject HelloCoroutine()
{
    // 이제 이렇게 쓸 수 있다.
    co_return;
}
```

😺 그럼 `co_return;`의 동작을 알아야 하는데<br>
😺 `co_return;`이 작성되면 컴파일러는 내부적으로 아래와 같은 코드를 만들어 준다.

```cpp
CoroutineObject HelloCoroutine()
{
    co_return;
}

/*
    CoroutineObject HelloCoroutine()
    {
        // promise를 생성후
        Promise prom; (get_return_object)   // get_return_object를 호출해 coroutine 객체를 생성한다.

        // 이후 promise의 initial_suspend를 호출 등등
        co_await prom.initial_suspend();
        try
        {
            // co_return, co_yield, co_await를 포함하는 코드
        }
        catch (...)
        {
            prom.unhandled_exception();
        }
        co_await prom.final_suspend();


        // 보면 모두 CoroutineObject를 생성하면 만들었던 함수들이다.
    }
*/
```

---

😺 그런데 코드는 많이 적었는데 뭘 한 건지는 전혀모르겠다. <br>
😺 아주 정상임 이제 위 코드에 기능을 하나하나 추가할 예정

```cpp
Future<int> CreateFuture()
{
    // 리턴을 받는 Future를 만들어보자
    co_return 2021;
}
```

```cpp
template<typename T>
class Future
{
public:
    Future(shared_ptr<T> value) : _value(value) { }
    T get() { return *_value; }

private:
    shared_ptr<T> _value;

public:
    struct promise_type
    {
        // 리턴을 받아야하기에 return_value(T value)를 생성
        void return_value(T value) { *_ptr = value; }

        // 나머지는 기존과 동일하다고 볼 수 있다.
        Future<T> get_return_object() { return Future<T>(_ptr); }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void unhandled_exception() { }

        // 데이터
        shared_ptr<T> _ptr = make_shared<T>();
    };
};
```

😺 실제사용은 어떻게 할까?

```cpp
int main() 
{
    // coroutine객체를 생성하고 ...
    auto future = CreateFuture();
    /*
        Future<int> CreateFuture()
        {
            co_return 2021;
        }
    */

    // TODO : 다른걸 하다...
    // 이후에 호출이 가능
    cout << future.get() << endl;
}
```

😺 앞서 `co_retur` 를 컴파일러가 어떻게 변경해 주는지 배웠으니

```cpp
// co_return이 호출되면 컴파일러에 의해 생성되는 코드는 아래이며 설명을 붙이자면
{
    Promise prom; (get_return_object)
    /*
        get_return_object 는,
        Future<T> get_return_object() { return Future<T>(_ptr); } 이기에
        Future 객체가 생성 그리고 _ptr = _value가 된다.
    */

    co_await prom.initial_suspend();
    try
    {
        // 여기에 co_return 2021; 가 들어가고
        // co_return 2021;는
            // void return_value(T value) { *_ptr = value; } 가 호출됨
            // _ptr에 value(2021)이 들어가게 된다.
    }
    catch (...)
    {
        prom.unhandled_exception();
    }
    co_await prom.final_suspend();
}
```

😺 `co_await prom.initial_suspend()`의 설명을 위해서 co_await의 설명이 필요하다

```cpp
// co_await 플로우(아래 코드는 C++코드가 아니라 의사코드임 헷갈리지 말기)
{
    // await_ready() : 준비가 되었는지 안되었는지 확인
    /*
        준비여부는
            std::suspend_never initial_suspend() { return {}; }
            std::suspend_never final_suspend() noexcept { return {}; }
        * std::suspend_never - 무조건 넘어가달라
        * std::suspend_always - 무조건 멈춰달라
    */
    if awaitable.await_ready() returns false;   // await_ready()가 false(준비가 안됨)일 경우 아래를 실행
        suspend coroutine
        awaitable.await_suspend(handle) returns:    // coroutine을 suspend(잠시멈춰라)
            // awaitable.await_suspend(handle)의 리턴형이 void, bool, another에 따라서 별도 처리
            void:
                // 리턴이 void일 경우
                awaitable.await_suspend(handle);
                coroutine keeps suspended   // coroutine을 suspend해두고
                return to caller            // 호출자를 다시 호출한다
            bool:
                bool result = awaitable.await_suspend(handle);
                if (result)
                    coroutine keeps suspended
                    return to caller
                else
                    return awaitable.await_resume()
            another coroutine handle:
                anotherCoroutineHandle = awaitable.await_suspend(handle);
                anotherCoroutineHandle.resume();
                return to caller;
    return awaitable.await_resume();
}
```

---

## co_yield

😺 다음은 co_yield를 어떻게 사용되는지 보자.<br>
😺 co_yield는 이전상황을 계속 저장하며 **정지/실행**을 반복하는 것을 의미한다.

```cpp
Generator<int> GenNumbers(int start = 0, int delta = 1)
{
    int now = start;
    while (true)
    {
        co_yield now; // yield return - 여기까지 돌고 리턴된다
        now += delta;
    }
}

//...

auto numbers = GenNumbers(0, 1);
for (int i = 0; i < 20; i++)
{
    numbers.next();
    cout << " " << numbers.get();
}
```

```cpp
template<typename T>
class Generator
{
public:
    struct promise_type;
    using handle_type = coroutine_handle<promise_type>;

    Generator(handle_type handle) : _handle(handle)
    {

    }

    ~Generator()
    {
        if (_handle)
            _handle.destroy();
    }

    T get() { return _handle.promise()._value; }

    bool next()
    {
        _handle.resume();       // 중요) coroutine 재개
        return !_handle.done();
    }

private:
    handle_type _handle;        // coroutine의 handle을 갖고있는다

public:
    struct promise_type
    {
        // Generator(handle_type::from_promise(*this)); 이런식으로 핸들을 넘길 수 있는데 이 부분은 받아들이자
        Generator<T> get_return_object() { return Generator(handle_type::from_promise(*this)); }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        // co_yield가 호출되면 yield_value가 호출됨.
        std::suspend_always yield_value(const T value) { _value = value; return {}; }
        std::suspend_always return_void() { return {}; }
        void unhandled_exception() { }
        T _value;
    };
};
```

😺 이걸 현실에 반영하기는 쉽지는 않을듯... 코드를 읽는 수준에서 보자

---

## co_await

😺 다음은 co_await

```cpp
Job PrepareJob()
{
    // co_await [Awaitable]
    co_await std::suspend_never();
    
    // 여기도 동일하게 corotine 의사코드가 오게되며
    /*
        co_await prom.initial_suspend();
        try
        {
            // std::suspend_never();
        }
        catch (...)
        {
            prom.unhandled_exception();
        }
        co_await prom.final_suspend();
    */
    // 이렇게 된다.
}

// ...

auto job = PrepareJob();
job.start();
```

```cpp
class Job
{
public:
    struct promise_type;
    using handle_type = coroutine_handle<promise_type>;

    Job(handle_type handle) : _handle(handle)
    {

    }

    ~Job()
    {
        if (_handle)
            _handle.destroy();
    }

    void start()
    {
        if (_handle)
            _handle.resume();
    }

private:
    handle_type _handle;
    
public:
    struct promise_type
    {
        Job get_return_object() { return Job(handle_type::from_promise(*this)); }
        std::suspend_always initial_suspend() { cout << "Prepare Job" << endl;  return {}; }
        std::suspend_never final_suspend() noexcept { cout << "Do Job" << endl; return {}; }
        std::suspend_never return_void() { return {}; }
        void unhandled_exception() { }
    };
};
```

```cpp
// Example

#include <iostream>
#include <coroutine>

class Generator
{
public:
    struct Promise
    {
		Generator get_return_object()
		{
			return Generator{ std::coroutine_handle<Promise>::from_promise(*this) };
		}
		auto initial_suspend() { return std::suspend_always{}; }
		auto return_void() { return std::suspend_never{}; }
		auto final_suspend() { return std::suspend_always{}; }
		void unhandled_exception() { std::exit(1); }
    };
    using promise_type = Promise;

    std::coroutine_handle<promise_type> coro;

    Generator( std::coroutine_handle<promise_type> c ) : coro(c) {}

    ~Generator() { if ( coro ) coro.destroy();}
};

Generator foo()
{
    std::cout << "Run 1" << std::endl;
    co_await std::suspend_always {};
    std::cout << "Run 2" << std::endl;
}

int main()
{
    foo();
}
```