---
layout: default
title: 5. Coroutine
parent: (C++20)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## coroutineì´ë€?

```

Foo() --------> void Foo()
                    |
                    |
                    |
        <ëª¨ë“  Fooì˜ ë™ì‘ì„ ë§ˆì¹˜ê³ >
                    |
<------------------- <ë‹¤ì‹œ mainìœ¼ë¡œ ëŒì•„ê°„ë‹¤.>

* ì´ëŸ° ë£¨í‹´(routine)ì„ sub-routineì´ë¼í•œë‹¤.

```

```

Foo() --------> void Foo()
                    |
                    |
<-------------------
|
|
-------------------->
                    |
                    |
<-------------------

* ì¤‘ê°„ì¤‘ê°„ mainìœ¼ë¡œ ë‹¤ì‹œ ëŒì•„ê°€ë©° ë§ˆì¹˜ í˜‘ì—…ì„ í•˜ë“¯ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.
* ì´ëŸ° ë£¨í‹´(routine)ì„ co-routineì´ë¼ í•œë‹¤.

```

## coroutineì˜ í•„ìš”ì„±

ğŸ˜º Coroutineì€ ë³´í†µ ì–´ë””ì— ì“°ì¼ê¹Œ?

```cpp
void VeryDifficultFunction()
{
    for(int i = 0; i < 100000; i++)
    {
        //... ë¬´ê±°ìš´ ì‘ì—…ì„ ë°˜ë³µì ìœ¼ë¡œ í•˜ëŠ” í•¨ìˆ˜
    }
}
// ì´ë ‡ê²Œ í•œ ë²ˆ ë¶€ë¥´ê¸°ë„ ë¶€ë‹´ìŠ¤ëŸ¬ìš´ í•¨ìˆ˜ê°€ ì¡´ì¬í•œë‹¤ê³  í• ë•Œ
VeryDifficultFunction();
// ì´ í•¨ìˆ˜ê°€ í•˜ë‚˜ì˜ Threadë¥¼ ì ìœ í•˜ëŠ” ê²ƒì€ ë¶€ë‹´ìŠ¤ëŸ¬ìš´ ì¼ ì¼ìˆ˜ìˆë‹¤.
    // ì—¬ê¸°ì„œ ì•„ì´ë””ì–´ê°€ ë‚˜ì˜¤ëŠ”ë° ë§¤ìš° ë¬´ê±°ìš´ í•¨ìˆ˜ë¥¼ ë‚˜ëˆ ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤ë©´??
    // 100000ë²ˆì„ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ëŒì•„ì•¼í•˜ëŠ”ë° 1000ë²ˆì”© ë‚˜ëˆ ì„œ ëŒë¦´ìˆ˜ ì—†ë‚˜?
```

ğŸ˜º ê¸°ì¡´ C++ì—ì„œëŠ” ë¶ˆê°€ëŠ¥! But Coroutine(C++20)ì—ì„œëŠ” ê°€ëŠ¥í•´ì¡Œë‹¤<br>
ğŸ˜¸ ê·¸ëŸ°ë° ì´ëŸ° ê²½ìš°ê°€ ë§ì´ ìˆëŠ”ê°€?? ì¢€ ë” íš¨ìœ¨ì ì¸ ì˜ˆì œëŠ” ì—†ë‚˜?

```cpp
void KillMonster()
{
    /*
        ëª¬ìŠ¤í„° ì²˜ì¹˜ì‹œ ì•„ë˜ì˜ ê³¼ì •ì´ í•„ìš”í•˜ë‹¤
        1. ëª¬ìŠ¤í„° ì²˜ì¹˜
        2. ì•„ì´í…œ íšë“ì‹œ DBì— ì²˜ë¦¬ìš”ì²­ <-- ì—¬ê¸°ê°€ ë§¤ìš° ëŠë¦¼
        3. ì•„ì´í…œ ìƒì„± ë° ì¸ë²¤í† ë¦¬ ì¶”ê°€
    */

    // * ì•„ì´í…œ íšë“ì‹œ DBì— ì²˜ë¦¬ìš”ì²­
    // ì´ ê³¼ì •ì„ Coroutineìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ ì í•˜ëŠ”ë° ìì„¸í•œê²ƒì€ ë’¤ì—ì„œ ì„¤ëª…
}
```

---

## coroutineì˜ ì¢…ë¥˜

ğŸ˜º ê·¸ëŸ¼ coroutineì„ ì–´ë–»ê²Œ ì“°ëŠ”ì§€ ì‚´í´ë³´ì.

* coroutineì€ ì•„ë˜ ì„¸ í•¨ìˆ˜ ì¤‘ í•˜ë‚˜ë¼ë„ ì‚¬ìš©í•  ê²½ìš° coroutineì´ ëœë‹¤.
    - `co_return`
    - `co_yield`
    - `co_await`
* í•˜ë‚˜í•˜ë‚˜ ì‚´í´ë³´ìë©´

### co_return

```cpp
// coroutineìœ¼ë¡œ ë¦¬í„´ì„ í•˜ë©´ coroutineì´ ë ê¹Œ?
void HelloCoroutine()
{
    // ì´ë ‡ê²Œ ì‚¬ìš©í•˜ë©´ coroutineì´ ë˜ëŠ” ê²ƒì¸ê°€?
    co_return;  // Error! - í˜„ì¬ ë¦¬í„´í˜•ì´ voidì¸ë°
                // coroutineì„ ì“°ê¸° ìœ„í•´ì„  coroutine êµ¬ì¡°ì²´ë¥¼ ë¦¬í„´í•´ì•¼í•¨
}
```

ğŸ˜º ?!?! ë¬´ìŠ¨ì†Œë¦¬ì§€? - ì•„ì§ C++20ì˜ coroutineì´ ê·¸ë¦¬ ì™„ë²½í•˜ì§€ ëª»í•˜ë‹¤. C++20ì—ì„œ ìš”êµ¬í•˜ëŠ” coroutineì˜ í˜•íƒœë¡œ ë§Œë“¤ì–´ì„œ ì‚¬ìš©í•´ì•¼ í•œë‹¤...;<br>
ğŸ˜º ê·¸ëŸ¼ **coroutine êµ¬ì¡°ì²´**ë¥¼ ë§Œë“¤ì–´ ë³´ì

```cpp
#include <coroutine>

// ...

struct CoroutineObject
{
    /*
        * promise ê°ì²´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•´ì•¼ í•¨
            * ìš”êµ¬í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ê²½ìš°ëŠ” co_return, co_yield, co_awaitì— ë”°ë¼ ë‹¤ë¥´ê¸°ì— ê·¸ë•Œê·¸ë•Œ ì—ëŸ¬ëœ¨ëŠ”ê²ƒì„ ë³´ê³  ë§Œë“¤ë©´ ëœë‹¤.

        - get_return_object : ì½”ë£¨í‹´ ê°ì²´ë¥¼ ë°˜í™˜ (resumable object)
        - return_value(val) : `co_return XXX;` ìœ¼ë¡œ ë¦¬í„´í•  ë³€ìˆ˜ë¥¼ ë‹´ëŠ” í•¨ìˆ˜.
        - return_void() : `co_return;` ë¦¬í„´ì´ voidì¼ ê²½ìš° ì²˜ë¦¬í•  ë¶€ë¶„ì„ ë‹´ëŠ” í•¨ìˆ˜.
        - yield_value(val) : `co_yield XXX;` ìœ¼ë¡œ ì ì‹œ ë³´ìœ í•  ë³€ìˆ˜ë¥¼ ë‹´ëŠ” í•¨ìˆ˜.
        - initial_suspend() : ì½”ë£¨í‹´ì´ ì‹¤í–‰ ì „ì— ì¤‘ë‹¨/ì—°ê¸°ë  ìˆ˜ ìˆëŠ”ì§€
        - final_suspend() : ì½”ë£¨í‹´ì´ ì¢…ë£Œ ì „ì— ì¤‘ë‹¨/ì—°ê¸°ë  ìˆ˜ ìˆëŠ”ì§€
        - unhandled_exception() : ì˜ˆì™¸ ì²˜ë¦¬ì‹œ í˜¸ì¶œë¨
    */

    // ë‚´ë¶€ì— struct promise_typeë¥¼ ë¬´ì¡°ê±´ í¬í•¨í•´ì•¼í•œë‹¤.
    struct promise_type
    {
        CoroutineObject get_return_object() { return {}; }
        std::suspend_never initial_suspend() const noexcept { return {}; }
        std::suspend_never final_suspend() const noexcept { return {}; }
        void return_void() { }
        void unhandled_exception() { }
    };
};

// ...

CoroutineObject HelloCoroutine()
{
    // ì´ì œ ì´ë ‡ê²Œ ì“¸ ìˆ˜ ìˆë‹¤.
    co_return;
}
```

ğŸ˜º ê·¸ëŸ¼ `co_return;`ì˜ ë™ì‘ì„ ì•Œì•„ì•¼ í•˜ëŠ”ë°<br>
ğŸ˜º `co_return;`ì´ ì‘ì„±ë˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì•„ë˜ì™€ ê°™ì€ ì½”ë“œë¥¼ ë§Œë“¤ì–´ ì¤€ë‹¤.

```cpp
CoroutineObject HelloCoroutine()
{
    co_return;
}

/*
    CoroutineObject HelloCoroutine()
    {
        // promiseë¥¼ ìƒì„±í›„
        Promise prom; (get_return_object)   // get_return_objectë¥¼ í˜¸ì¶œí•´ coroutine ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.

        // ì´í›„ promiseì˜ initial_suspendë¥¼ í˜¸ì¶œ ë“±ë“±
        co_await prom.initial_suspend();
        try
        {
            // co_return, co_yield, co_awaitë¥¼ í¬í•¨í•˜ëŠ” ì½”ë“œ
        }
        catch (...)
        {
            prom.unhandled_exception();
        }
        co_await prom.final_suspend();


        // ë³´ë©´ ëª¨ë‘ CoroutineObjectë¥¼ ìƒì„±í•˜ë©´ ë§Œë“¤ì—ˆë˜ í•¨ìˆ˜ë“¤ì´ë‹¤.
    }
*/
```

---

ğŸ˜º ê·¸ëŸ°ë° ì½”ë“œëŠ” ë§ì´ ì ì—ˆëŠ”ë° ë­˜ í•œ ê±´ì§€ëŠ” ì „í˜€ëª¨ë¥´ê² ë‹¤. <br>
ğŸ˜º ì•„ì£¼ ì •ìƒì„ ì´ì œ ìœ„ ì½”ë“œì— ê¸°ëŠ¥ì„ í•˜ë‚˜í•˜ë‚˜ ì¶”ê°€í•  ì˜ˆì •

```cpp
Future<int> CreateFuture()
{
    // ë¦¬í„´ì„ ë°›ëŠ” Futureë¥¼ ë§Œë“¤ì–´ë³´ì
    co_return 2021;
}
```

```cpp
template<typename T>
class Future
{
public:
    Future(shared_ptr<T> value) : _value(value) { }
    T get() { return *_value; }

private:
    shared_ptr<T> _value;

public:
    struct promise_type
    {
        // ë¦¬í„´ì„ ë°›ì•„ì•¼í•˜ê¸°ì— return_value(T value)ë¥¼ ìƒì„±
        void return_value(T value) { *_ptr = value; }

        // ë‚˜ë¨¸ì§€ëŠ” ê¸°ì¡´ê³¼ ë™ì¼í•˜ë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.
        Future<T> get_return_object() { return Future<T>(_ptr); }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void unhandled_exception() { }

        // ë°ì´í„°
        shared_ptr<T> _ptr = make_shared<T>();
    };
};
```

ğŸ˜º ì‹¤ì œì‚¬ìš©ì€ ì–´ë–»ê²Œ í• ê¹Œ?

```cpp
int main() 
{
    // coroutineê°ì²´ë¥¼ ìƒì„±í•˜ê³  ...
    auto future = CreateFuture();
    /*
        Future<int> CreateFuture()
        {
            co_return 2021;
        }
    */

    // TODO : ë‹¤ë¥¸ê±¸ í•˜ë‹¤...
    // ì´í›„ì— í˜¸ì¶œì´ ê°€ëŠ¥
    cout << future.get() << endl;
}
```

ğŸ˜º ì•ì„œ `co_retur` ë¥¼ ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–»ê²Œ ë³€ê²½í•´ ì£¼ëŠ”ì§€ ë°°ì› ìœ¼ë‹ˆ

```cpp
// co_returnì´ í˜¸ì¶œë˜ë©´ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìƒì„±ë˜ëŠ” ì½”ë“œëŠ” ì•„ë˜ì´ë©° ì„¤ëª…ì„ ë¶™ì´ìë©´
{
    Promise prom; (get_return_object)
    /*
        get_return_object ëŠ”,
        Future<T> get_return_object() { return Future<T>(_ptr); } ì´ê¸°ì—
        Future ê°ì²´ê°€ ìƒì„± ê·¸ë¦¬ê³  _ptr = _valueê°€ ëœë‹¤.
    */

    co_await prom.initial_suspend();
    try
    {
        // ì—¬ê¸°ì— co_return 2021; ê°€ ë“¤ì–´ê°€ê³ 
        // co_return 2021;ëŠ”
            // void return_value(T value) { *_ptr = value; } ê°€ í˜¸ì¶œë¨
            // _ptrì— value(2021)ì´ ë“¤ì–´ê°€ê²Œ ëœë‹¤.
    }
    catch (...)
    {
        prom.unhandled_exception();
    }
    co_await prom.final_suspend();
}
```

ğŸ˜º `co_await prom.initial_suspend()`ì˜ ì„¤ëª…ì„ ìœ„í•´ì„œ co_awaitì˜ ì„¤ëª…ì´ í•„ìš”í•˜ë‹¤

```cpp
// co_await í”Œë¡œìš°(ì•„ë˜ ì½”ë“œëŠ” C++ì½”ë“œê°€ ì•„ë‹ˆë¼ ì˜ì‚¬ì½”ë“œì„ í—·ê°ˆë¦¬ì§€ ë§ê¸°)
{
    // await_ready() : ì¤€ë¹„ê°€ ë˜ì—ˆëŠ”ì§€ ì•ˆë˜ì—ˆëŠ”ì§€ í™•ì¸
    /*
        ì¤€ë¹„ì—¬ë¶€ëŠ”
            std::suspend_never initial_suspend() { return {}; }
            std::suspend_never final_suspend() noexcept { return {}; }
        * std::suspend_never - ë¬´ì¡°ê±´ ë„˜ì–´ê°€ë‹¬ë¼
        * std::suspend_always - ë¬´ì¡°ê±´ ë©ˆì¶°ë‹¬ë¼
    */
    if awaitable.await_ready() returns false;   // await_ready()ê°€ false(ì¤€ë¹„ê°€ ì•ˆë¨)ì¼ ê²½ìš° ì•„ë˜ë¥¼ ì‹¤í–‰
        suspend coroutine
        awaitable.await_suspend(handle) returns:    // coroutineì„ suspend(ì ì‹œë©ˆì¶°ë¼)
            // awaitable.await_suspend(handle)ì˜ ë¦¬í„´í˜•ì´ void, bool, anotherì— ë”°ë¼ì„œ ë³„ë„ ì²˜ë¦¬
            void:
                // ë¦¬í„´ì´ voidì¼ ê²½ìš°
                awaitable.await_suspend(handle);
                coroutine keeps suspended   // coroutineì„ suspendí•´ë‘ê³ 
                return to caller            // í˜¸ì¶œìë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•œë‹¤
            bool:
                bool result = awaitable.await_suspend(handle);
                if (result)
                    coroutine keeps suspended
                    return to caller
                else
                    return awaitable.await_resume()
            another coroutine handle:
                anotherCoroutineHandle = awaitable.await_suspend(handle);
                anotherCoroutineHandle.resume();
                return to caller;
    return awaitable.await_resume();
}
```

---

## co_yield

ğŸ˜º ë‹¤ìŒì€ co_yieldë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ ë³´ì.<br>
ğŸ˜º co_yieldëŠ” ì´ì „ìƒí™©ì„ ê³„ì† ì €ì¥í•˜ë©° **ì •ì§€/ì‹¤í–‰**ì„ ë°˜ë³µí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.

```cpp
Generator<int> GenNumbers(int start = 0, int delta = 1)
{
    int now = start;
    while (true)
    {
        co_yield now; // yield return - ì—¬ê¸°ê¹Œì§€ ëŒê³  ë¦¬í„´ëœë‹¤
        now += delta;
    }
}

//...

auto numbers = GenNumbers(0, 1);
for (int i = 0; i < 20; i++)
{
    numbers.next();
    cout << " " << numbers.get();
}
```

```cpp
template<typename T>
class Generator
{
public:
    struct promise_type;
    using handle_type = coroutine_handle<promise_type>;

    Generator(handle_type handle) : _handle(handle)
    {

    }

    ~Generator()
    {
        if (_handle)
            _handle.destroy();
    }

    T get() { return _handle.promise()._value; }

    bool next()
    {
        _handle.resume();       // ì¤‘ìš”) coroutine ì¬ê°œ
        return !_handle.done();
    }

private:
    handle_type _handle;        // coroutineì˜ handleì„ ê°–ê³ ìˆëŠ”ë‹¤

public:
    struct promise_type
    {
        // Generator(handle_type::from_promise(*this)); ì´ëŸ°ì‹ìœ¼ë¡œ í•¸ë“¤ì„ ë„˜ê¸¸ ìˆ˜ ìˆëŠ”ë° ì´ ë¶€ë¶„ì€ ë°›ì•„ë“¤ì´ì
        Generator<T> get_return_object() { return Generator(handle_type::from_promise(*this)); }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        // co_yieldê°€ í˜¸ì¶œë˜ë©´ yield_valueê°€ í˜¸ì¶œë¨.
        std::suspend_always yield_value(const T value) { _value = value; return {}; }
        std::suspend_always return_void() { return {}; }
        void unhandled_exception() { }
        T _value;
    };
};
```

ğŸ˜º ì´ê±¸ í˜„ì‹¤ì— ë°˜ì˜í•˜ê¸°ëŠ” ì‰½ì§€ëŠ” ì•Šì„ë“¯... ì½”ë“œë¥¼ ì½ëŠ” ìˆ˜ì¤€ì—ì„œ ë³´ì

---

## co_await

ğŸ˜º ë‹¤ìŒì€ co_await

```cpp
Job PrepareJob()
{
    // co_await [Awaitable]
    co_await std::suspend_never();
    
    // ì—¬ê¸°ë„ ë™ì¼í•˜ê²Œ corotine ì˜ì‚¬ì½”ë“œê°€ ì˜¤ê²Œë˜ë©°
    /*
        co_await prom.initial_suspend();
        try
        {
            // std::suspend_never();
        }
        catch (...)
        {
            prom.unhandled_exception();
        }
        co_await prom.final_suspend();
    */
    // ì´ë ‡ê²Œ ëœë‹¤.
}

// ...

auto job = PrepareJob();
job.start();
```

```cpp
class Job
{
public:
    struct promise_type;
    using handle_type = coroutine_handle<promise_type>;

    Job(handle_type handle) : _handle(handle)
    {

    }

    ~Job()
    {
        if (_handle)
            _handle.destroy();
    }

    void start()
    {
        if (_handle)
            _handle.resume();
    }

private:
    handle_type _handle;
    
public:
    struct promise_type
    {
        Job get_return_object() { return Job(handle_type::from_promise(*this)); }
        std::suspend_always initial_suspend() { cout << "Prepare Job" << endl;  return {}; }
        std::suspend_never final_suspend() noexcept { cout << "Do Job" << endl; return {}; }
        std::suspend_never return_void() { return {}; }
        void unhandled_exception() { }
    };
};
```

```cpp
// Example

#include <iostream>
#include <coroutine>

class Generator
{
public:
    struct Promise
    {
		Generator get_return_object()
		{
			return Generator{ std::coroutine_handle<Promise>::from_promise(*this) };
		}
		auto initial_suspend() { return std::suspend_always{}; }
		auto return_void() { return std::suspend_never{}; }
		auto final_suspend() { return std::suspend_always{}; }
		void unhandled_exception() { std::exit(1); }
    };
    using promise_type = Promise;

    std::coroutine_handle<promise_type> coro;

    Generator( std::coroutine_handle<promise_type> c ) : coro(c) {}

    ~Generator() { if ( coro ) coro.destroy();}
};

Generator foo()
{
    std::cout << "Run 1" << std::endl;
    co_await std::suspend_always {};
    std::cout << "Run 2" << std::endl;
}

int main()
{
    foo();
}
```