---
layout: default
title: 5. Coroutine
parent: (C++20)
grand_parent: C++
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º Coroutineì€ ë³´í†µ ì–´ë””ì— ì“°ì¼ê¹Œ?

```cpp
void VeryDifficultFunction()
{
    for(int i = 0; i < 100000; i++)
    {
        //... ë¬´ê±°ìš´ ì‘ì—…ì„ ë°˜ë³µì ìœ¼ë¡œ í•˜ëŠ” í•¨ìˆ˜
    }
}
// ì´ë ‡ê²Œ í•œ ë²ˆ ë¶€ë¥´ê¸°ë„ ë¶€ë‹´ìŠ¤ëŸ¬ìš´ í•¨ìˆ˜ê°€ ì¡´ì¬í•œë‹¤ê³  í• ë•Œ
VeryDifficultFunction();
// ì´ í•¨ìˆ˜ê°€ í•˜ë‚˜ì˜ Threadë¥¼ ì ìœ í•˜ëŠ” ê²ƒì€ ë¶€ë‹´ìŠ¤ëŸ¬ìš´ ì¼ ì¼ìˆ˜ìˆë‹¤.
    // ì—¬ê¸°ì„œ ì•„ì´ë””ì–´ê°€ ë‚˜ì˜¤ëŠ”ë° ë§¤ìš° ë¬´ê±°ìš´ í•¨ìˆ˜ë¥¼ ë‚˜ëˆ ì„œ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤ë©´??
    // 100000ë²ˆì„ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ëŒì•„ì•¼í•˜ëŠ”ë° 1000ë²ˆì”© ë‚˜ëˆ ì„œ ëŒë¦´ìˆ˜ ì—†ë‚˜?
```

<br>

ğŸ˜º ê¸°ì¡´ C++ì—ì„œëŠ” ë¶ˆê°€ëŠ¥! But Coroutine(C++20)ì—ì„œëŠ” ê°€ëŠ¥í•´ì¡Œë‹¤

ğŸ˜¸ ê·¸ëŸ°ë° ì´ëŸ° ê²½ìš°ê°€ ë§ì´ ìˆëŠ”ê°€?? ì¢€ ë” íš¨ìœ¨ì ì¸ ì˜ˆì œëŠ” ì—†ë‚˜?

```cpp
void KillMonster()
{
    /*
    ëª¬ìŠ¤í„° ì²˜ì¹˜ì‹œ ì•„ë˜ì˜ ê³¼ì •ì´ í•„ìš”í•˜ë‹¤
    1. ëª¬ìŠ¤í„° ì²˜ì¹˜
    2. ì•„ì´í…œ íšë“ì‹œ DBì— ì²˜ë¦¬ìš”ì²­ <-- ì—¬ê¸°ê°€ ë§¤ìš° ëŠë¦¼
    3. ì•„ì´í…œ ìƒì„± ë° ì¸ë²¤í† ë¦¬ ì¶”ê°€
    */
    // * ì•„ì´í…œ íšë“ì‹œ DBì— ì²˜ë¦¬ìš”ì²­
    // ì´ ê³¼ì •ì„ Coroutineìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ ì í•˜ëŠ”ë° ìì„¸í•œê²ƒì€ ë’¤ì—ì„œ ì„¤ëª…
}
```

<br>

ğŸ˜º ê·¸ëŸ¼ coroutineì„ ì–´ë–»ê²Œ ì“°ëŠ”ì§€ ì‚´í´ë³´ì.

* coroutineì€ ì•„ë˜ ì„¸ í•¨ìˆ˜ ì¤‘ í•˜ë‚˜ë¼ë„ ì‚¬ìš©í•  ê²½ìš° coroutineì´ ëœë‹¤.
    - `co_return`
    - `co_yield`
    - `co_await`
* í•˜ë‚˜í•˜ë‚˜ ì‚´í´ë³´ìë©´

<br>

## co_return + coroutine ë™ì‘ì„¤ëª…

```cpp
// coroutineìœ¼ë¡œ ë¦¬í„´ì„ í•˜ë©´ coroutineì´ ë ê¹Œ?
void HelloCoroutine()
{
    co_return;  // Error! - coroutine êµ¬ì¡°ì²´ë¥¼ ë¦¬í„´í•´ì•¼í•¨
}
```

<br>

ğŸ˜º ?!?! ë¬´ìŠ¨ì†Œë¦¬ì§€? - ì•„ì§ C++20ì˜ coroutineì´ ê·¸ë¦¬ ì™„ë²½í•˜ì§€ ëª»í•˜ë‹¤. C++20ì—ì„œ ìš”êµ¬í•˜ëŠ” coroutineì˜ í˜•íƒœë¡œ ë§Œë“¤ì–´ì„œ ì‚¬ìš©í•´ì•¼ í•œë‹¤...;

ğŸ˜º ê·¸ëŸ¼ coroutineêµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ ë³´ì

```cpp
#include <coroutine>

// ...

struct CoroutineObject
{
    // * promise ê°ì²´ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•´ì•¼ í•¨
        // * ìš”êµ¬í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ê²½ìš°ëŠ” co_return, co_yield, co_awaitì— ë”°ë¼ ë‹¤ë¥´ê¸°ì— ê·¸ë•Œê·¸ë•Œ ì—ëŸ¬ëœ¨ëŠ”ê²ƒì„ ë³´ê³  ë§Œë“¤ë©´ ëœë‹¤.
        // - ê¸°ë³¸ ìƒì„±ì : promise ê°ì²´ëŠ” ê¸°ë³¸ ìƒì„±ìë¡œ ë§Œë“¤ì–´ì§ˆ ìˆ˜ ìˆì–´ì•¼ í•¨
        // - get_return_object : ì½”ë£¨í‹´ ê°ì²´ë¥¼ ë°˜í™˜ (resumable object)
        // - return_value(val) : co_return valì— ì˜í•´ í˜¸ì¶œë¨ (ì½”ë£¨í‹´ì´ ì˜êµ¬ì ìœ¼ë¡œ ëë‚˜ì§€ ì•Šìœ¼ë©´ ì—†ì–´ë„ ë¨)
        // - return_void() : co_returnì— ì˜í•´ í˜¸ì¶œë¨ (ì½”ë£¨í‹´ì´ ì˜êµ¬ì ìœ¼ë¡œ ëë‚˜ì§€ ì•Šìœ¼ë©´ ì—†ì–´ë„ ë¨)
        // - yield_value(val) : co_yieldì— ì˜í•´ í˜¸ì¶œë¨
        // - initial_suspend() : ì½”ë£¨í‹´ì´ ì‹¤í–‰ ì „ì— ì¤‘ë‹¨/ì—°ê¸°ë  ìˆ˜ ìˆëŠ”ì§€
        // - final_suspend() : ì½”ë£¨í‹´ì´ ì¢…ë£Œ ì „ì— ì¤‘ë‹¨/ì—°ê¸°ë  ìˆ˜ ìˆëŠ”ì§€
        // - unhandled_exception() : ì˜ˆì™¸ ì²˜ë¦¬ì‹œ í˜¸ì¶œë¨
    struct promise_type
    {
        // ì´ë ‡ê²Œ í•˜ë©´ ì—ëŸ¬ì—†ì´ coroutineì‚¬ìš©ì´ ê°€ëŠ¥.. ì—„ì²­ë‚˜êµ¬ë§Œ..
        CoroutineObject get_return_object() { return {}; }
        std::suspend_never initial_suspend() const noexcept { return {}; }
        std::suspend_never final_suspend() const noexcept { return {}; }
        void return_void() { }
        void unhandled_exception() { }
    };
};

// ...

CoroutineObject HelloCoroutine()
{
    co_return;
}
```

<br>

ğŸ˜º ê¶ê¸ˆí•œ ì ? `co_return`ì„ ì¶”ê°€ì‹œ ì»´íŒŒì¼ëŸ¬ëŠ” ì–´ë–¤ì½”ë“œë¥¼ ì¶”ê°€í• ê¹Œ??

```cpp
CoroutineObject HelloCoroutine()
{
    co_return;
}

/*{
    // promiseë¥¼ ìƒì„±í›„
    Promise prom; (get_return_object)   // get_return_objectë¥¼ í˜¸ì¶œí•˜ê²Œ ëœë‹¤.
    // ì´í›„ promiseì˜ initial_suspendë¥¼ í˜¸ì¶œ ë“±ë“±
    co_await prom.initial_suspend();
    try
    {
        // co_return, co_yield, co_awaitë¥¼ í¬í•¨í•˜ëŠ” ì½”ë“œ
    }
    catch (...)
    {
        prom.unhandled_exception();
    }
    co_await prom.final_suspend();
    // ë³´ë©´ ëª¨ë‘ CoroutineObjectë¥¼ ìƒì„±í•˜ë©´ ë§Œë“¤ì—ˆë˜ í•¨ìˆ˜ë“¤ì´ë‹¤.
}*/
```

<br>

ğŸ˜º ê·¸ëŸ°ë° ì½”ë“œëŠ” ë§ì´ ì ì—ˆëŠ”ë° ë­˜í•œê±´ì§€ëŠ” ì „í˜€ëª¨ë¥´ê² ë‹¤. ì•„ì£¼ ì •ìƒì„ ì´ì œ ìœ„ ì½”ë“œì— ê¸°ëŠ¥ì„ í•˜ë‚˜í•˜ë‚˜ ì¶”ê°€í•  ì˜ˆì •

```cpp
Future<int> CreateFuture()
{
    // ë¦¬í„´ì„ ë°›ëŠ” Futureë¥¼ ë§Œë“¤ì–´ë³´ì
    co_return 2021;
}
```

```cpp
template<typename T>
class Future
{
public:
    Future(shared_ptr<T> value) : _value(value) { }
    T get() { return *_value; }

private:
    shared_ptr<T> _value;

public:
    struct promise_type
    {
        // ë¦¬í„´ì„ ë°›ì•„ì•¼í•˜ê¸°ì— return_value(T value)ë¥¼ ìƒì„±
        void return_value(T value) { *_ptr = value; }

        // ë‚˜ë¨¸ì§€ëŠ” ê¸°ì¡´ê³¼ ë™ì¼í•˜ë‹¤ê³  ë³¼ ìˆ˜ ìˆë‹¤.
        Future<T> get_return_object() { return Future<T>(_ptr); }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        void unhandled_exception() { }

        // ë°ì´í„°
        shared_ptr<T> _ptr = make_shared<T>();
    };
};
```

<br>

ğŸ˜º ì‹¤ì œì‚¬ìš©ì€ ì–´ë–»ê²Œ í• ê¹Œ?

```cpp
// coroutineê°ì²´ë¥¼ ìƒì„±í•˜ê³  ...
auto future = CreateFuture();
// TODO : ë‹¤ë¥¸ê±¸ í•˜ë‹¤...
// ì´í›„ì— í˜¸ì¶œì´ ê°€ëŠ¥
cout << future.get() << endl;
```

<br>

ğŸ˜º ì¡°ê¸ˆ ë” ê¹Šì´ ì‚´í´ë³´ìë©´...

```cpp
// coroutine ê°ì²´ ë‚´ë¶€ëŠ” ì•„ë˜ì™€ ê°™ê³ ..
struct promise_type
{
    void return_value(T value) { *_ptr = value; }
    Future<T> get_return_object() { return Future<T>(_ptr); }
    std::suspend_never initial_suspend() { return {}; }
    std::suspend_never final_suspend() noexcept { return {}; }
    void unhandled_exception() { }
}
```

```cpp
// co_returnì´ í˜¸ì¶œë˜ë©´ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìƒì„±ë˜ëŠ” ì½”ë“œëŠ” ì•„ë˜ì´ë©° ì„¤ëª…ì„ ë¶™ì´ìë©´
{
    Promise prom; (get_return_object)
    /*
        coroutineê°ì²´ê°€ ìƒì„±ì‹œ shared_ptr<T> _ptr = make_shared<T>();ë¡œ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ìƒì„±
    */
    // ë‹¤ìŒì€ 
    // co_await prom.initial_suspend() ë¶€ë¶„
    // ì„¤ëª…ì´ ê¸¸ê¸°ì— ì•„ë˜ë¥¼ ì°¸ì¡°
    
    co_await prom.initial_suspend();
    try
    {
        // void return_value(T value) { *_ptr = value; } ê°€ í˜¸ì¶œë¨
        // _ptrì— value(2021)ì´ ë“¤ì–´ê°€ê²Œ ëœë‹¤.
    }
    catch (...)
    {
        prom.unhandled_exception();
    }
    co_await prom.final_suspend();
}
```

<br>

ğŸ˜º `co_await prom.initial_suspend()`ì˜ ì„¤ëª…ì„ ìœ„í•´ì„œ co_awaitì˜ ì„¤ëª…ì´ í•„ìš”í•˜ë‹¤

```cpp
// co_await í”Œë¡œìš°(ì•„ë˜ ì½”ë“œëŠ” C++ì½”ë“œê°€ ì•„ë‹ˆë¼ ì˜ì‚¬ì½”ë“œì„ í—·ê°ˆë¦¬ì§€ ë§ê¸°)
{
    // await_ready() : ì¤€ë¹„ê°€ ë˜ì—ˆëŠ”ì§€ ì•ˆë˜ì—ˆëŠ”ì§€ í™•ì¸
    /*
        ì¤€ë¹„ì—¬ë¶€ëŠ”
            std::suspend_never initial_suspend() { return {}; }
            std::suspend_never final_suspend() noexcept { return {}; }
        * std::suspend_never - ë¬´ì¡°ê±´ ë„˜ì–´ê°€ë‹¬ë¼
        * std::suspend_always - ë¬´ì¡°ê±´ ë©ˆì¶°ë‹¬ë¼
    */
    if awaitable.await_ready() returns false;   // await_ready()ê°€ false(ì¤€ë¹„ê°€ ì•ˆë¨)ì¼ ê²½ìš° ì•„ë˜ë¥¼ ì‹¤í–‰
        suspend coroutine
        awaitable.await_suspend(handle) returns:    // coroutineì„ suspend(ì ì‹œë©ˆì¶°ë¼)
            // awaitable.await_suspend(handle)ì˜ ë¦¬í„´í˜•ì´ void, bool, anotherì— ë”°ë¼ì„œ ë³„ë„ ì²˜ë¦¬
            void:
                // ë¦¬í„´ì´ voidì¼ ê²½ìš°
                awaitable.await_suspend(handle);
                coroutine keeps suspended   // coroutineì„ suspendí•´ë‘ê³ 
                return to caller            // í˜¸ì¶œìë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•œë‹¤
            bool:
                bool result = awaitable.await_suspend(handle);
                if (result)
                    coroutine keeps suspended
                    return to caller
                else
                    return awaitable.await_resume()
            another coroutine handle:
                anotherCoroutineHandle = awaitable.await_suspend(handle);
                anotherCoroutineHandle.resume();
                return to caller;
    return awaitable.await_resume();
}
```

<br>

## co_yield

ğŸ˜º ë‹¤ìŒì€ co_yieldë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ ë³´ì

ğŸ˜º co_yieldëŠ” ì´ì „ìƒí™©ì„ ê³„ì† ì €ì¥í•˜ë©° ì •ì§€/ì‹¤í–‰ì„ ë°˜ë³µí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤

```cpp
Generator<int> GenNumbers(int start = 0, int delta = 1)
{
    int now = start;
    while (true)
    {
        co_yield now; // yield return - ì—¬ê¸°ê¹Œì§€ ëŒê³  ë¦¬í„´ëœë‹¤
        now += delta;
    }
}

//...

auto numbers = GenNumbers(0, 1);
for (int i = 0; i < 20; i++)
{
    numbers.next();
    cout << " " << numbers.get();
}
```

```cpp
template<typename T>
class Generator
{
public:
    struct promise_type;
    using handle_type = coroutine_handle<promise_type>;

    Generator(handle_type handle) : _handle(handle)
    {

    }

    ~Generator()
    {
        if (_handle)
            _handle.destroy();
    }

    T get() { return _handle.promise()._value; }

    bool next()
    {
        _handle.resume();       // ì¤‘ìš”) coroutine ì¬ê°œ
        return !_handle.done();
    }

private:
    handle_type _handle;        // coroutineì˜ handleì„ ê°–ê³ ìˆëŠ”ë‹¤

public:
    struct promise_type
    {
        // Generator(handle_type::from_promise(*this)); ì´ëŸ°ì‹ìœ¼ë¡œ í•¸ë“¤ì„ ë„˜ê¸¸ ìˆ˜ ìˆëŠ”ë° ì´ ë¶€ë¶„ì€ ë°›ì•„ë“¤ì´ì
        Generator<T> get_return_object() { return Generator(handle_type::from_promise(*this)); }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        // co_yieldê°€ í˜¸ì¶œë˜ë©´ yield_valueê°€ í˜¸ì¶œë¨.
        std::suspend_always yield_value(const T value) { _value = value; return {}; }
        std::suspend_always return_void() { return {}; }
        void unhandled_exception() { }
        T _value;
    };
};
```

ğŸ˜º ì´ê±¸ í˜„ì‹¤ì— ë°˜ì˜í•˜ê¸°ëŠ” ì‰½ì§€ëŠ” ì•Šì„ë“¯... ì½”ë“œë¥¼ ì½ëŠ” ìˆ˜ì¤€ì—ì„œ ë³´ì

## co_await

ğŸ˜º ë‹¤ìŒì€ co_await

```cpp
Job PrepareJob()
{
    // co_await [Awaitable]
    co_await std::suspend_never();
    // ì—¬ê¸°ë„ ë™ì¼í•˜ê²Œ corotine ì˜ì‚¬ì½”ë“œê°€ ì˜¤ê²Œë˜ë©°
    /*
    co_await prom.initial_suspend();
    try
    {
        // std::suspend_never();
    }
    catch (...)
    {
        prom.unhandled_exception();
    }
    co_await prom.final_suspend();
    */
    // ì´ë ‡ê²Œ ëœë‹¤.
}
// ...
auto job = PrepareJob();
job.start();
```

```cpp
class Job
{
public:
    struct promise_type;
    using handle_type = coroutine_handle<promise_type>;

    Job(handle_type handle) : _handle(handle)
    {

    }

    ~Job()
    {
        if (_handle)
            _handle.destroy();
    }

    void start()
    {
        if (_handle)
            _handle.resume();
    }

private:
    handle_type _handle;
    
public:
    struct promise_type
    {
        Job get_return_object() { return Job(handle_type::from_promise(*this)); }
        std::suspend_always initial_suspend() { cout << "Prepare Job" << endl;  return {}; }
        std::suspend_never final_suspend() noexcept { cout << "Do Job" << endl; return {}; }
        std::suspend_never return_void() { return {}; }
        void unhandled_exception() { }
    };
};
```
