---
layout: default
title: "4. Constant Buffer"
parent: (DirectX)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ë­˜ í•˜ê³ ì í•˜ë‚˜?

ğŸ± ê¸°ì¡´ì— ê·¸ë¦° ì‚¼ê°í˜•ì„ ì´ë™, ìƒ‰ìƒì„ í•´ë³´ê³ ì í•œë‹¤.

ğŸ˜º ì´ë™, ìƒ‰ìƒë³€ê²½ì„ ìœ„í•´ì„œ ì‰ì´ë” ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•  ìƒìˆ˜ë¥¼ ë„˜ê²¨ ë‚´ê°€ ì›í•˜ëŠ” ì´ë™, ìƒ‰ìƒë³€ê²½ì„ í•˜ê³ ìí•˜ëŠ”ë°

ğŸ˜º ì‰ì´ë”ëŠ” GPUì—ì„œ ìˆ˜í–‰í•˜ëŠ” ëª…ë ¹ì´ê¸°ì— ìƒìˆ˜(ë³€ìˆ˜)ìì²´ë¥¼ ë„˜ê¸°ëŠ” ì¼ì´ ê·¸ë¦¬ ì‰½ì§€ëŠ” ì•Šë‹¤

```
// ...

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
    output.pos += ???;		// ì—¬ê¸°ë¥¼ ë³€ê²½í•  ìˆ˜ ìˆë‹¤ë©´??
    output.color = input.color;
    output.color += ???;

    return output;
}

// ...
```

<br>

---

## ConstantBuffer

ğŸ˜º ìš°ì„  ì§€ë‚œ ì¥ì—ì„œ ì‰ì´ë”© íŒŒì´í”„ë¼ì¸ì„ RootSignatureì—ì„œ ê´€ë¦¬í•˜ê³  RootSignatureë¥¼ í†µí•´ì„œ ì‰ì´ë”© íŒŒì´í”„ë¼ì¸ ì¤‘ íŠ¹ì •ë‹¨ê³„ì—ì„œ ìƒìˆ˜ë¥¼ ë„£ì„ ìˆ˜ ìˆë‹¤.

ğŸ˜º ë­ ëŒ€ëµ ì‚¬ìš©ì€ ì•„ë˜ì™€ ê°™ì´í•œë‹¤.

```
// cbuffer(constant buffer)ë¥¼ ì‚¬ìš©í• êº¼ê³  register b0ë¥¼ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤
// ì´ë¦„ì€ offset0ë¡œ í•´ì£¼ì„¸ìš”
cbuffer TEST_B0 : register(b0)
{
    float4 offset0;
};

cbuffer TEST_B1 : register(b1)
{
    float4 offset1;
};

// ...

// offset0, 1ì€ ì´ë ‡ê²Œ ì“°ê² ë‹¤.
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
    output.pos += offset0;
    output.color = input.color;
    output.color += offset1;

    return output;
}
```

```cpp
void RootSignature::Init(ComPtr<ID3D12Device> device) 
{ 
	// ìš°ì„ ì€ ë‘ ê°œì˜ ê°’ì„ ë„˜ê¸´ë‹¤ê³  ì•Œë ¤ì¤˜ì•¼í•œë‹¤. 
	CD3DX12_ROOT_PARAMETER param[2]; 
	param[0].InitAsConstantBufferView(0);  
	// 0ë²ˆ -> b0 -> CBV(Constant Buffer View), CBVëŠ” ë ˆì§€ìŠ¤í„°ì´ë¦„ì´ bë¡œ ì‹œì‘í•¨ 

	param[1].InitAsConstantBufferView(1); // 1ë²ˆ -> b1 -> CBV 

	D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(2, param);

	// ...
```

<br>

ğŸ± ì°¸ê³ ë¡œ ìœ„ ë°©ì‹ì€ RootSignatureì— constant(ìƒìˆ˜)ë¥¼ ë„˜ê¸°ëŠ” ë°©ì‹ì´ê³  Buffer View(ì¼ì¢…ì˜ í¬ì¸í„°)ë¡œ ë„˜ê¸¸ìˆ˜ ìˆê³  Descriptor tables í…Œì´ë¸”(ë°°ì—´) í˜•íƒœë¡œ ë„˜ê¸¸ìˆ˜ë„ ìˆë‹¤. [ì°¸ê³  ğŸŒ](https://docs.microsoft.com/en-us/windows/win32/direct3d12/example-root-signatures)

```cpp
void CommandQueue::RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect) 
{ 
	// ... 
	// RootSignatureê°€ ì‚¬ìš©ë˜ê²Œ í•´ë‹¬ë¼ê³  ì „ë‹¬ 
	_cmdList->SetGraphicsRootSignature(ROOT_SIGNATURE.Get());
```

<Br>

ğŸ˜º ì—¬ê¸°ê¹Œì§€í•˜ë©´ RootSignatureë¥¼ í†µí•´ ë³€ìˆ˜ë¥¼ ë„˜ê¸°ê³  ì‰ì´ë”ì—ì„œ ê·¸ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ”ë° ê¹Œì§„ ëëŠ”ë°

ğŸ˜º ê°€ì¥ì¤‘ìš”í•œ ë³€ìˆ˜ë¥¼ ì–´ë–¤ ê°’ìœ¼ë¡œ í• ë‹¹í•˜ëŠ”ì§€ë¥¼ ì–´ë–»ê²Œ í• ì§€ê°€ ë‚˜ì˜¤ì§€ ì•Šì•˜ë‹¤.

ğŸ˜º ëŒ€ëµ ì´ë ‡ê²Œ ì§„í–‰ëœë‹¤.

1. ë°ì´í„°ë¥¼ ë‹´ì„ GPU ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•œë‹¤.
2. CPUì˜ ë°ì´í„°ë¥¼ GPU ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë‹´ëŠ”ë‹¤
3. GPU ë ˆì§€ìŠ¤í„°ê°€ GPU ë©”ëª¨ë¦¬ì—ì„œ ì½ì–´ì˜¨ë‹¤
4. ì½ì–´ì˜¨ ë°ì´í„°ë¥¼ ì‰ì´ë”© ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•œë‹¤.

---

### ë°ì´í„°ë¥¼ ë‹´ì„ GPU ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•´ ë³´ì

```cpp
// ConstantBufferë¼ëŠ” í´ë˜ìŠ¤ì—ì„œ ë‹´ë‹¹
void ConstantBuffer::Init(uint32 size, uint32 count) 
{ 
	// ìƒìˆ˜ ë²„í¼ëŠ” 256 ë°”ì´íŠ¸ ë°°ìˆ˜ë¡œ ë§Œë“¤ì–´ì•¼ í•œë‹¤ 
	// 0 256 512 768 
	_elementSize = (size + 255) & ~255; 
	// & ~255 í•˜ìœ„ 8bits ì •ë³´ë¥¼ ëª¨ë‘ 0ìœ¼ë¡œ ë§Œë“¤ê¸°ì— 256ì˜ ë°°ìˆ˜ê°€ ëœë‹¤.
	_elementCount = count; 
	CreateBuffer(); 
}
```

```cpp
void ConstantBuffer::CreateBuffer() 
{ 
	uint32 bufferSize = _elementSize * _elementCount; 
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD); 
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);


   // ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•´ ì£¼ì„¸ìš” 
	DEVICE->CreateCommittedResource( 
		&heapProperty, 
		D3D12_HEAP_FLAG_NONE, 
		&desc, 
		D3D12_RESOURCE_STATE_GENERIC_READ, 
		nullptr, 
		IID_PPV_ARGS(&_cbvBuffer)); 

	_cbvBuffer->Map(0, nullptr, reinterpret_cast<void**>(&_mappedBuffer)); 
	// ì—¬ê¸°ê¹Œì§€í•˜ë©´ _mappedBufferë¥¼ í†µí•´ GPU ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë„£ì„ ìˆ˜ ìˆë‹¤
	// We do not need to unmap until we are done with the resource.  However, we must not write to 
	// the resource while it is in use by the GPU (so we must use synchronization techniques). 

	// ì—¬ê¸°ì„œ ì§ˆë¬¸? CPUê°€ ë°ì´í„°ë¥¼ GPUì— ì“¸ë•Œ
	// GPUê°€ ë°ì´í„°ë¥¼ ì½ì–´ê°€ ë²„ë¦¬ë©´???
	// ì ˆëŒ€ ê·¸ëŸ´ì¼ì´ì—†ìŒ -> fenceë¡œ í˜„ì¬ GPUì‘ì—…ì´ ë‹¤ ëë‚˜ë©´ ë‹¤ìŒì‘ì—…ì„ CPUì—ì„œ í•˜ë„ë¡ ê°•ì œí•˜ê²Œ ë§Œë“¤ì–´ë‘ .
}
```

### GPU ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë‹´ëŠ”ë‹¤

### GPU ë ˆì§€ìŠ¤í„°ê°€ GPU ë©”ëª¨ë¦¬ì—ì„œ ì½ì–´ì™€ ì‰ì´ë”© ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•œë‹¤.

```cpp
void Mesh::Render() 
{ 
	// ... 

	// 1) Bufferì—ë‹¤ê°€ ë°ì´í„° ì„¸íŒ… 
	// 2) Bufferì˜ ì£¼ì†Œë¥¼ registerì—ë‹¤ê°€ ì „ì†¡ 
	GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform)); 
	GEngine->GetCB()->PushData(1, &_transform, sizeof(_transform)); 

        // ...
}
```

```cpp
void ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size) 
{ 
	assert(_currentIndex < _elementSize);

	// 2. GPU ë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë‹´ëŠ”ë‹¤
	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size); 
	D3D12_GPU_VIRTUAL_ADDRESS address = GetGpuVirtualAddress(_currentIndex);

    /*
        D3D12_GPU_VIRTUAL_ADDRESS ConstantBuffer::GetGpuVirtualAddress(uint32 index)
        {
            D3D12_GPU_VIRTUAL_ADDRESS objCBAddress = _cbvBuffer->GetGPUVirtualAddress();
            objCBAddress += index * _elementSize;
            return objCBAddress;
        }
    */

	// 3. GPU ë ˆì§€ìŠ¤í„°ê°€ GPU ë©”ëª¨ë¦¬ì—ì„œ ì½ì–´ì™€ ì‰ì´ë”© ë‹¨ê³„ì—ì„œ ì‚¬ìš©í•œë‹¤. 
	// ì»¤ë©˜ë“œ ë¦¬ìŠ¤íŠ¸ì— ë“±ë¡í•´ GPU Registerê°€ ì½ì–´ê°€ë„ë¡ ëª…ë ¹
	CMD_LIST->SetGraphicsRootConstantBufferView(rootParamIndex, address); 
	_currentIndex++; 
}
```

---

## ì£¼ì˜ì‚¬í•­

ğŸ± êµ¬í˜„ì¤‘ ì´í•´ê°€ ë˜ì§€ ì•ŠëŠ” ë¶€ë¶„ì´ ìˆì„ ê²ƒì´ë‹¤.

ğŸ˜º ë©”ëª¨ë¦¬ ê³µê°„í• ë‹¹ì˜ ë¶€ë¶„ì¸ë° ì‚¬ìš©ë  ë©”ëª¨ë¦¬ë³´ë‹¤ GPUê³µê°„ì„ ë” ë§ì´ í• ë‹¹í•œë‹¤. 

ğŸ˜º ì´ëŸ° í• ë‹¹ì„ í•˜ëŠ” ì´ìœ ëŠ” CPU->GPU ë©”ëª¨ë¦¬ ë³µì‚¬ëŠ” ì¦‰ì‹œ ì¼ì–´ë‚˜ê³  ë ˆì§€ìŠ¤í„°ê°€ GPUë©”ëª¨ë¦¬ë¥¼ ì½ì–´ê°€ëŠ” ë¶€ë¶„ì€ íì— ì˜í•´ ë™ì‘í•˜ê¸°ì— ì¦‰ì‹œ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤

ğŸ˜º ê¼­ ë ˆì§€ìŠ¤í„°ì— ë°ì´í„°ë¥¼ ì“¸ë•Œì˜ ë¬¸ì œëŠ” ì•„ë‹ˆê³ , ì»¤ë©˜ë“œë¦¬ìŠ¤íŠ¸(cmdlist)ë¥¼ ì“¸ë•Œ ê³µí†µì ìœ¼ë¡œ ë°œìƒí•˜ëŠ” ì£¼ì˜ì‚¬í•­ì´ë‹¤.

```cpp
void ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size) 
{ 
	assert(_currentIndex < _elementSize);
	// ë©”ëª¨ë¦¬ì˜ ë³µì‚¬ëŠ” ì¦‰ì‹œ ì¼ì–´ë‚˜ëŠ” ë¶€ë¶„ì´ê³  
	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size); 
	D3D12_GPU_VIRTUAL_ADDRESS address = GetGpuVirtualAddress(_currentIndex);


	// ë ˆì§€ìŠ¤í„°ì— ì£¼ì†Œê°’ì„ ì „ë‹¬í•˜ëŠ”ê±´ queueì— ì˜í•´ ë‚˜ì¤‘ì— ì¼ì–´ë‚˜ëŠ” ë¶€ë¶„
	CMD_LIST->SetGraphicsRootConstantBufferView(rootParamIndex, address); 
	_currentIndex++; 
}
```

<br>

ğŸ˜º ê·¸ëŸ¼ ë³µì‚¬ëŠ” ì¼ì–´ë‚¬ëŠ”ë° queueì— ëª…ë ¹ì´ ìŒ“ì—¬ ë‚´ê°€ ì›í•˜ëŠ” ì‹œì ì˜ ë°ì´í„°ë¥¼ ëª» ê°€ì ¸ì˜¤ëŠ” ê²½ìš°ê°€ ì‹œì°¨ë•Œë¬¸ì— ë°œìƒí• ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ?

ğŸ˜º ë²„í¼ë¥¼ ì—¬ëŸ¬ê°œë§Œë“¤ì–´ì„œ ì´ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼í•œë‹¤.

```cpp
void ConstantBuffer::CreateBuffer()  
{  
	uint32 bufferSize = _elementSize * _elementCount; 
	// ë²„í¼ì‚¬ì´ì¦ˆë¥¼ ì‚¬ìš©í•˜ëŠ” ë ˆì§€ìŠ¤í„° countë§Œí¼ ì¡ìŒ 
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);  
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);
```

---

## ê²°ê³¼ì¶œë ¥

```cpp
void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();

	{
		Transform t;
		t.offset = Vec4(0.75f, 0.f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->Render();
	}

	{
		Transform t;
		t.offset = Vec4(0.f, 0.75f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->Render();
	}

	GEngine->RenderEnd();
}
```

<br>

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-4-1.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>