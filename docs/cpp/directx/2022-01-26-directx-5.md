---
layout: default
title: "5. Root Signature"
parent: (DirectX)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Constant Bufferë¥¼ ë°°ì—´ì˜ í˜•íƒœë¡œ ì‚¬ìš©í•´ ë³´ì.

```cpp
// EnginePch.h

// ...

enum class CBV_REGISTER
{
	// ë°ì´í„°ë¥¼ ë„£ëŠ”ë° ì‚¬ìš©í•  ë ˆì§€ìŠ¤í„°
	b0,
	b1,
	b2,
	b3,
	b4,

	END // ëª‡ê°œì¸ì§€ ê°œìˆ˜ë¥¼ ë¦¬í„´ë°›ìŒ
};

enum
{
	SWAP_CHAIN_BUFFER_COUNT = 2,
	CBV_REGISTER_COUNT = CBV_REGISTER::END,
	REGISTER_COUNT = CBV_REGISTER::END,
};

// ...
```

```cpp
void RootSignature::Init(ComPtr<ID3D12Device> device)
{
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 
								CBV_REGISTER_COUNT, // 5 (b0~b4)
								0),
		 // GPUë ˆì§€ìŠ¤í„° ê³µê°„ì— b0~b4 ë¥¼ ì“¸ ì˜ˆì •

		 // CD3DX12_DESCRIPTOR_RANGEë¥¼ êµ³ì´ ë°°ì—´(ranges[])ë¡œ ë§Œë“¤ì–´ì•¼í•˜ë‚˜??
		 // ì´í›„ì— ë‹¤ë¥¸ ë ˆì§€ìŠ¤í„°ì‚¬ìš©ì‹œì— ê°„ë‹¨íˆ CD3DX12_DESCRIPTOR_RANGEë§Œ ì¶”ê°€í•´ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•¨.
         // Ex) ì¶”ê°€í•˜ê³ ì í•œë‹¤ë©´
            // CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 
			//					CBV_REGISTER_COUNT, // 5 (b0~b4)
			//					0)
            // ë§Œ ì¶”ê°€í•˜ë©´ ëœë‹¤.
	};

	CD3DX12_ROOT_PARAMETER param[1];
	param[0].InitAsDescriptorTable(_countof(ranges), ranges);

	// ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„ë¼ëŠ” ê²ƒì„ ì˜ë¯¸
	D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(_countof(param), param);
	sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	// ...
}
```

```cpp
class ConstantBuffer
{
    // ...

    // ConstantBuffer DescritionHeapì˜ ì£¼ì†Œ
        // ConstantBuffer DescritionHeap - Descriptorê°€ View(Handle)ì´ë¼ í–ˆë‹¤ ì§€ê¸ˆì€ Bufferë¥¼ ë§Œë“œëŠ”ê²Œ ì•„ë‹ˆë¼ Bufferë¥¼ ì»¨íŠ¸ë¡¤í•  View(Handle)ì„ ë§Œë“œëŠ”ê³¼ì •ì„ì„ ê¸°ì–µ.
	ComPtr<ID3D12DescriptorHeap>		_cbvHeap;

    // ConstantBuffer DescritionHeapì˜ ì‹œì‘ì£¼ì†Œ != ConstantBuffer DescritionHeapì˜ ì£¼ì†Œ(GPUë§ˆë‹¤ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)
	D3D12_CPU_DESCRIPTOR_HANDLE			_cpuHandleBegin = {};

    // DescritionHeapì˜ ì‚¬ì´ì¦ˆ
	uint32								_handleIncrementSize = 0;
```

<br>

ğŸ˜º ê¸°ì¡´ ì½”ë“œ(Constant Buffer)ì™€ ì°¨ì´ì ì€ Constant Buffer Viewë¥¼ ì§ì ‘ paramì— ë„£ëŠ”ì§€ í˜¹ì€ DescriptorTable(View Table)í˜•íƒœë¡œ ë„£ëŠ”ì§€ì˜ ì°¨ì´ë‹¤. Constant Bufferë¥¼ ë°°ì—´ì˜ í˜•íƒœë¡œ ì“°ê¸°ìœ„í•´ì„  Descritor Tableí˜•íƒœë¡œ ë„£ì–´ì•¼ í•œë‹¤.

```cpp
void ConstantBuffer::Init(uint32 size, uint32 count)
{
	// ìƒìˆ˜ ë²„í¼ëŠ” 256 ë°”ì´íŠ¸ ë°°ìˆ˜ë¡œ ë§Œë“¤ì–´ì•¼ í•œë‹¤
	// 0 256 512 768
	_elementSize = (size + 255) & ~255;
	_elementCount = count;

	CreateBuffer();
	CreateView();
}

// GPUì— ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ëŠ” ë°©ë²•ì€ ê¸°ì¡´ê³¼ ë™ì¼í•˜ë©°
void ConstantBuffer::CreateBuffer()
{
	uint32 bufferSize = _elementSize * _elementCount;
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

	// ë²„í¼ë¥¼ í• ë‹¹í•´ ë‹¬ë¼.
	DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&_cbvBuffer));

	// ì´ ë²„í¼ë¥¼ GPUì™€ í†µì‹ í•˜ëŠ”ë° ì“¸ ê²ƒì´ë‹¤ ì„ ì–¸
	_cbvBuffer->Map(0, nullptr, reinterpret_cast<void**>(&_mappedBuffer));
	// We do not need to unmap until we are done with the resource.  However, we must not write to
	// the resource while it is in use by the GPU (so we must use synchronization techniques).
}
```

```cpp
// ì´ ViewëŠ” ìœ„ì—ì„œ í• ë‹¹í•œ Tableì„ ì»¨íŠ¸ë¡¤í•˜ê¸° ìœ„í•œ View(í•¸ë“¤)ì´ë‹¤.

void ConstantBuffer::CreateView()
{
	D3D12_DESCRIPTOR_HEAP_DESC cbvDesc = {};
	cbvDesc.NumDescriptors = _elementCount;
	cbvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	cbvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	DEVICE->CreateDescriptorHeap(&cbvDesc, IID_PPV_ARGS(&_cbvHeap));

	// Viewì˜ ì‹œì‘ì£¼ì†Œë¥¼ ê°–ê³ ìˆê³ 
	_cpuHandleBegin = _cbvHeap->GetCPUDescriptorHandleForHeapStart();

	// Viewì˜ ì£¼ì†Œ í¬ê¸°ë¥¼ ì•Œë©´ ëª¨ë“  Viewì— ì ‘ê·¼ì´ ê°€ëŠ¥(ì‹œì‘ì£¼ì†Œ + Viewì£¼ì†Œí¬ê¸° * i)
	// Viewë©´ HANDLEì¸ë° í•­ìƒ ì£¼ì†Œì˜ í¬ê¸°ëŠ” ê°™ì€ê±° ì•„ë‹˜??? 
        // -> Nope! ê·¸ë˜í”½ ì¹´ë“œì— ë”°ë¼ ì£¼ì†Œì˜ í¬ê¸°ê°€ ë‹¬ë¼ì§ˆìˆ˜ ìˆê¸°ì— êµ¬í•´ì˜¤ëŠ”ê²Œ ë§ìŒ.
	_handleIncrementSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

	for (uint32 i = 0; i < _elementCount; ++i)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle = GetCpuHandle(i); // (ì‹œì‘ì£¼ì†Œ + Viewì£¼ì†Œí¬ê¸° * i)

		D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = {};
		cbvDesc.BufferLocation = _cbvBuffer->GetGPUVirtualAddress() + static_cast<uint64>(_elementSize) * i;
		cbvDesc.SizeInBytes = _elementSize;   // CB size is required to be 256-byte aligned.

		DEVICE->CreateConstantBufferView(&cbvDesc, cbvHandle);
	}
}
```

```cpp
D3D12_CPU_DESCRIPTOR_HANDLE ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size)
{
	assert(_currentIndex < _elementSize);

	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
	
	_currentIndex++;

	return cpuHandle;
}
```

<Br>

ğŸ˜º ì—¬ê¸°ê¹Œì§€í•˜ë©´ GPUì— ë©”ëª¨ë¦¬ê³µê°„ì„ í• ë‹¹í•œê±°ê¹Œì§€ëŠ” ëë‚œë‹¤. ì´ì œ í• ë‹¹ëœ GPUë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë„£ê³ , ë‹¤ì‹œ ë ˆì§€ìŠ¤í„°ë¡œ ë³´ë‚´ëŠ”ê²ƒì„ í™•ì¸í•˜ë©´ ë

---

## TableDesciptorHeap

ğŸ± ë˜ Descriptor??? ìœ„ì—ì„œ GPU Buffer Descriptor(View)ë¥¼ ë§Œë“¤ì—ˆì§€ ì•Šë‚˜?

ğŸ˜º ë§ìŒ ìœ„ì—ì„œ ë§Œë“  DescripotrHeapì€ CPUì—ì„œ ë°”ë¡œ ë³µì‚¬ê°€ ì¼ì–´ë‚˜ëŠ” Bufferì´ê³  TableDescriptorHeapì€ ë ˆì§€ìŠ¤í„°ì— ì˜¬ë¦¬ê¸° ì§ì „ì˜ Bufferì´ë‹¤. ë”°ë¼ì„œ ë©”ëª¨ë¦¬ ê³µê°„ì„ í¬ê²Œ ì¡ê³ ìˆìŒê¸°ì–µ!

```cpp
class TableDescriptorHeap
{
    // ...

private:

    // ì—­ì‹œ Descriptorê°€ í•„ìš”í•˜ê³ 
	ComPtr<ID3D12DescriptorHeap> _descHeap;

    // ê° tableë¼ë¦¬ ì–¼ë§ˆë‚˜ ë–¨ì–´ì ¸ìˆëŠ”ì§€
	uint64					_handleSize = 0;

    // tableí•˜ë‚˜ì˜ ì‚¬ì´ì¦ˆ(ì‚¬ì‹¤ _handleSizeê³¼ ê°™ì€ ê°’ ì„¤ëª…ì„ ìœ„í•´ì„œ ë‚˜ëˆ”.)
	uint64					_groupSize = 0;

    // tableì´ ëª‡ê°œì¸ì§€
	uint64					_groupCount = 0;

    // í˜„ì¬ ì‚¬ìš©ì¤‘ì¸ tableì€?
	uint32					_currentGroupIndex = 0;
};
```

```cpp
void TableDescriptorHeap::Init(uint32 count)
{
	_groupCount = count;

	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = count * REGISTER_COUNT;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE; // ì´ ë¶€ë¶„ì´ ìœ„ì™€ ë‹¤ë¥¸ë°, ëŒ€ëµì ìœ¼ë¡œ ì„¤ëª…í•˜ë©´ D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLEë¥¼ í‚¤ë©´ ë¬´ì¡°ê±´ GPUë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°€ê²Œ ëœë‹¤.(MSDNì—ì„œ ì´ê±¸ ì¶”ì²œí•˜ê¸°ì— ì‹œí‚¤ëŠ”ë°ë¡œ í•˜ì)
    // D3D12_DESCRIPTOR_HEAP_FLAG_NONE - ê²½ìš°ì— ë”°ë¼ CPUë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°ˆìˆ˜ ìˆìŒ.
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

	DEVICE->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&_descHeap));

	_handleSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	_groupSize = _handleSize * REGISTER_COUNT;
}
```

ğŸ˜º GPUë©”ëª¨ë¦¬ì— ë°ì´í„° ë„£ê¸°

```cpp
void TableDescriptorHeap::SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg)
{
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

	uint32 destRange = 1;
	uint32 srcRange = 1;

    // srcHandleì— ìˆë˜ê±¸ destHandleë¡œ ë³µì‚¬í•´ ì£¼ì„¸ìš”
	DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}
```

ğŸ˜º ë ˆì§€ìŠ¤í„°ë¡œ ë°ì´í„° ë³´ë‚´ê¸°

```cpp
void TableDescriptorHeap::CommitTable()
{
	D3D12_GPU_DESCRIPTOR_HANDLE handle = _descHeap->GetGPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	CMD_LIST->SetGraphicsRootDescriptorTable(0, handle);

	_currentGroupIndex++;
}
```

```cpp
void Mesh::Render()
{
	CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)

	// TODO
	// 1) Bufferì—ë‹¤ê°€ ë°ì´í„° ì„¸íŒ…
	// 2) TableDescHeapì—ë‹¤ê°€ CBV ì „ë‹¬
	// 3) ëª¨ë‘ ì„¸íŒ…ì´ ëë‚¬ìœ¼ë©´ TableDescHeap ì»¤ë°‹
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);
	}
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b1);
	}

	GEngine->GetTableDescHeap()->CommitTable();

	CMD_LIST->DrawInstanced(_vertexCount, 1, 0, 0);
}
```

---

## Update Game ì „ì²´ìˆœì„œ

```cpp
void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();

	{
		Transform t;
		t.offset = Vec4(0.75f, 0.f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->Render();
	}

	{
		Transform t;
		t.offset = Vec4(0.f, 0.75f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->Render();
	}

	GEngine->RenderEnd();
}
```

```cpp
class Mesh
{
    // ...

	void SetTransform(const Transform& t) { _transform = t; }
```

```cpp
void Mesh::Render()
{
	// ...
    
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);
	}
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b1);
	}
```