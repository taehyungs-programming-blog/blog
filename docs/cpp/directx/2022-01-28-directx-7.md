---
layout: default
title: "7. Texture Mapping"
parent: (DirectX)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ± ê²°ë¡ ë¶€í„° ë§í•´ ê·¸ë ¤ë³¸ ë„¤ëª¨ì— ì´ë¯¸ì§€ë¥¼ ì…íˆê³ ìí•œë‹¤.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-7-1.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>

ğŸ± ì´ë¯¸ì§€ë¥¼ ë„£ê¸°ìœ„í•´ì„  ë­˜ í•´ì•¼í• ê¹Œ? ì´ë¯¸ì§€ë¥¼ ë¶ˆëŸ¬ì™€ì•¼ê² ì§€? DirectXì˜ ì´ë¯¸ì§€ ì²˜ë¦¬ë¥¼ ìœ„í•´ì„  ëª‡ê°€ì§€ ê°œë…ì„ ë¨¼ì € ì•Œì•„ì•¼í•œë‹¤.

ğŸ˜º **Texture**, **Sprite** ???

* ì²˜ìŒë“¤ìœ¼ë©´ ëª¨ë‘ ì´ë¯¸ì§€ ê°™ì€ë° ì™œ ì„¸ê°€ì§€ë¡œ ë‚˜ëˆ ì„œ ê´€ë¦¬í•˜ì§€? ì´í•´ê°€ ì•ˆëœë‹¤.
    * **Texture** : DirectXì—ì„œ ê´€ë¦¬í•˜ëŠ” ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ ìì²´ë¥¼ ì˜ë¯¸
    * **Sprite** : Textureì—ì„œ ì´ë¯¸ì§€ë¥¼ ì ë‹¹íˆ ì˜ë¼ë‚´, ì˜¤ë¸Œì íŠ¸ë¥¼ ë§Œë“¤í…ë° ê·¸ 2D ì˜¤ë¸Œì íŠ¸ë¥¼ ì˜ë¯¸í•œë‹¤.

ğŸ˜º ëŒ€ëµ ì´ë ‡ê²Œ ì“´ë‹¤

* [ì°¸ê³ ì½”ë“œ ğŸŒ](https://github.com/EasyCoding-7/Direct3DExample/blob/master/2D-Game/SpriteProject.cpp)

```cpp
ID3DXSprite *g_Sprite;
IDirect3DTexture9 *g_pTexture;

HRESULT CALLBACK OnD3D9CreateDevice( IDirect3DDevice9* pd3dDevice, const D3DSURFACE_DESC* pBackBufferSurfaceDesc,
                                     void* pUserContext )
{
    // Create
	D3DXCreateSprite( pd3dDevice, &g_Sprite );
	D3DXCreateTextureFromFileEx( pd3dDevice, L"fire.bmp", 0, 0, 0, 0, D3DFMT_UNKNOWN, 
				D3DPOOL_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DCOLOR_XRGB(0, 0, 0), 
				0, 0, &g_pTexture);

    // ...

// render
void CALLBACK OnD3D9FrameRender( IDirect3DDevice9* pd3dDevice, double fTime, 
	                             float fElapsedTime, void* pUserContext )
{
    HRESULT hr;	
	D3DXVECTOR3 vPos( 100, 200, 0.0f);
	
    // Clear the render target and the zbuffer 
    V( pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 
		                  D3DCOLOR_ARGB( 0, 45, 50, 170 ), 1.0f, 0 ) );

    // Render the scene
    if( SUCCEEDED( pd3dDevice->BeginScene() ) )
    {		
		g_Sprite->Begin( D3DXSPRITE_ALPHABLEND );

		g_Sprite->Draw( g_pTexture, &g_sFire.pRect[g_sFire.nIndex], 
					   &g_sFire.pCenter[g_sFire.nIndex], &vPos, 
					   D3DCOLOR_XRGB(255, 255, 255));
		g_Sprite->End();
        V( pd3dDevice->EndScene() );
    }
```

<br>

ğŸ˜º ì‚¬ì‹¤ ì˜¤ëŠ˜ê°•ì˜ì—ì„œ í¬ê²Œ ì¤‘ìš”í•œ ë‚´ìš©ì€ ì•„ë‹ˆë‹ˆ ëŒ€ëµ ì•Œê³ ë§Œ ìˆì.

---

## ì¶”ê°€ì ìœ¼ë¡œ í•˜ë‚˜ë§Œ ë”... Rasterizer Stage

ğŸ˜º ëœë”ë§ íŒŒì´í”„ë¼ì¸ì—ì„œ Rasterizer Stageê°€ ìˆëŠ”ë° ì–´ë–»ê²Œ ê° ì •ì ì—ì„œ ìƒ‰ìƒê°’ì„ ì •ì˜í•˜ëŠ”ì§€ë¥¼ ì˜ë¯¸í•œë‹¤.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-1-0.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>

ğŸ˜º ê°€ë ¹ ì•„ë˜ì™€ ê°™ì€ ì‚¼ê°í˜•ì„ í‘œí˜„ì‹œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ë„£ì€ ìƒ‰ìƒê°’ì€ ì •ì ì˜ ì„¸ ê°€ì§€ ìƒ‰ìƒë¿ì¸ë°

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-3-1.png" style="border-radius:5%;border:1px solid #e6e1e8"/>
</p>

<br>

```cpp
// í”„ë¡œê·¸ë˜ë¨¸ê°€ ë„£ì€ ìƒ‰ìƒê°’
void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);

	vector<Vertex> vec(3);
	vec[0].pos = Vec3(0.f, 0.5f, 0.5f);
	vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);

	vec[1].pos = Vec3(0.5f, -0.5f, 0.5f);
	vec[1].color = Vec4(0.f, 1.0f, 0.f, 1.f);

	vec[2].pos = Vec3(-0.5f, -0.5f, 0.5f);
	vec[2].color = Vec4(0.f, 0.f, 1.f, 1.f);
```

ğŸ˜º ìƒ‰ì€ ëª¨ë‘ ì±„ì›Œì ¸ ë‚˜ì˜¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì´ ìƒ‰ì±„ìš°ëŠ” ì‘ì—…ì„ Rasterizer Stageì—ì„œ ìˆ˜í–‰í•˜ë©° ìˆ˜í–‰ì˜ ê¸°ì¤€ì€ Shaderì—ì„œ í”„ë¡œê·¸ë˜ë¨¸ê°€ ë„£ì€ Pixel Shader í•¨ìˆ˜ì— ì˜í•´ ê²°ì •ëœë‹¤.

ğŸ˜º ê°‘ìê¸° ì—¬ê¸°ì„œ ì´ ì–˜ê¸°ë¥¼ í•˜ëŠ” ê±´ Textureë¥¼ mappingì‹œí‚¤ëŠ” ê²ƒë„ ê²°êµ­ ìƒ‰ì„ ë„£ëŠ” ê³¼ì •ì´ê³  **Rasterizer Stage** ì—ì„œ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

---

## ë³¸ê²©ì  ì‹œì‘

ğŸ˜º Libì— DirectXTex.libë¥¼ ì¶”ê°€í•´ì•¼í•¨

* [DirectXTex Github ğŸŒ](https://github.com/microsoft/DirectXTex)

```cpp
// EnginePch.h

// ...

// DirectXTexì˜ í—¤ë”íŒŒì¼ë§Œ ê°€ì ¸ì˜¤ê³ 
#include <DirectXTex/DirectXTex.h>
#include <DirectXTex/DirectXTex.inl>

// ...

// ë¹Œë“œëœ ë¼ì´ë¸ŒëŸ¬ë¦¬ë„ ê°€ì ¸ì˜¤ê³ 
#ifdef _DEBUG
#pragma comment(lib, "DirectXTex\\DirectXTex_debug.lib")
#else
#pragma comment(lib, "DirectXTex\\DirectXTex.lib")
#endif

// ...
```

### Texture Class(Texture ë¡œë“œ)

```cpp
#pragma once

class Texture
{
public:
	void Init(const wstring& path);

	D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle() { return _srvHandle; }

public:
	void CreateTexture(const wstring& path);
	void CreateView();

private:
	ScratchImage			 		_image;     // image íŒŒì¼ ë¡œë“œìš©
	ComPtr<ID3D12Resource>			_tex2D;

	ComPtr<ID3D12DescriptorHeap>	_srvHeap;
	D3D12_CPU_DESCRIPTOR_HANDLE		_srvHandle;
};
```

```cpp
void Texture::Init(const wstring& path)
{
	CreateTexture(path);
	CreateView();
}

void Texture::CreateTexture(const wstring& path)
{
	// íŒŒì¼ í™•ì¥ì ì–»ê¸°
    /*
        #include <filesystem>
        namespace fs = std::filesystem;

        // ë‹¨ C++17ì„ ì“°ë©´ std::byteì—ì„œ ì—ëŸ¬ê°€ ëœ¨ê¸°ì—
        #define _HAS_STD_BTYE 0
        // ì“°ì§€ì•Šê² ë‹¤ê³  ì•Œë ¤ì•¼ í•œë‹¤.
    */
	wstring ext = fs::path(path).extension();       // fs(file system) C++17ë¶€í„° ì§€ì›ëœë‹¤.

	if (ext == L".dds" || ext == L".DDS")
		::LoadFromDDSFile(path.c_str(), DDS_FLAGS_NONE, nullptr, _image);
	else if (ext == L".tga" || ext == L".TGA")
		::LoadFromTGAFile(path.c_str(), nullptr, _image);
	else // png, jpg, jpeg, bmp
		::LoadFromWICFile(path.c_str(), WIC_FLAGS_NONE, nullptr, _image);

    // ì´ë¯¸ì§€íŒŒì¼ì„ ì´ìš©í•´ textureìƒì„±
	HRESULT hr = ::CreateTexture(DEVICE.Get(), _image.GetMetadata(), &_tex2D);
	if (FAILED(hr))
		assert(nullptr);

	vector<D3D12_SUBRESOURCE_DATA> subResources;

	// ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œ(?) ì¤€ë¹„ (ì¼ë‹¨ ë°›ì•„ë“¤ì´ì)
	hr = ::PrepareUpload(DEVICE.Get(),
		_image.GetImages(),
		_image.GetImageCount(),
		_image.GetMetadata(),
		subResources);

	if (FAILED(hr))
		assert(nullptr);

	const uint64 bufferSize = ::GetRequiredIntermediateSize(_tex2D.Get(), 0, static_cast<uint32>(subResources.size()));

	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

	ComPtr<ID3D12Resource> textureUploadHeap;
	hr = DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(textureUploadHeap.GetAddressOf()));

	if (FAILED(hr))
		assert(nullptr);

	/*
        RESOURCE_CMD_LIST ??? -> ê¸°ì¡´ì˜ CMD_LISTì™€ ë‹¤ë¥¸ì•„ì´
        ê¸°ì¡´ CMD_LISTëŠ” Render begin ~ end ì‚¬ì´ì— ì¡´ì¬í•´ì•¼í•˜ëŠ”ë°
        ì´ë¯¸ì§€ë¥¼ ë¡œë“œí• ë•Œ Render begin ~ end ì‚¬ì´ì— ìˆì–´ì•¼í•  ì´ìœ ëŠ” ì—†ë‹¤

        * ë³„ë„ì˜ RESOURCE_CMD_LISTê°€ í•„ìš”í•¨ *
	*/

	::UpdateSubresources(RESOURCE_CMD_LIST.Get(),
		_tex2D.Get(),
		textureUploadHeap.Get(),
		0, 0,
		static_cast<unsigned int>(subResources.size()),
		subResources.data());

	GEngine->GetCmdQueue()->FlushResourceCommandQueue();
}
```

<Br>

ğŸ˜º ë¦¬ì†ŒìŠ¤ ë¡œë“œìš© (`RESOURCE_CMD_LIST`) ì»¤ë©˜ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ë³´ì.

```cpp
class CommandQueue
{
	// ...
	ComPtr<ID3D12CommandAllocator>		_cmdAlloc;			// ê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ ì»¤ë©˜ë“œ ë¦¬ìŠ¤íŠ¸
	ComPtr<ID3D12GraphicsCommandList>	_cmdList;

	ComPtr<ID3D12CommandAllocator>		_resCmdAlloc;		// ë¦¬ì†ŒìŠ¤ë¡œë“œìš© ì»¤ë©˜ë“œAlloc
	ComPtr<ID3D12GraphicsCommandList>	_resCmdList;		// ë¦¬ì†ŒìŠ¤ë¡œë“œìš© ì»¤ë©˜ë“œë¦¬ìŠ¤íŠ¸
```

```cpp
// ë¦¬ì†ŒìŠ¤ë¥¼ Flush
void CommandQueue::FlushResourceCommandQueue()
{
	_resCmdList->Close();

	ID3D12CommandList* cmdListArr[] = { _resCmdList.Get() };
	_cmdQueue->ExecuteCommandLists(_countof(cmdListArr), cmdListArr);

	WaitSync();	// GPUê°€ ë‹¤ ì½ì–´ê°„ë‹¤ë©´

	// ë¦¬ì…‹ ì‹œí‚¨ë‹¤.
	_resCmdAlloc->Reset();
	_resCmdList->Reset(_resCmdAlloc.Get(), nullptr);
}
```

<br>

## Textureë¥¼ ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¡œ ì—…ë¡œë“œ

ğŸ˜º í…ìŠ¤ì³ë¥¼ ë„˜ê¸°ê¸° ìœ„í•´ RootSignatureë„ ì¶”ê°€ë˜ì–´ì•¼ í•  ë¶€ë¶„ì´ ìˆë‹¤.

```cpp
void RootSignature::CreateRootSignature()
{
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, CBV_REGISTER_COUNT, 0), // b0~b4

		// Texture(SRV(Shader Resource View))ìš© t0~t4ë¥¼ í• ë‹¹
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, SRV_REGISTER_COUNT, 0), // t0~t4
	};

	// ...
}
```

<Br>

ğŸ˜º ì¶”ê°€ì ìœ¼ë¡œ Vertexê°’ì— uvê°’ì„ ì¶”ê°€í•´ Tuxtureë¥¼ ë°›ì„ ì¤€ë¹„ë¥¼ í•´ë³´ì.

```cpp
struct Vertex
{
	Vec3 pos;
	Vec4 color;
	Vec2 uv;
    // uvì¢Œí‘œëŠ” ì´ë¯¸ì§€ì˜ ì¢Œí‘œë¥¼ ì˜ë¯¸í•˜ë©° ëŒ€ëµ ì•„ë˜ì™€ ê°™ë‹¤

    /*

	   [0,0]-----------[1,0]
		 |               |
		 |               |
		 |               |
		 |               |
	   [0,1]-----------[1,1]

	*/
};
```

```
Texture2D tex_0 : register(t0);
// t0~t4ê¹Œì§€ ì¡ì•˜ëŠ”ë° t1~t4ëŠ” ì–´ë””ê°”ë‚˜??
// ì¡ì•„ë†¨ë‹¤ê³  ê¼­ ì¨ì•¼í•˜ëŠ”ê±´ ì•„ë‹˜ ìš°ì„ ì€ t0ë§Œ ì“´ë‹¤.

SamplerState sam_0 : register(s0);
// Pixelì‰ì´ë”ì˜ ìƒ‰ìƒì„ ê³ ë¥´ëŠ” ì •ì±…ì„ ì„¤ëª…(ìš°ì„ ì€ ë°›ì•„ë“¤ì¸ë‹¤.)

struct VS_IN
{
    float3 pos : POSITION;
    float4 color : COLOR;
    float2 uv : TEXCOORD;
};

struct VS_OUT
{
    float4 pos : SV_Position;
    float4 color : COLOR;
    float2 uv : TEXCOORD;
};

// ...

VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = float4(input.pos, 1.f);
    output.color = input.color;
    output.uv = input.uv;

    return output;
}

float4 PS_Main(VS_OUT input) : SV_Target
{
    // tex_0ì˜ texture ìƒ‰ìƒê°’ì„ sam_0ë¡œ ìƒ˜í”Œë§í•´ì„œ ì²˜ë¦¬í•˜ê² ë‹¤ ì •ë„ë§Œ ì´í•´í•˜ì
    float4 color = tex_0.Sample(sam_0, input.uv);
    return color;
}
```

```cpp
void Shader::Init(const wstring& path)
{
	CreateVertexShader(path, "VS_Main", "vs_5_0");
	CreatePixelShader(path, "PS_Main", "ps_5_0");

	D3D12_INPUT_ELEMENT_DESC desc[] =
	{
		{ "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
		{ "COLOR", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },

        // uvê°’ì„ TEXCOORDë¡œ ë„˜ê¸°ê² ë‹¤ ì•Œë¦°ë‹¤
		{ "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 28, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 },
	};
```

<br>

```cpp
void Mesh::Render()
{
	CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
	CMD_LIST->IASetIndexBuffer(&_indexBufferView);

	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);

        /*
            class Texture
            {
                // ...
                D3D12_CPU_DESCRIPTOR_HANDLE GetCpuHandle() { return _srvHandle; }
                // ...
                D3D12_CPU_DESCRIPTOR_HANDLE		_srvHandle;
        */

		GEngine->GetTableDescHeap()->SetSRV(_tex->GetCpuHandle(), SRV_REGISTER::t0);
```

<br>

ğŸ˜º TableDescriptorHeapì€ Constant Bufferê°€ ìƒìˆ˜ë‹¨ìœ„ë¡œ ë ˆì§€ìŠ¤í„°ì— ì˜¬ë¦¬ëŠ” ë©”ëª¨ë¦¬ë¼ë©´ TableDescriptorHeapì€ Tableë‹¨ìœ„ë¡œ ë ˆì§€ìŠ¤í„°ì— ì˜¬ë¦¬ëŠ” ë…€ì„

```cpp
void TableDescriptorHeap::SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg)
{
    /*
    D3D12_CPU_DESCRIPTOR_HANDLE TableDescriptorHeap::GetCPUHandle(SRV_REGISTER reg)
    {
        return GetCPUHandle(static_cast<uint8>(reg));
    }

    D3D12_CPU_DESCRIPTOR_HANDLE TableDescriptorHeap::GetCPUHandle(uint8 reg)
    {
        D3D12_CPU_DESCRIPTOR_HANDLE handle = _descHeap->GetCPUDescriptorHandleForHeapStart();
        handle.ptr += _currentGroupIndex * _groupSize;
        handle.ptr += reg * _handleSize;
        return handle;
    }
    */
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

	uint32 destRange = 1;
	uint32 srcRange = 1;
	DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}
```

<br>

ğŸ˜º ì°¸ê³ ë¡œ SamplerëŠ” ì•„ë˜ì™€ ê°™ì´ ë§Œë“¤ì–´ë§Œ ë‘ì(ìì„¸í•œ ì„¤ëª…ì€ ì´í›„ì—)

```cpp
// RootSignatureì—ì„œ samplerê¹Œì§€ ë§Œë“ ë‹¤

void RootSignature::CreateSamplerDesc()
{
    // CD3DX12_STATIC_SAMPLER_DESC(0) : ê°€ì¥ ê¸°ë³¸ ìƒíƒœì¸ë°
        // ì¼ë‹¨ì€ ê·¸ëƒ¥ ë°›ì•„ë“¤ì´ì. ì´í›„ì— ì“°ì¸ë‹¤
	_samplerDesc = CD3DX12_STATIC_SAMPLER_DESC(0);
}
```

```cpp
void Game::Init(const WindowInfo& info)
{
	GEngine->Init(info);

	vector<Vertex> vec(4);
	vec[0].pos = Vec3(-0.5f, 0.5f, 0.5f);
	vec[0].color = Vec4(1.f, 0.f, 0.f, 1.f);
	vec[0].uv = Vec2(0.f, 0.f);
	vec[1].pos = Vec3(0.5f, 0.5f, 0.5f);
	vec[1].color = Vec4(0.f, 1.f, 0.f, 1.f);
	vec[1].uv = Vec2(1.f, 0.f);
	vec[2].pos = Vec3(0.5f, -0.5f, 0.5f);
	vec[2].color = Vec4(0.f, 0.f, 1.f, 1.f);
	vec[2].uv = Vec2(1.f, 1.f);
	vec[3].pos = Vec3(-0.5f, -0.5f, 0.5f);
	vec[3].color = Vec4(0.f, 1.f, 0.f, 1.f);
	vec[3].uv = Vec2(0.f, 1.f);

    // ...
```