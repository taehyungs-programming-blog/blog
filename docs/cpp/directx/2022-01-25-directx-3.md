---
layout: default
title: "3. ì‚¼ê°í˜•ì„ ê·¸ë ¤ë³´ì"
parent: (DirectX)
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º ë“¤ì–´ê°€ê¸° ì „ ê¸°ì¡´ì½”ë“œì—ì„œ ì•½ê°„ì˜ ìˆ˜ì •ì´ í•„ìš”í•˜ë‹¤

## DescriptorHeapê³¼ SwapChainì„ í†µí•©

```cpp
class SwapChain
{
    // ...
private:
    ComPtr<IDXGISwapChain>  _swapChain;
    ComPtr<ID3D12Resource>  _renderTargets[SWAP_CHAIN_BUFFER_COUNT];
```

<Br>

ğŸ˜º `ComPtr<ID3D12Resource>  _renderTargets[SWAP_CHAIN_BUFFER_COUNT];` SwapChainì—ì„œëŠ” `_renderTargets`ë¥¼ í†µí•´ ë°±ë²„í¼ì˜ ë©”ëª¨ë¦¬ì£¼ì†Œë¥¼ ê°–ê³  ìˆì—ˆê³ 

```cpp
class DescriptorHeap // View
{
    // ...
private:
    ComPtr<ID3D12DescriptorHeap>    _rtvHeap;
    D3D12_CPU_DESCRIPTOR_HANDLE     _rtvHandle[SWAP_CHAIN_BUFFER_COUNT];
```

ğŸ˜º DescriptorHeapì—ì„œëŠ” `_rtvHandle`ë¥¼ í†µí•´ ë°±ë²„í¼ì˜ í•¸ë“¤ê°–ê³  ìˆì—ˆë‹¤.

ğŸ˜¸ ì°¸ê³ ë¡œ `ComPtr<ID3D12DescriptorHeap>    _rtvHeap;` ID3D12DescriptorHeapì€ ì•„ì§ ì–´ë–¤ìš©ë„ë¡œ ì‚¬ìš©í•œë‹¤ê³  ì•ˆë‚˜ì™”ì§€ë§Œ ìš°ì„ ì€ ì•„ë˜ì™€ ê°™ì´ ë°±ë²„í¼ì˜ í•¸ë“¤ì„ ì–»ëŠ”ë° ì“´ë‹¤.

```cpp
void DescriptorHeap::Init(ComPtr<ID3D12Device> device, shared_ptr<SwapChain> swapChain)
{
    // ...
    // ë””ë°”ì´ìŠ¤ë¡œ ë¶€í„° rtvDescë¥¼ í†µí•´ ID3D12DescriptorHeapì„ í• ë‹¹ë°›ê³ 
    device->CreateDescriptorHeap(&rtvDesc, IID_PPV_ARGS(&_rtvHeap));
    // _rtvHeapì„ í†µí•´ DescriptorHeapì˜ í•¸ë“¤(ì‹œì‘ì£¼ì†Œ)ë¥¼ ì–»ëŠ”ë‹¤
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHeapBegin = _rtvHeap->GetCPUDescriptorHandleForHeapStart();
    // ì–»ì€ í•¸ë“¤ì„ í†µí•´ RenderTargetViewë¥¼ ë§Œë“ ë‹¤
    for (int i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
    {
        _rtvHandle[i] = CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeapBegin, i * _rtvHeapSize);
        device->CreateRenderTargetView(swapChain->GetRenderTarget(i).Get(), nullptr, _rtvHandle[i]);
    }
}
```

<br>

ğŸ˜¸ ê·¸ëŸ°ë° RenderTargetì€ Swapchainì—ì„œ ë§Œë“¤ì§€ ì•Šì•˜ë‚˜?

```cpp
void SwapChain::Init(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
    // ...
    // dxgië¥¼ í†µí•´ SwapChainì„ ë§Œë“¤ê³ 
    dxgi->CreateSwapChain(cmdQueue.Get(), &sd, &_swapChain);
    // SwapChainì—ì„œ ë²„í¼ë¥¼ _renderTargetsì— ë„£ëŠ”ë°?
    for (int32 i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
        _swapChain->GetBuffer(i, IID_PPV_ARGS(&_renderTargets[i]));
```

<br>

ğŸ˜¸ ì¢€ ë” ì •í™•íˆ ì„¤ëª…í•˜ìë©´ ... RenderTargetê³¼ RenderTargetViewëŠ” ë‹¤ë¥¸ ë©”ëª¨ë¦¬ê³µê°„ì´ë‹¤.

ğŸ˜¸ RenderTargetì„ ì´ì „ê°•ì˜ì—ì„œ ë°±ë²„í¼ë¼ ì„¤ëª…í–ˆëŠ”ë°(ì •í™•íˆëŠ” ì•„ë‹ˆì§€ë§Œ..) RenderTargetViewëŠ” RenderTargetì— ê·¸ë ¤ì§€ê¸°ì „ ì„ì‹œê³µê°„ í˜¹ì€ RenderTargetì— ì–´ë–»ê²Œ ê·¸ë ¤ë‹¬ë¼ ì•Œë ¤ì£¼ëŠ” ì„¤ëª…ì„œ ì •ë„ë¼ ìƒê°í•˜ì

ğŸ˜¸ ì¡°ê¸ˆ ë” ì •í™•íˆëŠ” `ComPtr<ID3D12Resource>    _renderTargets[SWAP_CHAIN_BUFFER_COUNT];`ë¥¼ ì§ì ‘ ì»¨íŠ¸ë¡¤í•˜ì§€ ëª»í•œë‹¤. (`ID3D12Resource`ë¥¼ ì§ì ‘ ì»¨íŠ¸ë¡¤ ëª»í•¨) ë”°ë¼ì„œ View(Descriptor)ë¥¼ í†µí•´ ê·¸ë ¤ì§€ëŠ” ë°±ë²„í¼ë¥¼ ì»¨íŠ¸ë¡¤í•´ì•¼ í•˜ê¸°ì— rendertargetviewê°€ í•„ìš”í•˜ë‹¤

ğŸ˜¸ `SwapChain::Init`ì—ì„œì˜ `_swapChain->GetBuffer(i, IID_PPV_ARGS(&_renderTargets[i]));`ëŠ” RenderTargetì˜ ì£¼ì†Œë¥¼ ë°›ê³  ì„ ì–¸í•˜ëŠ” ë¶€ë¶„ì´ë©° / `DescriptorHeap::Init`ì˜ `device->CreateRenderTargetView(swapChain->GetRenderTarget(i).Get(), nullptr, _rtvHandle[i]);`ëŠ” RenderTargetView ë¥¼ í• ë‹¹í•œë‹¤

ğŸ± ì•„ë‹ˆ ì§ì ‘ì»¨íŠ¸ë¡¤ í•˜ì§€ë„ ëª»í•  `ComPtr<ID3D12Resource>  _renderTargets[SWAP_CHAIN_BUFFER_COUNT];`ëŠ” ê·¸ëŸ¼ ì™œ ê°–ê³ ìˆëŠ”ê°€? (ì•„ë˜ì„œ ì“°ì¸ë‹¤.)

```cpp
void CommandQueue::RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect)
{
    // ...

    /*
        class SwapChain
        {
        // ...
            ComPtr<ID3D12Resource> GetCurrentBackBufferResource() { return _renderTargets[_backBufferIndex]; }
    */

    D3D12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
        _swapChain->GetCurrentBackBufferResource().Get(),
        D3D12_RESOURCE_STATE_PRESENT, // í™”ë©´ ì¶œë ¥
        D3D12_RESOURCE_STATE_RENDER_TARGET); // ì™¸ì£¼ ê²°ê³¼ë¬¼

    // ...

    /*
        D3D12_CPU_DESCRIPTOR_HANDLE DescriptorHeap::GetBackBufferView()
        {
            return GetRTV(_swapChain->GetCurrentBackBufferIndex());
        }
    */

    // ì‹¤ì œ RenderTargetì— ê·¸ë¦¬ê¸°ìœ„í•´ RenderTargetViewë¥¼ í†µí•´ Commandë¥¼ ë³´ë‚¸ë‹¤
    D3D12_CPU_DESCRIPTOR_HANDLE backBufferView = _descHeap->GetBackBufferView();
    _cmdList->ClearRenderTargetView(backBufferView, Colors::LightSteelBlue, 0, nullptr);
    _cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, nullptr);
}
```

ğŸ˜º ì„¤ëª…ì´ ê¸¸ì–´ì¡Œìœ¼ë‚˜ ê²°ë¡ ì€ DescriptorHeap, SwapChainì€ í†µí•©í•´ë„ í¬ê²Œ ìƒê´€ì´ ì—†ë‹¤.

```cpp
class SwapChain
{
public:
    void Init(const WindowInfo& info, ComPtr<ID3D12Device> device, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);
    void Present();
    void SwapIndex();
    ComPtr<IDXGISwapChain> GetSwapChain() { return _swapChain; }
    ComPtr<ID3D12Resource> GetRenderTarget(int32 index) { return _rtvBuffer[index]; }
    ComPtr<ID3D12Resource> GetBackRTVBuffer() { return _rtvBuffer[_backBufferIndex]; }
    D3D12_CPU_DESCRIPTOR_HANDLE GetBackRTV() { return _rtvHandle[_backBufferIndex]; }

private:
    void CreateSwapChain(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);
    void CreateRTV(ComPtr<ID3D12Device> device);

private:
    ComPtr<IDXGISwapChain>  _swapChain;
    
    // RenderTarget
    ComPtr<ID3D12Resource>          _rtvBuffer[SWAP_CHAIN_BUFFER_COUNT];
    // RenderTargetView
    ComPtr<ID3D12DescriptorHeap>    _rtvHeap;
    D3D12_CPU_DESCRIPTOR_HANDLE     _rtvHandle[SWAP_CHAIN_BUFFER_COUNT];
    uint32                  _backBufferIndex = 0;
};
```

```cpp
void SwapChain::Init(const WindowInfo& info, ComPtr<ID3D12Device> device, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
    CreateSwapChain(info, dxgi, cmdQueue);
    CreateRTV(device);
}

// ...

void SwapChain::CreateSwapChain(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
    // ì´ì „ì— ë§Œë“  ì •ë³´ ë‚ ë¦°ë‹¤
    _swapChain.Reset();
    DXGI_SWAP_CHAIN_DESC sd;
    sd.BufferDesc.Width = static_cast<uint32>(info.width); // ë²„í¼ì˜ í•´ìƒë„ ë„ˆë¹„
    sd.BufferDesc.Height = static_cast<uint32>(info.height); // ë²„í¼ì˜ í•´ìƒë„ ë†’ì´
    sd.BufferDesc.RefreshRate.Numerator = 60; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
    sd.BufferDesc.RefreshRate.Denominator = 1; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // ë²„í¼ì˜ ë””ìŠ¤í”Œë ˆì´ í˜•ì‹
    sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
    sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
    sd.SampleDesc.Count = 1; // ë©€í‹° ìƒ˜í”Œë§ OFF
    sd.SampleDesc.Quality = 0;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // í›„ë©´ ë²„í¼ì— ë Œë”ë§í•  ê²ƒ 
    sd.BufferCount = SWAP_CHAIN_BUFFER_COUNT; // ì „ë©´+í›„ë©´ ë²„í¼
    sd.OutputWindow = info.hwnd;
    sd.Windowed = info.windowed;
    sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; // ì „ë©´ í›„ë©´ ë²„í¼ êµì²´ ì‹œ ì´ì „ í”„ë ˆì„ ì •ë³´ ë²„ë¦¼
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    dxgi->CreateSwapChain(cmdQueue.Get(), &sd, &_swapChain);
    for (int32 i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
        _swapChain->GetBuffer(i, IID_PPV_ARGS(&_rtvBuffer[i]));
}

void SwapChain::CreateRTV(ComPtr<ID3D12Device> device)
{
    // Descriptor (DX12) = View (~DX11)
    // [ì„œìˆ ì í™]ìœ¼ë¡œ RTV ìƒì„±
    // DX11ì˜ RTV(RenderTargetView), DSV(DepthStencilView), 
    // CBV(ConstantBufferView), SRV(ShaderResourceView), UAV(UnorderedAccessView)ë¥¼ ì „ë¶€!
    int32 rtvHeapSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
    D3D12_DESCRIPTOR_HEAP_DESC rtvDesc;
    rtvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
    rtvDesc.NumDescriptors = SWAP_CHAIN_BUFFER_COUNT;
    rtvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
    rtvDesc.NodeMask = 0;

    // ê°™ì€ ì¢…ë¥˜ì˜ ë°ì´í„°ë¼ë¦¬ ë°°ì—´ë¡œ ê´€ë¦¬
    // RTV ëª©ë¡ : [ ] [ ]
    device->CreateDescriptorHeap(&rtvDesc, IID_PPV_ARGS(&_rtvHeap));
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHeapBegin = _rtvHeap->GetCPUDescriptorHandleForHeapStart();
    for (int i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
    {
        _rtvHandle[i] = CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeapBegin, i * rtvHeapSize);
        device->CreateRenderTargetView(_rtvBuffer[i].Get(), nullptr, _rtvHandle[i]);
    }
}
```

<Br>

---

## ìì£¼ ì‚¬ìš©ë  device, commandqueue, swapchainì„ ë§¤í¬ë¡œë¡œ ë¹¼ì

```cpp
class Engine
{
public:
    void Init(const WindowInfo& info);
    void Render();

public:
    shared_ptr<Device> GetDevice() { return _device; }
    shared_ptr<CommandQueue> GetCmdQueue() { return _cmdQueue; }
    shared_ptr<SwapChain> GetSwapChain() { return _swapChain; }
    shared_ptr<RootSignature> GetRootSignature() { return _rootSignature; }
```

```cpp
// EnginePch.h

// ...

#define DEVICE          GEngine->GetDevice()->GetDevice()
#define CMD_LIST        GEngine->GetCmdQueue()->GetCmdList()        // Command Listë„ ìì£¼ì‚¬ìš©ë˜ê¸°ì— ë³„ë„ë¡œ ëºŒ.
#define ROOT_SIGNATURE  GEngine->GetRootSignature()->GetSignature()

// ...
```

---

ğŸ± ì´ì œ ì‚¼ê°í˜•ì„ ê·¸ë ¤ë³´ì

## RootSignature í´ë˜ìŠ¤

ğŸ˜º ì•„ì§ RootSignatureì— ëŒ€í•´ ì™„ë²½íˆ ì´í•´í• ìˆœ ì—†ê³  ëŒ€ëµ RootSignatureë¼ëŠ” ì• ê°€ ìˆê³  í˜„ì¬ëŠ” ìƒì„±ë§Œí•œë‹¤ê³  ë°›ì•„ë“¤ì´ì.

```cpp
class RootSignature
{
public:
    void Init(ComPtr<ID3D12Device> device);
    ComPtr<ID3D12RootSignature> GetSignature() { return _signature; }
private:
    ComPtr<ID3D12RootSignature> _signature;
};
```

```cpp
void RootSignature::Init(ComPtr<ID3D12Device> device)
{
    D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(D3D12_DEFAULT);
    sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT; // ì…ë ¥ ì¡°ë¦½ ë‹¨ê³„
    ComPtr<ID3DBlob> blobSignature;
    ComPtr<ID3DBlob> blobError;
    ::D3D12SerializeRootSignature(&sigDesc, D3D_ROOT_SIGNATURE_VERSION_1, &blobSignature, &blobError);
    device->CreateRootSignature(0, blobSignature->GetBufferPointer(), blobSignature->GetBufferSize(), IID_PPV_ARGS(&_signature));
}
```

```cpp
void Shader::Init(const wstring& path)
{
    // ...

    _pipelineDesc.InputLayout = { desc, _countof(desc) };
    // RootsignatureëŠ” Shaderì—ì„œ ì‚¬ìš©ë˜ë©° ì•„ì§ì€ ì„¤ëª…ì€ í•˜ì§€ì•Šê² ë‹¤.
    _pipelineDesc.pRootSignature = ROOT_SIGNATURE.Get();
```

---

## Mesh í´ë˜ìŠ¤

ğŸ˜º ì •ì ì •ë³´ë¥¼ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ë³´ì(í˜„ì¬ëŠ” ì‚¼ê°í˜•ë§Œ ì‚¬ìš©í•˜ëŠ”ë° ì´í›„ì—ëŠ” ë³µì¡í•œ êµ¬ì¡°ë¥¼ ë„£ê²Œëœë‹¤.)

```cpp
class Mesh 
{ 
public: 
    void Init(vector<Vertex>& vec); 
    void Render(); 

private: 
    ComPtr<ID3D12Resource>      _vertexBuffer; 
    // GPUì— í• ë‹¹í•  Mesh ë©”ëª¨ë¦¬(ë¦¬ì†ŒìŠ¤)
    D3D12_VERTEX_BUFFER_VIEW    _vertexBufferView = {}; 
    // í• ë‹¹ëœ ë©”ëª¨ë¦¬(ë¦¬ì†ŒìŠ¤)ì˜ í•¸ë“¤(View)
    uint32 _vertexCount = 0; 
};
```

```cpp
void Mesh::Init(vector<Vertex>& vec)
{
    _vertexCount = static_cast<uint32>(vec.size());
    uint32 bufferSize = _vertexCount * sizeof(Vertex);
    // GPUì— ì—…ë¡œë“œìš© ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•´ ë‹¬ë¼
    D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);   // ì—…ë¡œë“œìš©
    D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);
    // GPUì˜ ê³µê°„ì„ ë¹Œë¦°ë‹¤.
    DEVICE->CreateCommittedResource(
        &heapProperty,
        D3D12_HEAP_FLAG_NONE,
        &desc,
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&_vertexBuffer));  // _vertexBufferê°€ ìƒì„±ë¨, _vertexBuffer : GPUê³µê°„ì˜ ë©”ëª¨ë¦¬ë¥¼ ì˜ë¯¸
    // Copy the triangle data to the vertex buffer.
    // _vertexBufferëŠ” GPUê³µê°„ì´ë¼ ê·¸ëƒ¥ ë³µì‚¬ê°€ ë¶ˆê°€ëŠ¥ ì•„ë˜ì˜ ê³¼ì •ì´ í•„ìš”í•˜ë‹¤
    void* vertexDataBuffer = nullptr;
    CD3DX12_RANGE readRange(0, 0); // We do not intend to read from this resource on the CPU.
    _vertexBuffer->Map(0, &readRange, &vertexDataBuffer);   // GPUê³µê°„ì— ì ‘ê·¼í•  ê¶Œí•œì„ ì ê¹ ê°–ëŠ”ë‹¤.
    ::memcpy(vertexDataBuffer, &vec[0], bufferSize);        // ë©”ëª¨ë¦¬ ë³µì‚¬ í›„
    _vertexBuffer->Unmap(0, nullptr);                       // ê¶Œí•œì„ ë‹¤ì‹œ ëŒë ¤ì¤Œ
    // Initialize the vertex buffer view.
    _vertexBufferView.BufferLocation = _vertexBuffer->GetGPUVirtualAddress();
    _vertexBufferView.StrideInBytes = sizeof(Vertex); // ì •ì  1ê°œ í¬ê¸°
    _vertexBufferView.SizeInBytes = bufferSize; // ë²„í¼ì˜ í¬ê¸°   
}

void Mesh::Render()
{
    // ì»¤ë©˜ë“œ ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë¦¬ê¸°ë¥¼ ìš”ì²­í•¨ì„ ì£¼ëª©í•˜ì
    CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);  // Meshê°€ ì–´ë–¤í˜•íƒœì¸ì§€(ê¸°ë³¸ì€ ì‚¼ê°í˜•(TRIANGLELIST))
    CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)
    CMD_LIST->DrawInstanced(_vertexCount, 1, 0, 0); // ê·¸ë ¤ì¤­
}
```

---

## Shader í´ë˜ìŠ¤

ğŸ˜º ì •ì ì‚¬ì´ë¥¼ ì–´ë–»ê²Œ ì±„ì›Œë„£ì„ì§€(ê·¸ë¦´ì§€) ê´€ë¦¬

```cpp
#pragma once
// [ì¼ê° ê¸°ìˆ ì„œ] ì™¸ì£¼ ì¸ë ¥(GPU)ë“¤ì´ ë­˜ í•´ì•¼í• ì§€ ê¸°ìˆ 
class Shader
{
public:
    void Init(const wstring& path);     // ì‰ì´ë” íŒŒì¼ì„ ë°›ì•„ì•¼ í•œë‹¤.
    void Update();

private:
    void CreateShader(const wstring& path, const string& name, const string& version, ComPtr<ID3DBlob>& blob, D3D12_SHADER_BYTECODE& shaderByteCode);
    void CreateVertexShader(const wstring& path, const string& name, const string& version);
    void CreatePixelShader(const wstring& path, const string& name, const string& version);
    
private:
    ComPtr<ID3DBlob>                    _vsBlob;
    ComPtr<ID3DBlob>                    _psBlob;
    ComPtr<ID3DBlob>                    _errBlob;
    ComPtr<ID3D12PipelineState>         _pipelineState;
    D3D12_GRAPHICS_PIPELINE_STATE_DESC  _pipelineDesc = {};
};
```