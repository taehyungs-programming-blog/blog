---
layout: default
title: "28. Compute Shader"
parent: (DirectX)
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ì´ë¡ 

* **GPGPU** : GPUì—ê²Œ CPU ì²˜ëŸ¼ ì¼ë°˜ì  ì—°ì‚°ì„ ì‹œì¼œë³´ì(ì£¼ë¡œ ë³‘ë ¬ì  ì—°ì‚°)
    * Ex) ì†Œìˆ˜ì°¾ê¸°ëŠ” ëª¨ë“  ìˆ«ìë§ˆë‹¤ ì—°ê´€ì„±ì´ ì—†ê¸°ì— ë³‘ë ¬ì ìœ¼ë¡œ ì—°ì‚°ê°€ëŠ¥ ë“±ë“±..
    * Ex2) ê°€ìƒí™”í ì•”í˜¸ì—°ì‚°

```cpp
// compute.fx

#ifndef _COMPUTE_FX_
#define _COMPUTE_FX_

#include "params.fx"

// u0 ë ˆì§€ìŠ¤í„° : Compute Shader ì „ìš© ë ˆì§€ìŠ¤í„°
// RWTexture2D : Read, Writeê°€ ë˜ëŠ” Texture
RWTexture2D<float4> g_rwtex_0 : register(u0);

// ì“°ë ˆë“œ ê·¸ë£¹ë‹¹ ì“°ë ˆë“œ ê°œìˆ˜
// max : 1024 (CS_5.0)
// - í•˜ë‚˜ì˜ ì“°ë ˆë“œ ê·¸ë£¹ì€ í•˜ë‚˜ì˜ ë‹¤ì¤‘ì²˜ë¦¬ê¸°ì—ì„œ ì‹¤í–‰
[numthreads(1024, 1, 1)]
void CS_Main(int3 threadIndex : SV_DispatchThreadID)
{
    if (threadIndex.y % 2 == 0)
        // ì§ìˆ˜ëŠ” ë¹¨ê°•
        g_rwtex_0[threadIndex.xy] = float4(1.f, 0.f, 0.f, 1.f);
    else
        // í™€ìˆ˜ëŠ” ë…¹ìƒ‰
        g_rwtex_0[threadIndex.xy] = float4(0.f, 1.f, 0.f, 1.f);
}

#endif
```

ğŸ˜º `[numthreads(1024, 1, 1)]` ì½”ë“œ ì´í•´ë¥¼ ìœ„í•´ì„  GPGPU Threadë™ì‘ë°©ì‹ì— ëŒ€í•œ ì´í•´ê°€ í•„ìš”í•œë°

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-28-1.png"/>
</p>

ğŸ˜º ìœ„ ê·¸ë¦¼ê³¼ ê°™ì´ GPUë‚´ì—ì„œëŠ” Threadê°€ 2ì°¨ì› ë°°ì—´ë¡œ ê´€ë¦¬ë˜ê³  ê·¸ 2ì°¨ì› ë°°ì—´ì€ **Block(Thread Group)**ì´ë¼ëŠ” ë‹¨ìœ„ë¡œ ê´€ë¦¬ëœë‹¤.

ğŸ˜º `[numthreads(1024, 1, 1)]` : Block(Thread Group)ë‹¹ ì“°ë ˆë“œì˜ ê°œìˆ˜ë¥¼ ì •ì˜í•œë‹¤. ì´ Threadê°œìˆ˜ë¥¼ `1024 * 1 * 1` ê°œë¡œ í•´ë‹¬ë¼

* [numthreads MSDN ğŸŒ](https://docs.microsoft.com/ko-kr/windows/win32/direct3dhlsl/sm5-attributes-numthreads)

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-28-2.png"/>
</p>

* ìœ„ì˜ ì˜ˆë¥¼ ë“¤ë©´
    * `Dispatch(5, 3, 2)`ëŠ” Thread Groupì„ x = 5, y = 3, z = 2
    * `numthread(10, 8, 3`ì€ Threadë¥¼ x = 10, y = 8, z = 3ê°œë¡œ ë§Œë“¤ì–´ ë‹¬ë¼

* ë”°ë¼ì„œ `[numthreads(1024, 1, 1)]`ëŠ” 2ì°¨ì› ë°°ì—´ì´ ëœë‹¤.

---

## êµ¬í˜„

```cpp
// CommandQueue.h

// Compute Shaderìš© Queueë¥¼ ë§Œë“ ë‹¤

class ComputeCommandQueue
{
public:
	~ComputeCommandQueue();

	void Init(ComPtr<ID3D12Device> device);
	void WaitSync();
	void FlushComputeCommandQueue();

	ComPtr<ID3D12CommandQueue> GetCmdQueue() { return _cmdQueue; }
	ComPtr<ID3D12GraphicsCommandList> GetComputeCmdList() { return _cmdList; }

private:
	ComPtr<ID3D12CommandQueue>			_cmdQueue;
	ComPtr<ID3D12CommandAllocator>		_cmdAlloc;
	ComPtr<ID3D12GraphicsCommandList>	_cmdList;

	ComPtr<ID3D12Fence>					_fence;
	uint32								_fenceValue = 0;
	HANDLE								_fenceEvent = INVALID_HANDLE_VALUE;
};
```

```cpp
// Computeìš© RootSignatureë„ ìƒì„±

class RootSignature
{
public:
	void Init();

	ComPtr<ID3D12RootSignature>	GetGraphicsRootSignature() { return _graphicsRootSignature; }
	ComPtr<ID3D12RootSignature>	GetComputeRootSignature() { return _computeRootSignature; }

private:
	void CreateGraphicsRootSignature();
	void CreateComputeRootSignature();

private:
	D3D12_STATIC_SAMPLER_DESC	_samplerDesc; 
	ComPtr<ID3D12RootSignature>	_graphicsRootSignature;	
	ComPtr<ID3D12RootSignature>	_computeRootSignature;
};

```

```cpp
// DescriptorHeapë„ Computeìš©ìœ¼ë¡œ ìƒì„±

class ComputeDescriptorHeap
{
public:
	void Init();

	void SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg);
	void SetSRV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, SRV_REGISTER reg);
	void SetUAV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, UAV_REGISTER reg);

	void CommitTable();

	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(CBV_REGISTER reg);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(SRV_REGISTER reg);
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(UAV_REGISTER reg);

private:
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUHandle(uint8 reg);

private:

	ComPtr<ID3D12DescriptorHeap> _descHeap;
	uint64						_handleSize = 0;
};
```

ğŸ˜º Compute Shader ì¶”ê°€

```cpp
void Resources::CreateDefaultShader()
{
    // ...

	// Compute Shader
	{
		shared_ptr<Shader> shader = make_shared<Shader>();
		shader->CreateComputeShader(L"..\\Resources\\Shader\\compute.fx", "CS_Main", "cs_5_0");
        /*
            void Shader::CreateComputeShader(const wstring& path, const string& name, const string& version)
            {
                _info.shaderType = SHADER_TYPE::COMPUTE;

                CreateShader(path, name, version, _csBlob, _computePipelineDesc.CS);
                _computePipelineDesc.pRootSignature = COMPUTE_ROOT_SIGNATURE.Get();

                HRESULT hr = DEVICE->CreateComputePipelineState(&_computePipelineDesc, IID_PPV_ARGS(&_pipelineState));
                assert(SUCCEEDED(hr));
            }
        */
		Add<Shader>(L"ComputeShader", shader);
	}
```

ğŸ˜º Compute Shaderë¥¼ ì‚¬ìš©í•˜ëŠ” Material ìƒì„±

```cpp
void Resources::CreateDefaultMaterial()
{
    // ...

	// Compute Shader
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"ComputeShader");
		shared_ptr<Material> material = make_shared<Material>();
		material->SetShader(shader);
		Add<Material>(L"ComputeShader", material);
	}
```

```cpp
shared_ptr<Scene> SceneManager::LoadTestScene()
{
#pragma region LayerMask
	SetLayerName(0, L"Default");
	SetLayerName(1, L"UI");
#pragma endregion

#pragma region ComputeShader
	{
		shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"ComputeShader");

		// UAV(Unordered Access View) ìš© Texture ìƒì„±
		shared_ptr<Texture> texture = GET_SINGLE(Resources)->CreateTexture(L"UAVTexture",
			DXGI_FORMAT_R8G8B8A8_UNORM, 1024, 1024,
			CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE,
			D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS);

		shared_ptr<Material> material = GET_SINGLE(Resources)->Get<Material>(L"ComputeShader");
		material->SetShader(shader);
		material->SetInt(0, 1);
		GEngine->GetComputeDescHeap()->SetUAV(texture->GetUAVHandle(), UAV_REGISTER::u0);

		// ì“°ë ˆë“œ ê·¸ë£¹ (1 * 1024 * 1)
		material->Dispatch(1, 1024, 1);
	}
#pragma endregion

    // ...

#pragma region UI_Test
	for (int32 i = 0; i < 6; i++)
	{
		shared_ptr<GameObject> obj = make_shared<GameObject>();
		obj->SetLayerIndex(GET_SINGLE(SceneManager)->LayerNameToIndex(L"UI")); // UI
		obj->AddComponent(make_shared<Transform>());
		obj->GetTransform()->SetLocalScale(Vec3(100.f, 100.f, 100.f));
		obj->GetTransform()->SetLocalPosition(Vec3(-350.f + (i * 120), 250.f, 500.f));
		shared_ptr<MeshRenderer> meshRenderer = make_shared<MeshRenderer>();
		{
			shared_ptr<Mesh> mesh = GET_SINGLE(Resources)->LoadRectangleMesh();
			meshRenderer->SetMesh(mesh);
		}
		{
			shared_ptr<Shader> shader = GET_SINGLE(Resources)->Get<Shader>(L"Texture");

			shared_ptr<Texture> texture;
			if (i < 3)
				texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::G_BUFFER)->GetRTTexture(i);
			else if (i < 5)
				texture = GEngine->GetRTGroup(RENDER_TARGET_GROUP_TYPE::LIGHTING)->GetRTTexture(i - 3);
			else
                // UIë„ UAVìš© Textureë¥¼ ë°›ê²Œí•œë‹¤
				texture = GET_SINGLE(Resources)->Get<Texture>(L"UAVTexture");
```
