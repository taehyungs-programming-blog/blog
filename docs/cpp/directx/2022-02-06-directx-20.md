---
layout: default
title: "20. Normal Mapping"
parent: (DirectX)
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º Textureë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ [3D Textures](https://3dtextures.me/)ì™€ ê°™ì€ ì‚¬ì´íŠ¸ì—ì„œ Textureë¥¼ ë‹¤ìš´í›„ ì‚¬ìš©í•˜ë©´ ìƒê°ë³´ë‹¤ ë°‹ë°‹í•˜ë‹¤...

ğŸ˜º ì´ìœ ëŠ” Textureì—ëŠ” Lightì •ë³´ê°€ ì—†ì–´ì„œ ì¸ë° Textureë¥¼ í†µí•´ì„œ Normal Vectorì •ë³´ë¥¼ ë„˜ê²¨ ì…ì²´ê°ì„ ì£¼ëŠ” í‘œí˜„ë°©ì‹ì„ **Normal-Mapping(Bump-Mapping)**ì´ë¼í•œë‹¤.

```cpp
shared_ptr<Mesh> Resources::LoadCubeMesh()
{
	//...

	vector<Vertex> vec(24);
    /*
        struct Vertex
        {
            Vertex() {}

            Vertex(Vec3 p, Vec2 u, Vec3 n, Vec3 t)
                : pos(p), uv(u), normal(n), tangent(t)
            {
            }

            Vec3 pos;
            Vec2 uv;
            Vec3 normal;
            Vec3 tangent;
        };
    */

	// ì•ë©´
    // í•œìª½ë©´ì˜ í…ìŠ¤ì³ ë‚´ì— Normal Vectorê°’ì´ ì¼ì •í•˜ë‹ˆ ë¹› ë°˜ì‚¬ë¥¼ ëª¨ë‘ ì¼ì •í•˜ê²Œ í•˜ë©° í‰ë©´ì ìœ¼ë¡œ ë³´ì´ê²Œ ëœë‹¤.
    // ì•„ë˜ì„œ ì„¸ ë²ˆì§¸ ìš”ì†Œê°€ Normal Vectorì´ë‹¤
	vec[0] = Vertex(Vec3(-w2, -h2, -d2),        // position
                    Vec2(0.0f, 1.0f),           // uv
                    Vec3(0.0f, 0.0f, -1.0f),    // normal
                    Vec3(1.0f, 0.0f, 0.0f));    // tangent(ì•„ì§ ì™œì“°ëŠ”ì§€ ì•ˆë‚˜ì˜´.)
	vec[1] = Vertex(Vec3(-w2, +h2, -d2), Vec2(0.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[2] = Vertex(Vec3(+w2, +h2, -d2), Vec2(1.0f, 0.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));
	vec[3] = Vertex(Vec3(+w2, -h2, -d2), Vec2(1.0f, 1.0f), Vec3(0.0f, 0.0f, -1.0f), Vec3(1.0f, 0.0f, 0.0f));

    // ë³´ë©´ ì•ë©´ì˜ Normal-Vectorê°€ ëª¨ë‘ Vec3(0.0f, 0.0f, -1.0f)ë¡œ ë™ì¼í•˜ë‹¤

    // ...
```

ğŸ˜º ë§Œì•½ Cubeê°€ Sphere ì²˜ëŸ¼ Normalì´ ë‹¤ì–‘í•˜ë‹¤ë©´ ì…ì²´ê°ì´ ë‚˜íƒ€ë‚ í…ë°... ê·¸ëŸ¼ ëª¨ë“  Textureì— ë§ì¶°ì„œ Normalì„ ì„¸íŒ…í•´ ì¤˜ì•¼í• ê¹Œ? ì´ëŸ° ë…¸ê°€ë‹¤ê°€ì—†ë‹¤...

ğŸ˜º ì´ ë¬¸ì œì˜ í•´ê²°ì±…ìœ¼ë¡œ Textureìì²´ì— Normalì •ë³´ë¥¼ ì…í˜€ë‘” Textureê°€ ìˆë‹¤.

ğŸ± (ì°¸ê³ ) Normal-Mappingëœ Textureë¥¼ ì—´ì–´ë³´ë©´ í‘¸ë¥¸ìƒ‰ ì´ë¯¸ì§€ê°€ ë‚˜íƒ€ë‚˜ëŠ”ë°, ì™œ ê·¸ëŸ´ê¹Œ?

ğŸ˜º ìƒê°í•´ ë³´ë©´ ë‹¹ì—°í•œ ê²ƒì´ Tangent(ì ‘í•˜ëŠ” í‰ë©´) ì¢Œí‘œê³„ì˜ Normal Vectorë¥¼ í‘œí˜„í•˜ê¸°ì— í•­ìƒ Up(Blue)ê°’ì´ í¬ê²Œ ë‚˜íƒ€ë‚  ìˆ˜ ë°–ì— ì—†ë‹¤.

ğŸ˜º ì¢€ ë” ìì„¸íˆ ì„¤ëª…í•˜ìë©´ ... Normal-Mapping Textureì˜ ê²½ìš° ìì²´ì ì¸ ì¢Œí‘œê³„ tangentì¢Œí‘œê³„(Local ì¢Œí‘œê³„ê°€ ì•„ë‹˜)ë¥¼ ì‚¬ìš©í•œë‹¤. (tangent ì¢Œí‘œê³„ : ì ‘í•˜ëŠ” í‰ë©´ì„ ê¸°ì¤€ìœ¼ë¡œ í•˜ëŠ” ì¢Œí‘œê³„) tangent ì¢Œí‘œê³„ì˜ Upì´ Blueë¡œ ë§¤í•‘ë˜ì–´ ìˆì–´ í‘¸ë¥´ê²Œ ë‚˜íƒ€ë‚˜ë©°, ìì²´ì ì¸ ì¢Œí‘œê³„ë¥¼ ì“°ëŠ” ì´ìœ ëŠ” ì–´ëŠ í•œ ì¢Œí‘œê³„ ì˜ˆë¥¼ë“¤ì–´ Local, World ë“±ì— ì˜í–¥ì„ ë°›ì„ ì‹œ ì›€ì§ì„ì— ë”°ë¼ ë¹›ë°˜ì‚¬ë¥¼ í•˜ëŠ” ê²ƒì´ì•„ë‹ˆë¼ í•´ë‹¹ì¢Œí‘œê³„ì— ë”°ë¼ ë¹›ë°˜ì‚¬ë¥¼ í•˜ê¸°ì— ì–´ìƒ‰í•´ ì§„ë‹¤. ì˜ ì´í•´ëŠ” ì•ˆë˜ì§€ë§Œâ€¦ ë„˜ì–´ê°€ì(ê·¸ëƒ¥ ì“°ì)

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-20-1.png"/>
</p>

ğŸ± TangentView -> WorldView ì¢Œí‘œë³€í™˜ì„ ìœ„í•´ì„œ Binormal Vectorë¥¼ ì•Œì•„ì•¼í•˜ëŠ”ë° Normalì´ ì ‘í•œ í‰ë©´ì˜ ìˆ˜ì§ê°ì˜ Vectorë¼ë©´ Tangent Vectorì™€ Normalì˜ ë‚´ì ì´ë¼ ìƒê°í•˜ë©´ ëœë‹¤.

```
// Normal-Mapping Textureì˜ Tangent Space(ì¢Œí‘œê³„)ì—ì„œ View Spaceë¡œ ì˜®ê¸°ë ¤ë©´
// ì•„ë˜ Matrixë¥¼ ì—°ì‚°í•´ì£¼ë©´ëœë‹¤.
Tx Ty Tz    (Tangent x, y, z)
Bx By Bz    (Binormal x, y, z)
Nx Ny Nz    (Normal x, y, z)
```

```cpp
shared_ptr<Scene> SceneManager::LoadTestScene()
{
	// ...

    shared_ptr<Shader> shader = make_shared<Shader>();
    shared_ptr<Texture> texture = make_shared<Texture>();
    shared_ptr<Texture> texture2 = make_shared<Texture>();
    shader->Init(L"..\\Resources\\Shader\\default.hlsli");
    texture->Init(L"..\\Resources\\Texture\\Leather.jpg");
    
    // Normal Textureë¥¼ ë„£ëŠ”ë‹¤
    texture2->Init(L"..\\Resources\\Texture\\Leather_Normal.jpg");
```

```
cbuffer MATERIAL_PARAMS : register(b2)
{
    // ...

    // ì‰ì´ë”ì—ì„œëŠ” Texutreì˜ nullì²´í¬ê°€ ë¶ˆê°€ëŠ¥í•˜ê¸°ì—
    // onì´ë¼ëŠ” ë³€ìˆ˜ë¥¼ ë‘ì–´ nullì¸ì§€ ì•„ë‹Œì§€ í™•ì¸í•œë‹¤.
    int     g_tex_on_0;
    int     g_tex_on_1;

    // ...
};

Texture2D g_tex_0 : register(t0);
Texture2D g_tex_1 : register(t1);       // t1ì— normal textureë¥¼ ë„£ì–´ì¤„ ì˜ˆì •
Texture2D g_tex_2 : register(t2);

// ...
```

```cpp
void SetTexture(uint8 index, shared_ptr<Texture> texture) 
{ 
    _textures[index] = texture;
    // textureê°€ ì—†ë‹¤ë©´ 0 
    // ìˆë‹¤ë©´ 1ë¡œ ë„£ì–´ë‹¬ë¼
    _params.SetTexOn(index, (texture == nullptr ? 0 : 1));
}
```

```
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;

    // normal, tangent, binormalì„ ë„£ëŠ”ë‹¤
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);
    output.viewTangent = normalize(mul(float4(input.tangent, 0.f), g_matWV).xyz);
    output.viewBinormal = normalize(cross(output.viewTangent, output.viewNormal));

    return output;
}
```

```
float4 PS_Main(VS_OUT input) : SV_Target
{
    float4 color = float4(1.f, 1.f, 1.f, 1.f);
    if (g_tex_on_0)
        color = g_tex_0.Sample(g_sam_0, input.uv);

    float3 viewNormal = input.viewNormal;
    if (g_tex_on_1)
    {
        // [0,255] ë²”ìœ„ì—ì„œ [0,1]ë¡œ ë³€í™˜
        float3 tangentSpaceNormal = g_tex_1.Sample(g_sam_0, input.uv).xyz;
        // [0,1] ë²”ìœ„ì—ì„œ [-1,1]ë¡œ ë³€í™˜
        tangentSpaceNormal = (tangentSpaceNormal - 0.5f) * 2.f;

        // TBN ìˆœì„œë¡œ ìƒì„±ëœ Matrixë¥¼ ê³±í•´ì£¼ê²Œ ëœë‹¤.
        float3x3 matTBN = { input.viewTangent, 
                            input.viewBinormal, 
                            input.viewNormal };
                            /*
                                Tx Ty Tz    (Tangent x, y, z)
                                Bx By Bz    (Binormal x, y, z)
                                Nx Ny Nz    (Normal x, y, z)
                            */
        viewNormal = normalize(mul(tangentSpaceNormal, matTBN));
    }

    LightColor totalColor = (LightColor)0.f;

    for (int i = 0; i < g_lightCount; ++i)
    {
         LightColor color = CalculateLightColor(i, viewNormal, input.viewPos);
         totalColor.diffuse += color.diffuse;
         totalColor.ambient += color.ambient;
         totalColor.specular += color.specular;
    }

    color.xyz = (totalColor.diffuse.xyz * color.xyz)
        + totalColor.ambient.xyz * color.xyz
        + totalColor.specular.xyz;

     return color;
}
```