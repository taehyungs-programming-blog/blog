---
layout: default
title: "17. Singleton Pattern"
parent: (Desing Pattern)
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Singleton Pattern

ğŸ˜€ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ëŠ” ì˜¤ì§ í•˜ë‚˜ì„ì„ ë³´ì¥

```cpp
#include <iostream>
using namespace std;

class Cursor
{
    int x, y;
public:
};

int main()
{
    Cursor c1, c2;      // ì»¤ì„œëŠ” ì˜¤ì§ í•˜ë‚˜ë§Œ ë§Œë“¤ê³  ì‹¶ë‹¤
}
```

```cpp
class Cursor
{
    int x, y;
private:
    Cursor() {}
public:
    static Cursor& getInstance()
    {
        static Cursor instance;
        return instance;
    }
};

int main()
{
    Cursor& c1 = Cursor::getInstance();

    Cursor c3 = c1; 
    // ë³µì‚¬ ìƒì„±ìê°€ í˜¸ì¶œë˜ë©° ê°ì²´ê°€ ìƒì„±ë˜ì–´ ë²„ë¦°ë‹¤. -> ë³µì‚¬ìƒì„±ì ëŒ€ì…ìƒì„±ìë¥¼ ë§‰ì.
}
```

```cpp
class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
public:
    static Cursor& getInstance()
    {
        static Cursor instance;
        return instance;
    }
};
```

---

## ì¶”ê°€

ğŸ˜€ `getInstance`í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ì„œ

```cpp
// ë°©ë²• 1. static ë©¤ë²„ê°ì²´ë¡œ ë‘”ë‹¤.
class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;

    static Cursor instance;
public:
    static Cursor& getInstance()
    {
        return instance;
    }
};
Cursor Cursor::instance;
// ë¬¸ì œ. instanceë¥¼ í•œ ë²ˆë„ ì•ˆë¶ˆëŸ¬ë„ ë¬´ì¡°ê±´ ê°ì²´ê°€ ìƒì„±ëœë‹¤. -> ì˜¤ë²„í—¤ë“œì˜ ì›ì¸ì´ ë  ìˆ˜ ìˆë‹¤.
```

```cpp
// ë°©ë²• 2. static ì§€ì—­ë³€ìˆ˜ë¡œ ë‘”ë‹¤.
class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
public:
    static Cursor& getInstance()
    {
        static Cursor instance;
        return instance;
    }
};
```

```cpp
// ë°©ë²• 3. new ë¡œ ê°ì²´ë¥¼ ìƒì„±í•œë‹¤.
class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
    static Cursor* pInstance;
public:
    static Cursor& getInstance()
    {
        if(pInstance == 0) pInstance = new Cursur;
        return *instance;
    }
};
Cursor* Cursor::pInstance = 0;
```

---

## ë©€í‹°ì“°ë ˆë”©ì— ì•ˆì „í• ê¹Œ?

```cpp
class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
    static Cursor* pInstance;
public:
    static Cursor& getInstance()
    {
        if(pInstance == 0) pInstance = new Cursur;
        // ifë¥¼ ê²€ì‚¬í•˜ëŠ” ì‹œì ì— ë‹¤ë¥¸ threadì—ì„œ ë™ì‹œì— ifë¥¼ ê²€ì‚¬í•œë‹¤ë©´?
        // ê°ì²´ê°€ 2ê°œ ìƒì„±ë  ìˆ˜ ìˆë‹¤.
        return *instance;
    }
};
Cursor* Cursor::pInstance = 0;
```

```cpp
#include <iostream>
#include <mutex>
using namespace std;

class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
    static Cursor* pInstance;
    static mutex m;
public:
    static Cursor& getInstance()
    {
        m.lock();       
        // ê·¸ëŸ°ë° ì²˜ìŒì—ì•¼ lockì´ í•„ìš”í•˜ì§€ ì´í›„ëŠ” ê·¸ëƒ¥ ë¦¬í„´ë§Œí•˜ëŠ”ë° ë½ì„ ë§¤ë²ˆ ê²€ì‚¬í•´ì•¼í•˜ë‚˜??
        if(pInstance == 0) pInstance = new Cursur;
        m.unlock();
        return *instance;
    }
};
Cursor* Cursor::pInstance = 0;
mutex Cursor::m;
```

```cpp
#include <iostream>
#include <mutex>
using namespace std;

class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
    static Cursor* pInstance;
    static mutex m;
public:
    static Cursor& getInstance()
    {
        if(pInstance == 0)      // ê°ì²´ ìƒì„±ì„ ë‘ ë²ˆ ê²€ì‚¬í•œë‹¤. -> ì•„ë‹ˆ ifë¬¸ì„ ë‘ ë²ˆ íƒ€ëŠ”ê±°ë„ ë¬¸ì œì•„ë‹ˆì•¼??
        {
            m.lock();
            if(pInstance == 0) pInstance = new Cursur;
            // ê·¸ë¦¬ê³  ë©€í‹° ìŠ¤ë ˆë”© í™˜ê²½ì—ì„œ Cursorì˜ ìƒì„±ìê°€ ì™„ë£Œë˜ê¸° ì „
            // ë‹¤ë¥¸ threadì—ì„œ getInstanceë¥¼ í˜¸ì¶œí•´ ë²„ë¦´ ìˆ˜ ìˆë‹¤.
            m.unlock();
        }
        return *instance;
    }
};
Cursor* Cursor::pInstance = 0;
mutex Cursor::m;
```

ğŸ˜€ ì•„ë˜ì™€ ê°™ì€ ì½”ë”©ê¸°ë²•ì„ **DCLP(Double Check Locking Pattern)**ì´ë¼ í•œë‹¤. ë” ìƒì„¸í•œ ë‚´ìš©ì´ ê¶ê¸ˆí•˜ë©´ ê²€ìƒ‰í•´ë³´ì.

```cpp
class Cursor
{
    int x, y;
private:
    Cursor() {}
    Cursor(const Cursor&) = delete;
    void operator=(const Cursor&) = delete;
    static atomic<Cursor*> m_instance;
    static mutex m_mutex;
public:
    static Cursor& getInstance()
    {
        Cursor* tmp = m_instance.load();
        if(tmp == nullptr) {
            lock_guard<mutex> lock(m_mutex);
            tmp = m_instnace.load();
            if(tmp == nullptr) {
                tmp = new Cursor;
                m_instance.store(tmp);
            }
        }
        return *tmp;
    }
};
atomic<Cursor*> Cursor::m_instance;
mutex Cursor::m_mutex;
```

---

## singletonì˜ í™œìš©

```cpp
// ë°©ë²• 1. defineìœ¼ë¡œ ë§Œë“¤ì–´ ë‘ê¸°
#define MAKE_SINGLETON(classname)                \
private:                                         \
    classname() {}                               \
    classname(const classname&) = delete;        \
    void operator=(const classname&) = delete;   \
public:                                          \
    static classname& getInstance()              \
    {                                            \
        static classname instance;               \
        return instance;                         \
    }                                            \

class Cursor
{
    int x, y;
    MAKE_SINGLETON(Cursor)
};
```

```cpp
// ë°©ë²• 2. ìƒì†ì„ ì‚¬ìš©í•˜ê¸°(CRTP : Curiously Recurring Template Pattern)
template<typename TYPE> class Singleton
{
protected:
    Singleton() {}
    Singleton(const Singleton&) = delete;
    void operator=(const Singleton&) = delete;
public:
    static TYPE& getInstance()
    {
        static TYPE instance;
        return instance;
    }
};

class Mouse : public Singleton<Mouse>
{

};
```