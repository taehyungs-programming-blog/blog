---
layout: default
title: "01. 아키텍처"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Windows 아키텍쳐

```
+--------------------------------------------------+
|                  USER MODE (Ring 3)              |
+--------------------------------------------------+
|                   Application                    |
+--------------------------------------------------+
|         API Layer (Win32 API, C Runtime)         |
|  [Gdi32] [User32] [Kernel32] ...                 |
|                      |                           |
|                 [NtDll.dll]                      |
+----------------------|---------------------------+
                       |
                  System Call
                       ↓
+----------------------|---------------------------+
|                 KERNEL MODE (Ring 0)             |
+--------------------------------------------------+
| [Win32k.sys] | [Executive] | [Device Drivers]    |
+--------------+-------------+---------------------+
| [Kernel]     | [HAL]                             |
+--------------+-----------------------------------+
```

---

## Kernel Mode

### HAL (Hardware Abstract Layer)

* HAL (Hardware Abstraction Layer) 이란?
    * HAL은 운영체제(OS)의 커널과 실제 물리적인 하드웨어(CPU, 메인보드 칩셋 등) 사이에 위치하는 소프트웨어 계층

* HAL의 핵심 목적과 기능
    * 하드웨어의 차이 숨기기 (추상화)
    * 컴퓨터에 사용되는 하드웨어는 제조사(Intel, AMD 등)나 모델에 따라 명령을 처리하는 방식이 조금씩 다르다 
        * 예를 들어, 특정 CPU의 타이머를 제어하는 방식과 다른 CPU의 타이머를 제어하는 방식은 다를 수 있다

* HAL은 이러한 하드웨어 간의 차이점을 OS의 상위 계층(커널, 드라이버)으로부터 숨긴다
* 상위 계층은 하드웨어의 종류와 상관없이 **표준화된 함수(명령)**만을 사용

* 하드웨어 독립성 제공
* OS의 커널이나 드라이버는 HAL이 제공하는 표준 함수만 호출
    * 예를 들어 "인터럽트 활성화" 라는 표준 함수를 호출하면, HAL이 실제 하드웨어에 맞는 구체적인 명령을 실행

### Windows Executive

* Windows Executive 란?
    * Windows Executive는 Windows 커널 모드(Kernel Mode)의 핵심부로, **운영체제가 실제로 동작하는 데 필요한 대부분의 주요 관리** 서비스를 제공

* 가장 낮은 수준의 하드웨어 제어(HAL, Kernel) 바로 위에서 동작하며, 시스템 전체의 자원과 동작을 관리하고 감독하는 역할

* Executive의 주요 기능과 구성 요소
    * Executive는 여러 개의 독립적인 관리자(Manager) 컴포넌트로 구성되어 있으며, 각 관리자는 특정 기능을 전담.
    * 프로세스 및 스레드 관리 (Process Manager)
        * 프로그램의 실행 단위인 프로세스(Process)와 그 안에서 실제 작업을 수행하는 스레드(Thread)를 생성, 종료하고 관리
    * 메모리 관리 (Memory Manager)
        * 각 프로세스에 필요한 메모리(RAM)를 할당하고 회수
        * 실제 물리적인 메모리보다 더 큰 공간을 사용할 수 있도록 해주는 가상 메모리(Virtual Memory) 시스템을 관리
    * 입출력 관리 (I/O Manager)
        * 키보드, 마우스, 디스크, 네트워크 카드 등 모든 하드웨어 장치와의 데이터 입출력(I/O) 요청을 처리
        * 사용자 애플리케이션의 I/O 요청을 받아 적절한 장치 드라이버(Device Driver)로 전달하는 통로 역할
    * 보안 참조 모니터 (Security Reference Monitor)
        * 파일, 프로세스 등 시스템의 모든 자원에 대한 접근 권한을 검사하고 보안 정책을 시행
        * 사용자나 프로그램이 특정 작업을 수행할 권한이 있는지 매번 확인하는 역할을 합니다.

* Executive의 위치와 역할
    * "HAL, Kernel, Device Driver 기능을 기반으로 구현" 이라는 말의 의미는 다음과 같습니다.

* Windows Executive는 OS의 핵심 관리자로서, 하위 계층(Kernel, HAL, 드라이버)이 제공하는 기초적인 기능들을 조합하고 활용하여 프로세스, 메모리, I/O 등과 같은 더 복잡하고 고수준의 시스템 서비스를 구현하고 제공

---

## User Mode

### User32.dll

* User32.dll 이란?
    * User32.dll은 Windows 운영체제의 핵심 시스템 DLL 파일 중 하나로, 사용자 인터페이스(UI)와 관련된 기능을 담당하는 사용자 모드(User-Mode) 라이브러리
    * 애플리케이션이 화면에 창을 표시하고 사용자와 상호작용하는 데 필요한 대부분의 표준 함수(API)를 제공

* User32.dll의 주요 기능
    * 윈도우 창 생성 및 관리 (Window Management)
    * 애플리케이션이 화면에 창(Window)이나 버튼, 텍스트 박스와 같은 컨트롤을 생성, 표시, 이동, 크기 조절, 숨기거나 닫을 때 필요한 함수들을 제공
        * 예를 들어, 프로그램에서 CreateWindowEx 라는 API 함수를 호출하면, User32.dll이 이 요청을 받아 실제 화면에 창을 그리도록 시스템에 지시하는 역할
    * 사용자 입력 처리 (User Input Processing)
        * 키보드 입력, 마우스 움직임 및 클릭과 같은 물리적인 사용자 입력을 시스템으로부터 받는다
        * 이러한 입력이 발생했을 때, 해당 입력이 어떤 창에서 발생했는지를 판단하고, 그 입력 정보를 해당 창이 처리할 수 있는 형태로 가공하여 전달
    * Windows 메시지 처리 (Message Handling)

* User32.dll은 애플리케이션이 그래픽 사용자 인터페이스(GUI)를 구현하고, 사용자의 키보드/마우스 입력에 반응하여 동작하도록 만드는 데 필수적인 기능들을 모아놓은 핵심 라이브러리

---

### Kernel32.dll

* Kernel32.dll 이란?
    * Kernel32.dll은 Windows의 가장 기본적인 시스템 서비스를 사용자 모드(User-Mode) 애플리케이션에 노출하는 핵심 시스템 DLL 
    * 운영체제의 심장부인 커널(Kernel)이 제공하는 근본적인 기능들을 애플리케이션이 사용할 수 있도록 하는 관문(Gateway) 역할

* Kernel32.dll의 주요 기능
    * 유저모드 측 API 노출 (User-Mode API Exposure)

    * "커널에서 제공하는 시스템 서비스의 유저모드 측 API 노출"이란, 실제 핵심 기능은 보안 영역인 커널 모드(Kernel-Mode)에 있지만, 일반 애플리케이션이 이 기능들을 안전하게 호출할 수 있도록 사용자 모드용 함수 인터페이스를 제공

* 예를 들어, 애플리케이션이 CreateFile 함수(Kernel32.dll에 포함)를 호출하면, Kernel32.dll은 이 요청을 받아 시스템 콜(System Call)을 통해 커널 모드로 전환하고, 커널 내의 I/O 관리자가 실제 파일 작업을 수행 지시

* 프로세스와 스레드 관리 (Process and Thread Management)
* 파일 I/O 작업 (File I/O Operations)
* 메모리 할당 및 관리 (Memory Allocation and Management)

---

### Win32k.sys

* Win32k.sys 란?
    * Win32k.sys는 Windows의 그래픽 사용자 인터페이스(GUI)와 윈도우 관리 시스템의 핵심 기능이 구현되어 있는 커널 모드(Kernel-Mode) 드라이버
    * 파일 확장자인 .sys는 이 파일이 사용자 모드가 아닌, 시스템의 모든 권한을 가진 커널 모드에서 실행되는 시스템 파일임을 의미

* Win32k.sys의 핵심 역할
    * GUI의 커널 모드 측 구현 (Kernel-Mode GUI Implementation)
        * 화면에 창을 그리거나, 마우스 커서를 움직이거나, 텍스트를 렌더링하는 작업은 최종적으로 그래픽 하드웨어(그래픽 카드)에 직접 명령을 내려야 합니다.
        * 하드웨어 제어는 커널 모드의 고유 권한이므로, GUI와 관련된 핵심적이고 성능에 민감한 작업들은 Win32k.sys가 커널 모드에서 직접 처리합니다.
        * 이를 통해 사용자 모드와 커널 모드 간의 비싼 전환(Context Switching) 횟수를 줄여 GUI 성능을 크게 향상시킬 수 있습니다.

* GDI32.dll과 User32.dll의 실제 구현 (Actual Implementation)
    * 이것이 Win32k.sys의 가장 중요한 역할
    * 애플리케이션이 사용자 모드에서 User32.dll의 CreateWindow (창 생성) 함수나 GDI32.dll의 DrawText (텍스트 그리기) 함수를 호출하면, 이 DLL들은 요청을 받아 간단한 유효성 검사 등을 수행한 뒤, 시스템 콜(System Call)을 통해 커널 모드로 전환하여 Win32k.sys에 있는 실제 구현 코드를 호출합니다.
* 흐름:
    * 애플리케이션 → User32.dll!CreateWindow 호출
    * User32.dll → 시스템 콜 실행
    * (커널 모드 전환)
    * Win32k.sys → 실제 창 생성 로직 실행, 윈도우 객체 관리

* 즉, User32.dll과 GDI32.dll은 애플리케이션 개발자를 위한 '창구' 또는 '프록시(Proxy)' 역할을 하고, 그 요청을 받아 실질적인 작업을 처리하는 '엔진' 은 바로 Win32k.sys

---

### Ntdll.dll

* Ntdll.dll 이란?
    * Ntdll.dll은 사용자 모드(User-Mode)와 커널 모드(Kernel-Mode)를 잇는 가장 낮은 수준의 인터페이스 역할을 하는 핵심 시스템 DLL
    * 모든 사용자 모드 애플리케이션이나 다른 상위 DLL들이 커널의 서비스를 이용하기 위해 거쳐야 하는 최종 관문.

* Ntdll.dll의 주요 기능
    * 커널 모드-유저 모드 간의 중간 계층 (Intermediate Layer)
        * Ntdll.dll의 가장 핵심적인 역할은 사용자 모드에서의 함수 호출을 커널 모드로 전달
        * 애플리케이션이나 Kernel32.dll과 같은 상위 DLL이 커널의 기능이 필요한 함수를 호출하면, 최종적으로 Ntdll.dll 내의 해당 함수(주로 'Nt' 또는 'Zw' 접두사가 붙음)가 호출
        * 이 함수는 필요한 파라미터를 준비한 뒤, CPU에 'syscall' 같은 특수 명령을 실행하여 사용자 모드에서 커널 모드로의 전환(Context Switching)을 유발
    * 네이티브 API 지원 (Native API Support)
        * Ntdll.dll은 Windows "네이티브 API(Native API)"를 포함. 
        * 이것은 잘 알려진 Win32 API(Kernel32, User32 등에 있는)보다 더 낮은 수준의, 커널과 직접적으로 통신하기 위해 설계된 API 집합
        * 많은 Win32 API 함수들은 내부적으로 이 네이티브 API들을 호출하여 구현
        * 예를 들어, Kernel32.dll의 HeapAlloc 같은 함수도 내부적으로는 Ntdll.dll의 RtlAllocateHeap과 같은 더 근본적인 함수를 호출
    * 시스템 콜 전 파라미터 검증 (Parameter Validation)
        * 커널 모드로 전환하는 것은 비용이 많이 드는 작업이며, 잘못된 파라미터가 커널로 전달되면 시스템 전체에 심각한 문제를 일으킬 수 있습니다.
        * Ntdll.dll은 시스템 콜을 발생시키기 전에 전달된 파라미터들이 유효한지(예: 포인터가 유효한 주소인지 등)를 미리 검증하는 역할

---

### C-Runtime Library (CRT)

* C-Runtime Library (CRT) 란?
    * C 런타임 라이브러리(C-Runtime Library, 줄여서 CRT)는 C/C++ 언어 명세에 정의된 표준 함수들을 구현하여 모아놓은 라이브러리
    * C/C++로 작성된 프로그램이 실행되는 데 필요한 가장 기본적인 기능들을 제공

* CRT의 주요 역할과 특징
    * C 표준 함수 지원 (Support for Standard C Functions)
    * C 언어 표준에 명시된 모든 기본 함수들을 포함
    * 예를 들어, 콘솔에 텍스트를 출력하는 printf(), 문자열을 복사하는 strcpy(), 메모리를 동적으로 할당하는 malloc() 과 같은 함수들이 모두 CRT에 의해 제공
    * 이러한 표준 함수를 사용함으로써 개발자는 운영체제에 종속적인 코드를 직접 작성하지 않고도, 다양한 플랫폼에서 동작할 수 있는 이식성 높은 프로그램을 만들 수 있다.

* Windows API를 통한 내부 구현 (Internal Implementation via Windows API)
    * CRT는 독립적으로 모든 것을 처리하는 것이 아니라, Windows 환경에서는 내부적으로 Windows API를 호출하여 자신의 기능을 구현
    * 예를 들어, 개발자가 CRT 함수인 fopen()을 호출하여 파일을 열면, CRT 라이브러리 내부에서는 Kernel32.dll에 있는 Windows API 함수인 CreateFile()을 호출하여 실제 운영체제 수준의 파일 열기 작업을 수행
    * 즉, CRT는 개발자에게는 표준화된 인터페이스를 제공하고, 실제 구현은 해당 운영체제의 API를 활용하는 '래퍼(Wrapper)' 역할

