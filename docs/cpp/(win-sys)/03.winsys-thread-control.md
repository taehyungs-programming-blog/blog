---
layout: default
title: "03. Thread Control"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 이렇게 쓰지는 말자

```
          ┌─────────┐
          │         │
          ▼         │
    ┌──────────┐    │
    │ Thread A │    │
    └──────────┘    │
          │         │
          ▼         │
          ┌─────────┘
          │
          │         ┌─────────┐
          │         │         │
          ▼         │         ▼
    ┌──────────────────┐    ┌──────────┐
    │    variable      │◄───┤ Thread B │
    └──────────────────┘    └──────────┘
                              │         ▲
                              │         │
                              └─────────┘
```

```cpp
#include <iostream>
#include <atomic>
#include <thread>
#include <chrono>

std::atomic<int> shared_variable{0};

// Thread A: 변수를 10번 변경
void thread_a() {
    for (int i = 0; i < 10; i++) {
        shared_variable.store(i, std::memory_order_release);
        std::cout << "Thread A: 변수를 " << i << "로 변경\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

// Thread B: 변수를 계속 감시 (Busy-Waiting)
void thread_b() {
    int last_value = -1;
    int detected_changes = 0;
    
    for (int i = 0; i < 100; i++) {
        int current = shared_variable.load(std::memory_order_acquire);
        if (current != last_value) {
            detected_changes++;
            std::cout << "Thread B: 변경 감지 (" << current << ")\n";
            last_value = current;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        // CPU를 낭비하며 계속 polling
    }
    
    std::cout << "\nThread B가 감지한 변경: " << detected_changes 
              << "번 (실제는 10번)\n";
}

int main() {
    std::thread t_a(thread_a);
    std::thread t_b(thread_b);
    
    t_a.join();
    t_b.join();
    
    return 0;
}
```

### 왜 이렇게 쓰면 안될까?

#### 변경 횟수 불일치 문제

```cpp
// Thread A가 빠르게 변경
shared_variable.store(1);
shared_variable.store(2);  // Thread B가 체크하기 전에 덮어씀
shared_variable.store(3);
shared_variable.store(4);

// Thread B는 1을 놓치고 4만 볼 수 있음
// 중간 값들은 사라짐!
```

#### 타이밍 제어 불가능

```cpp
// Thread A: 10번 변경
// Thread B: 4번만 감지 (타이밍에 따라 매번 다름)
// 어떤 값을 놓칠지 예측 불가능
```

#### CPU 자원 낭비 (Busy-Waiting)

```cpp
// 계속 루프를 돌며 확인 -> CPU 100% 사용
while (true) {
    int value = shared_variable.load();
    // 변화 없어도 계속 실행됨!
}
```

### 해결법? (간단 버전)

#### queue 쓰기

```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <optional>

template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue_;
    mutable std::mutex mutex_;
    std::condition_variable cv_;
    
public:
    void push(T value) {
        {
            std::lock_guard<std::mutex> lock(mutex_);
            queue_.push(std::move(value));
        }
        cv_.notify_one();
    }
    
    std::optional<T> pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return !queue_.empty(); });
        
        T value = std::move(queue_.front());
        queue_.pop();
        return value;
    }
};

ThreadSafeQueue<int> message_queue;

void thread_a() {
    for (int i = 0; i < 10; i++) {
        message_queue.push(i);  // 모든 값이 큐에 저장됨!
        std::cout << "Thread A: " << i << " 전송\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
    message_queue.push(-1);  // 종료 신호
}

void thread_b() {
    int received = 0;
    while (true) {
        auto value = message_queue.pop();  // 블로킹, CPU 안 씀!
        if (value == -1) break;
        
        std::cout << "Thread B: " << *value << " 수신\n";
        received++;
    }
    std::cout << "\nThread B가 받은 메시지: " << received << "번 ✓ (모두 받음!)\n";
}

int main() {
    std::thread t_a(thread_a);
    std::thread t_b(thread_b);
    
    t_a.join();
    t_b.join();
    
    return 0;
}
```

#### future/promise 쓰기

```cpp
#include <iostream>
#include <thread>
#include <future>
#include <vector>

void thread_a(std::vector<std::promise<int>>& promises) {
    for (int i = 0; i < 10; i++) {
        promises[i].set_value(i);
        std::cout << "Thread A: " << i << " 전송\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

void thread_b(std::vector<std::future<int>>& futures) {
    for (int i = 0; i < 10; i++) {
        int value = futures[i].get();  // 블로킹
        std::cout << "Thread B: " << value << " 수신\n";
    }
    std::cout << "\nThread B가 받은 메시지: 10번 ✓\n";
}

int main() {
    std::vector<std::promise<int>> promises(10);
    std::vector<std::future<int>> futures;
    
    for (auto& p : promises) {
        futures.push_back(p.get_future());
    }
    
    std::thread t_a(thread_a, std::ref(promises));
    std::thread t_b(thread_b, std::ref(futures));
    
    t_a.join();
    t_b.join();
    
    return 0;
}
```

---

## Tips) Thread Pool 아이디어

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          Main Thread                                     │
│  ┌────────────────────────────────────────────────────────────────┐    │
│  │ for (DWORD i=0; i<4; i++)                                      │    │
│  │ {                                                               │    │
│  │     SetEvent(pThreadDescList[i].hEventList[0]);                │    │
│  │ }                                                               │    │
│  └────────────────────────────────────────────────────────────────┘    │
└──────────────┬───────────────────┬────────────────┬──────────────┬──────┘
               │                   │                │              │
               │                   │                │              │
               ▼                   ▼                ▼              ▼
        ┌─────────────┐     ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
        │   Wait...   │     │   Wait...   │  │   Wait...   │  │   Wait...   │
        ├─┬─┬─┬─┐    │     ├─┬─┬─┬─┐    │  ├─┬─┬─┬─┐    │  ├─┬─┬─┬─┐    │
        │0│1│2│3│◄───┘     │0│1│2│3│◄───┘  │0│1│2│3│◄───┘  │0│1│2│3│◄───┘
        └─┴─┴─┴─┘          └─┴─┴─┴─┘       └─┴─┴─┴─┘       └─┴─┴─┴─┘
       Event Table        Event Table     Event Table     Event Table
            │                  │               │               │
┌───────────┼──────────────────┼───────────────┼───────────────┼───────────┐
│           │                  │               │               │           │
│  ┌────────▼────────┐  ┌──────▼──────┐  ┌────▼────────┐  ┌──▼──────────┐│
│  │ Worker Thread(0)│  │Worker Thread│  │Worker Thread│  │Worker Thread││
│  │                 │  │     (1)     │  │     (2)     │  │     (3)     ││
│  ├─────────────────┤  ├─────────────┤  ├─────────────┤  ├─────────────┤│
│  │WaitForMultiple  │  │WaitForMulti │  │WaitForMulti │  │WaitForMulti ││
│  │   Objects()     │  │  pleObjects │  │ pleObjects  │  │ pleObjects  ││
│  └────────┬────────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘│
│           │                  │                │                │        │
│           ▼                  ▼                ▼                ▼        │
│  ┌─────────────────┐ ┌─────────────┐  ┌─────────────┐  ┌─────────────┐│
│  │ Switch (Index)  │ │Switch (Idx) │  │Switch (Idx) │  │Switch (Idx) ││
│  ├─────────────────┤ ├─────────────┤  ├─────────────┤  ├─────────────┤│
│  │ case 0:         │ │ case 0:     │  │ case 0:     │  │ case 0:     ││
│  │  ProcessEvent_0│ │  Process    │  │  Process    │  │  Process    ││
│  │  break;         │ │  Event_0(); │  │  Event_0(); │  │  Event_0(); ││
│  │ case 1:         │ │  break;     │  │  break;     │  │  break;     ││
│  │  ProcessEvent_1│ │ case 1:     │  │ case 1:     │  │ case 1:     ││
│  │  break;         │ │  Process    │  │  Process    │  │  Process    ││
│  │ case 2:         │ │  Event_1(); │  │  Event_1(); │  │  Event_1(); ││
│  │  ProcessEvent_2│ │  break;     │  │  break;     │  │  break;     ││
│  │  break;         │ │ case 2:     │  │ case 2:     │  │ case 2:     ││
│  │ case 3:         │ │  Process    │  │  Process    │  │  Process    ││
│  │  endthread();   │ │  Event_2(); │  │  Event_2(); │  │  Event_2(); ││
│  │  return 0;      │ │  break;     │  │  break;     │  │  break;     ││
│  │ }               │ │ case 3:     │  │ case 3:     │  │ case 3:     ││
│  └─────────────────┘ │  endthread│  │  endthread  │  │  endthread  ││
│                      │  return 0;  │  │  return 0;  │  │  return 0;  ││
│                      │ }           │  │ }           │  │ }           ││
│                      └─────────────┘  └─────────────┘  └─────────────┘│
└───────────────────────────────────────────────────────────────────────────┘
```