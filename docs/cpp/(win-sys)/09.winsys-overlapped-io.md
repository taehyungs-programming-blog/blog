---
layout: default
title: "09. Overlapped IO"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* Overlapped I/O는 Windows에서 제공하는 비동기(Asynchronous) I/O 방식
* 일반적인 동기 I/O와 달리, I/O 작업이 완료될 때까지 스레드가 블로킹되지 않고 즉시 반환되어 다른 작업을 수행

---

## Cf. 동기 방식

```cpp
BOOL TestWriteFile(float* pfOutElapsedTick, const char* pData, DWORD dwSize, const WCHAR* wchFileName)
{
    BOOL bResult = FALSE;

    HANDLE hFile = CreateFile(wchFileName, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, nullptr);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        DWORD dwWrittenBytes = 0;
        bResult = WriteFile(hFile, pData, dwSize, &dwWrittenBytes, nullptr);

        if (!bResult)
        {
            DWORD dwErr = GetLastError();
            __debugbreak();
        }
     
        CloseHandle(hFile);
        hFile = nullptr;
    }
    return bResult;
}
```

---

## 비동기(Overlapped) 방식

```cpp
BOOL TestWriteFileOverlapped(float* pfOutElapsedTick, const char* pData, DWORD dwSize, const WCHAR* wchFileName)
{
    BOOL bResult = FALSE;
    
    HANDLE hFile = CreateFile(wchFileName, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, 
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH,  // FILE_FLAG_OVERLAPPED 주목
                                nullptr);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        OVERLAPPED ovl = {};    // 이 함수를 벗어나기 전에 I/O가 완료되기 때문에 스택에 변수를 할당한 것임!!!
        ovl.Offset = (DWORD)(-1);
        ovl.OffsetHigh = (DWORD)(-1);

        bResult = WriteFile(hFile, pData, dwSize, nullptr, &ovl);

        if (!bResult)
        {
            DWORD dwErr = GetLastError();
            if (ERROR_IO_PENDING != dwErr)
                __debugbreak();
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////
        // WriteFile()이 즉시 리턴하므로 GetOverlappedResult()를 호출해서 결과를 확인할 때까지 다른 작업을 할 수 있다.
        ////////////////////////////////////////////////////////////////////////////////////////////////////////

        DWORD dwWrittenBytes = 0;
        if (GetOverlappedResult(hFile, &ovl, &dwWrittenBytes, TRUE))
        //                                                    ^^^^
        //                                      TRUE = 완료될 때까지 대기
        //                                      FALSE = 즉시 반환 (완료 여부만 확인)
        {
            bResult = TRUE;
        }
        else
        {
            DWORD dwErr = GetLastError();
            __debugbreak();
        }

        CloseHandle(hFile);
        hFile = nullptr;
    }
    return bResult;
```

### OVERLAPPED 구조체의 Offset 필드 상세 설명

```cpp
typedef struct _OVERLAPPED {
    ULONG_PTR Internal;        // 시스템 예약 (I/O 상태)
    ULONG_PTR InternalHigh;    // 시스템 예약 (전송된 바이트 수)
    union {
        struct {
            DWORD Offset;      // 파일 오프셋 하위 32비트
            DWORD OffsetHigh;  // 파일 오프셋 상위 32비트
        };
        PVOID Pointer;
    };
    HANDLE hEvent;             // 완료 알림용 이벤트
} OVERLAPPED;
```

* 왜 64비트 오프셋이 필요한가?
    * 파일 크기가 4GB(2³² 바이트)를 초과할 수 있기 때문

| 비트 수 | 최대 표현 가능 크기 |
|:---|:---|
| 32비트 (DWORD) | 4GB (4,294,967,295 바이트) |
| 64비트 (Offset + OffsetHigh) | 16EB (18,446,744,073,709,551,615 바이트) |

