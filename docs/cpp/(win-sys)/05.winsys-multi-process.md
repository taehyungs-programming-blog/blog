---
layout: default
title: "05. Multi Process Programming"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## File Mapping(Shared Memory)

* Shared Memory는 File Mapping 객체를 이용하여 서로 다른 프로세스들이 동일한 물리 메모리를 공유하는 IPC(Inter-Process Communication) 기법

```
┌─────────────────────┐     ┌─────────────────────┐
│     Process A       │     │     Process B       │
│  (Writer Process)   │     │  (Reader Process)   │
├─────────────────────┤     ├─────────────────────┤
│  Virtual Address    │     │  Virtual Address    │
│    0x10000000       │     │    0x20000000       │
│         │           │     │         │           │
│    Page Table       │     │    Page Table       │
│         │           │     │         │           │
└─────────┼───────────┘     └─────────┼───────────┘
          │                           │
          └───────────┬───────────────┘
                      ▼
          ┌───────────────────────┐
          │    Physical Memory    │
          │   (Shared Region)     │
          │    or Paging File     │
          └───────────────────────┘
```

* `CreateFileMapping()` - 파일 맵핑 객체 생성 (Writer)
* `OpenFileMapping()` - 이미 생성된 파일 맵핑 객체 열기 (Reader)
* `MapViewOfFile()` - 파일 맵핑을 프로세스의 가상 주소 공간에 매핑
* `UnmapViewOfFile()` - 매핑된 뷰 해제
* `CloseHandle()` - 파일 맵핑 핸들 닫기

```cpp
HANDLE CreateFileMapping(
    HANDLE hFile,           // 파일 핸들 (INVALID_HANDLE_VALUE = 페이징 파일 사용)
    LPSECURITY_ATTRIBUTES lpAttr,  // 보안 속성
    DWORD flProtect,        // 보호 속성 (PAGE_READWRITE, PAGE_READONLY 등)
    DWORD dwMaxSizeHigh,    // 최대 크기 상위 32비트
    DWORD dwMaxSizeLow,     // 최대 크기 하위 32비트
    LPCWSTR lpName          // 객체 이름 (프로세스간 공유용)
);
```

```cpp
HANDLE OpenFileMapping(
    DWORD dwDesiredAccess,  // 접근 권한 (FILE_MAP_ALL_ACCESS, FILE_MAP_READ 등)
    BOOL bInheritHandle,    // 핸들 상속 여부
    LPCWSTR lpName          // 객체 이름
);
```

```cpp
LPVOID MapViewOfFile(
    HANDLE hFileMappingObject,  // 파일 맵핑 핸들
    DWORD dwDesiredAccess,      // 접근 권한
    DWORD dwFileOffsetHigh,     // 오프셋 상위
    DWORD dwFileOffsetLow,      // 오프셋 하위
    SIZE_T dwNumberOfBytesToMap // 매핑할 바이트 수 (0 = 전체)
);
```

### Example

```cpp
#include <Windows.h>
#include <stdio.h>

// 공유 메모리 헤더 구조체
struct MEM_HEADER
{
    DWORD dwMaxMemSize;    // 최대 메모리 크기
    DWORD dwCurSize;       // 현재 사용 크기
    DWORD dwItemCount;     // 아이템 개수
    const char pReadDataEntry[0];  // 데이터 시작점 (가변 배열)
};

HANDLE g_hMemMap = nullptr;
HANDLE g_hMutex = nullptr;
MEM_HEADER* g_pWriteMemory = nullptr;

// 공유 메모리 초기화
BOOL InitSharedMemory(const WCHAR* wchMemoryMappedFileName, 
                      const WCHAR* wchMutexName, 
                      DWORD dwMaxMemSize)
{
    // 1. 파일 맵핑 객체 생성 (INVALID_HANDLE_VALUE = 페이징 파일 사용)
    g_hMemMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,   // 페이징 파일 사용
        NULL,                   // 기본 보안 속성
        PAGE_READWRITE,         // 읽기/쓰기 가능
        0,                      // 크기 상위 32비트
        dwMaxMemSize,           // 크기 하위 32비트
        wchMemoryMappedFileName // 이름 (다른 프로세스가 이 이름으로 열기)
    );
    if (!g_hMemMap) return FALSE;

    // 동기화용 Mutex 생성
    g_hMutex = CreateMutex(nullptr, FALSE, wchMutexName);

    // 2. 가상 주소 공간에 매핑
    g_pWriteMemory = (MEM_HEADER*)MapViewOfFile(
        g_hMemMap,          // 파일 맵핑 핸들
        FILE_MAP_WRITE,     // 쓰기 접근
        0, 0,               // 오프셋
        dwMaxMemSize        // 매핑 크기
    );
    if (!g_pWriteMemory) return FALSE;

    // 헤더 초기화
    g_pWriteMemory->dwMaxMemSize = dwMaxMemSize;
    g_pWriteMemory->dwCurSize = sizeof(MEM_HEADER);
    g_pWriteMemory->dwItemCount = 0;

    return TRUE;
}

// 공유 메모리에 데이터 쓰기
BOOL WriteToSharedMemory(const WCHAR* wchStr, DWORD dwLen)
{
    BOOL bResult = FALSE;
    DWORD dwRequiredMemSize = sizeof(DWORD) + (dwLen + 1) * sizeof(WCHAR);

    // Mutex로 동기화
    WaitForSingleObject(g_hMutex, INFINITE);

    if (g_pWriteMemory->dwCurSize + dwRequiredMemSize <= g_pWriteMemory->dwMaxMemSize)
    {
        char* pDest = (char*)g_pWriteMemory + g_pWriteMemory->dwCurSize;
        
        // 길이 저장
        *(DWORD*)pDest = dwLen;
        pDest += sizeof(DWORD);
        
        // 문자열 복사
        memcpy(pDest, wchStr, sizeof(WCHAR) * dwLen);
        pDest += sizeof(WCHAR) * dwLen;
        
        // null terminator
        *(WCHAR*)pDest = 0;

        g_pWriteMemory->dwCurSize += dwRequiredMemSize;
        g_pWriteMemory->dwItemCount++;
        bResult = TRUE;
    }

    ReleaseMutex(g_hMutex);
    return bResult;
}

// 공유 메모리 정리
void CleanupSharedMemory()
{
    // 3. 뷰 해제
    if (g_pWriteMemory)
    {
        UnmapViewOfFile(g_pWriteMemory);
        g_pWriteMemory = nullptr;
    }
    // 4. 핸들 닫기
    if (g_hMemMap)
    {
        CloseHandle(g_hMemMap);
        g_hMemMap = nullptr;
    }
    if (g_hMutex)
    {
        CloseHandle(g_hMutex);
        g_hMutex = nullptr;
    }
}
```

```cpp
#include <Windows.h>
#include <stdio.h>

struct MEM_HEADER
{
    DWORD dwMaxMemSize;
    DWORD dwCurSize;
    DWORD dwItemCount;
    const char pReadDataEntry[0];
};

HANDLE g_hMemMap = nullptr;
HANDLE g_hMutex = nullptr;
const MEM_HEADER* g_pReadMemory = nullptr;

// 공유 메모리 열기
BOOL InitSharedMemory(const WCHAR* wchMemoryMappedFileName, 
                      const WCHAR* wchMutexName, 
                      DWORD dwMaxMemSize)
{
    // 1. 이미 생성된 파일 맵핑 객체 열기
    g_hMemMap = OpenFileMapping(
        FILE_MAP_ALL_ACCESS,        // 접근 권한
        FALSE,                      // 핸들 상속 안함
        wchMemoryMappedFileName     // 이름 (Writer가 생성한 이름과 동일)
    );
    if (!g_hMemMap) return FALSE;

    // 동기화용 Mutex 열기
    g_hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, wchMutexName);
    if (!g_hMutex) return FALSE;

    // 2. 가상 주소 공간에 매핑
    g_pReadMemory = (const MEM_HEADER*)MapViewOfFile(
        g_hMemMap,
        FILE_MAP_ALL_ACCESS,
        0, 0,
        dwMaxMemSize
    );
    if (!g_pReadMemory) return FALSE;

    return TRUE;
}

// 공유 메모리에서 데이터 읽기
DWORD ReadSharedMemory(char* pDest, DWORD dwMaxMemSize)
{
    DWORD dwReadSize = 0;

    if (!g_hMemMap || !g_pReadMemory)
        return 0;

    // Mutex로 동기화
    WaitForSingleObject(g_hMutex, INFINITE);

    // 공유 메모리 내용을 로컬 버퍼로 복사
    memcpy(pDest, g_pReadMemory, g_pReadMemory->dwCurSize);
    dwReadSize = g_pReadMemory->dwCurSize;

    ReleaseMutex(g_hMutex);

    return dwReadSize;
}

// 공유 메모리 정리
void CleanupSharedMemory()
{
    if (g_hMutex)
    {
        CloseHandle(g_hMutex);
        g_hMutex = nullptr;
    }
    // 3. 뷰 해제
    if (g_pReadMemory)
    {
        UnmapViewOfFile(g_pReadMemory);
        g_pReadMemory = nullptr;
    }
    // 4. 핸들 닫기
    if (g_hMemMap)
    {
        CloseHandle(g_hMemMap);
        g_hMemMap = nullptr;
    }
}
```

---

## Named Pipe

* 특징
    * 양방향 통신 - PIPE_ACCESS_DUPLEX 플래그로 양방향(full-duplex) 통신 가능
    * 파일 API 사용 - ReadFile() / WriteFile() 함수로 데이터 송수신
    * 데이터 무결성 - TCP처럼 데이터 유실 없음 (신뢰성 있는 통신)
    * 메시지 모드 지원 - PIPE_TYPE_MESSAGE로 메시지 경계 유지 가능

* TCP Socket으로 치면
    * CreateNamedPipe() - socket() + bind() + listen()
    * ConnectNamedPipe() - accept()
    * CreateFile() (클라이언트) - connect()
    * ReadFile() / WriteFile() - recv() / send()
    * CloseHandle() - closesocket()

### Example

```
┌─────────────────────┐                    ┌─────────────────────┐
│       SERVER        │                    │       CLIENT        │
├─────────────────────┤                    ├─────────────────────┤
│ CreateNamedPipe()   │                    │                     │
│         ↓           │                    │                     │
│ ConnectNamedPipe()  │◄───── 연결 ───────│ CreateFile()        │
│    (대기 중...)     │                    │                     │
│         ↓           │                    │         ↓           │
│ WriteFile() ────────┼───── 데이터 ──────►│ ReadFile()          │
│         ↓           │                    │         ↓           │
│ ReadFile() ◄────────┼───── 데이터 ───────│ WriteFile()         │
│         ↓           │                    │         ↓           │
│ CloseHandle()       │                    │ CloseHandle()       │
└─────────────────────┘                    └─────────────────────┘
```

```cpp
#include <Windows.h>
#include <stdio.h>

// Named Pipe 생성 및 클라이언트 연결 대기
HANDLE InitNamedPipeAsServer(DWORD dwRecvBufferSize, DWORD dwSendBufferSize)
{
    // PIPE_ACCESS_DUPLEX: 양방향 통신
    // PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE: 메시지 단위로 송수신
    // PIPE_WAIT: 블로킹 모드
    HANDLE hPipe = CreateNamedPipe(
        L"\\\\.\\pipe\\MyNamedPipe",           // Pipe 이름
        PIPE_ACCESS_DUPLEX,                     // 양방향 통신
        PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES,               // 최대 인스턴스 수
        dwSendBufferSize,                       // 출력 버퍼 크기
        dwRecvBufferSize,                       // 입력 버퍼 크기
        0,                                      // 기본 타임아웃
        nullptr                                 // 보안 속성
    );

    if (INVALID_HANDLE_VALUE == hPipe)
        return hPipe;

    // 클라이언트 연결 대기 (TCP의 accept()와 유사)
    if (!ConnectNamedPipe(hPipe, nullptr))
    {
        CloseHandle(hPipe);
        return INVALID_HANDLE_VALUE;
    }
    
    return hPipe;
}

int main()
{
    wprintf_s(L"Named Pipe Server 시작...\n");

    HANDLE hPipe = InitNamedPipeAsServer(1024, 1024);
    if (INVALID_HANDLE_VALUE != hPipe)
    {
        wprintf_s(L"클라이언트 연결됨!\n");

        // 데이터 송신 (WriteFile 사용)
        PIPE_MSG msg;
        msg.dwStrLen = swprintf_s(msg.wchStr, L"Hello from Server!");

        DWORD dwWrittenBytes = 0;
        if (WriteFile(hPipe, &msg, msg.GetPacketSize(), &dwWrittenBytes, nullptr))
        {
            wprintf_s(L"데이터 전송 성공: %u bytes\n", dwWrittenBytes);
        }

        // 데이터 수신 (ReadFile 사용)
        PIPE_MSG recvMsg = {};
        DWORD dwReadBytes = 0;
        if (ReadFile(hPipe, &recvMsg, sizeof(recvMsg), &dwReadBytes, nullptr))
        {
            wprintf_s(L"수신 메시지: %s\n", recvMsg.wchStr);
        }

        CloseHandle(hPipe);
    }
    return 0;
}
```

```cpp
#include <Windows.h>
#include <stdio.h>

// Named Pipe에 연결 (TCP의 connect()와 유사)
HANDLE InitNamedPipeAsClient()
{
    HANDLE hPipe = CreateFile(
        L"\\\\.\\pipe\\MyNamedPipe",    // Pipe 이름
        GENERIC_READ | GENERIC_WRITE,    // 읽기/쓰기 권한 (양방향)
        0,                               // 공유 모드 없음
        NULL,                            // 기본 보안 속성
        OPEN_EXISTING,                   // 기존 파이프에 연결
        0,                               // 플래그
        nullptr                          // 템플릿 파일 없음
    );
    
    return hPipe;
}

int main()
{
    wprintf_s(L"Named Pipe Client 시작...\n");

    HANDLE hPipe = InitNamedPipeAsClient();
    if (INVALID_HANDLE_VALUE != hPipe)
    {
        wprintf_s(L"서버에 연결됨!\n");

        // 데이터 수신 (ReadFile 사용)
        PIPE_MSG recvMsg = {};
        DWORD dwReadBytes = 0;
        if (ReadFile(hPipe, &recvMsg, sizeof(recvMsg), &dwReadBytes, nullptr))
        {
            wprintf_s(L"수신 메시지: %s\n", recvMsg.wchStr);
        }

        // 데이터 송신 (WriteFile 사용) - 양방향 통신!
        PIPE_MSG sendMsg;
        sendMsg.dwStrLen = swprintf_s(sendMsg.wchStr, L"Hello from Client!");
        
        DWORD dwWrittenBytes = 0;
        if (WriteFile(hPipe, &sendMsg, sendMsg.GetPacketSize(), &dwWrittenBytes, nullptr))
        {
            wprintf_s(L"데이터 전송 성공: %u bytes\n", dwWrittenBytes);
        }

        CloseHandle(hPipe);
    }
    return 0;
}
```

---

## Named Pipe vs File Mapping(Shared Memory) 비교

| 구분 | Named Pipe | File Mapping (Shared Memory) |
| :--- | :--- | :--- |
| **통신 모델** | 스트림/메시지 기반 (데이터 흐름) | 메모리 공유 기반 (직접 접근) |
| **데이터 전달 방식** | 데이터를 **복사**해서 전송 | 메모리를 **공유**해서 직접 접근 |
| **동기화** | 자동 (읽기/쓰기 시 블로킹) | **수동** (동기화 객체 필요) |
| **데이터 순서** | **순서 보장** (FIFO) | 순서 개념 없음 |

### Named Pipe

```
┌──────────────┐         복사          ┌──────────────┐
│   Process A  │ ────── WriteFile ────►│   Pipe 버퍼  │
│   (Writer)   │                       │   (커널)     │
└──────────────┘                       └──────┬───────┘
                                              │
                                         ReadFile
                                              │
                                       ┌──────▼───────┐
                                       │   Process B  │
                                       │   (Reader)   │
                                       └──────────────┘
```

* 데이터가 커널 버퍼를 통해 복사됨
* WriteFile() → 커널 버퍼 → ReadFile() (2번 복사)
* 동기화가 자동으로 처리됨 (읽을 데이터 없으면 대기)
* TCP 소켓과 유사 - 연결 기반, 신뢰성 보장

### File Mapping (Shared Memory)

```
┌──────────────┐                       ┌──────────────┐
│   Process A  │                       │   Process B  │
│              │                       │              │
│   pDataA ────┼───────────┬───────────┼──── pDataB   │
└──────────────┘           │           └──────────────┘
                           │
                    ┌──────▼───────┐
                    │  공유 메모리  │
                    │  (물리 메모리)│
                    └──────────────┘
```

* 동일한 물리 메모리를 여러 프로세스가 직접 접근
* 복사 없음 (Zero-copy) → 대용량 데이터에 효율적
* 동기화를 직접 구현해야 함 (Mutex, Event 등)
* 데이터 순서 개념 없음 (그냥 메모리 덩어리)

### 조금 더 상세

| 항목 | Named Pipe | File Mapping |
| :--- | :--- | :--- |
| **성능** | 데이터 복사 오버헤드 있음 | 빠름 (Zero-copy) |
| **구현 복잡도** | 간단 | 동기화 로직 필요 |
| **데이터 크기** | 스트림/작은 메시지에 적합 | 대용량 데이터에 적합 |
| **통신 패턴** | 요청-응답, 스트리밍 | 데이터 공유, 상태 공유 |
| **네트워크** | 원격 컴퓨터 간 통신 가능 | 로컬 전용 |
| **동기화** | 내장됨 (블로킹 I/O) | 직접 구현 (Mutex, Event) |
| **데이터 유실** | 없음 (버퍼링) | 덮어쓰기 가능 |

---

## RPC

* RPC(Remote Procedure Call)는 프로세스 간 또는 네트워크 상에서 원격 함수를 호출할 수 있게 해주는 프로토콜
* 클라이언트가 마치 로컬 함수를 호출하는 것처럼 원격 서버의 함수를 호출할 수 있다

```
┌─────────────────┐                                    ┌─────────────────┐
│  Client Process │                                    │  Server Process │
│                 │                                    │                 │
│   함수 호출     │                                    │   실제 함수     │
│   RpcConvert()  │                                    │   구현 실행     │
└────────┬────────┘                                    └────────▲────────┘
         │                                                      │
         ▼                                                      │
┌─────────────────┐                                    ┌─────────────────┐
│   Marshalling   │ ──────── 네트워크/IPC ──────────▶  │  Unmarshalling  │
│  (직렬화)       │                                    │  (역직렬화)     │
│  데이터 → 바이트│                                    │  바이트 → 데이터│
└─────────────────┘                                    └─────────────────┘
       Client                                                Server
     RPC Runtime                                           RPC Runtime
```

* Marshalling - 함수 인자를 네트워크로 전송 가능한 바이트 스트림으로 직렬화
* RPC Runtime - 데이터 전송 및 수신 처리 (프로토콜: ncalrpc, TCP/IP, Named Pipe 등)
* Unmarshalling - 바이트 스트림을 원래 데이터 타입으로 역직렬화

### IDL (Interface Definition Language) - 인터페이스 정의

```cpp
// RPC_Stub.idl - 원격 호출할 함수의 인터페이스 정의
[
    uuid(f56cd7ef-28ad-47d6-821b-f0e9995938cd),
    version(1.0)
]
interface RPC_StubInteface
{
    // 문자열을 대문자로 변환하는 원격 함수
    unsigned int RPC_ConvertToUpperCase(
        [out, size_is(out_buffer_count)] wchar_t* pOutBuffer,
        [in] unsigned int out_buffer_count,
        [in, size_is(in_chr_count)] const wchar_t* pInBuffer,
        [in] unsigned int in_chr_count
    );
    
    // 메모리 복사 원격 함수
    unsigned int RPC_MemCpy(
        [out, size_is(dest_size)] unsigned char* pDest,
        [in] unsigned int dest_size,
        [in, size_is(src_size)] const unsigned char* pSrc,
        [in] unsigned int src_size
    );
}
```

### 서버 측 - 실제 함수 구현

```cpp
// RPC_Implements.cpp - 서버에서 실행되는 실제 로직
unsigned int RPC_ConvertToUpperCase( 
    handle_t IDL_handle,        // RPC 핸들 (자동 생성)
    wchar_t *pOutBuffer,        // [out] 결과 버퍼
    unsigned int out_buffer_count,
    const wchar_t *pInBuffer,   // [in] 입력 문자열
    unsigned int in_chr_count)
{
    // 소문자 → 대문자 변환 로직
    const int Offset = L'A' - L'a';
    for (DWORD i = 0; i < in_chr_count; i++)
    {
        WCHAR c = pInBuffer[i];
        if (c >= L'a' && c <= L'z')
            c += Offset;
        pOutBuffer[i] = c;
    }
    pOutBuffer[in_chr_count] = 0;
    
    wprintf_s(L"RPC_ConvertToUpperCase() 호출됨. 입력: %s\n", pInBuffer);
    return in_chr_count;
}
```

### 서버 측 - RPC 런타임 초기화

```cpp
// RpcServer.cpp - RPC 서버 등록 및 리스닝
BOOL RpcServerInit(const WCHAR* wchEndPointName)
{
    // 1. 프로토콜 및 엔드포인트 설정
    RPC_STATUS status = RpcServerUseProtseqEp(
        (RPC_WSTR)L"ncalrpc",       // 프로토콜: Local RPC
        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
        (RPC_WSTR)wchEndPointName,   // 엔드포인트 이름
        nullptr
    );

    // 2. 인터페이스 등록
    status = RpcServerRegisterIf2(
        RPC_StubInteface_v1_0_s_ifspec,  // 서버 스텁 인터페이스
        nullptr, nullptr,
        RPC_IF_ALLOW_LOCAL_ONLY,
        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
        -1, nullptr
    );

    // 3. 클라이언트 연결 대기 시작
    status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, 1);
    
    return TRUE;
}
```

| 프로토콜 | 설명 |
|:---|:---|
| ncalrpc | Local RPC - 같은 PC 내 프로세스 간 통신 (가장 빠름) |
| ncacn_ip_tcp | TCP/IP - 네트워크 통신 |
| ncacn_np | Named Pipe - SMB 기반 IPC |
| ncacn_http | HTTP 기반 |

### 클라이언트 측 - RPC 바인딩 및 호출

```cpp
// RpcClient.cpp - RPC 클라이언트 초기화
HANDLE InitRpcClient(const WCHAR* wchEndPointProtocol)
{
    HANDLE hBindingHandle = nullptr;
    
    // RPC 바인딩 생성 (서버 연결)
    // 예: "ncalrpc:[RpcServer-00001234]"
    RPC_STATUS status = RpcBindingFromStringBinding(
        (RPC_WSTR)wchEndPointProtocol, 
        &hBindingHandle
    );
    
    return hBindingHandle;
}

// 원격 함수 호출 래퍼
DWORD RpcConvertToUpperCase(HANDLE hRpcBinding, DWORD dwMaxBufferCount, 
                            WCHAR* wchOutBuffer, const WCHAR* wchSrc, DWORD dwLen)
{
    // 마치 로컬 함수처럼 호출 - 내부적으로 Marshalling → 전송 → Unmarshalling
    DWORD dwResultLen = RPC_ConvertToUpperCase(
        hRpcBinding, wchOutBuffer, dwMaxBufferCount, wchSrc, dwLen
    );
    return dwResultLen;
}
```

### 클라이언트 측 - 실제 호출 예시

```cpp
// main.cpp (Client)
// F1 키를 누르면 원격 함수 호출
if (irBuffer.Event.KeyEvent.wVirtualKeyCode == VK_F1)
{
    const WCHAR* wchStr = L"hello world~~";
    WCHAR wchResult[128] = {};
    
    // 원격 프로시저 호출 - 서버에서 대문자로 변환
    DWORD dwResultLen = RpcConvertToUpperCase(
        hRpcBinding,                    // RPC 바인딩 핸들
        (DWORD)_countof(wchResult),     // 출력 버퍼 크기
        wchResult,                      // [out] 결과
        wchStr,                         // [in] 입력 문자열
        (DWORD)wcslen(wchStr)           // 입력 길이
    );
    
    // 결과: "hello world~~" → "HELLO WORLD~~"
    wprintf_s(L"결과: %s -> %s\n", wchStr, wchResult);
}
```

```
[Client: main.cpp]                    [Server: RPC_Implements.cpp]
       │                                        │
       │ RpcConvertToUpperCase()                │
       │ "hello world~~"                        │
       ▼                                        │
┌──────────────────┐                            │
│ Client Stub      │ ← RPC_Stub_c.c             │
│ (Marshalling)    │                            │
│ 데이터 직렬화    │                            │
└────────┬─────────┘                            │
         │                                      │
         │ ncalrpc 프로토콜로 전송              │
         ▼                                      │
┌──────────────────┐                            │
│ Server Stub      │ ← RPC_Stub_s.c             │
│ (Unmarshalling)  │                            │
│ 데이터 역직렬화  │                            │
└────────┬─────────┘                            │
         │                                      ▼
         │                          ┌───────────────────┐
         └─────────────────────────▶│ RPC_ConvertToUpper│
                                    │ 실제 변환 로직    │
                                    │ "HELLO WORLD~~"   │
                                    └───────────────────┘
```
