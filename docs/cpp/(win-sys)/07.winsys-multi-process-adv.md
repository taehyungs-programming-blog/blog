---
layout: default
title: "07. Multi Process Programming 심화화"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 우선, OVERLAPPED에 대한 이해가 필요하다

* OVERLAPPED는 Windows에서 비동기(Asynchronous) I/O를 수행할 때 사용하는 구조체

```
동기(Synchronous) I/O - 블로킹
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Application           System
      │                    │
      │  ReadFile()        │
      │───────────────────►│
      │                    │  ← 데이터 도착할 때까지
      │    (블로킹 대기)    │     여기서 멈춤!
      │                    │
      │◄───────────────────│  데이터 도착
      │  함수 반환          │
      │                    │


비동기(Asynchronous) I/O - 논블로킹
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Application           System
      │                    │
      │  ReadFile()        │
      │───────────────────►│
      │◄───────────────────│  즉시 반환! (ERROR_IO_PENDING)
      │                    │
      │  다른 작업 수행     │  ← 시스템이 백그라운드에서
      │  (게임 로직 등)     │     데이터 수신 중
      │                    │
      │  GetOverlappedResult()
      │───────────────────►│
      │◄───────────────────│  완료 여부 확인
      │                    │
```

### OVERLAPPED 구조체 정의

```cpp
typedef struct _OVERLAPPED {
    ULONG_PTR Internal;         // 시스템 내부 사용 (상태 코드)
    ULONG_PTR InternalHigh;     // 시스템 내부 사용 (전송 바이트 수)
    union {
        struct {
            DWORD Offset;       // 파일 오프셋 (하위 32비트)
            DWORD OffsetHigh;   // 파일 오프셋 (상위 32비트)
        };
        PVOID Pointer;
    };
    HANDLE hEvent;              // 완료 시 시그널될 이벤트 핸들 (선택)
} OVERLAPPED;
```

### 어떻게 쓸까?

```cpp
// Step 1: 초기화
memset(&m_OvlRecv, 0, sizeof(m_OvlRecv));  // 반드시 0으로 초기화!
```

```cpp
// Step 2: 비동기 I/O 시작
BOOL bResult = ReadFile(
    m_hPipe,                              // 파이프 핸들
    m_pRecvBuffer + m_dwRecvBufferBytes,  // 버퍼
    dwAvailableBufferSize,                // 읽을 크기
    &dwTransferredBytes,                  // 실제 읽은 바이트 (비동기 시 무시됨)
    &m_OvlRecv                            // ★ OVERLAPPED 포인터
);

BOOL bResult = WriteFile(
    m_hPipe,
    m_pSendBuffer,
    m_dwPendingSendBufferBytes,
    &dwTransferredBytes,
    &m_OvlSend                            // ★ OVERLAPPED 포인터
);
```

```cpp
// Step 3: 반환값 해석
if (bResult)
{
    // ✅ 즉시 완료됨 (드문 경우)
    OnRecvCompleted(dwTransferredBytes);
}
else
{
    DWORD dwErr = GetLastError();
    if (ERROR_IO_PENDING == dwErr)
    {
        // ✅ 정상! 비동기 작업 진행 중
        m_bIsReceiving = TRUE;  // 플래그 설정
    }
    else
    {
        // ❌ 실제 에러
        __debugbreak();
    }
}
```

```cpp
// Step 4: 완료 확인 (폴링 방식)
DWORD dwTransferredBytes = 0;
BOOL bResult = GetOverlappedResult(
    m_hPipe,              // 핸들
    &m_OvlRecv,           // ★ 확인할 OVERLAPPED
    &dwTransferredBytes,  // 실제 전송된 바이트 수
    FALSE                 // FALSE = 논블로킹, TRUE = 블로킹 대기
);
```

---

## NamedPipe

### CreateNamedPipe

```cpp
m_hPipe = CreateNamedPipe(
    L"\\\\.\\pipe\\MyNamedPipe",      // 파이프 이름
    PIPE_ACCESS_DUPLEX |               // 양방향 통신
    FILE_FLAG_OVERLAPPED,              // 비동기 I/O
    PIPE_TYPE_BYTE |                   // 바이트 스트림 모드
    PIPE_READMODE_BYTE |               // 바이트 단위 읽기
    PIPE_WAIT,                         // 블로킹 모드 (Overlapped와 함께 사용)
    PIPE_UNLIMITED_INSTANCES,          // 무제한 인스턴스
    dwSendBufferSize,                  // 출력 버퍼 크기
    dwRecvBufferSize,                  // 입력 버퍼 크기
    0,                                 // 타임아웃 (기본값)
    nullptr                            // 보안 속성
);
```

### ConnectNamedPipe

```cpp
bResult = ConnectNamedPipe(m_hPipe, &m_OvlConnect);
```

### GetOverlappedResult

```cpp
if (!m_bIsConnected)
{
    DWORD dwTransferredBytes = 0;
    BOOL bResult = GetOverlappedResult(m_hPipe, &m_OvlConnect, &dwTransferredBytes, FALSE);
    if (bResult)
    {
        *pbOutOnConnected = TRUE;
        m_bIsConnected = TRUE;
    }
}
```

### Read/Write

```cpp
DWORD dwAvailableBufferSize = m_dwRecvBufferSize - m_dwRecvBufferBytes;

bResult = ReadFile(
    m_hPipe,
    m_pRecvBuffer + m_dwRecvBufferBytes,  // 기존 데이터 뒤에 추가
    dwAvailableBufferSize,
    &dwTransferredBytes,
    &m_OvlRecv
);
```

```cpp
BOOL bResult = WriteFile(
    m_hPipe,
    m_pSendBuffer,
    m_dwPendingSendBufferBytes,
    &dwTransferredBytes,
    &m_OvlSend  // Overlapped 구조체
);
```

---

## 이 쯤에서 다시 NamedPipe Vs SharedMemory 정리

| 특성 | Named Pipe | Shared Memory |
|:---|:---|:---|
| 데이터 모델| 메시지/스트림 큐 | 공유 버퍼 |
| 순서 보장 | 보장됨 (FIFO) | 없음 (최신값만) |
| 데이터 손실 | 없음 | 덮어쓰기 발생 가능 |
| 히스토리 | 모든 메시지 수신 가능 | 현재 상태만 존재 |
| 대용량 데이터 | 느림 (복사 2회) | 빠름 (복사 0~1회) |
| 소량 데이터 | 적당함 | 오버헤드 있음 |
| 지연 시간 | 약간 있음 | 거의 없음 |

### Named Pipe의 내부 구조

```
┌─────────────────────────────────────────────────────────────────────┐
│                         User Mode (사용자 모드)                      │
│  ┌─────────────────────┐              ┌─────────────────────┐       │
│  │     Process A       │              │     Process B       │       │
│  │  (송신 프로세스)     │              │  (수신 프로세스)     │       │
│  │                     │              │                     │       │
│  │  ┌───────────────┐  │              │  ┌───────────────┐  │       │
│  │  │ 송신 버퍼      │  │              │  │ 수신 버퍼      │  │       │
│  │  │ (Application) │  │              │  │ (Application) │  │       │
│  │  └───────┬───────┘  │              │  └───────▲───────┘  │       │
│  │          │ ①복사    │              │          │ ④복사    │       │
│  └──────────┼──────────┘              └──────────┼──────────┘       │
│             │                                     │                  │
├─────────────┼─────────────────────────────────────┼──────────────────┤
│             ▼          Kernel Mode (커널 모드)    │                  │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │                     Named Pipe 커널 버퍼                       │   │
│  │  ┌─────────────────┐          ┌─────────────────┐            │   │
│  │  │  Out Buffer     │ ②복사   │  In Buffer      │            │   │
│  │  │  (송신측)        │────────►│  (수신측)        │            │   │
│  │  └─────────────────┘          └────────┬────────┘            │   │
│  │                                        │ ③복사               │   │
│  └────────────────────────────────────────┼─────────────────────┘   │
│                                           ▼                          │
│                                    시스템 버퍼                       │
└─────────────────────────────────────────────────────────────────────┘
```

```cpp
// Process A (송신)
// 1차 복사
WriteFile(m_hPipe, m_pSendBuffer, size, &written, &overlapped);
```

```
// 2차 복사
User Mode:   [App Send Buffer]
                    │
                    │ memcpy (커널로 진입)
                    ▼
Kernel Mode: [Pipe Out Buffer]
```

```
// 3차 복사
Kernel Mode: [Pipe Out Buffer] ──► [Pipe In Buffer]
                                    (수신측 커널 버퍼)
```

```cpp
// 4차 복사
// Process B (수신)
ReadFile(m_hPipe, m_pRecvBuffer, size, &read, &overlapped);
```

```
// 4차 복사
Kernel Mode: [Pipe In Buffer]
                    │
                    │ memcpy (유저로 복귀)
                    ▼
User Mode:   [App Recv Buffer]
```

### SharedMemory

```
  [App Buffer A]                                   Process A
        │
        │ ① memcpy (직접 쓰기)
        ▼
  [Shared Memory] ◄─────────────────────────────── 물리 메모리
        │                                          (양쪽에서 직접 접근)
        │ ② memcpy (직접 읽기)
        ▼
  [App Buffer B]                                   Process B


총 복사 횟수: 최대 2회 (또는 0회 - 직접 접근 시)
```

---

## SharedMemory

> 너무 길어진거 같아 별도 페이지에 정리합니다.