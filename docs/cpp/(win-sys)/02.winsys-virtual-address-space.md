---
layout: default
title: "02. Virtual Address Space"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

> 여긴 아주 이론적 설명이

## Virtual Address Space (가상 주소 공간) 란?

* 가상 주소 공간(VAS)은 운영체제가 각 프로세스에게 제공하는 논리적인 메모리 주소의 집합
* 프로세스는 실제 물리적 메모리(RAM)의 주소를 직접 보거나 접근하는 것이 아니라, 이 가상 주소 공간이라는 추상화된 계층을 통해 메모리를 사용
* 운영체제와 CPU의 **메모리 관리 장치(MMU, Memory Management Unit)**가 협력하여, 이 가상 주소를 실제 물리적 주소로 실시간으로 변환(Mapping)해주는 작업을 수행

* 가상 주소 공간의 주요 특징과 목적
     * 물리적 메모리 제약 극복 및 더 큰 주소 공간 제공
          * 프로세스는 시스템에 장착된 물리적 RAM의 크기와 상관없이, 운영체제가 정한 거대한 가상 주소 공간을 할당 (예: 64비트 Windows에서는 프로세스마다 256TB의 가상 공간이 주어짐)
          * 이를 통해 실제 RAM이 16GB밖에 없더라도, 프로세스는 그보다 훨씬 큰 메모리 공간이 있는 것처럼 동작할 수 있다 (부족한 부분은 디스크를 이용하는 페이징/스왑 기술로 보완)
     * 프로세스 간 독립적인 주소 공간 제공 (메모리 보호)
          * 모든 프로세스는 자신만의 독립적이고 사적인 가상 주소 공간을 가진다
          * 따라서 A 프로세스의 가상 주소 0x401000과 B 프로세스의 가상 주소 0x401000은 이름만 같을 뿐, 실제 물리적 메모리에서는 완전히 다른 위치에 매핑
          * 이것이 "애플리케이션은 다른 애플리케이션에 간섭받지 않는다"는 의미입니다. 한 애플리케이션이 메모리 오류로 비정상 종료되어도 다른 애플리케이션이나 시스템 전체에 영향을 주지 않아 안정성이 크게 향상
     * User Space와 System Space로의 분리 (보안)
          * 하나의 가상 주소 공간은 다시 두 개의 영역으로 나뉜다
          * User Space (사용자 공간): 해당 애플리케이션의 코드, 데이터, 힙, 스택 등이 위치하는 영역. 애플리케이션은 이 공간 내에서 자유롭게 메모리를 읽고 쓸 수 있다.
          * System Space (시스템 공간 또는 커널 공간): 운영체제 커널, 핵심 시스템 파일(Ntoskrnl.exe, Win32k.sys 등), 장치 드라이버 등이 로드되는 영역입니다. 이 공간은 모든 프로세스의 가상 주소 공간에 동일하게 매핑되어 공유
     * 보안 핵심: 사용자 모드(User-Mode)에서 실행되는 애플리케이션은 절대로 System Space에 직접 접근할 수 없다. 커널의 기능이 필요하면 반드시 시스템 콜(System Call)을 통해 요청. 이는 악의적이거나 잘못된 코드가 시스템 핵심부를 손상시키는 것을 막는 결정적인 보안 장치.

---

## Page (페이지) 란?

* 페이지는 운영체제가 가상 메모리를 관리하는 고정된 크기의 기본 블록 단위
* 운영체제와 CPU의 메모리 관리 장치(MMU)는 메모리를 바이트(byte) 단위가 아닌, 이 페이지 단위로 나누어 처리

* 가상 메모리에서의 단위: 페이지 (Page)
     * 물리 메모리(RAM)에서의 단위: 페이지 프레임 (Page Frame)
     * 페이지와 페이지 프레임의 크기는 항상 동일합니다.

* 페이지의 주요 특징과 역할
     * 메모리 관리 단위 (Management Unit)
          * 메모리를 페이지라는 고정된 크기 단위로 관리함으로써, 운영체제는 메모리 할당 및 회수를 훨씬 단순하고 효율적으로 처리.
          * 일반적인 페이지 크기는 4KB이며, 대용량 메모리 처리를 위해 2MB 또는 그 이상의 크기를 갖는 '거대 페이지(Large Page)'를 사용하기도 한다.
     * 페이지 속성 (Page Attributes)
          * 각 페이지는 독립적인 속성을 가질 수 있습니다. 이는 주로 메모리 보호에 사용.
     * 주요 속성:
          * 접근 권한: 읽기(Read), 쓰기(Write), 실행(Execute) 권한을 조합하여 설정할 수 있다. 예를 들어, 코드(Code)가 저장된 페이지는 '읽기/실행'으로, 데이터가 저장된 페이지는 '읽기/쓰기'로 설정하여, 실수로 코드를 덮어쓰는 등의 오류를 방지.
          * 상태: 현재 페이지가 물리 메모리에 있는지(Present), 디스크에 있는지(Not-Present), 수정되었는지(Dirty) 등의 상태 정보도 포함.

* 주소 매핑과 페이지 테이블 (Address Mapping & Page Table)
     * 운영체제는 가상 주소 공간의 페이지(Virtual Page)가 물리 메모리의 어떤 페이지 프레임(Physical Page Frame)에 위치하는지에 대한 매핑 정보를 관리.
     * 이 매핑 정보는 **페이지 테이블(Page Table)**이라는 특별한 데이터 구조에 저장 (정확히는 Page Directory, Page Table 등의 계층적 구조를 사용합니다.)
     * "각 프로세스는 자신의 Page Table을 가짐"이라는 것은, 모든 프로세스가 독립된 가상 주소 공간을 가지므로, 그에 상응하는 자신만의 주소 변환 정보(페이지 테이블)를 가진다는 의미

* MMU를 통한 주소 변환 (Address Translation via MMU)
     * 프로세스가 가상 주소에 접근하려고 하면, CPU에 내장된 **MMU(Memory Management Unit)**가 그 프로세스의 페이지 테이블을 참조.
     * MMU는 이 테이블을 통해 요청된 가상 주소가 속한 페이지에 해당하는 물리 페이지 프레임의 주소를 찾아내고, 실제 물리 메모리에 접근. 이 모든 과정은 하드웨어 수준에서 매우 빠르게 일어납니다.

* 페이징 (Paging / Swapping)
     * "물리 메모리가 부족할 때" 운영체제는 이 페이지 시스템을 활용하여 효율적인 메모리 관리를 수행
     * 페이지 아웃 (Swap-out): 당장 사용되지 않는 페이지(예: 오랫동안 참조되지 않은 페이지)를 물리 메모리에서 빼내 하드 디스크나 SSD의 특정 공간(페이지 파일 또는 스왑 공간)에 임시로 저장
     * 페이지 인 (Swap-in): 이후 해당 페이지에 다시 접근이 필요해지면, 디스크에서 데이터를 다시 읽어와 비어있는 물리 페이지 프레임에 로드
     * 이 과정을 통해 물리적인 RAM 크기보다 더 큰 프로그램을 실행할 수 있게 된다.

---

## Virtual Add to Physical Add

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        32-bit Virtual Address                               │
├──────────┬───────────────┬───────────────┬──────────────────────────────────┤
│  2 bits  │    9 bits     │    9 bits     │            12 bits               │
│  (PDPT)  │    (PD)       │    (PT)       │           (Offset)               │
└────┬─────┴───────┬───────┴───────┬───────┴──────────────────┬───────────────┘
     │             │               │                          │
     │             │               │                          │
     ▼             │               │                          │
┌─────────┐        │               │                          │
│   CR3   │        │               │                          │
│Register │        │               │                          │
└────┬────┘        │               │                          │
     │             │               │                          │
     ▼             ▼               ▼                          ▼
┌─────────────┐  ┌─────────────┐  ┌─────────────┐        ┌─────────────┐
│    PDPT     │  │     PD      │  │     PT      │        │     RAM     │
│ (4 entries) │  │(512 entries)│  │(512 entries)│        │             │
├─────────────┤  ├─────────────┤  ├─────────────┤        ├─────────────┤
│    PDPE ────┼─▶│    PDE  ────┼─▶│    PTE  ────┼───────▶│    Page     │
├─────────────┤  ├─────────────┤  ├─────────────┤        ├─────────────┤
│    PDPE     │  │    PDE      │  │    PTE      │        │   Bytes  ◀──┼── Offset
├─────────────┤  ├─────────────┤  ├─────────────┤        │             │
│    PDPE     │  │    PDE      │  │    PTE      │        │             │
├─────────────┤  ├─────────────┤  ├─────────────┤        │             │
│    PDPE     │  │    ...      │  │    ...      │        │             │
└─────────────┘  └─────────────┘  └─────────────┘        └─────────────┘

     Page         Page            Page                   Physical
   Directory     Directory        Table                   Memory
    Pointer
     Table
```

*  x86 PAE (Physical Address Extension) 모드에서 32비트 가상 주소가 물리 주소로 변환되는 4단계 페이징 과정

* 2 bits - PDPT 인덱스 - Page Directory Pointer Table에서 엔트리 선택 (4개 중 1개)
* 9 bits - PD 인덱스 - Page Directory에서 엔트리 선택 (512개 중 1개)
* 9 bits - PT 인덱스 - Page Table에서 엔트리 선택 (512개 중 1개)
* 12 bits - 오프셋 - 4KB 페이지 내 바이트 위치

---

## Example

* 가상 주소 0x80A0_1234 를 물리 주소로 변환해 봅시다.

### 1단계: 가상 주소를 이진수로 변환

* `0x80A01234 = 1000 0000 1010 0000 0001 0010 0011 0100 (2진수)`

### 2단계: 4개 필드로 분할

```
┌──────────────────────────────────────────────────────────────────────────┐
│                    0x80A01234 (32비트)                                   │
├────────────┬─────────────────┬─────────────────┬─────────────────────────┤
│   2 bits   │     9 bits      │     9 bits      │        12 bits          │
├────────────┼─────────────────┼─────────────────┼─────────────────────────┤
│     10     │   000000101     │   000000001     │    0010 0011 0100       │
├────────────┼─────────────────┼─────────────────┼─────────────────────────┤
│   = 2      │     = 5         │     = 1         │      = 0x234            │
├────────────┼─────────────────┼─────────────────┼─────────────────────────┤
│ PDPT Index │    PD Index     │    PT Index     │       Offset            │
└────────────┴─────────────────┴─────────────────┴─────────────────────────┘
```

### 3단계: 변환 과정 시각화

```
                         가상 주소: 0x80A01234
                    ┌────┬─────────┬─────────┬──────────┐
                    │ 10 │000000101│000000001│0010001101│
                    │ =2 │   =5    │   =1    │  =0x234  │
                    └──┬─┴────┬────┴────┬────┴─────┬────┘
                       │      │         │          │
    ┌──────────────────┘      │         │          │
    │                         │         │          │
    ▼                         │         │          │
┌─────────────────┐           │         │          │
│   CR3 Register  │           │         │          │
│  = 0x00003000   │           │         │          │
└────────┬────────┘           │         │          │
         │                    │         │          │
         ▼                    │         │          │
    PDPT (물리주소 0x3000)     │         │          │
    ┌─────────────────┐       │         │          │
  0 │ PDPE → 0x4000   │       │         │          │
    ├─────────────────┤       │         │          │
  1 │ PDPE → 0x5000   │       │         │          │
    ├─────────────────┤       │         │          │
  2 │ PDPE → 0x6000 ──┼───────┘         │          │
    ├─────────────────┤  Index=2        │          │
  3 │ PDPE → 0x7000   │                 │          │
    └─────────────────┘                 │          │
                                        │          │
         ┌──────────────────────────────┘          │
         │                                         │
         ▼                                         │
    Page Directory (물리주소 0x6000)               │
    ┌─────────────────┐                            │
  0 │ PDE → ...       │                            │
    ├─────────────────┤                            │
  : │      ...        │                            │
    ├─────────────────┤                            │
  5 │ PDE → 0x8000 ───┼────────────────────────────┘
    ├─────────────────┤  Index=5                   │
  : │      ...        │                            │
    ├─────────────────┤                            │
511 │ PDE → ...       │                            │
    └─────────────────┘                            │
                                                   │
         ┌─────────────────────────────────────────┘
         │
         ▼
    Page Table (물리주소 0x8000)
    ┌─────────────────┐
  0 │ PTE → ...       │
    ├─────────────────┤
  1 │ PTE → 0xABC000 ─┼──────────┐  Index=1
    ├─────────────────┤          │
  : │      ...        │          │
    ├─────────────────┤          │
511 │ PTE → ...       │          │
    └─────────────────┘          │
                                 │
                                 ▼
                            RAM (물리 메모리)
                            ┌─────────────────┐
                            │   Page Frame    │
                            │  @ 0xABC000     │
                            ├─────────────────┤
                            │                 │
                            │  + Offset 0x234 │
                            │        ↓        │
                            │   0xABC234  ◀───┼── 최종 물리 주소!
                            │                 │
                            └─────────────────┘
```

### 4단계: 계산 요약

1. CR3에서 PDPT 주소 획득	`0x00003000`
2. PDPT[2]에서 PD 주소 획득	`0x00006000`
3. PD[5]에서 PT 주소 획득	`0x00008000`
4. PT[1]에서 Page Frame 주소 획득	`0x00ABC000`
5. Page Frame + Offset	`0x00ABC000 + 0x234`
6. 결과 : 최종 물리 주소	`0x00ABC234`

```
┌─────────────────────────────────────────────────────────────────────┐
│                        실제 시나리오                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  프로그램 코드:                                                      │
│  ┌─────────────────────────────────────────┐                        │
│  │  int *ptr = (int *)0x80A01234;          │                        │
│  │  int value = *ptr;  // 메모리 읽기       │                        │
│  └─────────────────────────────────────────┘                        │
│                                                                     │
│  CPU 내부 동작:                                                      │
│  ┌─────────────────────────────────────────┐                        │
│  │  1. 가상주소 0x80A01234 분해             │                        │
│  │  2. CR3 → PDPT 찾기                      │                        │
│  │  3. PDPT[2] → PD 찾기                    │                        │
│  │  4. PD[5] → PT 찾기                      │                        │
│  │  5. PT[1] → Page Frame 찾기              │                        │
│  │  6. 0xABC000 + 0x234 = 0xABC234          │                        │
│  │  7. 물리주소 0xABC234에서 4바이트 읽기    │                        │
│  └─────────────────────────────────────────┘                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```
