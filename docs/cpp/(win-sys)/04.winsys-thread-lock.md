---
layout: default
title: "04. Thread Lock 방법"
parent: "(Windows System Programming)"
grand_parent: "(C++)"
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## 결론부터 보자

* SRWLock
    * 241.78ms
* SpinLock without Yield
    * 1,299.43ms
* SpinLock with Yield
    * 147.09ms
* CriticalSection
    * 1,303.63ms
* CriticalSectionAndSpinCount
    * 1,017.58ms
* Mutex
    * 49,452.62ms
* Semaphore
    * 55,314.62ms

* Lock이 필요할 경우 
    * Atomic Operation -> 
    * Spin lock -> 
    * SRWLock ->
    * Critical Section/Mutex/Semaphore 순으로 검토.

---

* 시작해 보자

## Mutex

* 특징
    * 커널 오브젝트 : 운영체제가 관리하는 커널 수준의 동기화 객체
    * 속도 : Lock/Unlock 시 항상 커널 모드로 전환(System Call)해야 하므로 상대적으로 느리다
    * 프로세스 간 공유 : 이름(Named Mutex)을 지정하면 서로 다른 프로세스 간에도 동기화가 가능
    * 재진입 가능 (Recursive) : 동일한 스레드가 이미 소유한 Mutex를 다시 획득할 수 있다(내부적으로 카운트 관리)
    * 소유권 개념 : Mutex를 획득한 스레드만이 해제할 수 있다

```cpp
#include <Windows.h>
#include <stdio.h>

HANDLE g_hMutex = nullptr;
int g_sharedData = 0;

DWORD WINAPI ThreadFunc(LPVOID lpParam)
{
    for (int i = 0; i < 10000; i++)
    {
        // Mutex 획득 (Lock)
        WaitForSingleObject(g_hMutex, INFINITE);
        
        // 임계 영역 (Critical Section)
        g_sharedData++;
        
        // Mutex 해제 (Unlock)
        ReleaseMutex(g_hMutex);
    }
    return 0;
}

int main()
{
    // Mutex 생성
    g_hMutex = CreateMutex(nullptr, FALSE, nullptr);
    
    // 스레드 2개 생성
    HANDLE hThread1 = CreateThread(nullptr, 0, ThreadFunc, nullptr, 0, nullptr);
    HANDLE hThread2 = CreateThread(nullptr, 0, ThreadFunc, nullptr, 0, nullptr);
    
    // 스레드 종료 대기
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);
    
    printf("Result: %d (Expected: 20000)\n", g_sharedData);
    
    // 리소스 정리
    CloseHandle(hThread1);
    CloseHandle(hThread2);
    CloseHandle(g_hMutex);
    
    return 0;
}
```

---

## Semaphore

* Semaphore (세마포어)는 지정된 개수의 스레드만 동시에 임계 영역에 진입할 수 있도록 제한하는 동기화 객체
* Mutex가 "1개만 허용"이라면, Semaphore는 "N개까지 허용"

* 특징
    * 내부 카운터 : 진입 시 -1, 빠져나갈 때 +1 (카운터가 0이면 대기)
    * 커널 오브젝트 : 운영체제가 관리하는 커널 수준의 동기화 객체
    * 속도 : Lock/Unlock 시 항상 커널 모드로 전환해야 하므로 상대적으로 느리다
    * 프로세스 간 공유 : 이름(Named Semaphore)을 지정하면 서로 다른 프로세스 간에도 동기화가 가능
    * 재진입 불가 : Mutex와 달리 소유권 개념이 없어 동일 스레드가 다시 획득하면 카운터가 또 감소
    * 해제 스레드 무관 : 획득한 스레드가 아닌 다른 스레드에서도 해제 가능

> 느껴지겠지만 생각보다 Win Sys에선 잘 사용하지 않는다

```cpp
#include <Windows.h>
#include <stdio.h>

// 동시에 3개 스레드만 작업 가능한 세마포어
HANDLE g_hSemaphore = nullptr;

DWORD WINAPI WorkerThread(LPVOID lpParam)
{
    int threadId = (int)(INT_PTR)lpParam;
    
    printf("Thread %d: 대기 중...\n", threadId);
    
    // 세마포어 획득 (카운터 -1)
    WaitForSingleObject(g_hSemaphore, INFINITE);
    
    printf("Thread %d: 작업 시작!\n", threadId);
    Sleep(2000);  // 작업 수행 (2초)
    printf("Thread %d: 작업 완료!\n", threadId);
    
    // 세마포어 해제 (카운터 +1)
    ReleaseSemaphore(g_hSemaphore, 1, nullptr);
    
    return 0;
}

int main()
{
    // 최대 3개 스레드 동시 진입 허용
    g_hSemaphore = CreateSemaphore(nullptr, 3, 3, nullptr);
    
    HANDLE hThreads[10];
    
    // 10개 스레드 생성 (하지만 동시에 3개만 작업)
    for (int i = 0; i < 10; i++)
    {
        hThreads[i] = CreateThread(nullptr, 0, WorkerThread, 
                                   (LPVOID)(INT_PTR)i, 0, nullptr);
    }
    
    // 모든 스레드 종료 대기
    WaitForMultipleObjects(10, hThreads, TRUE, INFINITE);
    
    // 리소스 정리
    for (int i = 0; i < 10; i++)
        CloseHandle(hThreads[i]);
    CloseHandle(g_hSemaphore);
    
    return 0;
}
```

### Semaphore는 언제 쓸까?

* 접근을 제한하고 싶을때

```cpp
// 이미지 인코딩 - CPU 코어가 4개라서 동시에 4개까지만 처리하고 싶음

HANDLE g_hSemaphore = nullptr;

void Init()
{
    // 동시에 4개까지만 허용
    g_hSemaphore = CreateSemaphore(nullptr, 4, 4, nullptr);
}

void EncodeImage(Image* pImage)
{
    WaitForSingleObject(g_hSemaphore, INFINITE);  // 4개 이하면 통과, 아니면 대기
    
    // CPU 많이 쓰는 인코딩 작업
    DoHeavyEncoding(pImage);
    
    ReleaseSemaphore(g_hSemaphore, 1, nullptr);
}
```

* 대기중인 작업을 카운트 하려할 때

```cpp
// 작업 큐: 워커 스레드가 작업이 들어올 때까지 대기

HANDLE g_hJobCount = nullptr;  // 현재 큐에 있는 작업 수
Queue g_jobQueue;
CRITICAL_SECTION g_cs;

void Init()
{
    // 초기값 0 = 작업 없음
    g_hJobCount = CreateSemaphore(nullptr, 0, 10000, nullptr);
}

// 작업 추가 (메인 스레드)
void AddJob(Job* pJob)
{
    EnterCriticalSection(&g_cs);
    g_jobQueue.push(pJob);
    LeaveCriticalSection(&g_cs);
    
    // 작업 수 +1 (워커 스레드 깨움)
    ReleaseSemaphore(g_hJobCount, 1, nullptr);
}

// 작업 5개 한번에 추가
void AddJobs(Job* jobs[], int count)
{
    EnterCriticalSection(&g_cs);
    for (int i = 0; i < count; i++)
        g_jobQueue.push(jobs[i]);
    LeaveCriticalSection(&g_cs);
    
    // 작업 수 +5 (Semaphore는 한번에 N 증가 가능!)
    ReleaseSemaphore(g_hJobCount, count, nullptr);
}

// 워커 스레드
DWORD WINAPI WorkerThread(LPVOID)
{
    while (true)
    {
        // 작업이 있을 때까지 대기 (CPU 안 씀)
        WaitForSingleObject(g_hJobCount, INFINITE);
        
        EnterCriticalSection(&g_cs);
        Job* pJob = g_jobQueue.pop();
        LeaveCriticalSection(&g_cs);
        
        pJob->Execute();
    }
}
```

* 이걸 mutex로 하면?

```cpp
// 작업 없을 때 워커 스레드가 뭘 해야 하나?
while (true)
{
    WaitForSingleObject(g_hMutex, INFINITE);
    
    if (g_jobQueue.empty())
    {
        ReleaseMutex(g_hMutex);
        Sleep(10);  // Busy waiting... CPU 낭비
        continue;
    }
    // ...
}
```

---

## Critical Section

* Critical Section (임계 영역)은 하나의 스레드만 진입할 수 있도록 제한하는 동기화 객체
* Mutex와 기능은 동일하지만 유저 모드에서 먼저 처리하므로 더 빠르다

* 특징
    * 유저 모드 우선 : Lock 시도 시 커널 호출 없이 유저 모드에서 먼저 체크 → Mutex보다 빠름
    * 프로세스 내 전용 : 같은 프로세스 내의 스레드 간 동기화만 가능 (프로세스 간 공유 불가)
    * 재진입 가능 : 동일 스레드가 이미 소유한 Critical Section을 다시 획득 가능
    * 커널 오브젝트 아님 : 구조체 기반, 핸들 없음

```cpp
#include <Windows.h>
#include <stdio.h>

CRITICAL_SECTION g_cs;
int g_count = 0;

DWORD WINAPI ThreadFunc(LPVOID lpParam)
{
    for (int i = 0; i < 100000; i++)
    {
        EnterCriticalSection(&g_cs);  // Lock
        g_count++;
        LeaveCriticalSection(&g_cs);  // Unlock
    }
    return 0;
}

int main()
{
    InitializeCriticalSection(&g_cs);  // 초기화
    
    HANDLE h1 = CreateThread(nullptr, 0, ThreadFunc, nullptr, 0, nullptr);
    HANDLE h2 = CreateThread(nullptr, 0, ThreadFunc, nullptr, 0, nullptr);
    
    WaitForSingleObject(h1, INFINITE);
    WaitForSingleObject(h2, INFINITE);
    
    printf("Result: %d (Expected: 200000)\n", g_count);
    
    CloseHandle(h1);
    CloseHandle(h2);
    DeleteCriticalSection(&g_cs);  // 해제
    
    return 0;
}
```

---

## SRWLock

* SRWLock (Slim Reader/Writer Lock)은 읽기/쓰기 패턴에 최적화된 동기화 객체
* 읽기는 동시에 여러 스레드, 쓰기는 한 스레드만 허용

* 특징
    * 두 가지 모드 : Shared(읽기) - 여러 스레드 동시 접근 / Exclusive(쓰기) - 한 스레드만
    * 내부 Spin Lock : 유저 모드에서 spin하므로 빠른 반응성
    * 적은 메모리 : 포인터 크기(8바이트)만 사용
    * 재진입 불가 : 같은 스레드가 다시 획득하면 데드락 발생
    * 커널 오브젝트 아님 : 구조체 기반, 핸들 없음

```cpp
#include <Windows.h>
#include <stdio.h>

SRWLOCK g_srwLock;
int g_data = 0;

// 읽기 (여러 스레드 동시 가능)
int ReadData()
{
    AcquireSRWLockShared(&g_srwLock);
    
    int value = g_data;  // 읽기만
    
    ReleaseSRWLockShared(&g_srwLock);
    return value;
}

// 쓰기 (한 스레드만)
void WriteData(int value)
{
    AcquireSRWLockExclusive(&g_srwLock);
    
    g_data = value;  // 쓰기
    
    ReleaseSRWLockExclusive(&g_srwLock);
}

DWORD WINAPI ReaderThread(LPVOID lpParam)
{
    for (int i = 0; i < 1000; i++)
    {
        int val = ReadData();
        // 여러 Reader가 동시에 읽기 가능
    }
    return 0;
}

DWORD WINAPI WriterThread(LPVOID lpParam)
{
    for (int i = 0; i < 1000; i++)
    {
        WriteData(i);
        // Writer는 혼자만 접근
    }
    return 0;
}

int main()
{
    InitializeSRWLock(&g_srwLock);
    
    // Reader 5개, Writer 2개
    HANDLE hReaders[5], hWriters[2];
    
    for (int i = 0; i < 5; i++)
        hReaders[i] = CreateThread(nullptr, 0, ReaderThread, nullptr, 0, nullptr);
    for (int i = 0; i < 2; i++)
        hWriters[i] = CreateThread(nullptr, 0, WriterThread, nullptr, 0, nullptr);
    
    WaitForMultipleObjects(5, hReaders, TRUE, INFINITE);
    WaitForMultipleObjects(2, hWriters, TRUE, INFINITE);
    
    // 정리
    for (int i = 0; i < 5; i++) CloseHandle(hReaders[i]);
    for (int i = 0; i < 2; i++) CloseHandle(hWriters[i]);
    
    // DeleteSRWLock 같은 거 없음 - 해제 불필요
    return 0;
}
```

---

## Spin Lock

* Spin Lock은 커널 모드 진입 없이 CPU의 원자적 연산(CAS)을 이용해 임계 영역을 구현하는 동기화 기법
* Lock을 얻을 때까지 루프를 돌며 계속 시도

* 특징
    * 유저 모드 전용 : 커널 호출 없음 → 컨텍스트 스위칭 비용 없음
    * Busy Waiting : Lock 획득까지 CPU를 점유하며 계속 시도
    * 짧은 임계 영역에 적합 : 긴 작업이면 CPU 낭비 심함
    * pause 명령 필수 : 없으면 파이프라인 낭비로 성능 저하
    * Windows API 아님 : 직접 구현해서 사용


