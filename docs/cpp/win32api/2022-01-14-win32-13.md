---
layout: default
title: "13. Process Creation(ìë…€ í”„ë¡œì„¸ìŠ¤ ìƒì„±), ExitCode(í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œì½”ë“œ)"
parent: (Windows API)
grand_parent: C++
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Process Creation(ìë…€ í”„ë¡œì„¸ìŠ¤ ìƒì„±)

ğŸ˜º ì‚¬ì „ ì¤€ë¹„ì‚¬í•­

```cpp
// sample.cpp
// C:\\Windows\\Sample.exe ì— ë„£ëŠ”ë‹¤
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int _tmain(int argc, TCHAR* argv[])
{
    for(int i = 0; i < argc; i++)
    {
        _tprintf(_T("argv[%d] : %s\n"), i, argv[i]);
    }

    TCHAR name[256] = { 0 };
    GetCurrentDirectory(256, name);
    _tprintf(_T("current directory : %s\n"), name);

    _tprintf(_T("press enter key to quit\n"), name);
    getchar();

    return 100;
}
```

<br>

ğŸ˜º ìë…€ í”„ë¡œì„¸ìŠ¤ ìƒì„±

```cpp
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int _tmain()
{
    PROCESS_INFORMATION pi = { 0 };
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);

    TCHAR name[] = _T("C:\\Windows\\Sample.exe");
    TCHAR args[] = _T("Sample.exe A B C D");

    BOOL b = CreateProcess(name, args, 0, 0, FALSE, CREATE_NEW_CONSOLE, 0, 0, &si, &pi);

    if(b)
    {
        // Process, Thread Kernel Objectê°€ ìƒì„±ë˜ê¸°ì— Closeí•´ ì£¼ì–´ì•¼ í•œë‹¤.
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        // Closeë¥¼ ë°˜ë“œì‹œ í•´ì¤˜ì•¼ í•˜ëŠ” ê²ƒì´ Kernel Objectì˜ ì°¸ì¡°ê°œìˆ˜ê°€ ì˜¬ë¼ê°€ ìˆê¸°ì—
        // Closeë¥¼ í•´ì£¼ì§€ ì•Šìœ¼ë©´ ìƒì„±ëœ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì§€ ì•ŠìŒ.
    }

    return 0;
}
```

<br>

ğŸ˜º `CreateProcessA`ì— ëŒ€í•œ ì„¤ëª…

```cpp
BOOL CreateProcessA(
  LPCSTR                lpApplicationName,      // í”„ë¡œê·¸ë¨ì˜ ì´ë¦„, ë§Œì•½ 0ì´ë¼ë©´ í˜„ì¬ ë””ë ‰í„°ë¦¬ or PATHì—ì„œ exeê²€ìƒ‰í•¨.
  LPSTR                 lpCommandLine,          // args(ë°˜ë“œì‹œ ë²„í¼ì— ë‹´ì•„ì„œ ë³´ë‚´ì•¼í•¨.)
  LPSECURITY_ATTRIBUTES lpProcessAttributes,    // ìƒì„±ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ Process Kernel Objectì˜ ë³´ì•ˆì†ì„± ì„¤ì •
  LPSECURITY_ATTRIBUTES lpThreadAttributes,     // ìƒì„±ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ Thread Kernel Objectì˜ ë³´ì•ˆì†ì„± ì„¤ì •
  BOOL                  bInheritHandles,        // Object Handle Tableì„ ìƒì†í•  ê²ƒì¸ê°€
  DWORD                 dwCreationFlags,        // í”„ë¡œì„¸ìŠ¤ ìš°ì„ ìˆœìœ„, ìƒì„± í”Œë˜ê·¸ (CREATE_NEW_CONSOLE : ìƒì„±ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ë„ ìƒˆë¡œìš´ ì½˜ì†”ì„ ì“°ê² ë‹¤.)
  LPVOID                lpEnvironment,
  LPCSTR                lpCurrentDirectory,     // ìƒì„±ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ì˜ ì‹œì‘ ë””ë ‰í„°ë¦¬ë¥¼ ì§€ì •
  LPSTARTUPINFOA        lpStartupInfo,          // ìƒì„±ë˜ëŠ” í”„ë¡œì„¸ìŠ¤ ìƒì„±ì‹œ ì˜µì…˜ì§€ì •
  LPPROCESS_INFORMATION lpProcessInformation    // ìë…€ í”„ë¡œì„¸ìŠ¤ ì •ë³´
);
```

---

## ExitCode(í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œì½”ë“œ)

* ì¢…ë£Œ ì½”ë“œ
    * Kernel Object Tableë‚´ì— ìˆìœ¼ë©° í•´ë‹¹ í”„ë¡œì„¸ìŠ¤ê°€ ì‚´ì•„ìˆì„ ê²½ìš° `STILL_ACTIVE`ê°€ ë‹´ê²¨ìˆë‹¤.
    * í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œ ë˜ë©´ mainí•¨ìˆ˜ì˜ ë¦¬í„´ê°’ì´ ì„¤ì • ëœë‹¤.

```cpp
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int _tmain()
{
    PROCESS_INFORMATION pi = { 0 };
    STARTUPINFO si = { 0 };
    si.cb = sizeof(si);

    TCHAR name[] = _T("C:\\Windows\\Sample.exe");
    TCHAR args[] = _T("Sample.exe A B C D");

    BOOL b = CreateProcess(name, args, 0, 0, FALSE, CREATE_NEW_CONSOLE, 0, 0, &si, &pi);

    if(b)
    {
        // CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    // pi.hProcessë¥¼ í†µí•´ì„œ ìì‹ í”„ë¡œì„¸ìŠ¤ì— ì ‘ê·¼ ê°€ëŠ¥
    // ì¢…ë£Œ ì½”ë“œ êº¼ë‚´ë³´ê¸°
    while(1)
    {
        int cmd;
        scanf_s("%d", &cmd);

        if(cmd == 1)
        {
            DWROD code;
            // í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë  ê²½ìš° PKOë‚´ì— ì¢…ë£Œì½”ë“œê°€ ë“¤ì–´ê°„ë‹¤
            // GetExitCodeProcessëŠ” PKOë‚´ì˜ ì¢…ë£Œì½”ë“œë¥¼ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤
            GetExitCodeProcess(pi.hProcess, &code);

            if(code == STILL_ACTIVE)
                _tprintf(_T("child alive\n"));
            else
                _tprintf(_T("exit code %d\n"), code);
        }
    }
    return 0;
}
```

<br>

ğŸ˜º ê°•ì œë¡œ ì£½ì´ê¸°

```cpp
while(1)
{
    int cmd;
    scanf_s("%d", &cmd);

    if(cmd == 2)
    {
        TerminateProcess(pi.hProcess, 300); // 300ì´ ì¢…ë£Œ ì½”ë“œê°€ ëœë‹¤.

        // ì°¸ê³ ë¡œ TerminateProcessëŠ” ë¹„ë™ê¸° í•¨ìˆ˜ì´ë‹¤.
        // ì¢…ë£Œë¥¼ ìš”ì²­ë§Œ í•´ë‘ê³  ì¢…ë£ŒëŠ” ì´í›„ì— ì¼ì–´ë‚œë‹¤.
        // ì•„ë˜ì—ì„œ ë°”ë¡œ ìì‹ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ì§€ ì•ŠëŠ” í˜„ìƒì´ ë°œìƒí•  ìˆ˜ ìˆìŒ.

        // ì§„ì§œë¡œ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ ì¡°ì‚¬í•´ë³´ê¸°
        // -> í•¸ë“¤ì´ ì‹œê·¸ë„ ë˜ì—ˆëŠ”ì§€ ì¡°ì‚¬
        WaitForSingleObject(pi.hProcess, INFINITE);
    }

    if(cmd == 1)
    {
        DWROD code;
        GetExitCodeProcess(pi.hProcess, &code);

        if(code == STILL_ACTIVE)
            _tprintf(_T("child alive\n"));
        else
            _tprintf(_T("exit code %d\n"), code);
    }
}
```

---

### Kernel Objectì˜ Signal ì¡°ê±´

* Kernel Objectì— ë”°ë¼ signal ì¡°ê±´ì´ ë‹¤ë¥´ë‹¤.
    * Process
        * Signal : ì£½ì„ ë•Œ
        * Non Signal : ì‚´ì•„ ìˆëŠ” ë™ì•ˆ
    * Thread
        * Signal : ì£½ì„ ë•Œ
        * Non Signal : ì‚´ì•„ ìˆëŠ” ë™ì•ˆ
    * FILE
        * Signal : R/W ì‘ì—…ì´ ì¢…ë£Œ
        * Non Signal : R/W ì‘ì—… ì¤‘
    * MUTEX
        * Signal : ì†Œìœ ìê°€ ì—†ì„ ë•Œ
        * Non Signal : ì†Œìœ ìê°€ ìˆì„ ë•Œ
    * SEMAPHORE
        * Signal : ì¹´ìš´íŠ¸ê°€ 0 
        * Non Signal : ì¹´ìš´íŠ¸ê°€ 0 ì´ìƒ ì¼ë•Œ