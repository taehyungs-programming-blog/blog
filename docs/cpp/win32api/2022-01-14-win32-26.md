---
layout: default
title: "26. DLL_INJECTION"
parent: (Windows API)
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## DLL Injectionì´ë€?

* ë‚´ê°€ ë§Œë“  DLLì„ ì‹¤í–‰ì¤‘ì¸ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì— ë„£ì–´ë³´ì
    * ì‚¬ìš©ìê°€ ë§Œë“  DLLì„ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì— (ê°•ì œ)ë¡œë“œ

* DLL Injection ë°©ë²•(ì¢…ë¥˜)
    * Remote Thread (ìš°ë¦¬ê°€ ì‚¬ìš©í•  ë°©ë²•)
    * Windows Message Hook
    * Debugging API Injection
    * Registry Injection
    * Trojan horse 

---

## Remote Thread

* ëŒ€ëµ ì´ëŸ° ë°©í–¥ìœ¼ë¡œ êµ¬í˜„ëœë‹¤.
    * ìœˆë„ìš°ì—ì„œ ì‹¤í–‰ë˜ëŠ” ëª¨ë“  í”„ë¡œì„¸ìŠ¤ëŠ” `Kernel32.dll`ì„ ë¡œë“œí•˜ê²Œ ëœë‹¤.
    * `Kernel32.dll`ì•ˆì—ëŠ” `LoadLibrary()`í•¨ìˆ˜ê°€ ìˆë‹¤.
    * `CreateRemoteThread`ë¥¼ ì´ìš©í•˜ë©´ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì˜ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆë‹¤
    * ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ì— ìƒì„±ëœ ìŠ¤ë ˆë“œë¥¼ ì´ìš©í•´ `LoadLibrary()`ë¥¼ í˜¸ì¶œ í•˜ë©° ë‚´ê°€ ë§Œë“  DLLì„ ë¡œë“œí•˜ê²Œ í•´ë³´ì.

ğŸ™€ ì‚¬ì‹¤ ê¸€ë¡œëŠ” ì´í•´ê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤ ... ã…ã… ì•„ë˜ ì˜ˆì œë¥¼ ë³´ì

```cpp
// Spy.cpp
// ëŒ€ëµ dllì€ ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±í•˜ê³ ..
#include <Windows.h>
#include <stdio.h>

BOOL _stdcall DllMain(HINSTANCE hinstDll, DWORD fwdReason, LPVOID lpvReserved)
{
    switch(fwdReason)
    {
    case DLL_PROCESS_ATTACH:
        MessageBoxA(0, "Inject Spy.dll", "SPY" MB_OK);
        break;
    case DLL_PROCESS_DETACH:
        MessageBoxA(0, "Eject Spy.dll", "SPY" MB_OK);
        break;
    }

    return TRUE;
}
```

```cpp
#include <Windows.h>
#include <stdio.h>

int main()
{
    const char* dllname = "D:\\Spy.dll";

    // 1. Injectì‹œí‚¬ í”„ë¡œì„¸ìŠ¤(ë©”ëª¨ì¥)ì˜ í•¸ë“¤ ì–»ê¸°
    // ë©”ëª¨ì¥ì˜ ìœˆë„ìš° í•¸ë“¤ ì–»ìŒ
    HWND hwnd = FindWindowA("Notepad", 0);
    DWORD pid;
    // ìœˆë„ìš° í•¸ë“¤ì„ ê¸°ë°˜ìœ¼ë¡œ í”„ë¡œì„¸ìŠ¤id ì–»ìŒ
    DWORD tid = GetWindowThreadProcessId(hwnd, &pid);

    // í”„ë¡œì„¸ìŠ¤ idê¸°ë°˜ìœ¼ë¡œ ë©”ëª¨ì¥ì˜ í”„ë¡œì„¸ìŠ¤ í•¸ë“¤ì„ ì–»ìŒ
    HANDLE hProcess = OpenProcess(PRICESS_ALL_ACCESS, FALSE, pid);

    printf("%x, %x, %x\n" hwnd, pid, hProcess);

    // 2. LoadLibrary ì£¼ì†Œ êµ¬í•˜ê¸°
    // kernel32.dllë‚´ì— LoadLibraryê°€ ìˆì„ ê²ƒì´ë‹¤.
    HMODULE hDll = GetModuleHandleA("kernel32.dll");
    PTHREAD_START_ROUTINE f = (PTHREAD_START_ROUTINE)GetProcAddress(hDll, "LoadLibraryA");

    // ì—¬ê¸°ì„œ êµ¬í•œ LoadLibraryì£¼ì†Œê°€ ë‚´ê°€ ì‚¬ìš©ì¤‘ì¸ Processì˜ LoadLibraryì£¼ì†Œì´ì§€
    // Injection ì‹œí‚¬ Processì˜ LoadLibraryì¼ ê²ƒì´ë¼ëŠ” ë³´ì¥ì´ ì—†ìŒ
    // ì´ ë¶€ë¶„ì— ëŒ€í•´ì„  ì´í›„ì— ì„¤ëª…, ìš°ì„ ì€ Kernel32.dll ë‚´ì—ì„œ ê°™ì€ ì£¼ì†Œë¥¼ ì“¸êº¼ë¼ ê°€ì •í•˜ì

    printf("%p, %p\n", hDll, f);

    // 3. Inject ì‹œí‚¬ í”„ë¡œì„¸ìŠ¤ ë‚´ì—ì„œ ìŠ¤ë˜ë“œ ìƒì„± í›„ LoadLibraryA ì‹¤í–‰í•˜ê¸°
    // HANDLE hThread = CreateRemoteThread(hProcess, 0, 0, f, (void*)dllname, 0, 0);
    // (void*)dllname -> dllì´ë¦„ì„ ì£¼ì†Œê°’ìœ¼ë¡œ ë„˜ê¸°ëŠ”ë° Inject ì‹œí‚¬ í”„ë¡œì„¸ìŠ¤ëŠ” ì´ ì£¼ì†Œê³µê°„ì— ë©”ëª¨ë¦¬ê°€ í• ë‹¹ë˜ì–´ ìˆì§€ ì•ŠìŒ -> ë©”ëª¨ë¦¬ ë³µì‚¬ í•„ìš”

    char* p = (char*)VirtualAllocEx(hProcess, 0, strlen(dllname)+1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    SIZE_T sz;
    WriteProcessMemory(hProcess, p, dllname ,strl(dllname)+1, &sz);

    HANDLE hThread = CreateRemoteThread(hProcess,         // ë©”ëª¨ì¥ì˜ í”„ë¡œì„¸ìŠ¤ í•¸ë“¤
                                        0, 0, 
                                        f,                // LoadLibraryA ì£¼ì†Œ
                                        (void*)dllname,   // LoadLibraryAì— ë„˜ê¸¸ íŒŒë¼ë¯¸í„°
                                        0, 0);

    // 4. ë¹Œë“œ
    // cl DLL_inject.cpp /link user32.lib kernel32.lib
}
```

<br>

ğŸ˜º ì´ë ‡ê²Œ í•˜ë©´ ë ê¹Œ? -> ë©”ëª¨ì¥ì´ ê·¸ëƒ¥ ì£½ì–´ë²„ë¦°ë‹¤.

```cpp
HANDLE hThread = CreateRemoteThread(hProcess,
                                    0, 0, 
                                    f,
                                    (void*)dllname,   
                                    // dllnameì€ ë©”ëª¨ì¥ì— í• ë‹¹ëœ ë³€ìˆ˜ê°€ ì•„ë‹ˆë¼
                                    // ë‚´ í”„ë¡œì„¸ìŠ¤ë§Œ ì•Œê³ ìˆëŠ” ë³€ìˆ˜ì´ë‹¤.
                                    // ë©”ëª¨ì¥ë„ ì•Œê³ ìˆê²Œ í•´ì•¼í•œë‹¤
                                    0, 0);
```

```cpp
// ...
// dllnameì„ ë³µì‚¬í•œë‹¤

char* p = (char*)VirtualAllocEx(hProcess, 0, strlen(dllname)+1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
SIZE_T sz;
WriteProcessMemory(hProcess, p, dllname ,strl(dllname)+1, &sz);

HANDLE hThread = CreateRemoteThread(hProcess,         // ë©”ëª¨ì¥ì˜ í”„ë¡œì„¸ìŠ¤ í•¸ë“¤
                                0, 0, 
                                f,          // LoadLibraryA ì£¼ì†Œ
                                (void*)p,   // pì— dllnameì˜ ê°’ì´ ë³µì‚¬ë˜ì–´ ìˆìŒ
                                0, 0);

// ...
```