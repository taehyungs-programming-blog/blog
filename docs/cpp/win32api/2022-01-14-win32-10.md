---
layout: default
title: "10. 가상주소 공간이란?"
parent: (Windows API)
grand_parent: C++
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Virtual Address(가상주소)란?

😺 프로그램이 실행시 메모리 공간에 올라가지만 그렇다고 프로그램 개발자가 직접 메모리 주소를 컨트롤 할 수 있는 것은 아니다.(만약 직접 컨트롤 할 수있다면 보안, 안정성 등 위험이 너무많음)

🙀 프로그래머의 실수로 잘못된 메모리 공간에 직접 접근시 자신의 프로그램 뿐만 아니라 잘못 사용된 메모리공간에 있는 다른 프로그램 혹은 OS 또한 오류를 유발할 수 있다

😺 OS(Windows)는 개발자가 어떻게 메모리를 사용하게 했을까? 👉 Page Table을 사용하여 실제 메모리가 올라간 **물리주소**와 **가상주소**를 매핑시켜 프로그램은 가상의 주소만 사용했다.(OS에서 Page Table을 관리해준다)

😺 이런 가상주소로 하나의 프로세스는 다른 프로세스가 사용하는 메모리에 접근할 수 없게 된다.

😺 기본적으로 하나의 프로세스는 다른 프로세스가 사용하는 메모리에 접근할 수 없게된다.

😺 설명이 엄청 길어졌는데. 더 자세한건 아래서 설명한다.

---

## 가상주소의 메모리 공간은 어떻게 구성될까?

😺 32bit 프로그램을 기준 총 사용가능한 메모리 공간은 4G이다. (2^32 = 4,294,967,296 즉 32bits는 4294967296개를 표현가능하다는 말이다.)

😺 상위 2G는 OS가 사용하며, 하위 2G는 실행파일, DLL, 스택, 힙이 올라가는 메모리이다.

```

 0xFFFF FFFF
|           |
|           | <- OS가 사용하는 메모리
|           |
|-----------| <- 0x8000 0000
|           |
|           | <- 실행파일, DLL, 스택, 힙 등이 올라간다
|           |
 0x0000 0000

```

<br>

---

## A, B 프로세스에서 같은 DLL을 사용시 DLL은 메모리에 몇번 로드될까?

😺 DLL은 물리 메모리에 한 번만 로드되고, 각 가상주소를 통해 접근한다.

😺 DLL로 공유 메모리 접근이 가능해진다.

```
 A.exe
|      |
|      |
|      | <- .idata속에 x.dll정보 포함
|------|


 x.dll
|      |
|      |
|      |
|------|

 B.exe
|      |
|      |
|      | <- .idata에 역시 x.dll정보 포함
|------|
```

<br>

😺 두 A, B. exe에 있는 x.dll은 같은 주소를 갖고 있는다(물리공간에 한번만 로드)

😺 이 기술을 이용해서 다양한 응용프로그래밍이 가능한데 ㅎㅎ.. 이것은 이후에 설명(재미있음😻)