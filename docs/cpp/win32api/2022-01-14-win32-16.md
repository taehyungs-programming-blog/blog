---
layout: default
title: "16. Threadë™ê¸°í™” ê¸°ë²• 4ê°œ(Critical Section, Mutex, Semaphore, Event)"
parent: (Windows API)
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## User Mode / Kernel Mode - Synchronization

* User Mode : Critical Section - í”„ë¡œì„¸ìŠ¤ë‚´ì˜ Threadë™ê¸°í™”
* Kernel Mode : Mutex, Semaphore - Kernelë¡œ ë™ì‘í•˜ê¸°ì— í”„ë¡œì„¸ìŠ¤ê°„ì˜ Threadë™ê¸°í™”

---

## Critical Section

```cpp
#include <stdio.h>
#include <Windows.h>
#include <process.h>
#include <tchar.h>

void delay() { for (int i = 0; i < 2000000; i++); }

UINT __stdcall foo(void* p)
{
    int x = 0;

    for(int i = 0; i < 20; i++)
    {
        x = 100; delay();
        x = x+1; delay();
        printf("%s : %d\n", p, x);
    }

    return 0;
}

int main()
{
    HANDLE h1 = (HANDLE)_beginthreadex(0, 0, foo, (void*)"A", 0, 0);
    HANDLE h2 = (HANDLE)_beginthreadex(0, 0, foo, (void*)"\tB", 0, 0);

    HANDLE h[2] = { h1, h2 };
    WaitForMultipleObjects(2, h , TRUE, INFINITE);
    CloseHandle(h1);
    CloseHandle(h2);
    return 0;
}
```

<br>

* ì§€ì—­ë³€ìˆ˜ëŠ” ìŠ¤íƒì— ë†“ì´ê³ 
* ìŠ¤íƒì€ ìŠ¤ë ˆë“œë‹¹ í•œ ê°œì”© ë”°ë¡œ ë§Œë“¤ì–´ì§„ë‹¤.
* ê²°ë¡ ì ìœ¼ë¡œ xëŠ” A, B Threadê°€ ê°™ì´ ì“°ì§€ ì•ŠëŠ”ë‹¤.

```cpp
// ...

UINT __stdcall foo(void* p)
{
    static int x = 0;

    for(int i = 0; i < 20; i++)
    {
        x = 100; delay();
        x = x+1; delay();
        printf("%s : %d\n", p, x);
    }

// ...
```

<br>

* static ì§€ì—­ë³€ìˆ˜ ë˜ëŠ” ì „ì—­ë³€ìˆ˜ëŠ” (.data Section)ë©”ëª¨ë¦¬ ê³µê°„ì— ë†“ì¸ë‹¤.
* ëª¨ë“  Threadê°€ ë°ì´í„°ë¥¼ ê³µìœ í•˜ê²Œ ëœë‹¤.
* -> Critical Sectionì˜ í•„ìš”ì„±

í•´ê²°ì±…?

```cpp
#include <stdio.h>
#include <Windows.h>
#include <process.h>
#include <tchar.h>

void delay() { for (int i = 0; i < 2000000; i++); }

// 1. ì „ì—­ êµ¬ì¡°ì²´ ë§Œë“¤ê¸°
CRITICAL_SECTION cs;

UINT __stdcall foo(void* p)
{
    int x = 0;

    for(int i = 0; i < 20; i++)
    {
        EnterCriticalSection(&cs);  // CriticalSection Enter
        x = 100; delay();
        x = x+1; delay();
        printf("%s : %d\n", p, x);
        LeaveCriticalSection(&cs);  // CriticalSection Leave
    }

    return 0;
}

int main()
{
    InitializeCriticalSection(&cs); // CriticalSection ì´ˆê¸°í™”

    HANDLE h1 = (HANDLE)_beginthreadex(0, 0, foo, (void*)"A", 0, 0);
    HANDLE h2 = (HANDLE)_beginthreadex(0, 0, foo, (void*)"\tB", 0, 0);

    HANDLE h[2] = { h1, h2 };
    WaitForMultipleObjects(2, h , TRUE, INFINITE);
    CloseHandle(h1);
    CloseHandle(h2);

    DeleteCriticalSection(&cs); // CriticalSection ì‚­ì œ

    return 0;
}
```

<br>

* ì•„ë¬´ëŸ° ë¬¸ì œê°€ ì—†ì–´ë³´ì´ë‚˜ CPUë‚´ë¶€ì—ì„  ì´ëŸ° ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤
    * CriticalSectionì— ë“¤ì–´ê°€ë ¤ ì‹œë„ EnterCriticalSection
    * í˜„ì¬ Block ì´ë¼ ë“¤ì–´ê°€ê¸°ë¥¼ í¬ê¸°í•˜ê³  í•´ë‹¹ Threadë¥¼ ëŒ€ê¸°ì‹œí‚¨ë‹¤(Context Switch ë¹„ìš©ë°œìƒ)
        * ì—¬ê¸°ì„œ ë¬¸ì œë°œìƒ ë”± í•œ ë²ˆ EnterCriticalSectionì„ ì‹œë„í•˜ê¸°ì— ëª‡ë²ˆ ë” í•´ë´¤ìœ¼ë©´ ë“¤ì–´ê°ˆìˆ˜ ìˆì„ CriticalSectionì´ì˜€ëŠ”ë° ì˜ë¯¸ì—†ì´ ë‹¤ë¥¸ Threadì—ê²Œ ìš°ì„ ê¶Œì„ ë„˜ê¸°ê²Œ ë˜ë©° Context Switch ë¹„ìš©ë°œìƒëœë‹¤
        * ì¶”ê°€ë¡œ Blockë˜ì—ˆë˜ Threadë¥¼ ë‹¤ì‹œ Activeë¡œ ëŒë¦¬ë©° ë˜ Context Switch ë¹„ìš©ì´ ë°œìƒ

**ì°¨ë¼ë¦¬ CriticalSectionì— ë“¤ì–´ê°€ë ¤ëŠ” ì‹œë„ë¥¼ í•œ ë²ˆë§Œ í•´ë³´ëŠ”ê²Œ ì•„ë‹ˆë¼ ì—¬ëŸ¬ë²ˆ í•´ë³´ì.**

```cpp
#include <stdio.h>
#include <Windows.h>
#include <process.h>
#include <tchar.h>

void delay() { for (int i = 0; i < 2000000; i++); }

// 1. ì „ì—­ êµ¬ì¡°ì²´ ë§Œë“¤ê¸°
CRITICAL_SECTION cs;

UINT __stdcall foo(void* p)
{
    int x = 0;

    for(int i = 0; i < 20; i++)
    {
        EnterCriticalSection(&cs);
        x = 100; delay();
        x = x+1; delay();
        printf("%s : %d\n", p, x);
        LeaveCriticalSection(&cs);
    }

    return 0;
}

int main()
{
    InitializeCriticalSectionAndSpinCount(&cs, 4000);   // ë“¤ì–´ê°€ë ¤ëŠ” ì‹œë„ë¥¼ 4000ë²ˆ í•´ë´ë¼

    HANDLE h1 = (HANDLE)_beginthreadex(0, 0, foo, (void*)"A", 0, 0);
    HANDLE h2 = (HANDLE)_beginthreadex(0, 0, foo, (void*)"\tB", 0, 0);

    HANDLE h[2] = { h1, h2 };
    WaitForMultipleObjects(2, h , TRUE, INFINITE);
    CloseHandle(h1);
    CloseHandle(h2);

    DeleteCriticalSection(&cs);

    return 0;
}
```

---

## Mutex ê°œë…

* í•˜ë‚˜ì˜ í™”ì¥ì‹¤ì— ì—¬ëŸ¬ëª…ì´ ë“¤ì–´ê°€ë ¤í•œë‹¤.
* í‚¤ëŠ” í•˜ë‚˜ ë¿ì´ê³  ì´ í‚¤ë¥¼ Mutexë¼ í•˜ì
* ëˆ„êµ°ê°€ í™”ì¥ì‹¤ì„ ì‚¬ìš©ì¤‘ì¼ë•ŒëŠ” ë‚˜ë¨¸ì§€ ì¸ì›ì€ ëŒ€ê¸°í•´ì•¼ í•œë‹¤.

* Mutex : ê³µìœ  ìì›ì„ í•˜ë‚˜ì˜ Threadê°€ ë…ì í•  ìˆ˜ ìˆê²Œ í•´ì¤Œ

```cpp
// MutexExample.exe
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int main()
{
    printf("try acquire mutex\n");

    HANDLE hMutex = CreateMutexEx(0,            // ë³´ì•ˆì†ì„±
                                _T("MyMutex"),  // ì´ë¦„
                                0,              // ì†Œìœ ì ì§€ì •(0 : ì†Œìœ ì ì—†ìŒ)
                                MUTEX_ALL_ACCESS);

    WaitForSingleObject(hMutex, INFINITE);  // ì†Œìœ ìê°€ ì—†ì„ ê²½ìš° Signal

    // waitë¡œ mutex í†µê³¼ì‹œ, Threadê°€ mutexë¥¼ ì†Œìœ í•˜ê²Œ ë¨.
    // signal -> non-signalì´ ëœë‹¤

    printf("get mutex\n");

    MessageBoxA(0, "release", "", MB_OK);
    ReleaseMutex(hMutex);

    CloseHandle(hMutex);
}
```

<br>

ğŸ˜º `MutexExample.exe`ë¥¼ ì—¬ëŸ¬ë²ˆ ì‹¤í–‰í•´ë³´ë©´ ì²« ë²ˆì§¸ë¥¼ ì œì™¸í•˜ê³  ì´í›„ëŠ” get mutexë¥¼ ë³¼ ìˆ˜ ì—†ë‹¤. ë¨¼ì € Mutexë¥¼ ì¡ì•˜ë˜ í”„ë¡œì„¸ìŠ¤ê°€ Mutexë¥¼ Releaseí•´ì¤˜ì•¼ í•œë‹¤. get mutexê°€ ëœë‹¤.

ğŸ˜º ë‘ ë²ˆì§¸ Mutexë¶€í„°ëŠ” TKO(Thread Kernel Object)ì—ì„œ ê´€ë¦¬ì¤‘ì¸ Mutexì˜ ì†Œìœ íšŸìˆ˜ë¥¼ 1ì”© ì¦ê°€ ì‹œí‚¤ë©° ëˆ„ê°€ ê¸°ë‹¤ë¦¬ëŠ”ì§€ ì²´í¬í•˜ê²Œ ëœë‹¤.

> ğŸ™€ (ì°¸ê³ 1) WindowsëŠ” ê°™ì€ Kernel Object ì´ë¦„ì„ ì§€ì›í•˜ì§€ ì•ŠìŒ, ê°™ì€ Kernel Objectë¡œ ë§Œë“œë ¤í•  ê²½ìš° ê¸°ì¡´ì— ìˆë˜ Kernel Object ë¥¼ ë¦¬í„´í•´ì¤€ë‹¤.
> 
> ğŸ™€ (ì°¸ê³ 2) signalì´ ë  ê²½ìš° Wait í•œ ìˆœì„œëŒ€ë¡œ mutexë¥¼ ë°›ëŠ”ë‹¤ëŠ” ë³´ì¥ì´ ì—†ìŒ. ì£¼ì˜


```cpp
// MutexExample2.exe
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int main()
{
    printf("try acquire mutex\n");

    HANDLE hMutex = CreateMutexEx(0, _T("MyMutex"), 0, MUTEX_ALL_ACCESS);

    WaitForSingleObject(hMutex, INFINITE);
    printf("get mutex\n");
    MessageBoxA(0, "release", "", MB_OK);

    WaitForSingleObject(hMutex, INFINITE);  // ì£¼ Threadì—ì„œ Mutexë¥¼ ê°–ê³  ìˆê¸°ì— ì—¬ê¸°ì„œ Waitë˜ì§€ ì•ŠìŒ
    printf("get mutex\n");
    MessageBoxA(0, "release", "", MB_OK);

    // ë‹¨, í•˜ë‚˜ì˜ Threadì—ì„œ Mutexë¥¼ ë‘ ë²ˆ ì†Œìœ í•  ê²½ìš°
    // ì†Œìœ  ì¹´ìš´íŠ¸ê°€ ì˜¬ë¼ê°€ê¸°ì— Releaseë„ ë‘ ë²ˆ í•´ì¤˜ì•¼ í•œë‹¤.
    ReleaseMutex(hMutex);
    ReleaseMutex(hMutex);

    CloseHandle(hMutex);
}
```

```cpp
// MutexExample3.exe
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int main()
{
    printf("try acquire mutex\n");

    HANDLE hMutex = CreateMutexEx(0, _T("MyMutex"), 0, MUTEX_ALL_ACCESS);

    WaitForSingleObject(hMutex, INFINITE);

    printf("get mutex\n");

    MessageBoxA(0, "release", "", MB_OK);
    //ReleaseMutex(hMutex);
    // Mutexë¥¼ ë°˜ë‚©í•˜ì§€ ì•Šê³  ê·¸ëƒ¥ ì£½ì–´ë²„ë¦°ë‹¤ë©´??

    /*
    ABANDONED(ë²„ë ¤ì§„) MUTEX
    -> ë®¤í…ìŠ¤ë¥¼ ì†Œìœ í•œ ìŠ¤ë ˆë“œê°€ ReleaseMutexë¡œ ë°˜ë‚©í•˜ì§€ ì•Šê³  ì£½ì€ê²½ìš°
    -> ìƒˆë¡œìš´ ìŠ¤ë ˆë“œê°€ Mutexë¥¼ ì†Œìœ í•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ê³µìœ  ìì›ì— ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆë‹¤.(ë°ì´í„°ì˜ ì˜¤ì—¼ì´ ìˆì„ ìˆ˜ ìˆë‹¤ëŠ” ë§.)
    */

    CloseHandle(hMutex);
}
```

```cpp
// ë¦¬í„´ì€ ì´ë ‡ê²Œ ë°›ëŠ”ë‹¤

DWORD ret = WaitForSingleObject(hMutex, INFINITE);

if(ret == WAIT_OBJECT_0)
{
    // ì •ìƒì¢…ë£Œë˜ì–´ Mutexë¥¼ ë°›ìŒ.
}
else if(ret == WAIT_ABANDONED)
{
    // í¬ê¸°ëœ ë®¤í…ìŠ¤ë¥¼ ë°›ìŒ.
}
```

---

## Semaphore

* í™”ì¥ì‹¤ì´ ì—¬ëŸ¬ê°œì´ê³ , ê·¸ í™”ì¥ì‹¤ì˜ ê°œìˆ˜ë§Œí¼ í‚¤ë¥¼ ë§Œë“¦
* í‚¤ë¥¼ ì—­ì‹œ Semaphoreë¼ í•œë‹¤.
* ìì› ê°œìˆ˜ë¥¼ ê´€ë¦¬í•˜ê³  ìì›ì˜ í•œì •ì  ê³µìœ ê°€ ê°€ëŠ¥í•´ì§„ë‹¤.

```cpp
// SemaphoreExample.exe
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>

int main()
{
    HANDLE hSem = CreateSemaphoreEx(0,  // ë³´ì•ˆ ê°’
                    3,                  // ì¹´ìš´íŠ¸ ê°’
                    3,                  // ìµœëŒ€ ì¹´ìš´íŠ¸ ê°’
                    _T("MySem"),        // ì´ë¦„
                    0,                  // ì‚¬ìš©ì•ˆë¨
                    SEMAPHORE_ALL_ACCESS);

    WaitForSingleObject(hSem, INFINITE);    // ì¹´ìš´íŠ¸ê°€ 0ë³´ë‹¤ í´ ì‹œ Signal
    // ì¹´ìš´íŠ¸ ê°’ì´ -1ëœë‹¤.
    // ë§Œì•½ ì¹´ìš´íŠ¸ ê°’ì´ 0ì´ ë ì‹œ non Signalì´ ë¨.

    MessageBoxA(0, "Release", "", MB_OK);
    LONG old;
    ReleaseSemaphore(hSem, 1, &old);

    return 0;
}
```

ğŸ˜º `SemaphoreExample.exe`ë¥¼ ì—¬ëŸ¬ë²ˆ ì‹¤í–‰í•˜ë©´ ì¹´ìš´íŠ¸ ë§Œí¼ì€ ë©”ì‹œì§€ë°•ìŠ¤ê°€ ë‚˜íƒ€ë‚˜ë‚˜

ğŸ˜º ì¹´ìš´íŠ¸ ì´ìƒë„˜ì–´ê°€ë©´ non Signal ë˜ì–´ ë©”ì‹œì§€ë°•ìŠ¤ê°€ ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŒ.

* ìƒê°í•´ë³´ë©´ ì›ƒê¸°ì§€ ì•ŠëŠ”ê°€? semaphoreë¥¼ ì“°ëŠ”ì´ìœ ê°€ critical sectionì´ ìƒê²¨ì„œ ê·¸ sectionì„ ë³´í˜¸í•˜ê¸° ìœ„í•´ì„œì¸ë° ì—¬ëŸ¬ threadì˜ ì…ì¥ì„ í—ˆìš©í•œë‹¤??
* í•„ìš”í• ë•Œê°€ ìˆë‹¤. í•˜ë‚˜ì˜ Threadì—ì„œ ì“°ê³  ì—¬ëŸ¬ Threadì—ì„œ ì½ì–´ì•¼í•˜ëŠ” ìƒí™©ì´ ë°œìƒí•  ê²½ìš°
* ì“°ëŠ” ThreadëŠ” Mutexë¥¼ ì¡ê³  ì•„ë¬´ë„ ëª»ë“¤ì–´ì˜¤ê²Œí•˜ê³  ì½ëŠ” Threadë“¤ì€ semaphoreë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ì–¼ë§ˆë‚˜ ì½ê³  ìˆëŠ”ì§€ë¥¼ì²´í¬í•œë‹¤. ì´ëŸ°ì‹ìœ¼ë¡œ ì‚¬ìš©ë ë•Œê°€ ìˆìŒ.

---

## Event

* Threadê°„ í†µì‹ ì— ì‚¬ìš©ëœë‹¤.
* í•˜ë‚˜ì˜ Threadì—ì„œ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŒì„ ì•Œë¦´ ìˆ˜ ìˆë‹¤.

```cpp
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>
#include <process.h>

HANDLE hEvent = 0;

UINT __stdcall foo(void* p)
{
    WaitForSingleObject(hEvent, INFINITE);  // Signalì´ ë˜ì§€ ì•Šê¸°ì— ë¬´í•œ ëŒ€ê¸°
    printf("foo start work\n");
    return 0;
}

int main()
{
    hEvent = CreateEventEx(0, _T("MyEvent"),
                0, // ì´ˆê¸° ì‹œê·¸ë„ ìƒíƒœì™€ resetì˜ ì¢…ë¥˜(0 : non signal, auto reset)
                EVENT_ALL_ACCESS);

    HANDLE hThread = (HANDLE)_beginthreadex(0, 0, foo, 0, 0, 0);

    getchar();
    SetEvent(hEvent);   // Signal ë¨
    getchar();
    CloseHandle(hEvent);
    return 0;
}
```

```cpp
#include <stdio.h>
#include <Windows.h>
#include <tchar.h>
#include <process.h>

HANDLE hEvent = 0;

UINT __stdcall foo(void* p)
{
    // Waitë¥¼ ë‘ ë²ˆ í•˜ê²Œ í•´ë³´ì.
    WaitForSingleObject(hEvent, INFINITE);
    printf("foo start work\n");

    // auto resetì˜ íš¨ê³¼ë¡œ ë‹¤ì‹œ non-Signalë˜ì–´ ì—¬ê¸°ì„œ ë©ˆì¶¤
    WaitForSingleObject(hEvent, INFINITE);
    printf("foo start work\n");
    return 0;
}

int main()
{
    hEvent = CreateEventEx(0, _T("MyEvent"),
                0,
                EVENT_ALL_ACCESS);

    HANDLE hThread = (HANDLE)_beginthreadex(0, 0, foo, 0, 0, 0);

    getchar();
    SetEvent(hEvent);
    getchar();
    CloseHandle(hEvent);
    return 0;
}
```