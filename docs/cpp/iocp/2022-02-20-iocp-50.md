---
layout: default
title: "50. íŒ¨í‚· ìë™í™”"
parent: (IOCP)
grand_parent: C++
nav_order: 6
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

{% raw %}

ğŸ” ìš°ì„  ì§€ë‚œê°•ê³¼ ë‹¬ë¼ì§„ ì ì´ íŒ¨í‚·ì„ protobufë¡œ ì²˜ë¦¬í•˜ëŠ”ë° [ì—¬ê¸° ğŸŒ](https://taehyungs-programming-blog.github.io/blog/docs/cpp/protobuf/2022-02-21-proto-1/)ë¥¼ ì°¸ì¡°

---

ğŸ” protobufë¥¼ ì ìš©í•˜ê¸´ í–ˆìœ¼ë‚˜ ì•„ì§ê¹Œì§„ ë°˜ë³µì ì¸ ì‘ì—…ì´ ìš”êµ¬ëœë‹¤.

* ë¶ˆí¸í•œ ì‘ì—… ì •ë¦¬
    * ë°°ì¹˜íŒŒì¼ ì‹¤í–‰
    * `.proto` íŒŒì¼ ìƒì„±
    * ìƒì„±ëœ `.h`, `.cc` íŒŒì¼ ì˜®ê¸°ê¸°
    * ...

ğŸ” ìš°ì„  ì‰¬ìš´ê±° ë¶€í„° ì²˜ë¦¬í•´ë³´ì, 

## ìƒì„±ëœ .h, .cc íŒŒì¼ ì˜®ê¸°ê¸°

```bash
# GenPackets.bat

# pushd %~dp0 - GenPackets.batê°€ ìˆëŠ” ê²½ë¡œê°€ ì‹œì‘ê²½ë¡œê°€ ë˜ê²Œ ë³€ê²½
pushd %~dp0
protoc.exe -I=./ --cpp_out=./ ./Enum.proto
protoc.exe -I=./ --cpp_out=./ ./Struct.proto
protoc.exe -I=./ --cpp_out=./ ./Protocol.proto
IF ERRORLEVEL 1 PAUSE

# /Y - ë®ì–´ì“°ê¸° yes
XCOPY /Y Enum.pb.h "../../../GameServer"
XCOPY /Y Enum.pb.cc "../../../GameServer"
XCOPY /Y Struct.pb.h "../../../GameServer"
XCOPY /Y Struct.pb.cc "../../../GameServer"
XCOPY /Y Protocol.pb.h "../../../GameServer"
XCOPY /Y Protocol.pb.cc "../../../GameServer"

XCOPY /Y Enum.pb.h "../../../DummyClient"
XCOPY /Y Enum.pb.cc "../../../DummyClient"
XCOPY /Y Struct.pb.h "../../../DummyClient"
XCOPY /Y Struct.pb.cc "../../../DummyClient"
XCOPY /Y Protocol.pb.h "../../../DummyClient"
XCOPY /Y Protocol.pb.cc "../../../DummyClient"
```

ğŸ” ë¹Œë“œì‹œì—ë„ ìë™ìœ¼ë¡œ `GenPackets.bat`ì„ ì‹¤í–‰í•˜ë„ë¡ í•´ë³´ì.

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/iocp/iocp-50-1.png"/>
</p>

ğŸ” ë‹¨, `*.proto` íŒŒì¼ì´ ìˆ˜ì •ë˜ì—ˆì„ë•Œ `GenPackets.bat`ê°€ í˜¸ì¶œë˜ì–´ì•¼ í•˜ë‹ˆ ì¡°ê¸ˆë” ìˆ˜ì •ì´ í•„ìš”í•˜ë‹¤.<br>
ğŸ” ê·¸ëƒ¥ì€ ë¶ˆê°€ëŠ¥í•˜ê³  `.vcxproj`íŒŒì¼ì˜ ìˆ˜ì •ì´ í•„ìš”í•˜ë‹¤

```xml
<!-- ... -->

  <ItemGroup>
    <UpToDateCheckInput Include="..\Common\Protobuf\bin\Enum.proto" />
    <UpToDateCheckInput Include="..\Common\Protobuf\bin\Protocol.proto" />
    <UpToDateCheckInput Include="..\Common\Protobuf\bin\Struct.proto" />
  </ItemGroup>

<!-- ... -->
```

---

## ì½”ë“œ ìë™í™” í•„ìš” ë¶€ë¶„

ğŸ” ìš°ì„  ëŒ€ëµ ì–´ë–»ê²Œ ì“°ì¼ì§€ ì„¤ëª…í•˜ë©´

```cpp
void GameSession::OnRecvPacket(BYTE* buffer, int32 len)
{
	PacketSessionRef session = PacketSessionRef();
	PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);

    // íŒ¨í‚·ì´ ìˆ˜ì‹ ë˜ë©´ HandlePacketë¥¼ í˜¸ì¶œ
	ServerPacketHandler::HandlePacket(session, buffer, len);
}
```

```cpp
static bool HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len)
{
    PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);

    // ì •ì˜ëœ íŒ¨í‚·ë‚´ì—ì„œ ì²˜ë¦¬ëœë‹¤.
    return GPacketHandler[header->id](session, buffer, len);
}
```

ğŸ” ì´ ì •ì˜ëœ íŒ¨í‚·ë‚´ì˜ íŒ¨í‚·ì´ ìë™í™” ë˜ì–´ì•¼ í•¨.

```cpp
#pragma once
#include "Protocol.pb.h"

using PacketHandlerFunc = std::function<bool(PacketSessionRef&, BYTE*, int32)>;
extern PacketHandlerFunc GPacketHandler[UINT16_MAX];

enum : uint16
{
    // TODO : ì „ì²´ íŒ¨í‚· ìë™í™” í•„ìš”
	PKT_S_TEST = 1,
	PKT_S_LOGIN = 2,
};

// TODO : ìë™í™”
// Custom Handlers
bool Handle_INVALID(PacketSessionRef& session, BYTE* buffer, int32 len);
bool Handle_S_TEST(PacketSessionRef& session, Protocol::S_TEST& pkt);

class ServerPacketHandler
{
public:
	// TODO : ìë™í™”
	static void Init()
	{
		for (int32 i = 0; i < UINT16_MAX; i++)
			GPacketHandler[i] = Handle_INVALID;
            /*
                bool Handle_INVALID(PacketSessionRef& session, BYTE* buffer, int32 len)
                {
                    PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);
                    // TODO : Log
                    return false;
                }
            */

		GPacketHandler[PKT_S_TEST] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::S_TEST>(Handle_S_TEST, session, buffer, len); };
	}

	static bool HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len)
	{
		PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);
		return GPacketHandler[header->id](session, buffer, len);
	}

	// TODO : ìë™í™”
	static SendBufferRef MakeSendBuffer(Protocol::S_TEST& pkt) { return MakeSendBuffer(pkt, PKT_S_TEST); }

private:
	template<typename PacketType, typename ProcessFunc>
	static bool HandlePacket(ProcessFunc func, PacketSessionRef& session, BYTE* buffer, int32 len)
	{
		PacketType pkt;
		if (pkt.ParseFromArray(buffer + sizeof(PacketHeader), len - sizeof(PacketHeader)) == false)
			return false;

		return func(session, pkt);
	}

	template<typename T>
	static SendBufferRef MakeSendBuffer(T& pkt, uint16 pktId)
	{
		const uint16 dataSize = static_cast<uint16>(pkt.ByteSizeLong());
		const uint16 packetSize = dataSize + sizeof(PacketHeader);

		SendBufferRef sendBuffer = GSendBufferManager->Open(packetSize);
		PacketHeader* header = reinterpret_cast<PacketHeader*>(sendBuffer->Buffer());
		header->size = packetSize;
		header->id = pktId;
		ASSERT_CRASH(pkt.SerializeToArray(&header[1], dataSize));
		sendBuffer->Close(packetSize);

		return sendBuffer;
	}
};
```

---

## ì½”ë“œë¥¼ ìë™í™” í•´ë³´ì.

### python jinja2

```bash
$ pip install jinja2
$ pip install pyinstaller
```

```py
import argparse     # ì‹¤í–‰íŒŒì¼ ì „ë‹¬ ì•„ê·œë¨¼íŠ¸ ì²˜ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬
import jinja2       # ì½”ë“œ ìë™í™” ë¼ì´ë¸ŒëŸ¬ë¦¬
import ProtoParser  # ìš°ë¦¬ê°€ ë§Œë“  passer

def main():

	arg_parser = argparse.ArgumentParser(description = 'PacketGenerator')

    # .proto íŒŒì¼ì˜ ê²½ë¡œ ì§€ì •
	arg_parser.add_argument('--path', type=str, default='C:/Rookiss/CPP_Server/Server/Common/Protobuf/bin/Protocol.proto', help='proto path')

    # ì¶œë ¥íŒŒì¼ì˜ ê²½ë¡œ ì§€ì •
	arg_parser.add_argument('--output', type=str, default='TestPacketHandler', help='output file')

    # 
	arg_parser.add_argument('--recv', type=str, default='C_', help='recv convention')

    # 
	arg_parser.add_argument('--send', type=str, default='S_', help='send convention')

    # ì‚¬ìš©ì€ args.path = --path ì´ëŸ°ì‹ìœ¼ë¡œ ì‚¬ìš©ë¨.(ì•„ë˜ì°¸ì¡°)
	args = arg_parser.parse_args()

	parser = ProtoParser.ProtoParser(1000, args.recv, args.send)
	parser.parse_proto(args.path)
	file_loader = jinja2.FileSystemLoader('Templates')
	env = jinja2.Environment(loader=file_loader)

	template = env.get_template('PacketHandler.h')
	output = template.render(parser=parser, output=args.output)

	f = open(args.output+'.h', 'w+')
	f.write(output)
	f.close()

	print(output)
	return

if __name__ == '__main__':
	main()
```

```py
# ProtoParser.py

class ProtoParser():
	def __init__(self, start_id, recv_prefix, send_prefix):
		self.recv_pkt = []	    # ìˆ˜ì‹  íŒ¨í‚· ëª©ë¡
		self.send_pkt = []      # ì†¡ì‹  íŒ¨í‚· ëª©ë¡
        self.total_pkt = []     # ëª¨ë“  íŒ¨í‚· ëª©ë¡
		self.start_id = start_id
		self.id = start_id
		self.recv_prefix = recv_prefix
		self.send_prefix = send_prefix

	def parse_proto(self, path):
        # .proto íŒŒì¼ì„ ë¼ì¸ë‹¨ìœ„ë¡œ ì½ì–´ì¤€ë‹¤.
		f = open(path, 'r')
		lines = f.readlines()

		for line in lines:
            # messageë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸
			if line.startswith('message') == False:
				continue

            # S_, C_ë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸
			pkt_name = line.split()[1].upper()
			if pkt_name.startswith(self.recv_prefix):
				self.recv_pkt.append(Packet(pkt_name, self.id))
			elif pkt_name.startswith(self.send_prefix):
				self.send_pkt.append(Packet(pkt_name, self.id))
			else:
				continue

			self.total_pkt.append(Packet(pkt_name, self.id))
			self.id += 1

		f.close()

class Packet:
	def __init__(self, name, id):
		self.name = name
		self.id = id
```

```cpp
// template íŒŒì¼

#pragma once
#include "Protocol.pb.h"

using PacketHandlerFunc = std::function<bool(PacketSessionRef&, BYTE*, int32)>;
extern PacketHandlerFunc GPacketHandler[UINT16_MAX];

enum : uint16
{
// total_pkt ë‚´ì—ì„œ ë°˜ë³µë¬¸ì„ ëŒì•„ë‹¬ë¼ëŠ” ë§.
{%- for pkt in parser.total_pkt %}
	PKT_{{pkt.name}} = {{pkt.id}},
{%- endfor %}
};

// Custom Handlers
bool Handle_INVALID(PacketSessionRef& session, BYTE* buffer, int32 len);

// ì—­ì‹œ recv_pktë‚´ì—ì„œ ë°˜ë³µë¬¸ì„ ëŒì•„ë‹¬ë¼ëŠ” ë§.
{%- for pkt in parser.recv_pkt %}
bool Handle_{{pkt.name}}(PacketSessionRef& session, Protocol::{{pkt.name}}& pkt);
{%- endfor %}

class {{output}}
{
public:
	static void Init()
	{
		for (int32 i = 0; i < UINT16_MAX; i++)
			GPacketHandler[i] = Handle_INVALID;

{%- for pkt in parser.recv_pkt %}
		GPacketHandler[PKT_{{pkt.name}}] = [](PacketSessionRef& session, BYTE* buffer, int32 len) { return HandlePacket<Protocol::{{pkt.name}}>(Handle_{{pkt.name}}, session, buffer, len); };
{%- endfor %}
	}

	static bool HandlePacket(PacketSessionRef& session, BYTE* buffer, int32 len)
	{
		PacketHeader* header = reinterpret_cast<PacketHeader*>(buffer);
		return GPacketHandler[header->id](session, buffer, len);
	}

{%- for pkt in parser.send_pkt %}
	static SendBufferRef MakeSendBuffer(Protocol::{{pkt.name}}& pkt) { return MakeSendBuffer(pkt, PKT_{{pkt.name}}); }
{%- endfor %}

private:
	template<typename PacketType, typename ProcessFunc>
	static bool HandlePacket(ProcessFunc func, PacketSessionRef& session, BYTE* buffer, int32 len)
	{
		PacketType pkt;
		if (pkt.ParseFromArray(buffer + sizeof(PacketHeader), len - sizeof(PacketHeader)) == false)
			return false;

		return func(session, pkt);
	}

	template<typename T>
	static SendBufferRef MakeSendBuffer(T& pkt, uint16 pktId)
	{
		const uint16 dataSize = static_cast<uint16>(pkt.ByteSizeLong());
		const uint16 packetSize = dataSize + sizeof(PacketHeader);

		SendBufferRef sendBuffer = GSendBufferManager->Open(packetSize);
		PacketHeader* header = reinterpret_cast<PacketHeader*>(sendBuffer->Buffer());
		header->size = packetSize;
		header->id = pktId;
		ASSERT_CRASH(pkt.SerializeToArray(&header[1], dataSize));
		sendBuffer->Close(packetSize);

		return sendBuffer;
	}
};

```

{% endraw %}