---
layout: default
title: "20. STL ì»¨í…Œì´ë„ˆ ë©”ëª¨ë¦¬ ì§ì ‘í• ë‹¹"
parent: (IOCP)
grand_parent: C++
nav_order: 3
---

ğŸ˜º STL containerë„ ê°œë°œìê°€ ì§ì ‘ ë©”ëª¨ë¦¬ allocationí•  ìˆ˜ ìˆì„ê¹Œ??

ğŸ˜º STL ìƒì„±ìë¥¼ ë”°ë¼ê°€ë³´ë©´ Allocatorë¥¼ ë°›ì•„ì¤Œì„ ì•Œìˆ˜ ìˆë‹¤.

```cpp
// ...
// CLASS TEMPLATE vector
template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { // varying size array of values
private:
// ...
```

<br>

ğŸ˜º STLì—ì„œ ì‚¬ìš©ê°€ëŠ¥í•œ Allocatorë¥¼ ë§Œë“¤ì–´ë³´ì.

```cpp
template<typename T>
class StlAllocator
{
public:
    // ì¼ë‹¨ value_typeì„ STLAllocatorì— ì €ì¥í•´ë‘”ë‹¤.
    using value_type = T;
    StlAllocator() { }
    // ë³µì‚¬ìƒì„±ìì˜ í˜•ì‹ì„ ë§Œë“¤ì–´ë‘”ë‹¤.
    template<typename Other>
    StlAllocator(const StlAllocator<Other>&) { }
    // ì‹¤ì§ˆì ìœ¼ë¡œ ë°ì´í„°ë¥¼ í• ë‹¹ í—¤ì œí•˜ëŠ” í•¨ìˆ˜ë¥¼ ìƒì„±í•œë‹¤.(xalloc, xreleaseëŠ” ì´ì „ê°•ì˜ ì°¸ì¡°)
    T* allocate(size_t count)
    {
        const int32 size = static_cast<int32>(count * sizeof(T));
        return static_cast<T*>(xalloc(size));
    }
    void deallocate(T* ptr, size_t count)
    {
        xrelease(ptr);
    }
};
```

```cpp
// ...
#ifdef _DEBUG
#define xalloc(size)        StompAllocator::Alloc(size)
#define xrelease(ptr)       StompAllocator::Release(ptr)
#else
// ...
```

<br>

ğŸ˜º ì‚¬ìš©ì˜ í¸ì˜ì„±ì„ ìœ„í•´ì„œ ë§¤í¬ë¡œë¥¼ ë§Œë“¤ì–´ ì‚¬ìš©í•˜ì

```cpp
// ...
template<typename Type>
using Vector = vector<Type, StlAllocator<Type>>;
template<typename Type>
using List = list<Type, StlAllocator<Type>>;
template<typename Key, typename Type, typename Pred = less<Key>>
using Map = map<Key, Type, Pred, StlAllocator<pair<const Key, Type>>>;
template<typename Key, typename Pred = less<Key>>
using Set = set<Key, Pred, StlAllocator<Key>>;
template<typename Type>
using Deque = deque<Type, StlAllocator<Type>>;
template<typename Type, typename Container = Deque<Type>>
using Queue = queue<Type, Container>;
template<typename Type, typename Container = Deque<Type>>
using Stack = stack<Type, Container>;
template<typename Type, typename Container = Vector<Type>, typename Pred = less<typename Container::value_type>>
using PriorityQueue = priority_queue<Type, Container, Pred>;
// Stringë„ Allocatorë¥¼ í• ë‹¹
using String = basic_string<char, char_traits<char>, StlAllocator<char>>;
using WString = basic_string<wchar_t, char_traits<wchar_t>, StlAllocator<wchar_t>>;
template<typename Key, typename Type, typename Hasher = hash<Key>, typename KeyEq = equal_to<Key>>
using HashMap = unordered_map<Key, Type, Hasher, KeyEq, StlAllocator<pair<const Key, Type>>>;
template<typename Key, typename Hasher = hash<Key>, typename KeyEq = equal_to<Key>>
using HashSet = unordered_set<Key, Hasher, KeyEq, StlAllocator<Key>>;
```