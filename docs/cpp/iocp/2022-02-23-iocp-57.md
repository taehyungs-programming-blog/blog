---
layout: default
title: "57. XML Parser"
parent: (IOCP)
grand_parent: C++
nav_order: 6
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ‘º ìš°ì„  í˜„ì¬ì½”ë“œì˜ ë¬¸ì œëŠ”

```cpp
// Create Table
{
    // TABLEì„ í•œ ë²ˆ ë‚ ë ¤ì£¼ê³ 
    // TABLEì„ ì•„ì— ìƒˆë¡œ ë§Œë“¤ê²Œ ëœë‹¤
        // ì„œë²„ê°€ ê°€ë™ë ë•Œë§ˆë‹¤ ì´ëŸ´ ìˆœ ì—†ê³ 
        // ê¸°ì¡´ì˜ DBì •ë³´ë¥¼ ê°–ê³ ìˆì–´ì•¼ í•œë‹¤ -> ì´ê±¸ XMLì„ í†µí•´í•˜ê² ìŒ.
    auto query = L"									\
        DROP TABLE IF EXISTS [dbo].[Gold];			\
        CREATE TABLE [dbo].[Gold]					\
        (											\
            [id] INT NOT NULL PRIMARY KEY IDENTITY, \
            [gold] INT NULL							\
        );";

    DBConnection* dbConn = GDBConnectionPool->Pop();
    ASSERT_CRASH(dbConn->Execute(query));
    GDBConnectionPool->Push(dbConn);
}
```

ğŸ‘º ì°¸ê³ ë¡œ ë§í•˜ìë©´ ì•„ë˜ì™€ ê°™ì€ sqlíŒŒì¼ì„ ìƒì„±í•´ì„œ ê¸°ì¡´ DBì •ë³´ë¥¼ ë‹´ì•„ì•¼í•˜ëŠ”ë° ...<br>
ğŸ‘º ë§¤ë²ˆ sqlì„ ë§Œë“¤ê¸°ë„ í˜ë“¤ê³ , ë²„ì „ê´€ë¦¬ë„ í˜ë“¤ë‹¤. ë”°ë¼ì„œ XMLì´ë‚˜ JSONì„ ì“°ë©´ ì˜¤íˆë ¤ ì‰½ë‹¤. ì™œ ì‰¬ìš´ì§€ëŠ” ì•„ë˜ì„œ ì°¸ê³ í•˜ì.

```sql
CREATE TABLE [dbo] [Version]
(
    [version] FLOAT NOT NULL
);

CREATE TABLE [dbo] [Gold]
(
    [id] INT NOT NULL PRIMARY KEY IDENTITY,

);
```

ğŸ‘º ê²°ë¡ ë¶€í„° ë³´ìë©´ xmlì€ ì•„ë˜ì™€ ê°™ì´ êµ¬ì„±ì´ ëœë‹¤.

```xml
<?xml version="1.0" encoding="utf-8"?>
<GameDB>
	<Table name="Gold" desc="ê³¨ë“œ í…Œì´ë¸”">
		<Column name="id" type="int" notnull="true" />
		<Column name="gold" type="int" notnull="false" />
		<Column name="name" type="nvarchar(50)" notnull="false" />
		<Column name="createDate" type="datetime" notnull="false" />

        <!-- idë¼ëŠ” columnì„ ê¸°ì¤€ìœ¼ë¡œ indexë¥¼ ê±¸ê² ë‹¤ëŠ” ë§. -->
		<Index type="clustered">
			<PrimaryKey/>
			<Column name="id" />
		</Index>
	</Table>

    <!-- InsertGoldë¥¼ í•˜ëŠ” í•¨ìˆ˜ë„ ìë™ìœ¼ë¡œ ìƒì„±í•  ì˜ˆì • -->
	<Procedure name="spInsertGold">
		<Param name="@gold" type="int"/>
		<Param name="@name" type="nvarchar(50)"/>
		<Param name="@createDate" type="datetime"/>
		<Body>
            <!-- CDATA : []ì•ˆì˜ ë‚´ìš©ì€ xml ë¬¸ë²•ì´ ì•„ë‹ˆë¼ DBë¬¸ë²•ì´ë¼ê³  ì•Œë¦°ë‹¤. -->
			<![CDATA[
			INSERT INTO [dbo].[Gold]([gold], [name], [createDate]) VALUES(@gold, @name, @createDate);
			]]>
		</Body>		
	</Procedure>
	
    <!-- GetGoldë¥¼ í•˜ëŠ” í•¨ìˆ˜ë„ ìë™ìœ¼ë¡œ ìƒì„±í•  ì˜ˆì • -->
	<Procedure name="spGetGold">
		<Param name="@gold" type="int"/>
		<Body>
			<![CDATA[
			SELECT id, gold, name, createDate FROM [dbo].[Gold] WHERE gold = (@gold)
			]]>
		</Body>
	</Procedure>
	
</GameDB>
```

ğŸ‘º ì´ì œ ì € xmlì„ ì–´ë–»ê²Œ íŒŒì‹±í• ì§€ êµ¬í˜„í•´ ë³´ì.<br>
ğŸ‘º ì‚¬ì‹¤ xml Parserë¥¼ ëª¨ë‘ êµ¬í˜„í•˜ê¸° ë³´ë‹¤ëŠ” êµ¬í˜„ì´ ì˜ ëœ [OpenSource(rapid-xml)](http://rapidxml.sourceforge.net/)ë¥¼ ì“°ë„ë¡í•˜ì

```cpp
// xml íŒŒì¼ì„ ì½ê¸° ìœ„í•´ì„œ FileUtilsìƒì„±

namespace fs = std::filesystem;

Vector<BYTE> FileUtils::ReadFile(const WCHAR* path)
{
	Vector<BYTE> ret;

	fs::path filePath{ path };

	const uint32 fileSize = static_cast<uint32>(fs::file_size(filePath));
	ret.resize(fileSize);

	basic_ifstream<BYTE> inputStream{ filePath };
	inputStream.read(&ret[0], fileSize);

	return ret;
}

String FileUtils::Convert(string str)
{
	const int32 srcLen = static_cast<int32>(str.size());

	String ret;
	if (srcLen == 0)
		return ret;

	const int32 retLen = ::MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<char*>(&str[0]), srcLen, NULL, 0);
	ret.resize(retLen);
	::MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<char*>(&str[0]), srcLen, &ret[0], retLen);

	return ret;
}
```

```cpp
bool XmlParser::ParseFromFile(const WCHAR* path, OUT XmlNode& root)
{
	Vector<BYTE> bytes = FileUtils::ReadFile(path);
	_data = FileUtils::Convert(string(bytes.begin(), bytes.end()));

	if (_data.empty())
		return false;

	_document = MakeShared<XmlDocumentType>();
	_document->parse<0>(reinterpret_cast<WCHAR*>(&_data[0]));
	root = XmlNode(_document->first_node());    // First Nodeê°€ <GameDB>ê°€ ëœë‹¤.
	return true;
}
```

```cpp
// ì‹¤ì‚¬ìš©ì€ ì´ë ‡ê²Œ
XmlNode root;
XmlParser parser;
if (parser.ParseFromFile(L"GameDB.xml", OUT root) == false)
    return 0;

Vector<XmlNode> tables = root.FindChildren(L"Table");
for (XmlNode& table : tables)
{
    String name = table.GetStringAttr(L"name");
    String desc = table.GetStringAttr(L"desc");

    Vector<XmlNode> columns = table.FindChildren(L"Column");
    for (XmlNode& column : columns)
    {
        String colName = column.GetStringAttr(L"name");
        String colType = column.GetStringAttr(L"type");
        bool nullable = !column.GetBoolAttr(L"notnull", false);
        String identity = column.GetStringAttr(L"identity");
        String colDefault = column.GetStringAttr(L"default");
        // Etc...
    }

    Vector<XmlNode> indices = table.FindChildren(L"Index");
    for (XmlNode& index : indices)
    {
        String indexType = index.GetStringAttr(L"type");
        bool primaryKey = index.FindChild(L"PrimaryKey").IsValid();
        bool uniqueConstraint = index.FindChild(L"UniqueKey").IsValid();

        Vector<XmlNode> columns = index.FindChildren(L"Column");
        for (XmlNode& column : columns)
        {
            String colName = column.GetStringAttr(L"name");
        }
    }
}

Vector<XmlNode> procedures = root.FindChildren(L"Procedure");
for (XmlNode& procedure : procedures)
{
    String name = procedure.GetStringAttr(L"name");
    String body = procedure.FindChild(L"Body").GetStringValue();

    Vector<XmlNode> params = procedure.FindChildren(L"Param");
    for (XmlNode& param : params)
    {
        String paramName = param.GetStringAttr(L"name");
        String paramType = param.GetStringAttr(L"type");
        // TODO..
    }
}
```

ğŸ‘º íŒŒì‹±í•œ xml ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ DBì— ëª…ë ¹ì„ ë³´ë‚´ëŠ” ë¶€ë¶„ì´ ìˆëŠ”ë° ì½”ë“œê°€ ì—„ì²­ê¸¸ì–´ì„œ ë³„ë„ë¡œ ì •ë¦¬ ì•ˆí•¨. í•„ìš”í•˜ë‹¤ë©´ ì°¾ì•„ë³¼ ê²ƒ.