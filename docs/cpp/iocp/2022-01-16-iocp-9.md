---
layout: default
title: "9. Memory model"
parent: (IOCP)
grand_parent: C++
nav_order: 1
---

ğŸ˜º C++11ì—ì„œ ì¶”ê°€ëœ ê°€ì¥ì¤‘ìš”í•œ ê²ƒì€ â€“> **Memory Model**ì´ë¼ í•  ìˆ˜ ìˆë‹¤

ğŸ˜º ì¼ë‹¨ ì• ë‚´ìš©ì„ ê°„ë‹¨íˆ ë³µìŠµí•˜ê³  ë“¤ì–´ê°€ì

* ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ë™ì¼í•œ ë©”ëª¨ë¦¬ì— ë™ì‹œ ì ‘ê·¼(Writeë¥¼ í• ê²½ìš° ë¬¸ì œ)
    * Race Condition ì¡°ê±´ ê²½í•©ì´ ì¼ì–´ë‚œë‹¤
    * ë”°ë¼ì„œ Undefined Behavior ì •ì˜ë˜ì§€ ì•Šì€ í–‰ë™ì´ ë°œìƒí•˜ë©° í•´ê²°ë²•ì€
        * Lock, Atomicì„ ì´ìš©í•´ í•´ê²°ì„ í•´ì•¼í•œë‹¤.
        * atomic ì—°ì‚°ì— í•œí•´, ëª¨ë“  ì“°ë ˆë“œê°€ ë™ì¼ ê°ì²´ì— ëŒ€í•´ì„œ ë™ì¼í•œ ìˆ˜ì • ìˆœì„œë¥¼ ë³´ì¸ë‹¤.

* ë­”ì†Œë¦°ì§€ ëª¨ë¥´ê² ìœ¼ë‹ˆ ì•„ë˜ Exampleì„ ì°¸ì¡°

```cpp
// atomic ì„ ì–¸
atomic<int64> num;

vod Thread_1()
{
    num.store(1);   // num = 1
}

vod Thread_2()
{
    num.store(2);   // num = 2
}

// ... ì—¬ëŸ¬ê°œì˜ Threadê°€ ìˆë‹¤ê³  ê°€ì •í•˜ì


void Thread_Observer()
{
    while(true)
    {
        int64 value = num.load();
        // ì—¬ê¸° ì‚¬ì´ì—ì„œ ë³€í• ìˆ˜ ìˆì§€ë§Œ... ì´ê±°ëŠ” ì¼ë‹¨ ë¬´ì‹œ
        std::cout << value << std::endl;
        // ê´€ì°° ê²°ê³¼ëŠ”?
    }
}
```

```
# ì‹œê°„ì— ë”°ë¼ atomic<int64> numì´ ì•„ë˜ì™€ ê°™ì´ ë³€ê²½ëœë‹¤ê³  ìƒê°í•´ë³´ì.

-----(0)---(5)----(4)----(3)-------------<ì‹œê°„>
   ^            ^
   |            |
 (ê´€ì°°1)      (ê´€ì°°2)
```

* atomic ì—°ì‚°ì— í•œí•´, ëª¨ë“  ì“°ë ˆë“œê°€ ë™ì¼ ê°ì²´ì— ëŒ€í•´ì„œ ë™ì¼í•œ ìˆ˜ì • ìˆœì„œë¥¼ ë³´ì¥í•œë‹¤.
* ìœ„ë§ì€ ê¸°ì¡´ì˜ atomicì—°ì‚°ì´ ì•„ë‹ê²½ìš°, ê´€ì°° ì‹œì ì— ê´€ê³„ì—†ì´ ê³¼ê±°ì˜ ë°ì´í„°ë¥¼ ê´€ì°°í•˜ê²Œ ë  ìˆ˜ ìˆë‹¤.
* ì˜ˆë¥¼ ë“¤ì–´ (ê´€ì°°2)ì—ì„œ ê´€ì°°í–ˆëŠ”ë° 0ì´ ë‚˜ì˜¬ìˆ˜ ìˆìŒ(ì™œì¸ì§€ëŠ” ì´ì „ê°•ì˜ ì°¸ì¡°)
* ë‹¨, atomicì— í•œì—ì„œëŠ” ê´€ì°°ì‹œì ì˜ ë¯¸ë˜ ë°ì´í„°ëŠ” ë‹¹ì—°íˆ ëª¨ë¥´ê² ì§€ë§Œ í˜„ì¬ ë°ì´í„°ë¥¼ ë³´ì—¬ì¤€ë‹¤ëŠ” ë§

* ê·¸ëŸ¼ atomicí•˜ê²Œ CPUê°€ ì²˜ë¦¬í•˜ê³ ìˆëŠ”ì§€ ì•„ë‹Œì§€ ì–´ë–»ê²Œ ì•Œì§€? ê·¸ëƒ¥ atomicë§Œì¨ì£¼ë©´ ë‹¤ ì›ìì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ”ê°€?
* ë‹¹ì—°íˆ ì•„ë‹ˆë‹¤. ì˜ˆë¥¼ë“¤ì–´ 32bitsí™˜ê²½ì—ì„  64bits ë³€ìˆ˜ë¥¼ atomicí•˜ê²Œ ë°ì´í„°ë³€ê²½ì´ ë¶ˆê°€ëŠ¥(ë©”ëª¨ë¦¬ì£¼ì†Œë¥¼ 2ë²ˆ ì˜®ê²¨ì•¼í•¨)
* atomicí•˜ê²Œ ì²˜ë¦¬ê°€ëŠ¥í•œì§€ í™•ì¸í•  ë°©ë²•(`is_lock_free`)ì´ ìˆë‹¤.

```cpp
atomic<int64> v;
cout << v.is_lock_free() << endl; 
// 1 - CPU ìì²´ì  atomic ê°€ëŠ¥

struct Knight
{
    int32 level;
    int32 hp;
    int32 mp;
};

atomic<Knight> v;
cout << v.is_lock_free() << endl;   
// 0 - CPU ìì²´ì  atomic ë¶ˆê°€ëŠ¥
// ë‚´ë¶€ì—ì„œ lockì„ í•˜ë“  ì–´ë– í•œ ë°©ì‹ìœ¼ë¡œ atomicí•˜ê²Œ ì²˜ë¦¬í•´ì¤Œ.
```

```cpp
// atomic ì„ ì–¸
atomic<int64> num;

vod Thread_1()
{
    // num = 1
    // num.store(1);
    // ì•„ë˜ì™€ ë™ì¼í•œ ì˜ë¯¸ì´ë‹¤. (ë©”ëª¨ë¦¬ ì •ì±…ì„ memory_order::memory_order_seq_cstë¡œ ì¨ë‹¬ë¼)
    num.store(1, memory_order::memory_order_seq_cst);
}

vod Thread_2()
{
    // num = 2
    // num.store(2);
    num.store(2, memory_order::memory_order_seq_cst);
}

// ...


void Thread_Observer()
{
    while(true)
    {
        // int64 value = num.load();
        int64 value = num.load(memory_order::memory_order_seq_cst);
        // ê´€ì°° ê²°ê³¼ëŠ”?
    }
}
```

<Br>

ğŸ˜º `memory_order::memory_order_seq_cst`ì´ë€ ë­˜ê¹Œ?

ğŸ˜º ì ê¹ ë³µìŠµìœ¼ë¡œ `atomic`ì— ê°’ì„ ì½ê³ , ì“°ëŠ”ë²•ì„ ì •ë¦¬í•´ë³´ìë©´

```cpp
atomic<bool> flag;

int main()
{
    {
        // ìš°ì„  atomicì— ê°’ì„ ì½ê³ , ì“°ëŠ” ë²•ì„ ê°„ë‹¨íˆ ì •ë¦¬í•´ë³´ìë©´
        flag.store(true, memory_order::memory_order_seq_cst);

        bool val = flag.load(memory_order::memory_order_seq_cst);
    }

    {
        /*
            atomicì˜ í˜„ì¬ê°’ì„ ì €ì¥í•´ ë‘ê³  ë‹¤ë¥¸ê°’ì„ ëŒ€ì…í•˜ê³ ì í•œë‹¤ë©´
        */

        // ì´ì „ flag ê°’ì„ prevì— ë„£ê³ , flag ê°’ì„ ìˆ˜ì •
        bool prev = flag;
        flag = true;
        // ì´ ê³¼ì •ì´ ìœ„ ì½”ë“œì™€ ê°™ì´ ë‘ ì¤„ë¡œ ì´ë£¨ì–´ì§ˆê²½ìš° ë‹¤ë¥¸ Threadì—ì„œ flagê°’ì„ ë³€ê²½í•´ë²„ë¦´ ìœ„í—˜ì´ ì¡´ì¬

        // ì´ë ‡ê²Œ ì²˜ë¦¬ê°€ëŠ¥
        bool prev = flag.exchange(true);
        // prevì— í˜„ì¬ê°’ ë„£ê³  exchange ë§¤ê°œë³€ìˆ˜ì˜ ê°’ì„ flagì— ë„£ì–´ë‹¬ë¼
    }
    
    {
        // CAS(Compare-And_Swap) ì¡°ê±´ë¶€ ìˆ˜ì •
        bool expected = false;
        bool desire = true;

        flag.compare_exchange_strong(expected, desire);
        /*
        * ì˜ˆì „ì— ì •ë¦¬í–ˆì§€ë§Œ ë‹¤ì‹œ ë‚´ë¶€ ì˜ì‚¬ì½”ë“œë¥¼ ì ì–´ë³´ìë©´
        * ì´ê±¸ atomicí•˜ê²Œ ì²˜ë¦¬í•´ ì¤€ë‹¤ëŠ” ë§.
        if(flag == expected)
        {
            expected = flag;
            flag = desired;
            return true;
        }
        else
        {
            expected = flag;
            return false;
        }
        */
    }
}
```

ğŸ˜º ë‹¤ì‹œ Memory_model(`memory_order::memory_order_seq_cst`ì´ë†ˆ)ì— ëŒ€í•´ ì„¤ëª…í•œë‹¤.

* Memory model ì •ì±…
    * Sequentialiy Consistent (seq_cst)
    * Acquire-Release (consume, acquire, release, acq_rel)
    * Relaxed (relaxed)
* ìš°ì„  ê°„ë‹¨íˆ ì •ë¦¬í•˜ë©´
    * 1) seq_cst : ì—„ê²©, ì§ê´€ì , ì½”ë“œ ì¬ë°°ì¹˜(ìµœì í™”)ê°€ ì ìŒ
    * 2) acquire-release : ì¤‘ê°„
        * acquire-relaseë¡œ ë™ì‘í•˜ë©° storeì—ì„œ releaseë¥¼ ì¡ì•„ë‘ë©´
        * acquire ì „ê¹Œì§€ ì½”ë“œì¬ë°°ì¹˜ê°€ ì¼ì–´ë‚˜ëŠ”ê²ƒì„ ë§‰ì•„ì¤€ë‹¤.
        * acquire ì´í›„ ë°ì´í„°ë“¤ì´ ê°±ì‹ ì´ ë˜ì–´ ìµœì‹  ë°ì´í„° ìˆ˜ì‹ ê°€ëŠ¥
    * 3) relaxed : ììœ ë¡œì›€, ë¹„ì§ê´€ì , ì½”ë“œ ì¬ë°°ì¹˜(ìµœì í™”)ê°€ ìˆìŒ
        * ê°€ì¥ ê¸°ë³¸ ì¡°ê±´ì¸ ë™ì¼ ê°ì²´ì— ëŒ€í•œ ë™ì¼ ê´€ì „ ìˆœì„œë§Œ ë³´ì¥í•´ì¤€ë‹¤.
        * ì‚¬ì‹¤ìƒ ì‚¬ìš©ì´ ì˜ ì•ˆëœë‹¤.
* Intel, AMDì˜ ê²½ìš° ìˆœì°¨ì  ì¼ê´€ì„±ì„ ë³´ì¥í•´ì¤€ë‹¤.
* ë”°ë¼ì„œ seq_cstë¥¼ ê·¸ëƒ¥ ì“°ë©´ëœë‹¤.
* ë‹¨, ARMì˜ ê²½ìš° ê½¤ ì˜ë¯¸ìˆëŠ” ì°¨ì´ê°€ ìˆë‹¤ê³  í•˜ëŠ”ë°â€¦ ì•ˆì¨ë´ì„œ ì˜â€¦

```cpp
atomic<bool> ready;
int32 value;

void Producer()
{
    value = 10;
    // 1)
    ready.store(true, memory_order::memory_order_seq_cst);

    // 2)
    // ready.store(true, memory_order::memory_order_release);
    // ì—¬ê¸°ì„œ ë¶€í„´ ì½”ë“œì¬ë°°ì¹˜ í•˜ì§€ë§ˆ

    // 3)
    // ready.store(true, memory_order::memory_order_relaxed);
    // memory_order_relaxedì¼ ê²½ìš° value = 10;ê°€ read.storeì•„ë˜ë¡œ ë°°ì¹˜ë  ìˆ˜ ìˆë‹¤ëŠ” ë§.
}

void Consumer()
{
    // 1)
    while(read.load(memory_order::memory_order_seq_cst) == false);

    // 2)
    // while(read.load(memory_order::memory_order_acquire) == false);
    // ì´ì œ ì½”ë“œì¬ë°°ì¹˜ ê°€ëŠ¥
    // acquireì´í›„ì— ë°ì´í„°ë“¤ì´ ê°±ì‹ ì´ ëœë‹¤.

    // 3)
    // while(read.load(memory_order::memory_order_relaxed) == false);

    cout << value << endl;
}

int main()
{
    ready = false;
    value = 0;

    thread t1(Producer);
    thread t2(Consumer);
    t1.join();
    t2.join();
}
```