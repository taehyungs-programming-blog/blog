---
layout: default
title: "15. LOCKì„ ì¢€ ë” ì‰½ê²Œ ì‚¬ìš©í•˜ê²Œ êµ¬í˜„"
parent: (IOCP)
grand_parent: C++
nav_order: 2
---

ğŸ˜» ëŒ€ëµ ì´ë ‡ê²Œ ì“°ê³ ì‹¶ë‹¤

```cpp
class TestLock
{
    // LOCKì„ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤.
	USE_LOCK;

public:
	int32 TestRead()
	{
		// Lockì„ ê±¸ì–´ì¤„ ë¶€ë¶„ì— ì„ ì–¸
		READ_LOCK;

		if (_queue.empty())
			return -1;

		return _queue.front();
	}

	void TestPush()
	{
		WRITE_LOCK;

		_queue.push(rand() % 100);
	}

//...
```

```cpp
// ë§¤í¬ë¡œëŠ” ì´ë ‡ê²Œ ì„ ì–¸ë¨.
// ...

#define USE_MANY_LOCKS(count)	Lock _locks[count];
#define USE_LOCK				USE_MANY_LOCKS(1)
#define	READ_LOCK_IDX(idx)		ReadLockGuard readLockGuard_##idx(_locks[idx]);
#define READ_LOCK				READ_LOCK_IDX(0)
#define	WRITE_LOCK_IDX(idx)		WriteLockGuard writeLockGuard_##idx(_locks[idx]);
#define WRITE_LOCK				WRITE_LOCK_IDX(0)

// ...
```

---

ğŸ˜¾ êµ¬í˜„í•´ë³´ì

```cpp
/*--------------------------------------------
[WWWWWWWW][WWWWWWWW][RRRRRRRR][RRRRRRRR]
// 32bitsë¥¼ ì‚¬ìš©í•˜ë©° ìƒìœ„ 16bitsëŠ” Write / í•˜ìœ„ 16bitsëŠ” Readìš© flag
W : WriteFlag (Exclusive Lock Owner ThreadId)
R : ReadFlag (Shared Lock Count)
---------------------------------------------*/

class Lock
{
    enum : uint32
    {
        ACQUIRE_TIMEOUT_TICK = 10000,       // ì´ ì‹œê°„ ì´í›„ ì‹œë„ì‹œ Crash
        MAX_SPIN_COUNT = 5000,              // ëª‡ë²ˆì„ ìì› ê²½í•©í•  ê²ƒì¸ê°€
        WRITE_THREAD_MASK = 0xFFFF'0000,    // ìƒìœ„ 16bits Mask
        READ_COUNT_MASK = 0x0000'FFFF,      // í•˜ìœ„ 16bits Mask
        EMPTY_FLAG = 0x0000'0000
    };

public:
    void WriteLock();
    void WriteUnlock();
    void ReadLock();
    void ReadUnlock();

private:
    Atomic<uint32> _lockFlag = EMPTY_FLAG;
    uint16 _writeCount = 0;
};
```

```cpp
#include "pch.h"
#include "Lock.h"
#include "CoreTLS.h"

void Lock::WriteLock()
{
	// ë™ì¼í•œ ì“°ë ˆë“œê°€ ì†Œìœ í•˜ê³  ìˆë‹¤ë©´ ë¬´ì¡°ê±´ ì„±ê³µ.
        // lockì´ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œë˜ëŠ” ê²½ìš°ë¥¼ ëŒ€ë¹„í•¨.
		// ì´ë¯¸ lockì´ ì¡í˜€ìˆê¸°ì— returní•˜ëŠ” ê²ƒì„.
	const uint32 lockThreadId = (_lockFlag.load() & WRITE_THREAD_MASK) >> 16;
	if (LThreadId == lockThreadId)
	{
		_writeCount++;
		return;
	}

	// ì•„ë¬´ë„ ì†Œìœ  ë° ê³µìœ í•˜ê³  ìˆì§€ ì•Šì„ ë•Œ, ê²½í•©í•´ì„œ ì†Œìœ ê¶Œì„ ì–»ëŠ”ë‹¤.
	const int64 beginTick = ::GetTickCount64();
	const uint32 desired = ((LThreadId << 16) & WRITE_THREAD_MASK);
	while (true)
	{
        // MAX_SPIN_COUNTë§Œí¼ ëŒë©´ì„œ ìì› ê²½í•©
		for (uint32 spinCount = 0; spinCount < MAX_SPIN_COUNT; spinCount++)
		{
			uint32 expected = EMPTY_FLAG;

            // í˜„ì¬ _lockFlagë¥¼ ì°¨ì§€í•˜ê³  ìˆëŠ” ThreadIdê°€ ì—†ë‹¤ë©´ ë‚´ ThreadIdë¥¼ ë„£ê³  Lock
                // OUTì€ #define OUT ê°œë°œìì—ê²Œ expectedê°’ì´ í•¨ìˆ˜ì— ì˜í•´ ë³€ê²½ë ìˆ˜ ìˆë‹¤ê³  ì•Œë ¤ì¤Œ.
                // ì¶”ê°€ì ìœ¼ë¡œ ëˆ„êµ°ê°€ Readì¤‘ì¼ë•ŒëŠ” Writeí• ìˆ˜ ì—†ìŒì„ ê¸°ì–µ.
				/*
					ë°˜ëŒ€ë¡œ ë§í•˜ë©´ Writeì¤‘ì¼ë•ŒëŠ” Readê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ë§ì¸ë°
					ì´ëŸ¬ë©´ ìœ„í—˜í•˜ë‹¤ ì‚¬ì‹¤
					ê·¸ë˜ì„œ ëŒ€ë¶€ë¶„ WRITE_LOCKë§Œ ì‚¬ìš©ë¨
					Writeì¤‘ì¼ë•Œ READê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì£¼ê¸°ìœ„í•œ ì˜ˆì‹œì •ë„ë¼ ë°›ì•„ë“¤ì´ì
				*/
			if (_lockFlag.compare_exchange_strong(OUT expected, desired))
			{
				_writeCount++;
				return;
			}
		}

		if (::GetTickCount64() - beginTick >= ACQUIRE_TIMEOUT_TICK)
			CRASH("LOCK_TIMEOUT");  // ACQUIRE_TIMEOUT_TICK ì‹œê°„ì´ìƒ ëŒ€ê¸°ì‹œ Deadlockì´ë¼ ìƒê°í•œë‹¤.

        // threadë¥¼ ì–‘ë³´
		this_thread::yield();
	}
}

void Lock::WriteUnlock()
{
	// ReadLock ë‹¤ í’€ê¸° ì „ì—ëŠ” WriteUnlock ë¶ˆê°€ëŠ¥.
	if ((_lockFlag.load() & READ_COUNT_MASK) != 0)
		CRASH("INVALID_UNLOCK_ORDER");

	const int32 lockCount = --_writeCount;
	if (lockCount == 0)
		_lockFlag.store(EMPTY_FLAG);
}

void Lock::ReadLock()
{
	// ë™ì¼í•œ ì“°ë ˆë“œê°€ ì†Œìœ í•˜ê³  ìˆë‹¤ë©´ ë¬´ì¡°ê±´ ì„±ê³µ.
	const uint32 lockThreadId = (_lockFlag.load() & WRITE_THREAD_MASK) >> 16;
	if (LThreadId == lockThreadId)
	{
		_lockFlag.fetch_add(1);
		return;
	}

	// ì•„ë¬´ë„ ì†Œìœ í•˜ê³  ìˆì§€ ì•Šì„ ë•Œ ê²½í•©í•´ì„œ ê³µìœ  ì¹´ìš´íŠ¸ë¥¼ ì˜¬ë¦°ë‹¤.
	const int64 beginTick = ::GetTickCount64();
	while (true)
	{
		for (uint32 spinCount = 0; spinCount < MAX_SPIN_COUNT; spinCount++)
		{
			uint32 expected = (_lockFlag.load() & READ_COUNT_MASK);
			if (_lockFlag.compare_exchange_strong(OUT expected, expected + 1))
				return;
		}

		if (::GetTickCount64() - beginTick >= ACQUIRE_TIMEOUT_TICK)
			CRASH("LOCK_TIMEOUT");

		this_thread::yield();
	}
}

void Lock::ReadUnlock()
{
    // fetch_sub(1)ì€ -1í•˜ê¸° ì „ì˜ ê°’ì´ ë¦¬í„´ë˜ëŠ”ë° -1 ì „ì˜ ê°’ì´ 0ì´ë©´ ë­”ê°€ ì´ìƒí•œê±°... -> Crash!!
	if ((_lockFlag.fetch_sub(1) & READ_COUNT_MASK) == 0)
		CRASH("MULTIPLE_UNLOCK");
}
```