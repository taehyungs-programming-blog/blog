---
layout: default
title: "51. JobQueue-2"
parent: (IOCP)
grand_parent: C++
nav_order: 6
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ¶ í˜„ì¬ ì½”ë“œì˜ ë¬¸ì œëŠ” Jobì´ ìƒì„±ë ë•Œë§ˆë‹¤ í´ë˜ìŠ¤ë¥¼ ìƒˆë¡œ ìƒì„±í•´ì•¼ í•œë‹¤.

```cpp
// ë§¤ë²ˆ ì´ëŸ°ê±¸ ë§Œë“¤ì–´ì•¼ í•œë‹¤ëŠ” ë§...
class BroadcastJob : public IJob
{
public:
	BroadcastJob(Room& room, SendBufferRef sendBuffer) : _room(room), _sendBuffer(sendBuffer)
	{
	}

	virtual void Execute() override
	{
		_room.Broadcast(_sendBuffer);
	}

public:
	Room& _room;
	SendBufferRef _sendBuffer;
};
```

ğŸ¶ ìš°ì„  ì§€ê¸ˆí•  ë‚´ìš©ì„ JobQueue Ver1.2 ì •ë„ë¼ ìƒê°í•˜ê³  ìœ„ ë¬¸ì œì˜ í•´ê²°ë°©ë²•ì€ ê³µìš©í´ë˜ìŠ¤ë¥¼ ì„ ì–¸í•˜ê³  JobQueueë¥¼ ê´€ë¦¬í•  ì˜ˆì •ì„ì„ ì•Œì

---

ğŸ¶ í ... ì´ë ‡ê²Œ í•˜ë©´ ì¢‹ê² ëŠ”ê±¸ Jobì´ë¼ëŠ” Fuctorë¥¼ ë§Œë“¤ê³  ë§ˆì¹˜ Fuctorë¥¼ í˜¸ì¶œí•˜ë©´ Queueì— ìŒ“ì¸ Jobì´ í˜¸ì¶œë˜ê²Œ?

```cpp
// ë§ˆì¹˜ ì´ëŸ° í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë“¯ fuctorë¥¼ ë§Œë“¤ê³  ì‹¶ë‹¤
void HealByValue(int64 target, int32 value)
{
    // ...
}

// ê·¸ëŸ¼ Jobì´ë¼ëŠ” Fuctorë§Œ ë§Œë“¤ë©´ ë ê¹Œ?
template<typename Ret, typename T1, typename T2>
class Job
{
public:
    Ret operator()(T1 t1, T2 t2)
    {
        // ...
    }

    // or ì´ì „ë°©ì‹ëŒ€ë¡œ Executeë¥¼ ì´ìš©í•´ë„ ë¨
    Ret Execute(T1 t1, T2 t2)
    {
        // ...
    }
};

int main()
{
    Job<void, int64, int32> job;
    job(100, 10);   
}
```

ğŸ¶ í•˜ì§€ë§Œ... ìœ„ ì½”ë“œëŠ” ì˜ˆìƒí•˜ë“¯ ë¬¸ì œê°€ ë§ë‹¤<br>
ğŸ¶ ìš°ì„ ì€ ë§¤ê°œë³€ìˆ˜ê°€ 2ê°œë§Œ ë“¤ì–´ì˜¬ê²ƒì´ë¼ëŠ” í™•ì‹ ì´ ì—†ë‹¤(ì—¬ëŸ¬ê°œë¥¼ ë°›ì•„ì•¼í•  ìˆ˜ë„ ìˆë‹¤.)

```cpp
template<typename Ret, typename... Args>
class Job
{
public:
    Ret operator()(Args... args)
    {
        // do something
    }

    Ret Execute(Args... args)
    {
        // do something
    }
};
```

ğŸ¶ ê·¸ëŸ¼ ë§¤ê°œë³€ìˆ˜ ë¬¸ì œëŠ” í•´ê²°ëê³ <br>
ğŸ¶ `do something`ì´ ë“¤ì–´ê°ˆ ìë¦¬ì— ìš°ë¦¬ê°€ ì›í•˜ëŠ” ì½”ë“œë¥¼ ë„£ì–´ì•¼í• í…ë° ê·¸ ë¬¸ì œëŠ”??<br>
ğŸ¶ **í•¨ìˆ˜í¬ì¸í„°**ë¥¼ ì´ìš©í•´ë³´ì


```cpp
template<typename Ret, typename... Args>
class FuncJob   // í´ë˜ìŠ¤ì´ë¦„ì„ ë°”ê¿ˆ
{
    using FuncType = Ret(*)(Args...);

public:
    FuncJob(FuncType func) : _func(func) {}

    Ret operator()(Args... args)
    {
        _func(args...);
    }

    Ret Execute(Args... args)
    {
        _func(args...);
    }

private:
    FuncType _func;
};

// ...

void HealByValue(int64 target, int32 value)
{
    // ...
}

int main()
{
    Job<void, int64, int32> job(HealByValue);
    job(100, 10);   
}
```

ğŸ¶ ì¢‹ë‹¤! ê±°ì˜ í•´ê²°ëœê±° ê°™ì€ë° ... `job(100, 10)`ë¥¼ í˜¸ì¶œì‹œì— 100, 10ì„ ë„˜ê¸°ëŠ”ë° ë§¤ê°œë³€ìˆ˜ë§Œ ë„£ì–´ë‘ê³  ë‚˜ì¤‘ì— í˜¸ì¶œí•´ì•¼í•  í•¨ìˆ˜ê°€ ìˆì„ìˆ˜ ìˆë‹¤. ë§¤ê°œë³€ìˆ˜ë¥¼ ì§€ì—­ë³€ìˆ˜ë¡œ ê´€ë¦¬í–ˆìœ¼ë©´ í•œëŠ”ë° ... ?

```cpp
template<typename Ret, typename... Args>
class FuncJob
{
    using FuncType = Ret(*)(Args...);

public:
    FuncJob(FuncType func) : _func(func), _tuple(args...) {}

    Ret operator()()
    {
        // C++17 ì´í›„ë¶€í„°ëŠ” ì•„ë˜ í‘œí˜„ì´ ê°€ëŠ¥
        std::apply(_func, _tuple);
    }

    Ret Execute()
    {
        // C++17 ì´í›„ë¶€í„°ëŠ” ì•„ë˜ í‘œí˜„ì´ ê°€ëŠ¥
        std::apply(_func, _tuple);
    }

private:
    FuncType _func;
    // tupleì— Argsë¥¼ ë³´ê´€í•  ì˜ˆì •
    std::tuple<Args...> _tuple;
};

// ...

int main()
{
    Job<void, int64, int32> job(HealByValue, 100, 10);

    // do others

    job.Execute();   
}
```

ğŸ¶ `std::apply(_func, _tuple);`ê°€ C++17ê¸°ì¤€ì´ë¼ í–ˆëŠ”ë° C++17 ì´ì „ì—ëŠ” ì–´ë–»ê²Œ ì¼ì„ê¹Œ?<br>
ğŸ¶ ì•„ë˜ì— ì½”ë“œë¥¼ ë‚¨ê¸°ëŠ”ë° ... ê·¸ëƒ¥ C++17ì“°ëŠ”ê²Œ ë§ˆìŒ í¸í• ì§€ë„?

```cpp
// ì‚¬ì „ì— ì•Œì•„ì•¼ í•  ë¶€ë¶„ì´ ìˆëŠ”ë°
    // tuple : ì—¬ëŸ¬ê°œì˜ ìë£Œí˜•ì„ ê´€ë¦¬
auto tup = std::tuple<int32, int32>(1, 2);
    // ë­ ì´ëŸ°ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë¹¼ì˜¬ìˆ˜ ìˆìŒ
auto val0 = std::get<0>(tup);
auto val1 = std::get<1>(tup);
```

```cpp
// C++11 apply
template<int... Remains>
struct seq
{};

template<int N, int... Remains>
struct gen_seq : gen_seq<N-1, N-1, Remains...>
{};

template<int... Remains>
struct gen_seq<0, Remains...> : seq<Remains...>
{};

/*
    gen_seq<3> ì„ ì„ ì–¸ì‹œ
    : gen_seq<2, 2> ë¥¼ ìƒì† ë°›ê²Œ ëœë‹¤.
        N == 2ê°€ ë˜ê³  ë‹¤ì‹œ
    : gen_seq<1, 1, 2> ë¥¼ ìƒì† ë°›ê²Œ ëœë‹¤.
        N == 1ì´ ë˜ê³  ë‹¤ì‹œ
    : gen_seq<0, 0, 1, 2> ë¥¼ ìƒì† ë°›ê²Œ ëœë‹¤.
        N == 0ì¼ì‹œ
    seq<0, 1, 2> ë¥¼ ìƒì† ë°›ëŠ”ë‹¤ (-> ì´ê±¸ ë§Œë“œë ¤ê³  gen_seqë¥¼ í˜¸ì¶œí•¨.)
*/

template<typename Ret, typename... Args>
void xapply(Ret(*func)(Args...), std::tuple<Args...>& tup)
{
	xapply_helper(func, gen_seq<sizeof...(Args)>(), tup);
    /*
        ì˜ˆë¥¼ë“¤ì–´
        xapply(func), int, int, int)ê°€ ë“¤ì–´ì˜¬ ê²½ìš°
        xapply_helper(func, gen_seq<3>(), tup); ì´ ë˜ê¸°ì—
        xapply_helper(func, seq<0, 1, 2>, tup); ê°€ ëœë‹¤
    */
}

template<typename F, typename... Args, int... ls>
void xapply_helper(F func, seq<ls...>, std::tuple<Args...>& tup)
{
    // func(std::get<0>(tup), std::get<1>(tup), std::get<2>(tup) ... )
	(func)(std::get<ls>(tup)...);
}

template<typename T, typename Ret, typename... Args>
void xapply(T* obj, Ret(T::*func)(Args...), std::tuple<Args...>& tup)
{
    // ë©¤ë²„ í•¨ìˆ˜ë¥¼ ëŒ€ë¹„
	xapply_helper(obj, func, gen_seq<sizeof...(Args)>(), tup);
}

template<typename T, typename F, typename... Args, int... ls>
void xapply_helper(T* obj, F func, seq<ls...>, std::tuple<Args...>& tup)
{
	(obj->*func)(std::get<ls>(tup)...);
}
```

ğŸ¶ ë©¤ë²„ í•¨ìˆ˜ë„ ëŒ€ë¹„ë¥¼ í•´ì•¼í•œë‹¤.

```cpp
template<typename T/*ê°ì²´ë„ í•„ìš”*/, typename Ret, typename... Args>
class MemberJob
{
    using FuncType = Ret(T::*)(Args...);

public:
    MemberJob(T* obj, FuncType func, Args... args) : _obj(obj), _func(func), _tuple(args...) {}

    Ret operator()()
    {
        std::apply(_func, _tuple);
    }

    Ret Execute()
    {
        std::apply(_func, _tuple);
    }

private:
    T*                  _obj;
    FuncType            _func;
    std::tuple<Args...> _tuple;
};

// ...

Kning k1;
MemberJob job(&k1, &Knight::HealMe, 10);

job.Execute();
```

ì‚¬ìš©ì€ ì´ë ‡ê²Œ ëœë‹¤.

```cpp
class Room
{
    // ...
    template<typename T, typename Ret, typename... Args>
    void PushJob(Ret(T::*memFunc)(Args...), Args... args)
    {
        auto job = MakeShared<MemberJob<T, Ret, Args...>>(static_cast<T*>(this), memFunc, args...);
        _jobs.Push(job);
    }
```

```cpp
bool Handle_C_CHAT(PacketSessionRef& session, Protocol::C_CHAT& pkt)
{
	std::cout << pkt.msg() << endl;

	Protocol::S_CHAT chatPkt;
	chatPkt.set_msg(pkt.msg());
	auto sendBuffer = ClientPacketHandler::MakeSendBuffer(chatPkt);

	//GRoom.PushJob(MakeShared<BroadcastJob>(GRoom, sendBuffer));
	GRoom.PushJob(&Room::Broadcast, sendBuffer);

	return true;
}
```