---
layout: default
title: "53. JobQueue-3"
parent: (IOCP)
grand_parent: C++
nav_order: 6
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ¨ ëŒë‹¤ì—ëŠ” ì–´ë–¤ ì¥ì ì´ ìˆì„ê¹Œ?

```cpp
// Fuctorì—ì„œëŠ” ë§¤ê°œë³€ìˆ˜ a, bë¥¼ ì„ì‹œë¡œ ë‹´ì•„ ë‘ê¸°ìœ„í•´ì„œ tupleì„ ì‚¬ìš©í–ˆì—ˆë‹¤.
void HelloWorld(int32 a, int32 b)
{
    // ...
}

int main()
{
    std::function<void()> func = [=]()
    {
        // ëŒë‹¤ë¥¼ ì‚¬ìš©í•  ê²½ìš° ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ì‹œë¡œ ë‹´ì•„ë‘ì§€ ì•Šì•„ë„ ëœë‹¤.
            // ëŒë‹¤ê°€ ì•Œì•„ì„œ í•´ì¤€ë‹¤.
        HelloWorld(1, 2);
    }

    // ...

    func(); // ì •ìƒì ìœ¼ë¡œ HelloWorld(1, 2); í˜¸ì¶œë¨.

    // ì¢€ ë” ì–´ë µê²Œ ì„¤ëª…í•˜ë©´ closure objectë¥¼ ëŒë‹¤ì—ì„œ ìƒì„±í•´ ì¤€ë‹¤.
}
```

ğŸ¨ ë‹¨, ëŒë‹¤ë„ ì—­ì‹œ ë‹¨ì ì´ ìˆëŠ”ë°

```cpp
// ë¬¸ì œ1) ì°¸ì¡°í•œ ê°ì²´ì˜ ìƒì¡´ë³´ì¥

PlayerRef player = make_shared<Player>();

std::function<void()> func = [&player]()
{
    // ëŒë‹¤ì—ì„œ playerë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ playerì˜ ìƒì¡´ì´ ë³´ì¥ë˜ì–´ì•¼ í•œë‹¤.
}
```

```cpp
// ë¬¸ì œ2) ìê¸° ìì‹ ì˜ ìƒì¡´ë³´ì¥

class Knight
{
public:
    void HealMe(int32 value)
    {
        _hp += value;
    }

    void Test()
    {
        // ì™¸ë¶€ì—ì„œ ì´ ëŒë‹¤ë¥¼ í˜¸ì¶œì‹œ Knightë¼ëŠ” ê°ì²´ì˜ ìƒì¡´ì„ ë³´ì¥í•˜ì§€ ì•Šìœ¼ë©´ crashê°€ ë‚ ìˆ˜ ìˆìŒ
        auto job = [=]()
        {
            HealMe(_hp);
        }
        /* 
            // ìœ„ì™€ ë™ì¼í•œ í‘œí˜„ì´ë‹¤. ê²°êµ­ thisë¥¼ ìƒëµí•œ í˜•íƒœì´ë‹¤.
            auto job = [this]()
            {
                HealMe(this->_hp);
            }
        */
    }

private:
    int32 _hp = 100;
};
```

```cpp
// ì‚¬ì‹¤ ë¬¸ì œ2ëŠ” ì´ë ‡ê²Œ í•´ê²°ì´ ê°€ëŠ¥í•˜ê¸´ í•¨

class Knight : public enable_shared_from_this<Knight>
{
    // ...

    void Test()
    {
        auto job = [self = shared_from_this()]()
        {
            // jobì´ ìœ ì§€ë ë•ŒëŠ” Knightë„ ë¬´ì¡°ê±´ ìœ ì§€ëœë‹¤.
            HealMe(self->_hp);
        }
```

---

ğŸ¨ ìœ„ ë¬¸ì œë¥¼ ì¡°ì‹¬í•˜ë©° êµ¬í˜„ì„ í•´ë³´ìë©´<br>
ğŸ¨ ìš°ì„ ì€ ê²°ë¡ ë¶€í„°... ì´ë ‡ê²Œ ì‚¬ìš©í•˜ê³ ì í•œë‹¤.

```cpp
bool Handle_C_CHAT(PacketSessionRef& session, Protocol::C_CHAT& pkt)
{
	std::cout << pkt.msg() << endl;

	Protocol::S_CHAT chatPkt;
	chatPkt.set_msg(pkt.msg());
	auto sendBuffer = ClientPacketHandler::MakeSendBuffer(chatPkt);

    // ì‚¬ì‹¤ìƒ ì‚¬ìš©ë²•ì€ ì´ì „ê³¼ ë™ì¼
	GRoom->PushJob(&Room::Broadcast, sendBuffer);
    /*
        template<typename T, typename Ret, typename... Args>
        void PushJob(Ret(T::*memFunc)(Args...), Args... args)
        {
            shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
            auto job = ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...);
            _jobQueue.Push(job);
        }
    */

	return true;
}
```

```cpp
class JobSerializer : public enable_shared_from_this<JobSerializer>
{
public:
	void PushJob(CallbackType&& callback)
	{
		auto job = ObjectPool<Job>::MakeShared(std::move(callback));
		_jobQueue.Push(job);
	}

	template<typename T, typename Ret, typename... Args>
	void PushJob(Ret(T::*memFunc)(Args...), Args... args)
	{
		shared_ptr<T> owner = static_pointer_cast<T>(shared_from_this());
		auto job = ObjectPool<Job>::MakeShared(owner, memFunc, std::forward<Args>(args)...);
		_jobQueue.Push(job);
	}

	virtual void FlushJob() abstract;

protected:
	JobQueue _jobQueue;
};
```

```cpp
using CallbackType = std::function<void()>;

class Job
{
public:
	Job(CallbackType&& callback) : _callback(std::move(callback))
	{
	}

	template<typename T, typename Ret, typename... Args>
	Job(shared_ptr<T> owner, Ret(T::* memFunc)(Args...), Args&&... args)
	{
		_callback = [owner, memFunc, args...]()
		{
			(owner.get()->*memFunc)(args...);
		};
	}

	void Execute()
	{
		_callback();
	}

private:
	CallbackType _callback;
};
```