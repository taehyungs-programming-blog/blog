---
layout: default
title: "13. Lock-Free Stack/Queue êµ¬í˜„ - 2"
parent: (IOCP)
grand_parent: C++
nav_order: 2
---

ğŸ˜¼ ê²°ë¡ ì ìœ¼ë¡œ nodeì˜ deleteë¥¼ í•´ì•¼í•œë‹¤ëŠ” ë§ì¸ë° ìš°ë¦¬ëŠ” ê°€ì¥ ì¢‹ì€ ë°©ë²•ì„ ì•Œê³ ìˆë‹¤. ğŸ‘‰ smart pointer!

ğŸ˜¼ `shared_ptr`ë¡œ ê°„ë‹¨íˆ í•´ê²°í•´ë³´ì

```cpp
template<typename T>
class LockFreeStack
{
	struct Node
	{
		Node(const T& value) : data(make_shared<T>(value)), next(nullptr)
		{

		}

        // dataì™€ next Nodeë¥¼ shared_ptrë¡œ ê´€ë¦¬
		shared_ptr<T> data;
		shared_ptr<Node> next;
	};

public:
	void Push(const T& value)
	{
        // Nodeë¥¼ ë„£ì„ë•Œ make_sharedí•œë‹¤
		shared_ptr<Node> node = make_shared<Node>(value);

        // ê·¸ëƒ¥ headë¥¼ ì½ì–´ì˜¬ ê²½ìš° atomicí•˜ì§€ ì•Šê¸°ì— std::atomic_loadí†µí•´ ì½ì–´ì˜¨ë‹¤
		node->next = std::atomic_load(&_head);

        // ì¼ë°˜ atomic_compare_exchange_weakì™€ ë™ì‘ì´ ê°™ìŒ.
        // atomic í•˜ê²Œ _head == node->next ì¸ì§€ í™•ì¸ í›„ _head = node í•˜ë¼
		while (std::atomic_compare_exchange_weak(&_head, &node->next, node) == false)
		{
		}
	}

	shared_ptr<T> TryPop()
	{
		shared_ptr<Node> oldHead = std::atomic_load(&_head);

		while (oldHead && std::atomic_compare_exchange_weak(&_head, &oldHead, oldHead->next) == false)
		{

		}

		if (oldHead == nullptr)
			return shared_ptr<T>();

		return oldHead->data;
	}

    // ì´ë ‡ê²Œ í•˜ë©´ deleteë¥¼ êµ³ì´ í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.

    /*

    ê·¸ëŸ°ë° shared_ptrìì²´ê°€ lock_freeí•œê°€???
    -> ë§Œì•½ shared_ptrìì²´ì—ì„œ lockì„í•˜ê³  ìˆë‹¤ë©´ ì´ê²Œ ë¬´ìŠ¨ ì˜ë¯¸ì¸ê°€???

    shared_ptr<int32> ptr;
    bool value = atomic_is_lock_free(&ptr);     // falseê°€ ë‚˜ì˜´, share_ptrìì²´ì—ì„œ lockì„ ê±¸ê²Œëœë‹¤.  

    */

private:
	shared_ptr<Node> _head;
};
```

<br>

ğŸ™€ ì„¸ìƒ ë§Œì‚¬ê°€ ê·¸ë¦¬ ì‰½ì§€ì•Šë‹¤... `shared_ptr` ìì²´ê°€ lock_freeí•˜ì§€ ëª»í•˜ê¸°ì— ê²°êµ­ lockìœ¼ë¡œ ë™ì‘í•˜ê²Œ ëœë‹¤. ã… ã… .. ìš°ë¦¬ê°€ ì›í•˜ë˜ ê²°ê³¼ê°€ ì•„ë‹˜

ğŸ˜¼ ë‹¤ì‹œ lock_freeí•˜ê²Œ êµ¬í˜„í•´ë³´ì ((ì°¸ë¡œê³ , ì•„ë˜ ë‚´ìš©ì´ ì—„ì²­ì–´ë ¤ìš´ë° ë‚˜ëŠ” ì™œ ì´ëŸ°ì½”ë“œë¥¼ ëª» ì§œì§€ ì‹¤ë§ë§ì.

ğŸ˜¼ ì•„ë˜ì½”ë“œëŠ” ë…¼ë¬¸ì—ì„œ ë‚˜ì˜¨ë‚´ìš©ì„ ì½”ë“œë¡œ êµ¬í˜„, ì˜¤ë˜ëœ í•™ìˆ ì˜ ê²°ê³¼ì´ë‹¤.(ë³´í†µì‚¬ëŒì€ ì•„ë˜ì²˜ëŸ¼ ì˜ ëª»ì§ ë‹¤ëŠ” ë§))

```cpp
template<typename T>
class LockFreeStack
{
	struct Node;

	struct CountedNodePtr
	{
		int32 externalCount = 0;    // í¬ì¸í„° ì°¸ì¡° íšŸìˆ˜
		Node* ptr = nullptr;
	};

	struct Node
	{
		Node(const T& value) : data(make_shared<T>(value))
		{

		}

		shared_ptr<T> data;
		atomic<int32> internalCount = 0;
		CountedNodePtr next;
	};

public:
	// [][][][][][][]
	// [head]
	void Push(const T& value)
	{
		CountedNodePtr node;
		node.ptr = new Node(value);
		node.externalCount = 1;
		// [!]
		node.ptr->next = _head;
		while (_head.compare_exchange_weak(node.ptr->next, node) == false)
		{
		}
	}
	
	// [][][][][][][]
	// [head]
	shared_ptr<T> TryPop()
	{
		while (true)
		{
		    CountedNodePtr oldHead = _head; 
			// ì°¸ì¡°ê¶Œ íšë“ (externalCountë¥¼ í˜„ ì‹œì  ê¸°ì¤€ +1 í•œ ì• ê°€ ì´ê¹€)
            // externalCountì´ ê¸°ë³¸ 1ì´ê³  ì´í•¨ìˆ˜ë¥¼ ì§€ë‚˜ë©´ ê¸°ë³¸ 2ê°€ ëœë‹¤.
            // ë§Œì•½ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œ ì§„ì…ì´ ë˜ì—ˆë‹¤ë©´ 2ì´ìƒì´ ë˜ê² ì§€?
			IncreaseHeadCount(oldHead);
			// ìµœì†Œí•œ externalCount >= 2 ì¼í…Œë‹ˆ ì‚­ì œX (ì•ˆì „í•˜ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ”)
            // ì—¬ê¸°ê¹Œì§€ì˜¤ë©´ externalCountì„ ì¦ê°€ ì‹œì¼°ê¸°ì— ì ‘ê·¼ê¶Œ(ì°¸ì¡°ê¶Œ)ì€ ìˆëŠ”ê²ƒ.
			Node* ptr = oldHead.ptr;

			// ë°ì´í„° ì—†ìŒ
			if (ptr == nullptr)
				return shared_ptr<T>();

			// ì†Œìœ ê¶Œ íšë“ (ptr->nextë¡œ headë¥¼ ë°”ê¿”ì¹˜ê¸° í•œ ì• ê°€ ì´ê¹€)
			if (_head.compare_exchange_strong(oldHead, ptr->next))
			{
                // ì°¸ì¡°ê¶Œì„ íšë“í•œ ì²« ë²ˆì§¸ Threadê°€ ì—¬ê¸°ë¡œ ë“¤ì–´ì˜´

				shared_ptr<T> res;
				res.swap(ptr->data);

                // ë°ì´í„°ë¥¼ ëˆ„ê°€ ì“°ê³ ìˆë‚˜ í™•ì¸ìš©
				// external : 1 -> 2(ë‚˜+1) -> 4(ë‚˜+1 ë‚¨+2)
				// internal : 1 -> 0
				const int32 countIncrease = oldHead.externalCount - 2;
                // externalCount - 2ì„ í•˜ë©´ ëª‡ ëª…(ìŠ¤ë ˆë“œ)ì´ ì°¸ì¡°ê¶Œì„ ê°–ê³  ìˆëŠ”ì§€ ë‚˜ì˜¨ë‹¤.

                // fetch_addì— ì–¼ë§ˆë¥¼ ë„£ë“  ì›ë˜ ê°’ì´ ë¦¬í„´ë¨
                // ì˜ˆë¥¼ë“¤ì–´ internalCount = 0ì´ê³  fetch_add(2)ë¥¼í•˜ë©´ ë¦¬í„´ê°’ì€ 0ì´ê³  ì´í›„ 2ë¡œ ë³€ê²½
				if (ptr->internalCount.fetch_add(countIncrease) == -countIncrease)
					delete ptr;

				return res;
			}
			else if (ptr->internalCount.fetch_sub(1) == 1)
			{
                // ì°¸ì¡°ê¶Œì€ ìˆìœ¼ë‚˜ ì†Œìœ ê¶Œì´ ì—†ëŠ”, ê·¸ëŸ¬ë‹ˆê¹ ì²« ë²ˆì§¸ Threadì´í›„ì˜ ThreadëŠ” ëª¨ë‘ ì—¬ê¸°ë¡œ ì˜¨ë‹¤.
				// ì°¸ì¡°ê¶Œì€ ì–»ì—ˆìœ¼ë‚˜, ì†Œìœ ê¶Œì€ ì‹¤íŒ¨ -> ë’·ìˆ˜ìŠµì€ ë‚´ê°€ í•œë‹¤
				delete ptr;
			}
		}
	}

private:
	void IncreaseHeadCount(CountedNodePtr& oldCounter)
	{
        CountedNodePtr newCounter = oldCounter;
        
		while (true)
		{
			newCounter.externalCount++;

			if (_head.compare_exchange_strong(oldCounter, newCounter))
			{
				oldCounter.externalCount = newCounter.externalCount;
				break;
			}
		}
	}

private:
	atomic<CountedNodePtr> _head;
};
```