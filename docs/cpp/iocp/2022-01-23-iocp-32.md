---
layout: default
title: "32. WSAEventSelect ëª¨ë¸ êµ¬í˜„"
parent: (IOCP)
grand_parent: C++
nav_order: 4
---

ğŸ˜º Select ë°©ì‹ì˜ ë¬¸ì œì  ğŸ‘‰ ë§¤ë²ˆ ì†Œì¼“ ì…‹ì„ ì´ˆê¸°í™” í•˜ê³  socketì— ë“±ë¡ì„ í•´ì•¼í•œë‹¤.

```cpp
// ì•„ë˜ë¶€ë¶„

FD_ZERO(&reads);
FD_ZERO(&writes);

FD_SET(listenSocket, &reads)

for(Session& s : sessions)
{
    // ...
}
```

<Br>

---

ğŸ˜º í•´ê²°ì±…?

```cpp
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <atomic>
#include <mutex>
#include <windows.h>
#include <future>
#include "ThreadManager.h"

#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

void HandleError(const char* cause)
{
	int32 errCode = ::WSAGetLastError();
	cout << cause << " ErrorCode : " << errCode << endl;
}

const int32 BUFSIZE = 1000;

struct Session
{
	SOCKET socket = INVALID_SOCKET;
	char recvBuffer[BUFSIZE] = {};
	int32 recvBytes = 0;
	int32 sendBytes = 0;
};

int main()
{
	WSAData wsaData;
	if (::WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
		return 0;

	SOCKET listenSocket = ::socket(AF_INET, SOCK_STREAM, 0);
	if (listenSocket == INVALID_SOCKET)
		return 0;

	u_long on = 1;
	if (::ioctlsocket(listenSocket, FIONBIO, &on) == INVALID_SOCKET)
		return 0;

	SOCKADDR_IN serverAddr;
	::memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = ::htonl(INADDR_ANY);
	serverAddr.sin_port = ::htons(7777);

	if (::bind(listenSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
		return 0;

	if (::listen(listenSocket, SOMAXCONN) == SOCKET_ERROR)
		return 0;

	cout << "Accept" << endl;

	// WSAEventSelect = (WSAEventSelect í•¨ìˆ˜ê°€ í•µì‹¬ì´ ë˜ëŠ”)
	// ì†Œì¼“ê³¼ ê´€ë ¨ëœ ë„¤íŠ¸ì›Œí¬ ì´ë²¤íŠ¸ë¥¼ [ì´ë²¤íŠ¸ ê°ì²´]ë¥¼ í†µí•´ ê°ì§€

	// ì´ë²¤íŠ¸ ê°ì²´ ê´€ë ¨ í•¨ìˆ˜ë“¤
	// ìƒì„± : WSACreateEvent (ìˆ˜ë™ ë¦¬ì…‹ Manual-Reset + Non-Signaled ìƒíƒœ ì‹œì‘)
	// ì‚­ì œ : WSACloseEvent
	// ì‹ í˜¸ ìƒíƒœ ê°ì§€ : WSAWaitForMultipleEvents
	// êµ¬ì²´ì ì¸ ë„¤íŠ¸ì›Œí¬ ì´ë²¤íŠ¸ ì•Œì•„ë‚´ê¸° : WSAEnumNetworkEvents

	// ì†Œì¼“ <-> ì´ë²¤íŠ¸ ê°ì²´ ì—°ë™
	// WSAEventSelect(socket, event, networkEvents);
	// - ê´€ì‹¬ìˆëŠ” ë„¤íŠ¸ì›Œí¬ ì´ë²¤íŠ¸
	// FD_ACCEPT : ì ‘ì†í•œ í´ë¼ê°€ ìˆìŒ accept
	// FD_READ : ë°ì´í„° ìˆ˜ì‹  ê°€ëŠ¥ recv, recvfrom
	// FD_WRITE : ë°ì´í„° ì†¡ì‹  ê°€ëŠ¥ send, sendto
	// FD_CLOSE : ìƒëŒ€ê°€ ì ‘ì† ì¢…ë£Œ
	// FD_CONNECT : í†µì‹ ì„ ìœ„í•œ ì—°ê²° ì ˆì°¨ ì™„ë£Œ
	// FD_OOB

	// ì£¼ì˜ ì‚¬í•­
	// WSAEventSelect í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´, í•´ë‹¹ ì†Œì¼“ì€ ìë™ìœ¼ë¡œ ë„Œë¸”ë¡œí‚¹ ëª¨ë“œ ì „í™˜
	// accept() í•¨ìˆ˜ê°€ ë¦¬í„´í•˜ëŠ” ì†Œì¼“ì€ listenSocketê³¼ ë™ì¼í•œ ì†ì„±ì„ ê°–ëŠ”ë‹¤
	// - ë”°ë¼ì„œ clientSocketì€ FD_READ, FD_WRITE ë“±ì„ ë‹¤ì‹œ ë“±ë¡ í•„ìš”
	// - ë“œë¬¼ê²Œ WSAEWOULDBLOCK ì˜¤ë¥˜ê°€ ëœ° ìˆ˜ ìˆìœ¼ë‹ˆ ì˜ˆì™¸ ì²˜ë¦¬ í•„ìš”
	// ì¤‘ìš”)
	// - ì´ë²¤íŠ¸ ë°œìƒ ì‹œ, ì ì ˆí•œ ì†Œì¼“ í•¨ìˆ˜ í˜¸ì¶œí•´ì•¼ í•¨
	// - ì•„ë‹ˆë©´ ë‹¤ìŒ ë²ˆì—ëŠ” ë™ì¼ ë„¤íŠ¸ì›Œí¬ ì´ë²¤íŠ¸ê°€ ë°œìƒ X
	// ex) FD_READ ì´ë²¤íŠ¸ ë–´ìœ¼ë©´ recv() í˜¸ì¶œí•´ì•¼ í•˜ê³ , ì•ˆí•˜ë©´ FD_READ ë‘ ë²ˆ ë‹¤ì‹œ X

	// 1) count, event
	// 2) waitAll : ëª¨ë‘ ê¸°ë‹¤ë¦¼? í•˜ë‚˜ë§Œ ì™„ë£Œ ë˜ì–´ë„ OK?
	// 3) timeout : íƒ€ì„ì•„ì›ƒ
	// 4) ì§€ê¸ˆì€ false
	// return : ì™„ë£Œëœ ì²«ë²ˆì§¸ ì¸ë±ìŠ¤
	// WSAWaitForMultipleEvents

	// 1) socket
	// 2) eventObject : socket ê³¼ ì—°ë™ëœ ì´ë²¤íŠ¸ ê°ì²´ í•¸ë“¤ì„ ë„˜ê²¨ì£¼ë©´, ì´ë²¤íŠ¸ ê°ì²´ë¥¼ non-signaled
	// 3) networkEvent : ë„¤íŠ¸ì›Œí¬ ì´ë²¤íŠ¸ / ì˜¤ë¥˜ ì •ë³´ê°€ ì €ì¥
	// WSAEnumNetworkEvents

	vector<WSAEVENT> wsaEvents;
	vector<Session> sessions;
	sessions.reserve(100);

	WSAEVENT listenEvent = ::WSACreateEvent();
	wsaEvents.push_back(listenEvent);
	sessions.push_back(Session{ listenSocket });
	// ì†Œì¼“(listenSocket)ê³¼ ì´ë²¤íŠ¸(listenEvent)ë¥¼ ì—°ê²°í•œë‹¤.
	if (::WSAEventSelect(listenSocket, listenEvent, FD_ACCEPT | FD_CLOSE) == SOCKET_ERROR)
		return 0;

	while (true)
	{
		int32 index = ::WSAWaitForMultipleEvents(wsaEvents.size(), &wsaEvents[0], FALSE, WSA_INFINITE, FALSE);
		if (index == WSA_WAIT_FAILED)
			continue;

		index -= WSA_WAIT_EVENT_0;

		//::WSAResetEvent(wsaEvents[index]);

		WSANETWORKEVENTS networkEvents;
		if (::WSAEnumNetworkEvents(sessions[index].socket, wsaEvents[index], &networkEvents) == SOCKET_ERROR)
			continue;

		// Listener ì†Œì¼“ ì²´í¬
		if (networkEvents.lNetworkEvents & FD_ACCEPT)
		{
			// Error-Check
			if (networkEvents.iErrorCode[FD_ACCEPT_BIT] != 0)
				continue;

			SOCKADDR_IN clientAddr;
			int32 addrLen = sizeof(clientAddr);

			SOCKET clientSocket = ::accept(listenSocket, (SOCKADDR*)&clientAddr, &addrLen);
			if (clientSocket != INVALID_SOCKET)
			{
				cout << "Client Connected" << endl;

				WSAEVENT clientEvent = ::WSACreateEvent();
				wsaEvents.push_back(clientEvent);
				sessions.push_back(Session{ clientSocket });
				if (::WSAEventSelect(clientSocket, clientEvent, FD_READ | FD_WRITE | FD_CLOSE) == SOCKET_ERROR)
					return 0;
			}
		}

		// Client Session ì†Œì¼“ ì²´í¬
		if (networkEvents.lNetworkEvents & FD_READ || networkEvents.lNetworkEvents & FD_WRITE)
		{
			// Error-Check
			if ((networkEvents.lNetworkEvents & FD_READ) && (networkEvents.iErrorCode[FD_READ_BIT] != 0))
				continue;
			// Error-Check
			if ((networkEvents.lNetworkEvents & FD_WRITE) && (networkEvents.iErrorCode[FD_WRITE_BIT] != 0))
				continue;

			Session& s = sessions[index];

			// Read
			if (s.recvBytes == 0)
			{
				int32 recvLen = ::recv(s.socket, s.recvBuffer, BUFSIZE, 0);
				if (recvLen == SOCKET_ERROR && ::WSAGetLastError() != WSAEWOULDBLOCK)
				{
					// TODO : Remove Session
					continue;
				}

				s.recvBytes = recvLen;
				cout << "Recv Data = " << recvLen << endl;
			}

			// Write
			if (s.recvBytes > s.sendBytes)
			{
				int32 sendLen = ::send(s.socket, &s.recvBuffer[s.sendBytes], s.recvBytes - s.sendBytes, 0);
				if (sendLen == SOCKET_ERROR && ::WSAGetLastError() != WSAEWOULDBLOCK)
				{
					// TODO : Remove Session
					continue;
				}

				s.sendBytes += sendLen;
				if (s.recvBytes == s.sendBytes)
				{
					s.recvBytes = 0;
					s.sendBytes = 0;
				}

				cout << "Send Data = " << sendLen << endl;
			}
		}

		// FD_CLOSE ì²˜ë¦¬
		if (networkEvents.lNetworkEvents & FD_CLOSE)
		{
			// TODO : Remove Socket
		}
	}

	
	// ìœˆì† ì¢…ë£Œ
	::WSACleanup();
}
```