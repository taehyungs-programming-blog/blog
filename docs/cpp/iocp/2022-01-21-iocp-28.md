---
layout: default
title: "28. UDP, TCP ë¹„êµ/êµ¬í˜„"
parent: (IOCP)
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

ğŸ˜º TCP, UDP ì°¨ì´ì 

* TCP
    * ì—°ê²°ì„ ìœ„í•´ í• ë‹¹ë˜ëŠ” ë…¼ë¦¬ì ì¸ ê²½ë¡œê°€ ì¡´ì¬
    * ì „ì†¡ ìˆœì„œê°€ ë³´ì¥
    * ë¶„ì‹¤ì´ ì¼ì–´ë‚˜ë©´ ì±…ì„ì§€ê³  ë‹¤ì‹œ ì „ì†¡(ì‹ ë¢°ì„±ì´ ì¢‹ë‹¤)
    * ê³ ë ¤í•  ê²ƒ(íë¦„ í˜¼ì¡ ì œì–´)ì´ ë§ì•„ ì†ë„ê°€ ëŠë¦¬ë‹¤
* UDP
    * ì—°ê²°ì´ë¼ëŠ” ê°œë…ì´ ì—†ë‹¤
    * ì „ì†¡ ìˆœì‚¬ê°€ ë³´ì¥ë˜ì§€ ì•ŠìŒ
    * ê²½ê³„(boundary)ì˜ ê°œë…ì´ ìˆë‹¤ -> Hello / Worldë¥¼ ë³´ë‚´ë©´ Hello / Worldë¡œ ë“¤ì–´ì˜´(TCPëŠ” ì–´ë–»ê²Œ ë“¤ì–´ì˜¬ì§€ ëª¨ë¦„)
    * ë¶„ì‹¤ì— ëŒ€í•œ ì±…ì„ì´ ì—†ë‹¤(ì‹ ë¢°ì„±ì´ ë‚®ë‹¤)
    * ë‹¨ìˆœí•˜ê¸°ì— ì†ë„ê°€ ë¹ ë¥´ë‹¤

---

## êµ¬í˜„

### Server

```cpp
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <atomic>
#include <mutex>
#include <windows.h>
#include <future>
#include "ThreadManager.h"
#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

void HandleError(const char* cause)
{
    int32 errCode = ::WSAGetLastError();
    cout << cause << " ErrorCode : " << errCode << endl;
}

int main()
{
    WSAData wsaData;
    if (::WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
        return 0;

    // UDPëŠ” ì„œë²„ì†Œì¼“ì„ í•˜ë‚˜ë§Œ ë§Œë“¤ê³  ê·¸ ì†Œì¼“ì„ í†µí•´ ë°ì´í„°ë¥¼ ë°›ìŒ.
    SOCKET serverSocket = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (serverSocket == INVALID_SOCKET)
    {
        HandleError("Socket");
        return 0;
    }

    SOCKADDR_IN serverAddr;
    ::memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = ::htonl(INADDR_ANY);
    serverAddr.sin_port = ::htons(7777);

    if (::bind(serverSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR)
    {
        HandleError("Bind");
        return 0;
    }

    while (true)
    {
        SOCKADDR_IN clientAddr;
        ::memset(&clientAddr, 0, sizeof(clientAddr));
        int32 addrLen = sizeof(clientAddr);
        this_thread::sleep_for(1s);
        char recvBuffer[1000];

        // UDPëŠ” Listenì´ ì—†ê³  ë°”ë¡œ recvë¥¼í•˜ê²Œ ëœë‹¤
        int32 recvLen = ::recvfrom(serverSocket, recvBuffer, sizeof(recvBuffer), 0,
            (SOCKADDR*)&clientAddr, &addrLen);

        if (recvLen <= 0)
        {
            HandleError("RecvFrom");
            return 0;
        }

        cout << "Recv Data! Data = " << recvBuffer << endl;
        cout << "Recv Data! Len = " << recvLen << endl;
        // ë³´ë‚¼ë•Œë„ sendtoë¡œ ë³´ë‚¸ë‹¤
        int32 errorCode = ::sendto(serverSocket, recvBuffer, recvLen, 0,
            (SOCKADDR*)&clientAddr, sizeof(clientAddr));

        if (errorCode == SOCKET_ERROR)
        {
            HandleError("SendTo");
            return 0;
        }

        cout << "Send Data! Len = " << recvLen << endl;
    }

    // ìœˆì† ì¢…ë£Œ
    ::WSACleanup();
}
```

### Client

```cpp
#include "pch.h"
#include <iostream>
#include <winsock2.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")

void HandleError(const char* cause)
{
    int32 errCode = ::WSAGetLastError();
    cout << cause << " ErrorCode : " << errCode << endl;
}

int main()
{
    WSAData wsaData;
    if (::WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
        return 0;

    SOCKET clientSocket = ::socket(AF_INET, SOCK_DGRAM, 0);
    if (clientSocket == INVALID_SOCKET)
    {
        HandleError("Socket");
        return 0;
    }

    SOCKADDR_IN serverAddr;
    ::memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    ::inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);
    serverAddr.sin_port = ::htons(7777);
    // Connected UDP
    ::connect(clientSocket, (SOCKADDR*)&serverAddr, sizeof(serverAddr));
    // UnConnected UDPëŠ” connectìì²´ê°€ í•„ìš”ì—†ìŒ
    
    // ---------------------------
    while (true)
    {
        char sendBuffer[100] = "Hello World!";

        // ë‚˜ì˜ IP ì£¼ì†Œ + í¬íŠ¸ ë²ˆí˜¸ ì„¤ì •
        // Unconnected UDP
        /*int32 resultCode = ::sendto(clientSocket, sendBuffer, sizeof(sendBuffer), 0,
            (SOCKADDR*)&serverAddr, sizeof(serverAddr));*/

        // Connected UDP
        int32 resultCode = ::send(clientSocket, sendBuffer, sizeof(sendBuffer), 0);
        if (resultCode == SOCKET_ERROR)
        {
            HandleError("SendTo");
            return 0;
        }

        cout << "Send Data! Len = " << sizeof(sendBuffer) << endl;
        SOCKADDR_IN recvAddr;
        ::memset(&recvAddr, 0, sizeof(recvAddr));
        int32 addrLen = sizeof(recvAddr);
        char recvBuffer[1000];

        // Unconnected UDP
        //int32 recvLen = ::recvfrom(clientSocket, recvBuffer, sizeof(recvBuffer), 0,
        //  (SOCKADDR*)&recvAddr, &addrLen);
        
        int32 recvLen = ::recv(clientSocket, recvBuffer, sizeof(recvBuffer), 0);
        if (recvLen <= 0)
        {
            HandleError("RecvFrom");
            return 0;
        }

        cout << "Recv Data! Data = " << recvBuffer << endl;
        cout << "Recv Data! Len = " << recvLen << endl;
        this_thread::sleep_for(1s);
    }
    
    // ---------------------------
    // ì†Œì¼“ ë¦¬ì†ŒìŠ¤ ë°˜í™˜
    ::closesocket(clientSocket);
    // ìœˆì† ì¢…ë£Œ
    ::WSACleanup();
}
```