---
layout: default
title: "11. mimalloc"
parent: "(OpenSource ğŸ‘¨â€ğŸ’»)"
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## mimallocì´ë€?

* mimallocì€ Microsoft Researchì—ì„œ ê°œë°œí•œ ê³ ì„±ëŠ¥ ë©”ëª¨ë¦¬ í• ë‹¹ì
    * [Github](https://github.com/microsoft/mimalloc)

---

## ì‚¬ì „ ì •ì˜

* 3ë‹¨ê³„ ê³„ì¸µ êµ¬ì¡°:
    * Heap (í™): ìŠ¤ë ˆë“œë³„ ë¡œì»¬ í™
    * Segment (ì„¸ê·¸ë¨¼íŠ¸): 32GB í¬ê¸°ì˜ í° ë©”ëª¨ë¦¬ ì²­í¬
    * Page (í˜ì´ì§€): 64KB/512KB í¬ê¸°ì˜ ì‹¤ì œ í• ë‹¹ ë‹¨ìœ„

* í¬ê¸°ë³„ ì „ëµ:
    * Small (â‰¤8KB): 64KB í˜ì´ì§€ì—ì„œ í• ë‹¹
    * Medium (â‰¤64KB): 512KB í˜ì´ì§€ì—ì„œ í• ë‹¹
    * Large (â‰¤16MB): ì „ìš© ì„¸ê·¸ë¨¼íŠ¸ì—ì„œ í• ë‹¹
    * Huge (>16MB): ê°€ë³€ í¬ê¸° ì„¸ê·¸ë¨¼íŠ¸

---

## Example

```cpp
#include <stdio.h>
#include <string.h>
#include "mimalloc.h"

void basic_usage_example() {
    printf("=== ê¸°ë³¸ ì‚¬ìš©ë²• ===\n");
    
    // 1. ê¸°ë³¸ í• ë‹¹/í•´ì œ - malloc/freeì™€ ë™ì¼í•œ ì¸í„°í˜ì´ìŠ¤
    void* ptr1 = mi_malloc(1024);
    printf("í• ë‹¹ëœ ì£¼ì†Œ: %p\n", ptr1);
    mi_free(ptr1);
    
    // 2. 0ìœ¼ë¡œ ì´ˆê¸°í™”ëœ ë©”ëª¨ë¦¬ í• ë‹¹
    void* ptr2 = mi_zalloc(512);
    printf("0 ì´ˆê¸°í™” ë©”ëª¨ë¦¬: %p\n", ptr2);
    mi_free(ptr2);
    
    // 3. ë°°ì—´ í• ë‹¹ (callocê³¼ ìœ ì‚¬)
    int* arr = (int*)mi_calloc(100, sizeof(int));
    printf("ë°°ì—´ í• ë‹¹: %p\n", arr);
    mi_free(arr);
    
    // 4. ì •ë ¬ëœ ë©”ëª¨ë¦¬ í• ë‹¹
    void* aligned_ptr = mi_malloc_aligned(1024, 64); // 64ë°”ì´íŠ¸ ì •ë ¬
    printf("64ë°”ì´íŠ¸ ì •ë ¬ ë©”ëª¨ë¦¬: %p\n", aligned_ptr);
    mi_free(aligned_ptr);
}

void heap_usage_example() {
    printf("\n=== í™ ì‚¬ìš©ë²• ===\n");
    
    // 1. ì „ìš© í™ ìƒì„± - ìŠ¤ë ˆë“œë³„ ë…ë¦½ì ì¸ í™
    mi_heap_t* heap = mi_heap_new();
    printf("ìƒˆ í™ ìƒì„±: %p\n", heap);
    
    // 2. íŠ¹ì • í™ì—ì„œ í• ë‹¹
    void* ptr1 = mi_heap_malloc(heap, 256);
    void* ptr2 = mi_heap_malloc(heap, 512);
    printf("í™ì—ì„œ í• ë‹¹: %p, %p\n", ptr1, ptr2);
    
    // 3. í™ ì „ì²´ í•´ì œ - ëª¨ë“  ë¸”ë¡ì´ í•œë²ˆì— í•´ì œë¨
    mi_heap_destroy(heap);
    printf("í™ ì „ì²´ í•´ì œ ì™„ë£Œ\n");
}

void performance_features() {
    printf("\n=== ì„±ëŠ¥ ê¸°ëŠ¥ë“¤ ===\n");
    
    // 1. ì‘ì€ ê°ì²´ ë¹ ë¥¸ í• ë‹¹
    void* small_ptr = mi_malloc_small(64); // ì‘ì€ ê°ì²´ ìµœì í™” ê²½ë¡œ
    printf("ì‘ì€ ê°ì²´ í• ë‹¹: %p\n", small_ptr);
    mi_free(small_ptr);
    
    // 2. í†µê³„ ì •ë³´ ì¶œë ¥
    mi_stats_print_out(NULL, NULL);
    
    // 3. ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ (ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” í˜ì´ì§€ ì •ë¦¬)
    mi_collect(false); // ê°•ì œë¡œ ìˆ˜ì§‘í•˜ì§€ ì•ŠìŒ
    printf("ë©”ëª¨ë¦¬ ì •ë¦¬ ì™„ë£Œ\n");
}

int main() {
    // mimalloc ì´ˆê¸°í™” (ë³´í†µ ìë™ìœ¼ë¡œ ë¨)
    mi_process_init();
    
    basic_usage_example();
    heap_usage_example();
    performance_features();
    
    printf("\nmimalloc ë²„ì „: %d\n", mi_version());
    
    // ì •ë¦¬ (ë³´í†µ ìë™ìœ¼ë¡œ ë¨)
    mi_process_done();
    return 0;
}
```

---

## mimallocì€ ì–´ë–¤ì‹ìœ¼ë¡œ ìµœì í™”ë¥¼ í–ˆì„ê¹Œ?

### 1. ì´ˆê³ ì† í• ë‹¹ ê²½ë¡œ (Fast Path) êµ¬í˜„

* í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ (src/alloc.c:30-50)

```c
extern inline void* _mi_page_malloc_zero(mi_heap_t* heap, mi_page_t* page, size_t size, bool zero) {
  // 1. Free list ì²´í¬ (ë‹¨ì¼ NULL í…ŒìŠ¤íŠ¸)
  mi_block_t* const block = page->free;
  if mi_unlikely(block == NULL) {
    return _mi_malloc_generic(heap, size, zero, 0);  // ëŠë¦° ê²½ë¡œë¡œ ì´ë™
  }
  
  // 2. ë‹¤ìŒ ë¸”ë¡ í¬ì¸í„° ê°€ì ¸ì˜¤ê¸° (ë‹¨ì¼ ë©”ëª¨ë¦¬ ì½ê¸°)
  page->free = mi_block_next(page, block);
  
  // 3. ì‚¬ìš© ì¹´ìš´í„° ì¦ê°€ (ë‹¨ì¼ ì¦ê°€ ì—°ì‚°)
  page->used++;
  
  // ì´ê²Œ ì „ë¶€! ë¦´ë¦¬ì¦ˆ ëª¨ë“œì—ì„œ ë‹¨ 7ê°œ ì–´ì…ˆë¸”ë¦¬ ëª…ë ¹ì–´
  return block;
}
```

* ì‚¬ì „ì§€ì‹:
    * Free listëŠ” ì‚¬ìš© ê°€ëŠ¥í•œ(í•´ì œëœ) ë©”ëª¨ë¦¬ ë¸”ë¡ë“¤ì„ ì—°ê²°í•œ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸

```cpp
// í•´ì œëœ ë©”ëª¨ë¦¬ ë¸”ë¡ì˜ êµ¬ì¡°
typedef struct mi_block_s {
  mi_encoded_t next;  // ë‹¤ìŒ í•´ì œëœ ë¸”ë¡ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
} mi_block_t;
```

```
í˜ì´ì§€ ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Block A â”‚ Block B â”‚ Block C â”‚ Block D â”‚
â”‚ (ì‚¬ìš©ì¤‘) â”‚ (FREE) â”‚ (FREE) â”‚ (ì‚¬ìš©ì¤‘) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Free List ì—°ê²°:
page->free â†’ Block B â†’ Block C â†’ NULL
             â†‘next      â†‘next
```

* ì„±ëŠ¥ ìµœì í™” í¬ì¸íŠ¸:

- **ë¶„ê¸° ì˜ˆì¸¡**: `mi_unlikely()` ë§¤í¬ë¡œë¡œ ì»´íŒŒì¼ëŸ¬ì—ê²Œ íŒíŠ¸ ì œê³µ
- **ì¸ë¼ì¸**: `extern inline`ìœ¼ë¡œ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì œê±°  
- **ë‹¨ì¼ í…ŒìŠ¤íŠ¸**: NULL ì²´í¬ í•˜ë‚˜ë¡œ ë¹ ë¥¸/ëŠë¦° ê²½ë¡œ ê²°ì •
- **ìºì‹œ íš¨ìœ¨ì„±**: í˜ì´ì§€ ë‚´ì—ì„œ ìˆœì°¨ì  ì ‘ê·¼ íŒ¨í„´

---

### 2. ìŠ¤ë ˆë“œ ë¡œì»¬ í™ ìµœì í™”

* (ì‚¬ì „ì§€ì‹) ìŠ¤ë ˆë“œ ë¡œì»¬ í™ì´ í•„ìš”í•œ ì´ìœ ?

```
// ì „í†µì ì¸ ë¬¸ì œ ìƒí™©
Thread A: ptr = malloc(1024);        // A í™ì—ì„œ í• ë‹¹
Thread B: free(ptr);                 // ì–´ë–»ê²Œ í•´ì œí•˜ì§€? A í™? B í™?

// ë§Œì•½ ê°ì í™ì„ ì“´ë‹¤ë©´...
Thread Aì˜ í™: [1024ë°”ì´íŠ¸ê°€ ì‚¬ìš©ì¤‘ì¸ ìƒíƒœ]
Thread Bì˜ í™: [ì´ ë©”ëª¨ë¦¬ì— ëŒ€í•´ ì „í˜€ ëª¨ë¦„]
â†’ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°œìƒ!
```

```
// ì „í†µì ì¸ malloc - ëª¨ë“  ìŠ¤ë ˆë“œê°€ í•˜ë‚˜ì˜ í™ ê³µìœ 
Thread 1: malloc(100) â†’ ğŸ”’ LOCK â†’ í• ë‹¹ â†’ ğŸ”“ UNLOCK
Thread 2: malloc(200) â†’ â° ëŒ€ê¸°... â†’ ğŸ”’ LOCK â†’ í• ë‹¹ â†’ ğŸ”“ UNLOCK
Thread 3: malloc(50)  â†’ â° ëŒ€ê¸°... â†’ â° ëŒ€ê¸°... â†’ ğŸ”’ LOCK â†’ í• ë‹¹
```

```
// ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ë…ë¦½ì ì¸ í™
Thread 1: mi_malloc(100) â†’ Heap A â†’ ì¦‰ì‹œ í• ë‹¹ âœ…
Thread 2: mi_malloc(200) â†’ Heap B â†’ ì¦‰ì‹œ í• ë‹¹ âœ…
Thread 3: mi_malloc(50)  â†’ Heap C â†’ ì¦‰ì‹œ í• ë‹¹ âœ…
```

* Lock-Free ë©€í‹°ìŠ¤ë ˆë”©:
    * ê° ìŠ¤ë ˆë“œê°€ ë…ë¦½ì ì¸ í™ì„ ê°€ì§
    * ì‘ì€ ê°ì²´ í• ë‹¹/í•´ì œëŠ” ì™„ì „íˆ lock-free
    * í¬ë¡œìŠ¤ ìŠ¤ë ˆë“œ í•´ì œë§Œ ì›ìì  ì—°ì‚° ì‚¬ìš©

----

### 3. ìºì‹œ ì¹œí™”ì  ë°ì´í„° êµ¬ì¡°

* (ì‚¬ì „ì§€ì‹) cpu ì†ë„ì˜ ì°¨ì´
    * CPUëŠ” ë©”ëª¨ë¦¬ë¥¼ 64ë°”ì´íŠ¸ ë‹¨ìœ„(ìºì‹œ ë¼ì¸)ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤. ì¦‰, 1ë°”ì´íŠ¸ë¥¼ ì½ì–´ë„ 64ë°”ì´íŠ¸ë¥¼ í†µì§¸ë¡œ ê°€ì ¸ì™€ì•¼ í•œë‹¤

```c

typedef struct mi_page_s {
  // === ì²« ë²ˆì§¸ ìºì‹œ ë¼ì¸ (0-63ë°”ì´íŠ¸) ===
  // ğŸš€ í• ë‹¹/í•´ì œ ì‹œ ê°€ì¥ ìì£¼ ì ‘ê·¼í•˜ëŠ” í•„ë“œë“¤
  uint32_t slice_count;        //  0-3ë°”ì´íŠ¸   
  uint32_t slice_offset;       //  4-7ë°”ì´íŠ¸
  uint8_t  is_committed:1;     //  8ë°”ì´íŠ¸ (ë¹„íŠ¸í•„ë“œ)
  uint8_t  is_zero_init:1;     //  8ë°”ì´íŠ¸ 
  uint8_t  is_huge:1;          //  8ë°”ì´íŠ¸
  
  uint16_t capacity;           //  9-10ë°”ì´íŠ¸  â­ ê°€ì¥ ì¤‘ìš”!
  uint16_t reserved;           // 11-12ë°”ì´íŠ¸  â­ ì¤‘ìš”!
  mi_page_flags_t flags;       // 13ë°”ì´íŠ¸     â­ ì¤‘ìš”!
  uint8_t  free_is_zero:1;     // 14ë°”ì´íŠ¸    
  uint8_t  retire_expire:7;    // 14ë°”ì´íŠ¸
  
  mi_block_t* free;            // 16-23ë°”ì´íŠ¸  â­ ê°€ì¥ ì¤‘ìš”!
  mi_block_t* local_free;      // 24-31ë°”ì´íŠ¸  â­ ì¤‘ìš”!
  uint16_t used;               // 32-33ë°”ì´íŠ¸  â­ ì¤‘ìš”!
  uint8_t  block_size_shift;   // 34ë°”ì´íŠ¸
  uint8_t  heap_tag;           // 35ë°”ì´íŠ¸
  
  size_t   block_size;         // 36-43ë°”ì´íŠ¸  â­ ì¤‘ìš”!
  uint8_t* page_start;         // 44-51ë°”ì´íŠ¸  â­ ì¤‘ìš”!
  uintptr_t keys[2];           // 52-67ë°”ì´íŠ¸
  
  // === ë‘ ë²ˆì§¸ ìºì‹œ ë¼ì¸ (64-127ë°”ì´íŠ¸) ===  
  // ğŸŒ ëœ ìì£¼ ì ‘ê·¼í•˜ëŠ” í•„ë“œë“¤
  _Atomic(mi_thread_free_t) xthread_free;  // 68-75ë°”ì´íŠ¸ (ê°€ë” ì ‘ê·¼)
  _Atomic(uintptr_t) xheap;               // 76-83ë°”ì´íŠ¸ (ê°€ë” ì ‘ê·¼)
  // ... ê¸°íƒ€ í•„ë“œë“¤
};
```

* ë°ì´í„° êµ¬ì¡° (include/mimalloc/types.h:285-330)

---

### 4. ë©€í‹°ìŠ¤ë ˆë“œ í•´ì œ ìµœì í™” (Delayed Free)

* ê¸°ì¡´ freeì˜ ë¬¸ì œ

```cpp
// Thread Aì—ì„œ í• ë‹¹
Thread A: char* ptr = malloc(1024);

// Thread Bì—ì„œ í•´ì œ ì‹œë„
Thread B: free(ptr);  // ì–´ë–»ê²Œ í•´ì œí•˜ì§€???

/*
ptrì€ Thread Aì˜ í™ì—ì„œ í• ë‹¹ë¨
Thread BëŠ” Thread Aì˜ í™ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ (private)
ê¸€ë¡œë²Œ í™ìœ¼ë¡œ ë³´ë‚´ë©´ â†’ Lock í•„ìš” â†’ ì„±ëŠ¥ ì €í•˜
*/
```

```cpp
void mi_free(void* p) {
  // 1. í¬ì¸í„°ì—ì„œ ì„¸ê·¸ë¨¼íŠ¸ ì •ë³´ ì¶”ì¶œ
  mi_segment_t* const segment = mi_checked_ptr_segment(p, "mi_free");
  
  // 2. ğŸ”‘ í•µì‹¬: ì†Œìœ ê¶Œ í™•ì¸!
  const bool is_local = (_mi_prim_thread_id() == mi_atomic_load_relaxed(&segment->thread_id));
  
  if (is_local) {
    // ë‚´ê°€ í• ë‹¹í•œ ë©”ëª¨ë¦¬ â†’ ì¦‰ì‹œ í•´ì œ (ë¹ ë¥¸ ê²½ë¡œ)
    mi_free_block_local(page, block, true, false);
  }
  else {
    // ğŸš¨ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ í• ë‹¹í•œ ë©”ëª¨ë¦¬ â†’ íŠ¹ë³„ ì²˜ë¦¬ í•„ìš”!
    mi_free_generic_mt(page, segment, p);
  }
}
```

* ì§€ì—° í•´ì œëŠ” ì–´ë–¤ì‹?

```cpp
static void mi_free_block_delayed_mt(mi_page_t* page, mi_block_t* block) {
  // 1. í˜ì´ì§€ì˜ í¬ë¡œìŠ¤ ìŠ¤ë ˆë“œ í•´ì œ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ ì‹œë„
  mi_thread_free_t tfree = mi_atomic_load_relaxed(&page->xthread_free);
  
  do {
    if (ì²« ë²ˆì§¸_í¬ë¡œìŠ¤_ìŠ¤ë ˆë“œ_í•´ì œ) {
      // í™ì˜ ì§€ì—° í•´ì œ ë¦¬ìŠ¤íŠ¸ë¡œ ë³´ë‚´ê¸°
      use_delayed = true;
    }
    else {
      // í˜ì´ì§€ ë¡œì»¬ ë¦¬ìŠ¤íŠ¸ì— ì§ì ‘ ì¶”ê°€
      mi_block_set_next(page, block, mi_tf_block(tfree));
      tfreex = mi_tf_set_block(tfree, block);
    }
  } while (!mi_atomic_cas_weak_release(&page->xthread_free, &tfree, tfreex));
}
```

### ìµœì í™” íš¨ê³¼:
- **ìºì‹œ ì§€ì—­ì„±**: ì†Œìœ  ìŠ¤ë ˆë“œê°€ ë‚˜ì¤‘ì— ì¼ê´„ ì²˜ë¦¬
- **ì›ìì  ì—°ì‚° ìµœì†Œí™”**: ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ë‹¨ìˆœ ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
- **ë©”ëª¨ë¦¬ ìˆœì„œ**: Release/Acquireë¡œ í•„ìš”í•œ ë™ê¸°í™”ë§Œ ìˆ˜í–‰

---

### 5. ì›ìì  ë¹„íŠ¸ë§µ í• ë‹¹ (Arena Allocation)

* ì›ìì  ë¹„íŠ¸ë§µ í• ë‹¹ì€ **ëŒ€ìš©ëŸ‰ ë©”ëª¨ë¦¬ ë¸”ë¡(Arena)**ì„ ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê³  ë¹ ë¥´ê²Œ í• ë‹¹í•˜ëŠ” ë°©ë²•

```
Arena êµ¬ì¡°:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Arena (ì˜ˆ: 4GB)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¤
â”‚ Block 0 â”‚ Block 1 â”‚ Block 2 â”‚ Block 3 â”‚ Block 4 â”‚ ...  â”‚
â”‚ (64MB) â”‚ (64MB) â”‚ (64MB) â”‚ (64MB) â”‚ (64MB) â”‚      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚  FREE   â”‚  USED   â”‚  FREE   â”‚  FREE   â”‚  USED   â”‚ ...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
    0        1        2        3        4       ...
```

* ê¸°ì¡´ë¬¸ì œ?

```
// ë¬¸ì œ ìƒí™©: ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— Arenaì—ì„œ í• ë‹¹ ì‹œë„
Thread A: 300MB í• ë‹¹ ìš”ì²­ â†’ Block 2,3,4,5 í•„ìš” (4ê°œ ë¸”ë¡)
Thread B: 200MB í• ë‹¹ ìš”ì²­ â†’ Block 2,3,4 í•„ìš” (3ê°œ ë¸”ë¡)
Thread C: 100MB í• ë‹¹ ìš”ì²­ â†’ Block 3,4 í•„ìš” (2ê°œ ë¸”ë¡)

// ğŸš¨ ë™ì‹œì— ì ‘ê·¼í•˜ë©´...
ëª¨ë“  ìŠ¤ë ˆë“œê°€ Block 2,3,4ë¥¼ "ì‚¬ìš© ê°€ëŠ¥"í•˜ë‹¤ê³  íŒë‹¨!
â†’ ê°™ì€ ë©”ëª¨ë¦¬ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ê²Œ í• ë‹¹
â†’ ë©”ëª¨ë¦¬ ì¶©ëŒ!
```

* ë¹„íŠ¸ë§µ = ê° ë¸”ë¡ì˜ ì‚¬ìš© ìƒíƒœë¥¼ ë¹„íŠ¸ë¡œ í‘œí˜„

```
// 64ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œ MI_BITMAP_FIELD_BITS = 64
typedef _Atomic(size_t) mi_bitmap_field_t;  // 64ë¹„íŠ¸ ì›ìì  ì •ìˆ˜

// Arenaì˜ ë¸”ë¡ ìƒíƒœë¥¼ ë¹„íŠ¸ë§µìœ¼ë¡œ í‘œí˜„:
// 0 = FREE, 1 = USED
ë¹„íŠ¸ë§µ í•„ë“œ 0: 01001000... (Block 0,1,2,3... 64ê°œ ë¸”ë¡ ìƒíƒœ)
ë¹„íŠ¸ë§µ í•„ë“œ 1: 11000100... (Block 64,65,66... ë‹¤ìŒ 64ê°œ ë¸”ë¡ ìƒíƒœ)
```

* ì˜ˆì‹œë¥¼ ë“¤ì–´ë³´ìë©´ ...

```
// 300MB í• ë‹¹ ìš”ì²­ â†’ 5ê°œ ë¸”ë¡ í•„ìš” â†’ ì—°ì†ëœ 5ê°œì˜ 0ë¹„íŠ¸ ì°¾ê¸°
ë¹„íŠ¸ë§µ: 01001000111000... 
           â†‘ 
        ì—¬ê¸°ì„œ 5ê°œ ì—°ì† 0ë¹„íŠ¸ ë°œê²¬!
```

```cpp
const size_t mask = mi_bitmap_mask_(count, 0);
// count=5ì¸ ê²½ìš° mask = 00011111 (5ê°œ ë¹„íŠ¸)

size_t m = (mask << bitidx);
// bitidx=3ì¸ ê²½ìš° m = 01111100 (3ë²ˆì§¸ë¶€í„° 5ê°œ ë¹„íŠ¸)
```

```cpp
const size_t newmap = (map | m);
// ê¸°ì¡´:    01001000111000...
// ë§ˆìŠ¤í¬:  01111100000000...  
// ê²°ê³¼:    01111100111000... (5ê°œ ë¸”ë¡ì´ USEDë¡œ ë³€ê²½)

if (!mi_atomic_cas_strong_acq_rel(field, &map, newmap)) {
    // CAS ì‹¤íŒ¨ â†’ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¨¼ì € í• ë‹¹í•¨ â†’ ë‹¤ì‹œ ì‹œë„
    continue;
}
else {
    // CAS ì„±ê³µ â†’ í• ë‹¹ ì™„ë£Œ!
    return true;
}
```

* ë¹„íŠ¸ë§µ ê¸°ë°˜ í• ë‹¹ (src/bitmap.c:40-100)

```c
inline bool _mi_bitmap_try_find_claim_field(mi_bitmap_t bitmap, size_t idx, 
                                            const size_t count, mi_bitmap_index_t* bitmap_idx) {
  mi_bitmap_field_t* field = &bitmap[idx];
  size_t map = mi_atomic_load_relaxed(field);
  
  if (map == MI_BITMAP_FIELD_FULL) return false;  // ë¹ ë¥¸ ì‹¤íŒ¨
  
  const size_t mask = mi_bitmap_mask_(count, 0);
  const size_t bitidx_max = MI_BITMAP_FIELD_BITS - count;
  
#ifdef MI_HAVE_FAST_BITSCAN
  size_t bitidx = mi_ctz(~map);    // í•˜ë“œì›¨ì–´ ì§€ì› ë¹„íŠ¸ ìŠ¤ìº”
#else
  size_t bitidx = 0;               // ì„ í˜• ìŠ¤ìº”
#endif
  
  size_t m = (mask << bitidx);
  while (bitidx <= bitidx_max) {
    const size_t mapm = (map & m);
    if (mapm == 0) {  // ë§ˆìŠ¤í¬ ë¹„íŠ¸ë“¤ì´ ëª¨ë‘ 0ì¸ê°€?
      const size_t newmap = (map | m);
      if (!mi_atomic_cas_strong_acq_rel(field, &map, newmap)) {
        continue;  // CAS ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„
      }
      else {
        *bitmap_idx = mi_bitmap_index_create(idx, bitidx);
        return true;  // ì„±ê³µ!
      }
    }
    else {
#ifdef MI_HAVE_FAST_BITSCAN
      const size_t shift = (MI_SIZE_BITS - mi_clz(mapm) - bitidx);
#else
      const size_t shift = 1;
#endif
      bitidx += shift;
      m <<= shift;
    }
  }
  return false;
}
```

### í•˜ë“œì›¨ì–´ ìµœì í™”:
- **ë¹„íŠ¸ ìŠ¤ìº”**: `ctz`(count trailing zeros) ëª…ë ¹ì–´ í™œìš©
- **Compare-and-Swap**: í•˜ë“œì›¨ì–´ ì›ìì  ì—°ì‚°
- **ìºì‹œ ë¼ì¸ ì •ë ¬**: 64ë°”ì´íŠ¸ ê²½ê³„ ì •ë ¬ë¡œ false sharing ë°©ì§€

---

### 6. ì»¤ë°‹ ë§ˆìŠ¤í¬ ìµœì í™” (Virtual Memory Management)

* ì„¸ë°€í•œ ë©”ëª¨ë¦¬ ì œì–´ (src/segment.c:20-120)

```c
static void mi_commit_mask_create(size_t bitidx, size_t bitcount, mi_commit_mask_t* cm) {
  mi_commit_mask_create_empty(cm);
  size_t i = bitidx / MI_COMMIT_MASK_FIELD_BITS;
  size_t ofs = bitidx % MI_COMMIT_MASK_FIELD_BITS;
  
  while (bitcount > 0) {
    size_t avail = MI_COMMIT_MASK_FIELD_BITS - ofs;
    size_t count = (bitcount > avail ? avail : bitcount);
    size_t mask = (count >= MI_COMMIT_MASK_FIELD_BITS ? 
                   ~((size_t)0) : 
                   (((size_t)1 << count) - 1) << ofs);
    cm->mask[i] = mask;
    bitcount -= count;
    ofs = 0;
    i++;
  }
}

size_t _mi_commit_mask_committed_size(const mi_commit_mask_t* cm, size_t total) {
  size_t count = 0;
  for (size_t i = 0; i < MI_COMMIT_MASK_FIELD_COUNT; i++) {
    size_t mask = cm->mask[i];
    if (~mask == 0) {
      count += MI_COMMIT_MASK_FIELD_BITS;  // ëª¨ë“  ë¹„íŠ¸ ì„¤ì •ë¨
    }
    else {
      for (; mask != 0; mask >>= 1) {  // popcountë¡œ ìµœì í™” ê°€ëŠ¥
        if ((mask & 1) != 0) count++;
      }
    }
  }
  return ((total / MI_COMMIT_MASK_BITS) * count);
}
```

### ê°€ìƒ ë©”ëª¨ë¦¬ ìµœì í™”:
- **64KB ë‹¨ìœ„ ì œì–´**: ìš´ì˜ì²´ì œ í˜ì´ì§€ í¬ê¸°ì— ìµœì í™”
- **ì§€ì—° ì»¤ë°‹**: ì‹¤ì œ ì‚¬ìš©ë  ë•Œê¹Œì§€ ë¬¼ë¦¬ ë©”ëª¨ë¦¬ ë§¤í•‘ ì—°ê¸°
- **ìë™ ë””ì»¤ë°‹**: ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì˜ì—­ ìë™ ë°˜í™˜

---

## 7. ì»´íŒŒì¼ëŸ¬ ìµœì í™” í™œìš©

* (ì‚¬ì „ì§€ì‹) ë¸Œëœì¹˜ ì˜ˆì¸¡ì´ë€?
    * CPUëŠ” ë¶„ê¸°ë¬¸(if-else)ì„ ë§Œë‚˜ë©´ ë¯¸ë¦¬ ì–´ëŠ ìª½ìœ¼ë¡œ ê°ˆì§€ ì˜ˆì¸¡, 
    * ì˜ˆì¸¡ì´ ë§ìœ¼ë©´ ë¹ ë¥´ê³ , í‹€ë¦¬ë©´ íŒŒì´í”„ë¼ì¸ì„ ë¹„ì›Œì•¼ í•´ì„œ ëŠë ¤ì§„ë‹¤

```
// CPU íŒŒì´í”„ë¼ì¸
ëª…ë ¹ì–´ 1: FETCH â†’ DECODE â†’ EXECUTE â†’ WRITE
ëª…ë ¹ì–´ 2:         FETCH â†’ DECODE â†’ EXECUTE â†’ WRITE  
ëª…ë ¹ì–´ 3:                 FETCH â†’ DECODE â†’ EXECUTE â†’ WRITE

// ë¸Œëœì¹˜ ì˜ˆì¸¡ ì‹¤íŒ¨ ì‹œ
if (condition) { ... }
â†“ CPUê°€ trueë¡œ ì˜ˆì¸¡í–ˆëŠ”ë° ì‹¤ì œë¡œëŠ” false
â†’ íŒŒì´í”„ë¼ì¸ ì „ì²´ë¥¼ ë¹„ìš°ê³  ë‹¤ì‹œ ì‹œì‘! (20-30 cycles ì†ì‹¤)
```

```cpp
// âœ… mimalloc ë°©ì‹
mi_block_t* const block = page->free;
if mi_unlikely(block == NULL) {  // ì»´íŒŒì¼ëŸ¬: "ì´ ê²½ìš°ëŠ” ê±°ì˜ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤"
    return _mi_malloc_generic(heap, size, zero, 0);  // ëŠë¦° ê²½ë¡œ
}
// ë¹ ë¥¸ ê²½ë¡œ ê³„ì†...

// ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•˜ëŠ” ì–´ì…ˆë¸”ë¦¬:
// 1. ë¹ ë¥¸ ê²½ë¡œë¥¼ ë©”ì¸ ë¼ì¸ì— ë°°ì¹˜
// 2. ëŠë¦° ê²½ë¡œë¥¼ ë©€ë¦¬ ë–¨ì–´ì§„ ê³³ì— ë°°ì¹˜
// 3. CPUê°€ ìì—°ìŠ¤ëŸ½ê²Œ ë¹ ë¥¸ ê²½ë¡œë¥¼ ì˜ˆì¸¡í•˜ê²Œ ë¨
```

* ë¸Œëœì¹˜ ì˜ˆì¸¡ íŒíŠ¸:

```c
#if defined(__GNUC__) || defined(__clang__)
#define mi_unlikely(x) (__builtin_expect(!!(x), false))
#define mi_likely(x)   (__builtin_expect(!!(x), true))
#else
#define mi_unlikely(x) (x)
#define mi_likely(x)   (x)
#endif
```

* ì¸ë¼ì¸ ìµœì í™”:

```c
// âŒ í•¨ìˆ˜ í˜¸ì¶œ ë°©ì‹
void* mi_malloc(size_t size) {
    return _mi_heap_malloc_zero(mi_prim_get_default_heap(), size, false);
}

// ì–´ì…ˆë¸”ë¦¬ë¡œ ë³€í™˜ë˜ë©´:
// 1. ë§¤ê°œë³€ìˆ˜ë¥¼ ë ˆì§€ìŠ¤í„°/ìŠ¤íƒì— ì €ì¥    (2-3 cycles)
// 2. í•¨ìˆ˜ ì£¼ì†Œë¡œ ì í”„                  (1-2 cycles)  
// 3. ìŠ¤íƒ í”„ë ˆì„ ì„¤ì •                  (2-3 cycles)
// 4. ì‹¤ì œ ì‘ì—…                        (5-10 cycles)
// 5. ìŠ¤íƒ í”„ë ˆì„ ì •ë¦¬                  (2-3 cycles)
// 6. ì›ë˜ ìœ„ì¹˜ë¡œ ëŒì•„ê°€ê¸°               (1-2 cycles)
// ì´ 13-23 cyclesì˜ ì˜¤ë²„í—¤ë“œ!
```

```c
#define mi_decl_noinline __attribute__((noinline))  // í° í•¨ìˆ˜ëŠ” ì¸ë¼ì¸ ë°©ì§€
extern inline                                       // ì‘ì€ í•¨ìˆ˜ëŠ” ê°•ì œ ì¸ë¼ì¸
```

```cpp
// âœ… ì¸ë¼ì¸ í•  ê²ƒë“¤ (ì‘ê³  ìì£¼ í˜¸ì¶œ)
extern inline void* _mi_page_malloc_zero(...) {
    // ë‹¨ ëª‡ ì¤„ì˜ í•µì‹¬ í• ë‹¹ ì½”ë“œ
}

// âŒ ì¸ë¼ì¸ í•˜ì§€ ì•Šì„ ê²ƒë“¤ (í¬ê³  ë³µì¡)
static mi_decl_noinline void mi_page_free_list_extend(...) {
    // ë³µì¡í•œ í˜ì´ì§€ í™•ì¥ ë¡œì§ (ìˆ˜ì‹­ ì¤„)
}

static mi_decl_noinline void mi_free_block_delayed_mt(...) {
    // ë³µì¡í•œ ë©€í‹°ìŠ¤ë ˆë“œ í•´ì œ ë¡œì§
}
```

* ë©”ëª¨ë¦¬ ìˆœì„œ ìµœì í™”:

```c
// ì›ë˜ ì½”ë“œ
data = 42;           // 1. ë°ì´í„° ì„¤ì •
ready = true;        // 2. ì¤€ë¹„ ì™„ë£Œ í”Œë˜ê·¸

// CPUê°€ ìµœì í™”í•œ ì½”ë“œ (ìˆœì„œ ë°”ë€œ!)
ready = true;        // 2. ì¤€ë¹„ ì™„ë£Œ í”Œë˜ê·¸ ë¨¼ì €
data = 42;           // 1. ë°ì´í„° ì„¤ì • ë‚˜ì¤‘ì—

// ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ:
if (ready) {         // readyê°€ trueì¸ë°
    use(data);       // dataëŠ” ì•„ì§ 42ê°€ ì•„ë‹˜! ğŸš¨
}
```

```c
#define mi_atomic_load_relaxed(p)     atomic_load_explicit(p, memory_order_relaxed)
#define mi_atomic_load_acquire(p)     atomic_load_explicit(p, memory_order_acquire)
#define mi_atomic_store_release(p,x)  atomic_store_explicit(p, x, memory_order_release)
```

