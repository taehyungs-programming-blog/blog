---
layout: default
title: "5. (Telegram) Reactive Programming Library(1~4 ì •ë¦¬)"
parent: "(OpenSource ğŸ‘¨â€ğŸ’»)"
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/telegramdesktop/tdesktop)

* ê²°êµ­ ì•ì—ì„œ ì •ë¦¬í•œ ë‚´ìš©ì´ ëª¨ë‘ **Reactive Programming Library**ë¥¼ ìœ„í•œê²ƒ

```cpp
// ì˜ˆë¥¼ë“¤ì–´ ì´ë ‡ê²Œ ì‚¬ìš©í•œë‹¤ ê°€ì •í•˜ì
raw->paintRequest(
) | rpl::start_with_next([=] {
    QPainter p(raw);

    p.setOpacity(state->animation.value(to));
    p.drawPixmap(QPoint(), pixmap);
}, raw->lifetime());
```

```cpp
// producerë¥¼ returní•œë‹¤
rpl::producer<QRect> RpWidgetWrap::paintRequest() const {
	return eventStreams().paint.events();
}
```

```cpp
// nextëŠ” Callbackì„ì„ ê¸°ì–µí•˜ì
template <typename OnNext>
inline auto start_with_next(OnNext &&next, lifetime &alive_while)
-> details::lifetime_with_next<std::decay_t<OnNext>> {
	return { alive_while, std::forward<OnNext>(next) };
}

// start_with_nextëŠ” lifetime_with_nextì™€ ê°™ì´ êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ ë„˜ê¸´ë‹¤
template <typename OnNext>
struct lifetime_with_next {
	lifetime &alive_while;
	OnNext next;
};
```

```cpp
template <
	typename Value,
	typename Error,
	typename Generator,
	typename OnNext,
	typename = std::enable_if_t<is_callable_v<OnNext, Value>>>
inline void operator|(
		producer<Value, Error, Generator> &&value,
		lifetime_with_next<OnNext> &&handlers) {
	std::move(value).start(
		std::move(handlers.next),
		[] {},
		[] {},
		handlers.alive_while);
}
```

```cpp
template <typename Value, typename Error, typename Generator>
template <
	typename OnNext,
	typename OnError,
	typename OnDone,
	typename>
inline void producer_base<Value, Error, Generator>::start(
		OnNext &&next,
		OnError &&error,
		OnDone &&done,
		lifetime &alive_while) && {
	return std::move(*this).start_existing(
		make_consumer<Value, Error>(
			std::forward<OnNext>(next),
			std::forward<OnError>(error),
			std::forward<OnDone>(done)),
		alive_while);
}
```

```cpp
template <typename Value, typename Error, typename Generator>
template <typename Handlers>
inline void producer_base<Value, Error, Generator>::start_existing(
		const consumer_type<Handlers> &consumer,
		lifetime &alive_while) && {
	alive_while.add(consumer.terminator());
	consumer.add_lifetime(std::move(_generator)(consumer));
}
```

* ì—ì œ event_streamì— ì˜í•´ ë™ì‘í•¨.

```cpp
bool RpWidgetWrap::handleEvent(QEvent *event) {
	// ...

	case QEvent::Paint:
		if (streams->paint.has_consumers()) {
			if (!allAreObserved) {
				that = rpWidget();
			}
			const auto rect = static_cast<QPaintEvent*>(event)->rect();
            // ì´ë ‡ê²Œ í˜¸ì¶œ! ì‰½ì¥¬?
			streams->paint.fire_copy(rect);
			if (!that) {
				return true;
			}
		}
		break;
	}
```