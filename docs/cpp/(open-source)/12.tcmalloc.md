---
layout: default
title: "12. tcmalloc"
parent: "(OpenSource 👨‍💻)"
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## mimalloc이란?

* mimalloc은 Google에서 개발한 고성능 메모리 할당자
    * [Github](https://github.com/google/tcmalloc)

---

## 기존 Malloc의 문제점

```cpp
class TraditionalMalloc {
private:
    static std::mutex global_lock;  // 모든 할당에 대한 전역 락
    static std::atomic<int> allocation_count;
    static std::atomic<int> lock_contentions;
    
public:
    static void* allocate(size_t size) {
        // 기존 malloc: 모든 할당에 대해 전역 락 필요
        std::lock_guard<std::mutex> lock(global_lock);
        
        // 락 경합 카운터 증가
        lock_contentions++;
        
        // 실제 할당 시뮬레이션 (느린 시스템 콜)
        std::this_thread::sleep_for(std::chrono::microseconds(1));
        
        allocation_count++;
        return malloc(size);
    }
    
    static void deallocate(void* ptr) {
        std::lock_guard<std::mutex> lock(global_lock);
        lock_contentions++;
        free(ptr);
    }
    
    static void printStats() {
        std::cout << "Traditional Malloc Stats:\n";
        std::cout << "  Total allocations: " << allocation_count << "\n";
        std::cout << "  Lock contentions: " << lock_contentions << "\n";
    }
};

std::mutex TraditionalMalloc::global_lock;
std::atomic<int> TraditionalMalloc::allocation_count{0};
std::atomic<int> TraditionalMalloc::lock_contentions{0};
```

## TCMalloc의 Thread-Locale 최적화

```cpp
class ThreadLocalCache {
private:
    struct CacheEntry {
        void* ptr;
        size_t size;
    };
    
    // 각 스레드별 캐시 (락 없음!)
    thread_local static std::vector<CacheEntry> local_cache;
    thread_local static int cache_hits;
    thread_local static int cache_misses;
    
    // Central Cache (공유, 락 필요)
    static std::mutex central_lock;
    static std::vector<CacheEntry> central_cache;
    static std::atomic<int> central_requests;
    
public:
    static void* allocate(size_t size) {
        // 1단계: Thread Local Cache에서 찾기 (락 없음 - 핵심 최적화!)
        for (auto it = local_cache.begin(); it != local_cache.end(); ++it) {
            if (it->size >= size) {
                void* ptr = it->ptr;
                local_cache.erase(it);
                cache_hits++;
                return ptr;
            }
        }
        
        // 2단계: Cache Miss - Central에서 보충
        cache_misses++;
        refillFromCentral(size);
        
        // 3단계: Central에서 가져온 후 재시도
        for (auto it = local_cache.begin(); it != local_cache.end(); ++it) {
            if (it->size >= size) {
                void* ptr = it->ptr;
                local_cache.erase(it);
                return ptr;
            }
        }
        
        // 4단계: 새로 할당
        return malloc(size);
    }
    
    static void deallocate(void* ptr, size_t size) {
        // Thread Local Cache에 저장 (락 없음!)
        if (local_cache.size() < 32) {  // 캐시 크기 제한
            local_cache.push_back({ptr, size});
            return;
        }
        
        // 캐시가 가득 참 - Central로 일부 이동
        moveToCentral();
        local_cache.push_back({ptr, size});
    }
    
private:
    static void refillFromCentral(size_t size) {
        std::lock_guard<std::mutex> lock(central_lock);
        central_requests++;
        
        // Central에서 여러 개를 한 번에 가져옴 (배치 처리)
        int moved = 0;
        for (auto it = central_cache.begin(); it != central_cache.end() && moved < 8;) {
            if (it->size >= size) {
                local_cache.push_back(*it);
                it = central_cache.erase(it);
                moved++;
            } else {
                ++it;
            }
        }
    }
    
    static void moveToCentral() {
        std::lock_guard<std::mutex> lock(central_lock);
        
        // Local Cache의 절반을 Central로 이동
        int to_move = local_cache.size() / 2;
        for (int i = 0; i < to_move; ++i) {
            central_cache.push_back(local_cache.back());
            local_cache.pop_back();
        }
    }
    
public:
    static void printThreadStats() {
        std::cout << "Thread " << std::this_thread::get_id() << ":\n";
        std::cout << "  Cache hits: " << cache_hits << "\n";
        std::cout << "  Cache misses: " << cache_misses << "\n";
        if (cache_hits + cache_misses > 0) {
            double hit_ratio = (double)cache_hits / (cache_hits + cache_misses) * 100;
            std::cout << "  Hit ratio: " << hit_ratio << "%\n";
        }
    }
    
    static void printGlobalStats() {
        std::cout << "ThreadLocalCache Global Stats:\n";
        std::cout << "  Central requests: " << central_requests << "\n";
    }
};

// Thread-local 변수들 초기화
thread_local std::vector<ThreadLocalCache::CacheEntry> ThreadLocalCache::local_cache;
thread_local int ThreadLocalCache::cache_hits = 0;
thread_local int ThreadLocalCache::cache_misses = 0;
std::mutex ThreadLocalCache::central_lock;
std::vector<ThreadLocalCache::CacheEntry> ThreadLocalCache::central_cache;
std::atomic<int> ThreadLocalCache::central_requests{0};
```

---

## TCMalloc의 Size최적화

```cpp
class SizeClassAllocator {
private:
    // 미리 정의된 크기들 (TCMalloc과 유사)
    static const std::vector<size_t> SIZE_CLASSES;
    
    struct SizeClassBucket {
        size_t class_size;
        std::vector<void*> free_list;
        int max_capacity;
        
        SizeClassBucket(size_t size, int capacity) 
            : class_size(size), max_capacity(capacity) {
            free_list.reserve(capacity);
        }
    };
    
    thread_local static std::vector<SizeClassBucket> buckets;
    thread_local static bool initialized;
    thread_local static int internal_fragmentation_bytes;
    thread_local static int perfect_fit_count;
    thread_local static int size_class_count;
    
public:
    static void initializeBuckets() {
        if (!initialized) {
            for (size_t size : SIZE_CLASSES) {
                buckets.emplace_back(size, 32);
            }
            initialized = true;
            internal_fragmentation_bytes = 0;
            perfect_fit_count = 0;
            size_class_count = 0;
        }
    }
    
    static size_t getSizeClass(size_t requested_size) {
        // 요청된 크기에 맞는 Size Class 찾기
        for (size_t class_size : SIZE_CLASSES) {
            if (requested_size <= class_size) {
                return class_size;
            }
        }
        return requested_size; // Large object
    }
    
    static void* allocate(size_t size) {
        initializeBuckets();
        
        size_t class_size = getSizeClass(size);
        
        // 적절한 버킷 찾기
        for (auto& bucket : buckets) {
            if (bucket.class_size == class_size) {
                if (!bucket.free_list.empty()) {
                    void* ptr = bucket.free_list.back();
                    bucket.free_list.pop_back();
                    
                    // 단편화 통계
                    int waste = class_size - size;
                    internal_fragmentation_bytes += waste;
                    
                    if (waste == 0) perfect_fit_count++;
                    size_class_count++;
                    
                    return ptr;
                }
                
                // 버킷이 비어있음 - 새로 할당
                void* ptr = malloc(class_size);
                
                int waste = class_size - size;
                internal_fragmentation_bytes += waste;
                if (waste == 0) perfect_fit_count++;
                size_class_count++;
                
                return ptr;
            }
        }
        
        // Large object
        return malloc(size);
    }
    
    static void deallocate(void* ptr, size_t original_size) {
        if (!ptr) return;
        
        initializeBuckets();
        
        size_t class_size = getSizeClass(original_size);
        
        // 적절한 버킷에 반환
        for (auto& bucket : buckets) {
            if (bucket.class_size == class_size) {
                if (bucket.free_list.size() < bucket.max_capacity) {
                    bucket.free_list.push_back(ptr);
                    return;
                }
                break;
            }
        }
        
        // 버킷이 가득 참 - 직접 해제
        free(ptr);
    }
    
    static void printFragmentationStats() {
        std::cout << "Size Class Fragmentation Stats (Thread " 
                  << std::this_thread::get_id() << "):\n";
        std::cout << "  Total internal fragmentation: " 
                  << internal_fragmentation_bytes << " bytes\n";
        std::cout << "  Perfect fits: " << perfect_fit_count 
                  << "/" << size_class_count << "\n";
        if (size_class_count > 0) {
            double perfect_ratio = (double)perfect_fit_count / size_class_count * 100;
            std::cout << "  Perfect fit ratio: " << perfect_ratio << "%\n";
            double avg_waste = (double)internal_fragmentation_bytes / size_class_count;
            std::cout << "  Average waste per allocation: " << avg_waste << " bytes\n";
        }
    }
};

const std::vector<size_t> SizeClassAllocator::SIZE_CLASSES = {
    8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 96, 112, 128, 
    144, 160, 192, 224, 256, 320, 384, 448, 512, 640, 768, 
    896, 1024, 1280, 1536, 1792, 2048, 2560, 3072, 3584, 4096
};

thread_local std::vector<SizeClassAllocator::SizeClassBucket> SizeClassAllocator::buckets;
thread_local bool SizeClassAllocator::initialized = false;
thread_local int SizeClassAllocator::internal_fragmentation_bytes = 0;
thread_local int SizeClassAllocator::perfect_fit_count = 0;
thread_local int SizeClassAllocator::size_class_count = 0;
```

