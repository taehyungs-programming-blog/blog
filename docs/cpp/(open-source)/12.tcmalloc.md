---
layout: default
title: "12. tcmalloc"
parent: "(OpenSource ğŸ‘¨â€ğŸ’»)"
grand_parent: (C++)
nav_order: 2
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## mimallocì´ë€?

* mimallocì€ Googleì—ì„œ ê°œë°œí•œ ê³ ì„±ëŠ¥ ë©”ëª¨ë¦¬ í• ë‹¹ì
    * [Github](https://github.com/google/tcmalloc)

---

## ê¸°ì¡´ Mallocì˜ ë¬¸ì œì 

```cpp
class TraditionalMalloc {
private:
    static std::mutex global_lock;  // ëª¨ë“  í• ë‹¹ì— ëŒ€í•œ ì „ì—­ ë½
    static std::atomic<int> allocation_count;
    static std::atomic<int> lock_contentions;
    
public:
    static void* allocate(size_t size) {
        // ê¸°ì¡´ malloc: ëª¨ë“  í• ë‹¹ì— ëŒ€í•´ ì „ì—­ ë½ í•„ìš”
        std::lock_guard<std::mutex> lock(global_lock);
        
        // ë½ ê²½í•© ì¹´ìš´í„° ì¦ê°€
        lock_contentions++;
        
        // ì‹¤ì œ í• ë‹¹ ì‹œë®¬ë ˆì´ì…˜ (ëŠë¦° ì‹œìŠ¤í…œ ì½œ)
        std::this_thread::sleep_for(std::chrono::microseconds(1));
        
        allocation_count++;
        return malloc(size);
    }
    
    static void deallocate(void* ptr) {
        std::lock_guard<std::mutex> lock(global_lock);
        lock_contentions++;
        free(ptr);
    }
    
    static void printStats() {
        std::cout << "Traditional Malloc Stats:\n";
        std::cout << "  Total allocations: " << allocation_count << "\n";
        std::cout << "  Lock contentions: " << lock_contentions << "\n";
    }
};

std::mutex TraditionalMalloc::global_lock;
std::atomic<int> TraditionalMalloc::allocation_count{0};
std::atomic<int> TraditionalMalloc::lock_contentions{0};
```

## TCMallocì˜ Thread-Locale ìµœì í™”

```cpp
class ThreadLocalCache {
private:
    struct CacheEntry {
        void* ptr;
        size_t size;
    };
    
    // ê° ìŠ¤ë ˆë“œë³„ ìºì‹œ (ë½ ì—†ìŒ!)
    thread_local static std::vector<CacheEntry> local_cache;
    thread_local static int cache_hits;
    thread_local static int cache_misses;
    
    // Central Cache (ê³µìœ , ë½ í•„ìš”)
    static std::mutex central_lock;
    static std::vector<CacheEntry> central_cache;
    static std::atomic<int> central_requests;
    
public:
    static void* allocate(size_t size) {
        // 1ë‹¨ê³„: Thread Local Cacheì—ì„œ ì°¾ê¸° (ë½ ì—†ìŒ - í•µì‹¬ ìµœì í™”!)
        for (auto it = local_cache.begin(); it != local_cache.end(); ++it) {
            if (it->size >= size) {
                void* ptr = it->ptr;
                local_cache.erase(it);
                cache_hits++;
                return ptr;
            }
        }
        
        // 2ë‹¨ê³„: Cache Miss - Centralì—ì„œ ë³´ì¶©
        cache_misses++;
        refillFromCentral(size);
        
        // 3ë‹¨ê³„: Centralì—ì„œ ê°€ì ¸ì˜¨ í›„ ì¬ì‹œë„
        for (auto it = local_cache.begin(); it != local_cache.end(); ++it) {
            if (it->size >= size) {
                void* ptr = it->ptr;
                local_cache.erase(it);
                return ptr;
            }
        }
        
        // 4ë‹¨ê³„: ìƒˆë¡œ í• ë‹¹
        return malloc(size);
    }
    
    static void deallocate(void* ptr, size_t size) {
        // Thread Local Cacheì— ì €ì¥ (ë½ ì—†ìŒ!)
        if (local_cache.size() < 32) {  // ìºì‹œ í¬ê¸° ì œí•œ
            local_cache.push_back({ptr, size});
            return;
        }
        
        // ìºì‹œê°€ ê°€ë“ ì°¸ - Centralë¡œ ì¼ë¶€ ì´ë™
        moveToCentral();
        local_cache.push_back({ptr, size});
    }
    
private:
    static void refillFromCentral(size_t size) {
        std::lock_guard<std::mutex> lock(central_lock);
        central_requests++;
        
        // Centralì—ì„œ ì—¬ëŸ¬ ê°œë¥¼ í•œ ë²ˆì— ê°€ì ¸ì˜´ (ë°°ì¹˜ ì²˜ë¦¬)
        int moved = 0;
        for (auto it = central_cache.begin(); it != central_cache.end() && moved < 8;) {
            if (it->size >= size) {
                local_cache.push_back(*it);
                it = central_cache.erase(it);
                moved++;
            } else {
                ++it;
            }
        }
    }
    
    static void moveToCentral() {
        std::lock_guard<std::mutex> lock(central_lock);
        
        // Local Cacheì˜ ì ˆë°˜ì„ Centralë¡œ ì´ë™
        int to_move = local_cache.size() / 2;
        for (int i = 0; i < to_move; ++i) {
            central_cache.push_back(local_cache.back());
            local_cache.pop_back();
        }
    }
    
public:
    static void printThreadStats() {
        std::cout << "Thread " << std::this_thread::get_id() << ":\n";
        std::cout << "  Cache hits: " << cache_hits << "\n";
        std::cout << "  Cache misses: " << cache_misses << "\n";
        if (cache_hits + cache_misses > 0) {
            double hit_ratio = (double)cache_hits / (cache_hits + cache_misses) * 100;
            std::cout << "  Hit ratio: " << hit_ratio << "%\n";
        }
    }
    
    static void printGlobalStats() {
        std::cout << "ThreadLocalCache Global Stats:\n";
        std::cout << "  Central requests: " << central_requests << "\n";
    }
};

// Thread-local ë³€ìˆ˜ë“¤ ì´ˆê¸°í™”
thread_local std::vector<ThreadLocalCache::CacheEntry> ThreadLocalCache::local_cache;
thread_local int ThreadLocalCache::cache_hits = 0;
thread_local int ThreadLocalCache::cache_misses = 0;
std::mutex ThreadLocalCache::central_lock;
std::vector<ThreadLocalCache::CacheEntry> ThreadLocalCache::central_cache;
std::atomic<int> ThreadLocalCache::central_requests{0};
```

---

## TCMallocì˜ Sizeìµœì í™”

```cpp
class SizeClassAllocator {
private:
    // ë¯¸ë¦¬ ì •ì˜ëœ í¬ê¸°ë“¤ (TCMallocê³¼ ìœ ì‚¬)
    static const std::vector<size_t> SIZE_CLASSES;
    
    struct SizeClassBucket {
        size_t class_size;
        std::vector<void*> free_list;
        int max_capacity;
        
        SizeClassBucket(size_t size, int capacity) 
            : class_size(size), max_capacity(capacity) {
            free_list.reserve(capacity);
        }
    };
    
    thread_local static std::vector<SizeClassBucket> buckets;
    thread_local static bool initialized;
    thread_local static int internal_fragmentation_bytes;
    thread_local static int perfect_fit_count;
    thread_local static int size_class_count;
    
public:
    static void initializeBuckets() {
        if (!initialized) {
            for (size_t size : SIZE_CLASSES) {
                buckets.emplace_back(size, 32);
            }
            initialized = true;
            internal_fragmentation_bytes = 0;
            perfect_fit_count = 0;
            size_class_count = 0;
        }
    }
    
    static size_t getSizeClass(size_t requested_size) {
        // ìš”ì²­ëœ í¬ê¸°ì— ë§ëŠ” Size Class ì°¾ê¸°
        for (size_t class_size : SIZE_CLASSES) {
            if (requested_size <= class_size) {
                return class_size;
            }
        }
        return requested_size; // Large object
    }
    
    static void* allocate(size_t size) {
        initializeBuckets();
        
        size_t class_size = getSizeClass(size);
        
        // ì ì ˆí•œ ë²„í‚· ì°¾ê¸°
        for (auto& bucket : buckets) {
            if (bucket.class_size == class_size) {
                if (!bucket.free_list.empty()) {
                    void* ptr = bucket.free_list.back();
                    bucket.free_list.pop_back();
                    
                    // ë‹¨í¸í™” í†µê³„
                    int waste = class_size - size;
                    internal_fragmentation_bytes += waste;
                    
                    if (waste == 0) perfect_fit_count++;
                    size_class_count++;
                    
                    return ptr;
                }
                
                // ë²„í‚·ì´ ë¹„ì–´ìˆìŒ - ìƒˆë¡œ í• ë‹¹
                void* ptr = malloc(class_size);
                
                int waste = class_size - size;
                internal_fragmentation_bytes += waste;
                if (waste == 0) perfect_fit_count++;
                size_class_count++;
                
                return ptr;
            }
        }
        
        // Large object
        return malloc(size);
    }
    
    static void deallocate(void* ptr, size_t original_size) {
        if (!ptr) return;
        
        initializeBuckets();
        
        size_t class_size = getSizeClass(original_size);
        
        // ì ì ˆí•œ ë²„í‚·ì— ë°˜í™˜
        for (auto& bucket : buckets) {
            if (bucket.class_size == class_size) {
                if (bucket.free_list.size() < bucket.max_capacity) {
                    bucket.free_list.push_back(ptr);
                    return;
                }
                break;
            }
        }
        
        // ë²„í‚·ì´ ê°€ë“ ì°¸ - ì§ì ‘ í•´ì œ
        free(ptr);
    }
    
    static void printFragmentationStats() {
        std::cout << "Size Class Fragmentation Stats (Thread " 
                  << std::this_thread::get_id() << "):\n";
        std::cout << "  Total internal fragmentation: " 
                  << internal_fragmentation_bytes << " bytes\n";
        std::cout << "  Perfect fits: " << perfect_fit_count 
                  << "/" << size_class_count << "\n";
        if (size_class_count > 0) {
            double perfect_ratio = (double)perfect_fit_count / size_class_count * 100;
            std::cout << "  Perfect fit ratio: " << perfect_ratio << "%\n";
            double avg_waste = (double)internal_fragmentation_bytes / size_class_count;
            std::cout << "  Average waste per allocation: " << avg_waste << " bytes\n";
        }
    }
};

const std::vector<size_t> SizeClassAllocator::SIZE_CLASSES = {
    8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 96, 112, 128, 
    144, 160, 192, 224, 256, 320, 384, 448, 512, 640, 768, 
    896, 1024, 1280, 1536, 1792, 2048, 2560, 3072, 3584, 4096
};

thread_local std::vector<SizeClassAllocator::SizeClassBucket> SizeClassAllocator::buckets;
thread_local bool SizeClassAllocator::initialized = false;
thread_local int SizeClassAllocator::internal_fragmentation_bytes = 0;
thread_local int SizeClassAllocator::perfect_fit_count = 0;
thread_local int SizeClassAllocator::size_class_count = 0;
```

