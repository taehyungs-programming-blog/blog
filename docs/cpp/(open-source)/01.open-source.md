---
layout: default
title: "1. (Telegram) Reactive Programming Library(rpl::producer)"
parent: "(OpenSource ğŸ‘¨â€ğŸ’»)"
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/telegramdesktop/tdesktop)

---

* ìƒë‹¹íˆ ë³µì¡í•˜ë‹¤ ëª¨ë‘ ì´í•´í•  ìˆ˜ëŠ” ì—†ê³  ì¼ë¶€ ë¶€ë¶„ë§Œ ì„¤ëª…í•˜ê² ìŒ.
* í•¨ìˆ˜ì˜ ë¦¬í„´í˜• í˜¹ì€ ë³€ìˆ˜ë¥¼ `rpl::producer` ì‚¬ìš©í•˜ëŠ” ë¶€ë¶„ì´ ìˆë‹¤.

```cpp
// ì´ë ‡ê²Œ ì„ ì–¸ë˜ì–´ ìˆì„ ê²ƒì´ë‹¤.
rpl::producer<QRect> paintRequest() const;
```

* paintRequest()ë¥¼ ë°›ì•„ ë³€í™”ê°€ ì‹œí‚¤ë©´ callbackì„ í˜¸ì¶œí•´ ì¤€ë‹¤.

```cpp
const auto raw = result.data();
raw->paintRequest(  // | ë‹¤ìŒë¶€í„° callback
) | rpl::start_with_next([=](QRect clip) {
    auto p = QPainter(raw);
    p.fillRect(clip, st::searchedBarBg);
}, raw->lifetime());
```

```cpp
// paintRequest()ëŠ” paint eventì˜ producerì´ë‹¤.
rpl::producer<QRect> RpWidgetWrap::paintRequest() const {
	return eventStreams().paint.events();
}
```

```cpp
// start_with_nextëŠ” life timeê³¼ call backì„ ë¬¶ì–´ lifetime_with_nextë¡œ ë§Œë“ ë‹¤
template <typename OnNext>
inline auto start_with_next(OnNext &&next, lifetime &alive_while)
-> details::lifetime_with_next<std::decay_t<OnNext>> {
	return { alive_while, std::forward<OnNext>(next) };
}
```

```cpp
// operator|ëŠ” producerì˜ startë¥¼ í˜¸ì¶œí•´ì¤€ë‹¤
template <
	typename Value,
	typename Error,
	typename Generator,
	typename OnNext,
	typename = std::enable_if_t<is_callable_v<OnNext, Value>>>
inline void operator|(
		producer<Value, Error, Generator> &&value,
		lifetime_with_next<OnNext> &&handlers) {
	std::move(value).start(
		std::move(handlers.next),
		[] {},
		[] {},
		handlers.alive_while);
}
```

```cpp
// startëŠ” start_existingí˜¸ì¶œ
template <typename Value, typename Error, typename Generator>
template <
	typename OnNext,
	typename OnError,
	typename OnDone,
	typename>
inline void producer_base<Value, Error, Generator>::start(
		OnNext &&next,
		OnError &&error,
		OnDone &&done,
		lifetime &alive_while) && {
	return std::move(*this).start_existing(
		make_consumer<Value, Error>(
			std::forward<OnNext>(next),
			std::forward<OnError>(error),
			std::forward<OnDone>(done)),
		alive_while);
}
```

```cpp
template <typename Value, typename Error, typename Generator>
template <typename Handlers>
inline void producer_base<Value, Error, Generator>::start_existing(
		const consumer_type<Handlers> &consumer,
		lifetime &alive_while) && {
	alive_while.add(consumer.terminator());
	consumer.add_lifetime(std::move(_generator)(consumer));
}
```

```cpp
// handlerëŠ” consumer ìƒì„±íƒ€ì´ë°ì— ê²°ì •
template <
    typename Handlers,
    typename = std::enable_if_t<
        details::is_specific_handlers_v<Value, Error, Handlers>>>
consumer &operator=(
        const details::consumer_base<Value, Error, Handlers> &other) {
    this->_handlers = other._handlers;
    return *this;
}
```

---

* ë³€í™” ê°ì§€ëŠ” ì´ëŸ°ì‹ìœ¼ë¡œ

```cpp
case QEvent::Paint:
    if (streams->paint.has_consumers()) {
        if (!allAreObserved) {
            that = rpWidget();
        }
        const auto rect = static_cast<QPaintEvent*>(event)->rect();
        streams->paint.fire_copy(rect);
        if (!that) {
            return true;
        }
    }
    break;
}
```

```cpp
void fire_copy(const Value &value) const {
    return fire_forward(value);
}
```

```cpp
template <typename Value, typename Error>
template <typename OtherValue>
inline void event_stream<Value, Error>::fire_forward(
		OtherValue &&value) const {
	if (!_data) {
		return;
	}
	const auto copy = _data;
	auto &consumers = copy->consumers;
	if (consumers.empty()) {
		return;
	}

	++copy->depth;
	const auto begin = base::index_based_begin(consumers);
	const auto end = base::index_based_end(consumers);

	// Copy value for every consumer except the last.
	const auto prev = end - 1;
	auto staleFrom = std::remove_if(begin, prev, [&](const auto &consumer) {
		return !consumer.put_next_copy(value);
	});

    // ...
```

```cpp
template <
	typename Value,
	typename Error,
	typename OnNext,
	typename OnError,
	typename OnDone>
bool consumer_handlers<
	Value,
	Error,
	OnNext,
	OnError,
	OnDone
>::put_next_copy(const Value &value) {
	if (this->_terminated) {
		return false;
	}
	auto handler = this->_next;
	details::const_ref_call_invoke(std::move(handler), value);
	return true;
}
```

```cpp
template <typename Method, typename Arg>
inline decltype(auto) const_ref_call_invoke(
		Method &&method,
		const Arg &arg) {
	if constexpr (allows_const_ref_v<Method, Arg>) {
		return callable_invoke(std::forward<Method>(method), arg);
	} else {
		auto copy = arg;
		return callable_invoke(
			std::forward<Method>(method),
			std::move(copy));
	}
}
```

```cpp
template <typename Method, typename Arg>
inline decltype(auto) callable_invoke(Method &&method, Arg &&arg) {
	if constexpr (is_callable_plain_v<Method, Arg>) {
		return std::forward<Method>(method)(std::forward<Arg>(arg));
	} else if constexpr (is_callable_tuple_v<Method, Arg>) {
		return std::apply(
			std::forward<Method>(method),
			std::forward<Arg>(arg));
	} else if constexpr (is_callable_v<Method>) {
		return std::forward<Method>(method)();
	} else {
		static_assert(false_(method, arg), "Bad callable_invoke() call.");
	}
}
```

---

* lifetimeì€ ì–´ë””ì“°ì´ë‚˜?

```cpp
template <typename Value, typename Error>
inline void type_erased_handlers<Value, Error>::terminate() {
	if (!_terminated) {
		_terminated = true;
        // terminateì‹œì ì— í˜¸ì¶œë˜ë©°
		_lifetime.destroy();
	}
}
```

```cpp
// destroyì‹œ ë“±ë¡ëœ callbackì„ ëª¨ë‘ í˜¸ì¶œ
inline void lifetime::destroy() {
	auto callbacks = details::take(_callbacks);
	for (auto i = callbacks.rbegin(), e = callbacks.rend(); i != e; ++i) {
		(*i)();
	}
}
```

```cpp
// ì´ëŸ°ì‹ìœ¼ë¡œ ë“±ë¡í•´ ë‘”ë‹¤
lifetime().add([=] {
    if (!*saveEditMsgRequestId) {
        return;
    }
    session().api().request(base::take(*saveEditMsgRequestId)).cancel();
});
```