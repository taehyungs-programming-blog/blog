---
layout: default
title: "9. (yalantinglibs) syncAwait()"
parent: "(OpenSource ğŸ‘¨â€ğŸ’»)"
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Link ğŸŒ](https://github.com/alibaba/yalantinglibs)

* í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ í™•ì¸í•´ ë³´ë©´

```cpp
int main() {
  test_coro_http_server();
  test_sync_client();
  use_out_buf();

  // ì´ëŸ°ì‹ìœ¼ë¡œ Awaitì„ ëŒ€ê¸°í•œë‹¤.
    // ê¶ê¸ˆí•œ ì ì€ êµ³ì´ syncAwaitë¥¼ ì™œ ì“°ëƒì´ë‹¤
  coro_http::coro_http_client client{};
  async_simple::coro::syncAwait(test_async_client(client));

  // ...
```

```cpp
template <typename LazyType>
inline auto syncAwait(LazyType &&lazy) {
  // Q1. LazyTypeì´ templateì¸ë° getExecutor()ì˜ ìœ ë¬´ë¥¼ ì–´ë–»ê²Œ ë³´ì¥í•˜ë‚˜?
    // A. ë§Œì•½ lazyì— getExecutor()ê°€ ì—†ë‹¤ë©´ ì»´íŒŒì¼ë‹¨ê³„ì—ì„œ ê±¸ë¦¼.
  auto executor = lazy.getExecutor();
  if (executor)
    logicAssert(!executor->currentThreadInExecutor(),
                "do not sync await in the same executor with Lazy");

  util::Condition cond;
  using ValueType = typename std::decay_t<LazyType>::ValueType;

  Try<ValueType> value;
  // Q2. std::move(std::forward) ë­ì•¼ ì´ê±°?
    // A. std::forward - í¼í™íŠ¸ í¬ì›Œë”© -> rì´ë©´ rë¡œ lì´ë©´ lë¡œ ì „ë‹¬
    // std::move - r-value ìºìŠ¤íŒ…
    // ì´ê±¸ ì™œ í•˜ëƒ? startë‚´ë¶€ì—ì„œ r-valueë¡œ ëŒë‹¤ìº¡ì³í•´ ì‚¬ìš©í•˜ëŠ”ë° í•„ìš”í•¨
    // ì—¬ê¸°ì„œ ë¶€í„° r-valueë¡œ ê°•ì œë¡œ ë³´ë‚´ê¸° ìœ„í•¨ì´ë‹¤.
  std::move(std::forward<LazyType>(lazy))
      .start([&cond, &value](Try<ValueType> result) {
        value = std::move(result);
        cond.release();
      });
  // Q3. acquire() ì—¬ê¸°ì„œ ì™œ í˜¸ì¶œ?
    // A. ë¹„ë™ê¸° ì‘ì—…ì´ ëë‚¬ìŒì„ ì•Œìˆ˜ìˆê²Œ ëœë‹¤.
  cond.acquire();
  return std::move(value).value();
}
```

---

```cpp
// start í•¨ìˆ˜ ë‚´ë¶€
template <typename F>
void start(F&& callback) requires(std::is_invocable_v<F&&, Try<T>>) {

auto launchCoro = [](LazyBase lazy,
                        std::decay_t<F> cb) -> detail::DetachedCoroutine {
    cb(co_await lazy.coAwaitTry());
};
[[maybe_unused]] auto detached =
    launchCoro(std::move(*this), std::forward<F>(callback));
}
```

```cpp
auto coAwaitTry() { return TryAwaiter(std::exchange(_coro, nullptr)); }
```