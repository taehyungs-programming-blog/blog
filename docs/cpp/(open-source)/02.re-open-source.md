---
layout: default
title: "2. (Telegram) Reactive Programming Library(rpl::producer)"
parent: "(OpenSource ğŸ‘¨â€ğŸ’»)"
grand_parent: (C++)
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## ë“¤ì–´ê°€ê¸° ì „

* telegram uiì˜ í•µì‹¬ ì‹œìŠ¤í…œì´ ë‘ ê°€ì§€ì¸ë°
	* **rpl(Reactive Programming Library)**
	* **codegen_style**
* ë‘ ê°€ì§€ë§Œ ì•Œë©´ ë‚˜ë¨¸ì§„ ê·¸ëƒ¥ ì»¨í…ì¸ ë¥¼ ì°ì–´ë‚´ëŠ” ì •ë„ë¼ ì´í•´í•´ë„ ëœë‹¤.
* ì—¬ê¸°ì„œëŠ” rplì„ ì„¤ëª…ì˜ˆì •

---

## rpl ëŒ€ëµ ë™ì‘ì€ ì–´ë–»ê²Œ í•˜ë‚˜?

* eventStreamì— Consumerë¥¼ ë“±ë¡í•´ ë‘ê³ 
* RPLì— ì˜í•´ Fireë¥¼ í˜¸ì¶œí•˜ë©´ ë“±ë¡ëœ Consumerë“¤ì—ê²Œ Valueë¥¼ ì „ë‹¬í•´ì¤€ë‹¤.

---

## ì„ ì–¸

* `producer.h`

```cpp
template <typename Value, typename Error>
class producer<
	Value,
	Error,
	details::type_erased_generator<Value, Error>> final
: public details::producer_base_type_erased<Value, Error> {
	using parent_type = details::producer_base_type_erased<
		Value,
		Error>;
```

---

## ì‚¬ìš©

* ë³´í†µ ì•„ë˜ì™€ ê°™ì´ ë¦¬í„´ì„ í•´ì¤€ë‹¤

```cpp
rpl::producer<QRect> paintRequest() const;
```

```cpp
// ì†Œìœ í•œ eventStreamsì˜ eventë¥¼ ë¦¬í„´
rpl::producer<QRect> RpWidgetWrap::paintRequest() const {
	return eventStreams().paint.events();
}
```

---

## eventStreams ?

* [Link ğŸŒ](https://taehyungs-programming-blog.github.io/blog/docs/cpp/(open-source)/03.re-open-source/)
    * ë³„ë„ë¡œ ì •ë¦¬í•¨.
* ì¼ë‹¨, ì´ ì •ë„ë§Œ ì•Œì•„ë„ ì¶©ë¶„
	* Fireê°€ í˜¸ì¶œë˜ë©´ eventStreamì— ë“±ë¡ëœ ëª¨ë“  objectì—ê²Œ eventê°€ ë‚ ì•„ê°„ë‹¤
* ê·¸ëŸ¼ í•µì‹¬ì€
	* eventë¥¼ ì–´ë–»ê²Œ Fireì‹œí‚¤ëƒ -> ì´ê±´ ê·¸ëƒ¥ `Fire()` í•¨ìˆ˜ í˜¸ì¶œ
	* eventë¥¼ ì–´ë–»ê²Œ ë°›ëƒ -> ìš”ê²Œ ì¤‘ìš”!

---

## ì‹¤ì œì‚¬ìš© ë° ì½œ ìŠ¤í…

* ìš°ì„  Event ìŠ¤íŠ¸ë¦¼ì´ Call

```cpp
bool RpWidgetWrap::handleEvent(QEvent *event) {
	Expects(event != nullptr);

	auto streams = _eventStreams.get();
	if (!streams) {
		return eventHook(event);
	}

	// ...

	case QEvent::Paint:
		if (streams->paint.has_consumers()) {
			if (!allAreObserved) {
				that = rpWidget();
			}
			const auto rect = static_cast<QPaintEvent*>(event)->rect();
            
            // ì—¬ê¸°ì„œ Fireë˜ë©° í˜¸ì¶œëœë‹¤.
			streams->paint.fire_copy(rect);
			if (!that) {
				return true;
			}
		}
		break;
	}

	return eventHook(event);
}
```

```cpp
_dimmingContent->paintRequest(
) | rpl::start_with_next([=](QRect clip) {
    auto p = QPainter(_dimmingContent);
    const auto palette = (dark ? _darkPalette : _lightPalette).get();
    p.fillRect(clip, equals ? st::boxBg : palette->boxBg());
}, _dimmingContent->lifetime());
```

* `paintRequest()` í˜¸ì¶œì‹œ `rpl::producer<QRect>` producerê°€ ë¦¬í„´ëœë‹¤.
* producerì˜ `opeartor|`ê°€ í˜¸ì¶œ

```cpp
template <typename Value, typename Error, typename Generator>
inline void operator|(
		producer<Value, Error, Generator> &&value,
		lifetime_with_none &&handlers) {
	std::move(value).start(
		[] {},
		[] {},
		[] {},
		handlers.alive_while);
}
```

* producerì˜ `start()` í˜¸ì¶œ
* ì°¸ê³  lifetimeë§Œë“œëŠ” ê³¼ì •

```cpp
// start_with_next
template <typename OnNext>
inline auto start_with_next(OnNext &&next, lifetime &alive_while)
-> details::lifetime_with_next<std::decay_t<OnNext>> {
	return { alive_while, std::forward<OnNext>(next) };
}
```

```cpp
// lifetime_with_next
template <typename OnNext>
struct lifetime_with_next {
	lifetime &alive_while;
	OnNext next;
};
```

* ë‹¤ì‹œ, producerì˜ `start()` í˜¸ì¶œ

```cpp
template <typename Value, typename Error, typename Generator>
template <
	typename OnNext,
	typename OnError,
	typename OnDone,
	typename>
inline void producer_base<Value, Error, Generator>::start(
		OnNext &&next,
		OnError &&error,
		OnDone &&done,
		lifetime &alive_while) && {
	return std::move(*this).start_existing(
		make_consumer<Value, Error>(
			std::forward<OnNext>(next),
			std::forward<OnError>(error),
			std::forward<OnDone>(done)),
		alive_while);
}
```

```cpp
template <typename Value, typename Error, typename Generator>
template <typename Handlers>
inline void producer_base<Value, Error, Generator>::start_existing(
		const consumer_type<Handlers> &consumer,
		lifetime &alive_while) && {
	alive_while.add(consumer.terminator());
	consumer.add_lifetime(std::move(_generator)(consumer));
}
```

---

## í•˜ë‚˜í•˜ë‚˜ ì •ë¦¬

* ì§„ì§œ ë³µì¡;;; 

```cpp
// ì•„ë˜ë¥¼ í†µí•´ rplë“±ë¡ì‹œ
_dimmingContent->paintRequest(
	) | // ...
```

```cpp
rpl::producer<QRect> RpWidgetWrap::paintRequest() const {
	// eventsì— ì ‘ê·¼í•œ
	return eventStreams().paint.events();
}
```

```cpp
#if defined _MSC_VER && _MSC_VER >= 1914 && _MSC_VER < 1916
	producer<Value, Error> events() const {
#else // _MSC_VER >= 1914 && _MSC_VER < 1916
	auto events() const {
#endif // _MSC_VER >= 1914 && _MSC_VER < 1916

// eventsëŠ” producerë¥¼ ìƒì„±í•´ì¤€ë‹¤
	return make_producer<Value, Error>([weak = make_weak()](
			const auto &consumer) {
		if (const auto strong = weak.lock()) {
			auto result = [weak, consumer] {
				if (const auto strong = weak.lock()) {
					const auto it = std::find(
						strong->consumers.begin(),
						strong->consumers.end(),
						consumer);
					if (it != strong->consumers.end()) {
						it->terminate();
					}
				}
			};
			strong->consumers.push_back(std::move(consumer));
			return lifetime(std::move(result));
		}
		return lifetime();
	});
}
```

```cpp
inline auto make_producer(Generator &&generator)
#ifdef RPL_PRODUCER_TYPE_ERASED_ALWAYS
-> producer<Value, Error> {
#else // RPL_PRODUCER_TYPE_ERASED_ALWAYS
-> producer<Value, Error, std::decay_t<Generator>> {
#endif // !RPL_PRODUCER_TYPE_ERASED_ALWAYS

	// ì—¬ê¸°ê°€ í—·ê°ˆë¦¬ëŠ”ë° Generatorë¥¼ Forwardí•´ì¤„ ë¿ì¸ë° ì–´ë–»ê²Œ producerê°€ ìƒì„±ë˜ëƒ?
	return std::forward<Generator>(generator);
}
```

* ë¦¬í„´ì´ ê²°êµ­ `-> producer<Value, Error>`ì´ê¸°ì— producerì—ì„œ generatorë¥¼ ë°›ì„ìˆ˜ ìˆëŠ”ì§€ ì²´í¬í•˜ë©´ ëœë‹¤.

```cpp
template <typename Value, typename Error, typename Generator>
class producer final
// producerì—ì„œ ì§ì ‘ ë°›ì§€ëŠ” ì•Šê³  producer_baseë¥¼ í†µí•´ ë°›ê²Œ ëœë‹¤.
: public details::producer_base<Value, Error, Generator> {
	// ...
```

```cpp
template <typename Value, typename Error, typename Generator>
class producer_base {
public:
	template <typename Handlers>
	using consumer_type = consumer<Value, Error, Handlers>;
	using value_type = Value;
	using error_type = Error;

	template <
		typename OtherGenerator,
		typename = std::enable_if_t<
			std::is_constructible_v<Generator, OtherGenerator&&>>>

	// ì–˜ë¥¼ í†µí•´ ë°›ê²Œ ë¨.
	producer_base(OtherGenerator &&generator);
```

```cpp
template <typename Value, typename Error, typename Generator>
template <typename OtherGenerator, typename>
inline producer_base<Value, Error, Generator>::producer_base(
	OtherGenerator &&generator)
: _generator(std::forward<OtherGenerator>(generator)) {

	// ê²°êµ­ _generatorì— ë“±ë¡
}
```

* ê·¸ë˜ì„œ ì–´ë–»ê²Œ ì“°ì´ëƒ?

```cpp
template <typename Value, typename Error, typename Generator>
template <typename Handlers>
inline void producer_base<Value, Error, Generator>::start_existing(
		const consumer_type<Handlers> &consumer,
		lifetime &alive_while) && {
	alive_while.add(consumer.terminator());

	// ì—¬ê¸°ì„œ ì‚¬ìš©ëœ generatorê°€ make_producerì˜ ëŒë‹¤ì´
	consumer.add_lifetime(std::move(_generator)(consumer));
}
```

```cpp
auto events() const {
#endif // _MSC_VER >= 1914 && _MSC_VER < 1916
	return make_producer<Value, Error>([weak = make_weak()](
			const auto &consumer) {
		if (const auto strong = weak.lock()) {
			auto result = [weak, consumer] {
				if (const auto strong = weak.lock()) {
					const auto it = std::find(
						strong->consumers.begin(),
						strong->consumers.end(),
						consumer);
					if (it != strong->consumers.end()) {
						it->terminate();
					}
				}
			};
			strong->consumers.push_back(std::move(consumer));
			return lifetime(std::move(result));
		}
		return lifetime();
	});
}
```

* ê·¼ë³¸ì  ì§ˆë¬¸) ì™œ ì´ë ‡ê²Œ ì“¸ê¹Œ?
	* `make_producer` í•˜ë©´ì„œ generatorë¥¼ ì•ˆì— ì‹¬ëŠ”êµ¬ì¡°ì´ë‹¤
	* ê²°êµ­ ì™¸ë¶€ì—ì„œ generatorë¥¼ ì‹¬ëŠ”êµ¬ì¡°ë¥¼ ë§Œë“¤ê¸° ìœ„í•¨ì„ ... (ìœ„ë‘ ê°™ì€ë§ì¸ê°€?)