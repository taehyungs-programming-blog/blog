---
layout: default
title: "20. Lighting - êµ¬í˜„2"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: C++
nav_order: 3
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/15)

* (Q) LightëŠ” ì–´ëŠ ì¢Œí‘œê³„ì—ì„œ ë°˜ì˜í•´ì•¼í• ê¹Œ? World? View?
    * ì–´ëŠ ì¢Œí‘œê³„ë“  ìƒê´€ì—†ë‹¤.
    * ë‹¨, Normal Vetorë¥¼ Worldì¢Œí‘œê³„ë¡œ í–ˆë‹¤ë©´
    * Tangent Vectorì—­ì‹œ Worldì¢Œí‘œê³„ë¡œ í†µì¼í•´ì•¼í•œë‹¤ ì •ë„ë§Œ ì£¼ì˜í•˜ë©´ ëœë‹¤.
* ë³´í†µì€ Viewì¢Œí‘œê³„ì—ì„œ ë§ì´ Lightì„ ê³„ì‚°í•œë‹¤

---

ğŸ˜º Lightì˜ Pixel Shaderì— ê´€í•œ ë¶€ë¶„

```
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    // ViewPosition(ì¢Œí‘œ)ì™€ NormalVectorì„ Outputìœ¼ë¡œ ë„˜ê¸´ë‹¤
    output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);

    return output;
}

float4 PS_Main(VS_OUT input) : SV_Target
{
    // ìƒ‰ìƒì„ ì´ˆê¸°í™”
    // í°ìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™” í•œ ì´ìœ ëŠ” ë¹›ì„ ì˜ ë°›ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•¨.
    float4 color = float4(1.f, 1.f, 1.f, 1.f);

    LightColor totalColor = (LightColor)0.f;
    /*
        struct LightColor
        {
            float4      diffuse;
            float4      ambient;
            float4      specular;
        };
    */

    for (int i = 0; i < g_lightCount/* ì§€ì›í•˜ëŠ” Lightì˜ ê°œìˆ˜ */; ++i)
    {
        // CalculateLightColor(ë¹› ì •ë³´ ì—°ì‚°)ëŠ” ì•„ë˜ì— ìˆìŒ ì°¸ê³ 
         LightColor color = CalculateLightColor(i, input.viewNormal, input.viewPos);
         totalColor.diffuse += color.diffuse;
         totalColor.ambient += color.ambient;
         totalColor.specular += color.specular;
    }

    // diffuse, ambientëŠ” ìì‹ ì˜ ìƒ‰ìƒ (color.xyz)ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ”(ê³±í•´ì§€ëŠ”) ë°©ì‹ì´ê³ 
    // specularëŠ” ì „ë°˜ì ìœ¼ë¡œ ë”í•´ì§€ëŠ” í˜•ì‹
    color.xyz = (totalColor.diffuse.xyz * color.xyz)
        + totalColor.ambient.xyz * color.xyz
        + totalColor.specular.xyz;

     return color;
}
```

```
#ifndef _UTILS_HLSLI_
#define _UTILS_HLSLI_

LightColor CalculateLightColor(int lightIndex,      // ëª‡ ë²ˆì§¸ ë¹›ì¸ê°€?
                                float3 viewNormal,  // (View Position ê¸°ì¤€) Normal Vector
                                float3 viewPos)     // (View Position ê¸°ì¤€) Pixel ìœ„ì¹˜
{
    LightColor color = (LightColor)0.f;

    float3 viewLightDir = (float3)0.f;

    float diffuseRatio = 0.f;
    float specularRatio = 0.f;
    float distanceRatio = 1.f;


    // lightTypeì´ Directional Lightì¼ê²½ìš°
    if (g_light[lightIndex].lightType == 0)
    {
        // ë“¤ì–´ì˜¤ëŠ” ë¹› ìì²´ë„ View ì¢Œí‘œê³„ë¡œ ë³€í™˜í•œë‹¤.
        viewLightDir = normalize(mul(float4(g_light[lightIndex].direction.xyz, 0.f), g_matView).xyz);

        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));
        // diffuse êµ¬í• ë•Œ ë“¤ì–´ì˜¨ ë¹›(L), NormalVectorì˜ ë‚´ì ì„ì„ ê¸°ì–µí•˜ì
            // dot(-viewLightDir, viewNormal) : ë‚´ì  í›„
            // saturate : 0 ~ 1 ì‚¬ì´ ê°’ìœ¼ë¡œ ë³€ê²½(ìŒìˆ˜ì œê±°)
                // ìŒìˆ˜ê°€ ìˆë‚˜ ì‹¶ê² ì§€ë§Œ, ë¹›ì´ ê±°ê¾¸ë¡œ(ì•„ë˜ì„œ ìœ„ë¡œ, ê°€ë ¤ì§„ ë¶€ë¶„) ì˜¬ê²½ìš° ìŒìˆ˜ê°€ ëœë‹¤.

        /*
              (L)  (N)
                \   |
                 \  |
                  \ |
                   \|
        -----------------------------
     ** -Lê³¼ Në‚´ì ì‹œ cos(a)ê°€ ë‚˜ì˜¤ê²Œ ë¨ **
        */
    }

    // lightTypeì´ Point Lightì¼ê²½ìš°
    else if (g_light[lightIndex].lightType == 1)
    {
        float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
        viewLightDir = normalize(viewPos - viewLightPos);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));

        // ê±°ë¦¬ê°’ì— ëŒ€í•´ ë¹›ì˜ ì„¸ê¸° ë°˜ì˜
        float dist = distance(viewPos, viewLightPos);
        if (g_light[lightIndex].range == 0.f)
            distanceRatio = 0.f;
        else
            distanceRatio = saturate(1.f - pow(dist / g_light[lightIndex].range, 2));
    }

    // lightTypeì´ Spot Lightì¼ê²½ìš°
    else
    {
        // Spot Light
        float3 viewLightPos = mul(float4(g_light[lightIndex].position.xyz, 1.f), g_matView).xyz;
        viewLightDir = normalize(viewPos - viewLightPos);
        diffuseRatio = saturate(dot(-viewLightDir, viewNormal));

        if (g_light[lightIndex].range == 0.f)
            distanceRatio = 0.f;
        else
        {
            float halfAngle = g_light[lightIndex].angle / 2;

            float3 viewLightVec = viewPos - viewLightPos;
            float3 viewCenterLightDir = normalize(mul(float4(g_light[lightIndex].direction.xyz, 0.f), g_matView).xyz);

            float centerDist = dot(viewLightVec, viewCenterLightDir);
            distanceRatio = saturate(1.f - centerDist / g_light[lightIndex].range);

            float lightAngle = acos(dot(normalize(viewLightVec), viewCenterLightDir));

            if (centerDist < 0.f || centerDist > g_light[lightIndex].range) // ìµœëŒ€ ê±°ë¦¬ë¥¼ ë²—ì–´ë‚¬ëŠ”ì§€
                distanceRatio = 0.f;
            else if (lightAngle > halfAngle) // ìµœëŒ€ ì‹œì•¼ê°ì„ ë²—ì–´ë‚¬ëŠ”ì§€
                distanceRatio = 0.f;
            else // ê±°ë¦¬ì— ë”°ë¼ ì ì ˆíˆ ì„¸ê¸°ë¥¼ ì¡°ì ˆ
                distanceRatio = saturate(1.f - pow(centerDist / g_light[lightIndex].range, 2));
        }
    }

    // specular ê³„ì‚°
    float3 reflectionDir = normalize(viewLightDir + 2 * (saturate(dot(-viewLightDir, viewNormal)) * viewNormal));

    /*
          (L)  (N)    (R)-> Relection(ì •ë°˜ì‚¬)
            \   |    /
             \  |   /
              \ |  /
               \| /
    -----------------------------
    ** -Lê³¼ Nì˜ ì™¸ì ì˜ ê²°ê³¼ë¥¼ 2ë²ˆ ë”í•˜ë©´ Reflectionì´ ë‚˜ì˜¨ë‹¤ **
    */
    // ê³„ì‚°ëœ Reflectionì„ ì¹´ë©”ë¼ë¡œ ë°˜ì˜í•´ ì¤˜ì•¼í•˜ëŠ”ë°
    // Reflectionê³¼ ì¹´ë©”ë¼ì˜ ë°©í–¥ì„ ë‚´ì í•´ ì£¼ë©´ Specular ê³„ì‚°ì™„ë£Œ
    float3 eyeDir = normalize(viewPos);
    specularRatio = saturate(dot(-eyeDir, reflectionDir));
    specularRatio = pow(specularRatio, 2);  // ì¢€ ë” ê·¹ì ì¸ íš¨ê³¼ë¥¼ ìœ„í•´ì„œ powë¥¼ ë„£ìŒ.
    // powê°’ì„ ë³€ê²½í•´ ê°€ë©´ì„œ ë³€í™”ë¥¼ í™•ì¸í•´ ë³´ì.(powê°€ ì—†ìœ¼ë©´ specularê°€ ë„ˆë¬´ í¬ê²Œ ì ìš©ë¼ ì˜¤íˆë ¤ ì–´ìƒ‰í•´ì§„ë‹¤)

    color.diffuse = g_light[lightIndex].color.diffuse * diffuseRatio * distanceRatio;
    color.ambient = g_light[lightIndex].color.ambient * distanceRatio;
    color.specular = g_light[lightIndex].color.specular * specularRatio * distanceRatio;

    return color;
}


#endif
```

<p align="center">
  <img src="https://taehyungs-programming-blog.github.io/blog/assets/images/cpp/directx/directx-19-1.png"/>
</p>

---

## Shader ë³µìŠµ

ğŸ˜º ê·¸ëŸ°ë° ìƒê°í•´ë³´ë©´ ì°¸ ì‹ ê¸°í•˜ì§€ ì•Šì€ê°€? 

```
VS_OUT VS_Main(VS_IN input)
{
    VS_OUT output = (VS_OUT)0;

    // ìš°ë¦¬ê°€ Vertex Shaderë¡œ ë„£ì€ê±´ 
    // input.pos(ì •ì ì˜ x, y, z ì¢Œí‘œ)
    // ì¢Œí‘œê³„ì˜ Matrix(g_matXXX)ì •ë„ì¸ë°
    // ì–´ë–»ê²Œ í•˜ë‚˜í•˜ë‚˜ Pixelì˜ ìƒ‰ìƒ(íŠ¹íˆ Light ì •ë³´)ë¥¼ ì…íìˆ˜ ìˆì„ê¹Œ?
    output.pos = mul(float4(input.pos, 1.f), g_matWVP);
    output.uv = input.uv;

    output.viewPos = mul(float4(input.pos, 1.f), g_matWV).xyz;
    output.viewNormal = normalize(mul(float4(input.normal, 0.f), g_matWV).xyz);

    return output;
}
```

ğŸ˜º ì¼ë‹¨ ìš°ë¦¬ê°€ ìƒê°í•˜ë˜ í•¨ìˆ˜í˜¸ì¶œ ê·œì¹™ì²˜ëŸ¼ `VS_Main` -> `PS_Main`ì´ ìˆœìœ¼ë¡œ í˜¸ì¶œë˜ëŠ”ê²Œ ì•„ë‹ˆë‹¤.

ğŸ˜º `VS_Main`ë¥¼ í†µí•´ ì •ì ì •ë³´ë¥¼ ì…ë ¥ í›„ DirectXì—ì„œ ì •ì ì˜ indexë¥¼ í†µí•´ ê° ì •ì ì˜ `PS_Main`ì„ ê³„ì‚°í•œë‹¤

```
float4 PS_Main(VS_OUT input) : SV_Target
{
    float4 color = float4(1.f, 1.f, 1.f, 1.f);

    LightColor totalColor = (LightColor)0.f;


    for (int i = 0; i < g_lightCount/* ì§€ì›í•˜ëŠ” Lightì˜ ê°œìˆ˜ */; ++i)
    {
        // CalculateLightColor(ë¹› ì •ë³´ ì—°ì‚°)ëŠ” ì•„ë˜ì— ìˆìŒ ì°¸ê³ 
         LightColor color = CalculateLightColor(i, input.viewNormal, input.viewPos);
         totalColor.diffuse += color.diffuse;
         totalColor.ambient += color.ambient;
         totalColor.specular += color.specular;
    }

    color.xyz = (totalColor.diffuse.xyz * color.xyz)
        + totalColor.ambient.xyz * color.xyz
        + totalColor.specular.xyz;

     return color;
}
```
