---
layout: default
title: "05. Descriptor Table"
parent: "(DirectX 12 ğŸŒ )"
grand_parent: C++
nav_order: 1
---

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

* [Get Code ğŸŒ](https://github.com/taehyung77/DirextX-Example/tree/5)

* Constant Bufferì˜ í•œê³„ì 
    * 64 DWORD (64 * 4 bytes = 256 bytes) ê¹Œì§€ë§Œ ì§€ì›
* ë©”ëª¨ë¦¬ ìš©ëŸ‰ì˜ ë¬¸ì œë¡œ Descriptor Tableì„ ì¨ì•¼í•œë‹¤.

### ê¸°ì¡´ Constant Bufferì˜ ë™ì‘ë°©ì‹

```cpp
void ConstantBuffer::CreateBuffer()
{
    // ***************************
    // 1. GPU Registerì— ë©”ëª¨ë¦¬ í• ë‹¹
    // ***************************
	uint32 bufferSize = _elementSize * _elementCount;
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

	DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&_cbvBuffer));

    // ***************************
    // 2. GPU RAMì— ë©”ëª¨ë¦¬ í• ë‹¹
    // ***************************
	_cbvBuffer->Map(0, nullptr, reinterpret_cast<void**>(&_mappedBuffer));
```

```cpp
void ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size)
{
	assert(_currentIndex < _elementSize);

    // ***************************
    // 3. CPU ë©”ëª¨ë¦¬ë¥¼ GPUë¡œ ë³µì‚¬
    // ***************************
	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

    // ***************************
    // 4. GPUì—ê²Œ í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•´ ë‹¬ë¼ê³  ëª…ë ¹
    // ***************************
	D3D12_GPU_VIRTUAL_ADDRESS address = GetGpuVirtualAddress(_currentIndex);
	CMD_LIST->SetGraphicsRootConstantBufferView(rootParamIndex, address);
	_currentIndex++;
}
```

---

### Descriptor Tableì˜ ë™ì‘ë°©ì‹

* ëŒ€ëµ ìˆœì„œëŠ” ì•Œê³  ê°€ì•¼í•˜ëŠ”ë°
    * CPUë©”ëª¨ë¦¬ë¥¼
    * GPU Descriptor Heapì— í• ë‹¹ í›„
    * GPU Descriptor Tableì— í• ë‹¹ í›„
    * GPU Registerì—ê²Œ ì½ì–´ê°€ ë‹¬ë¼ê³  ìš”ì²­í•œë‹¤.
* 

```cpp
void ConstantBuffer::CreateView()
{
	D3D12_DESCRIPTOR_HEAP_DESC cbvDesc = {};
	cbvDesc.NumDescriptors = _elementCount;
	cbvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	cbvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	DEVICE->CreateDescriptorHeap(&cbvDesc, IID_PPV_ARGS(&_cbvHeap));

	_cpuHandleBegin = _cbvHeap->GetCPUDescriptorHandleForHeapStart();
	_handleIncrementSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

	for (uint32 i = 0; i < _elementCount; ++i)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle = GetCpuHandle(i);

        // ***************************
        // 1. GPU Descriptor Heapí• ë‹¹
        // ***************************
		D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = {};
		cbvDesc.BufferLocation = _cbvBuffer->GetGPUVirtualAddress() + static_cast<uint64>(_elementSize) * i;
		cbvDesc.SizeInBytes = _elementSize;   // CB size is required to be 256-byte aligned.

		DEVICE->CreateConstantBufferView(&cbvDesc, cbvHandle);
	}
}
```

```cpp
void TableDescriptorHeap::Init(uint32 count)
{
	_groupCount = count;

    // ***************************
    // 2. GPU Descriptor Tableí• ë‹¹
    // ***************************
	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = count * REGISTER_COUNT;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

	DEVICE->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&_descHeap));

	_handleSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	_groupSize = _handleSize * REGISTER_COUNT;
}
```

```cpp
D3D12_CPU_DESCRIPTOR_HANDLE ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size)
{
	assert(_currentIndex < _elementSize);

    // ***************************
    // 3. CPUë©”ëª¨ë¦¬ë¥¼ Descriptor Heapì— ë³µì‚¬
    // ***************************
	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
	
	_currentIndex++;

	return cpuHandle;
}
```

```cpp
void TableDescriptorHeap::SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg)
{
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

    // ***************************
    // 4. Descriptor Heapì˜ ë©”ëª¨ë¦¬ë¥¼ Descriptor Tableë¡œ ë³µì‚¬
    // ***************************
	uint32 destRange = 1;
	uint32 srcRange = 1;
	DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}
```

```cpp
// ***************************
// 5. GPUì—ê²Œ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•´ ë‹¬ë¼ê³  ëª…ë ¹
// ***************************
void TableDescriptorHeap::CommitTable()
{
	D3D12_GPU_DESCRIPTOR_HANDLE handle = _descHeap->GetGPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	CMD_LIST->SetGraphicsRootDescriptorTable(0, handle);

	_currentGroupIndex++;
}
```

---

## Constant Bufferë¥¼ ë°°ì—´ì˜ í˜•íƒœë¡œ ì‚¬ìš©í•´ ë³´ì.

```cpp
// EnginePch.h

// ...

enum class CBV_REGISTER
{
	// ë°ì´í„°ë¥¼ ë„£ëŠ”ë° ì‚¬ìš©í•  ë ˆì§€ìŠ¤í„°
	b0,
	b1,
	b2,
	b3,
	b4,

	END // ëª‡ê°œì¸ì§€ ê°œìˆ˜ë¥¼ ë¦¬í„´ë°›ìŒ
};

enum
{
	SWAP_CHAIN_BUFFER_COUNT = 2,
	CBV_REGISTER_COUNT = CBV_REGISTER::END,
	REGISTER_COUNT = CBV_REGISTER::END,
};

// ...
```

```cpp
// 1. GPU Registersì— ì‚¬ìš©í•  ë©”ëª¨ë¦¬ í• ë‹¹

void RootSignature::Init(ComPtr<ID3D12Device> device)
{
	CD3DX12_DESCRIPTOR_RANGE ranges[] =
	{
		CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 
								CBV_REGISTER_COUNT, // 5 (b0~b4)
								0),
		 // GPUë ˆì§€ìŠ¤í„° ê³µê°„ì— b0~b4 ë¥¼ ì“¸ ì˜ˆì •

		 // CD3DX12_DESCRIPTOR_RANGEë¥¼ êµ³ì´ ë°°ì—´(ranges[])ë¡œ ë§Œë“¤ì–´ì•¼í•˜ë‚˜??
		 // ì´í›„ì— ë‹¤ë¥¸ ë ˆì§€ìŠ¤í„°ì‚¬ìš©ì‹œì— ê°„ë‹¨íˆ CD3DX12_DESCRIPTOR_RANGEë§Œ ì¶”ê°€í•´ì„œ ì‚¬ìš©í•˜ê¸° ìœ„í•¨.
         // Ex) SRVë¼ëŠ” ë ˆì§€ìŠ¤í„°ë¥¼ ì¶”ê°€í•˜ê³ ì í•œë‹¤ë©´
            // CD3DX12_DESCRIPTOR_RANGE(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 
			//					SRV_REGISTER_COUNT,
			//					0)
            // ë§Œ ì¶”ê°€í•˜ë©´ ëœë‹¤.
	};

	CD3DX12_ROOT_PARAMETER param[1];
	param[0].InitAsDescriptorTable(_countof(ranges), ranges);

	// ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„ë¼ëŠ” ê²ƒì„ ì˜ë¯¸
	D3D12_ROOT_SIGNATURE_DESC sigDesc = CD3DX12_ROOT_SIGNATURE_DESC(_countof(param), param);
	sigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	// ...
}
```

```cpp
// 2. Descriptor Heap ìƒì„±

class ConstantBuffer
{
    // ...

    // ConstantBuffer DescritionHeapì˜ ì£¼ì†Œ
        // ConstantBuffer DescritionHeap - Descriptorê°€ View(Handle)ì´ë¼ í–ˆë‹¤.
        // ì§€ê¸ˆì€ Bufferë¥¼ ë§Œë“œëŠ”ê²Œ ì•„ë‹ˆë¼ Bufferë¥¼ ì»¨íŠ¸ë¡¤í•  View(Handle)ì„ ë§Œë“œëŠ”ê³¼ì •ì„ì„ ê¸°ì–µ.
	ComPtr<ID3D12DescriptorHeap>		_cbvHeap;

    // Viewì˜ ì‹œì‘ì£¼ì†Œ
        // ì‹œì‘ì£¼ì†Œ * DescritionHeapì˜ ì‚¬ì´ì¦ˆ = ë‹¤ìŒì£¼ì†Œ ì´ëŸ°ì‹ìœ¼ë¡œ ì£¼ì†Œë¥¼ êµ¬í• ì˜ˆì •
	D3D12_CPU_DESCRIPTOR_HANDLE		_cpuHandleBegin = {};

    // DescritionHeapì˜ ì‚¬ì´ì¦ˆ
	uint32					_handleIncrementSize = 0;
```

<br>

ğŸ˜º ê¸°ì¡´ ì½”ë“œ(Constant Buffer)ì™€ ì°¨ì´ì ì€ Constant Buffer Viewë¥¼ ì§ì ‘ paramì— ë„£ëŠ”ì§€ í˜¹ì€ DescriptorTable(View Table)í˜•íƒœë¡œ ë„£ëŠ”ì§€ì˜ ì°¨ì´ë‹¤. Constant Bufferë¥¼ ë°°ì—´ì˜ í˜•íƒœë¡œ ì“°ê¸°ìœ„í•´ì„  Descritor Tableí˜•íƒœë¡œ ë„£ì–´ì•¼ í•œë‹¤.

```cpp
void ConstantBuffer::Init(uint32 size, uint32 count)
{
	// ìƒìˆ˜ ë²„í¼ëŠ” 256 ë°”ì´íŠ¸ ë°°ìˆ˜ë¡œ ë§Œë“¤ì–´ì•¼ í•œë‹¤
	// 0 256 512 768
	_elementSize = (size + 255) & ~255;
	_elementCount = count;

        // ì—¬ê¸°ì„œ ì‹œì‘.
	CreateBuffer();
	CreateView();
}

// GPUì— ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ëŠ” ë°©ë²•ì€ ê¸°ì¡´ê³¼ ë™ì¼í•˜ë©°
void ConstantBuffer::CreateBuffer()
{
	uint32 bufferSize = _elementSize * _elementCount;
	D3D12_HEAP_PROPERTIES heapProperty = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	D3D12_RESOURCE_DESC desc = CD3DX12_RESOURCE_DESC::Buffer(bufferSize);

	// ë²„í¼ë¥¼ í• ë‹¹í•´ ë‹¬ë¼.
	DEVICE->CreateCommittedResource(
		&heapProperty,
		D3D12_HEAP_FLAG_NONE,
		&desc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&_cbvBuffer));

	// ì´ ë²„í¼ë¥¼ GPUì™€ í†µì‹ í•˜ëŠ”ë° ì“¸ ê²ƒì´ë‹¤ ì„ ì–¸
	_cbvBuffer->Map(0, nullptr, reinterpret_cast<void**>(&_mappedBuffer));
	// We do not need to unmap until we are done with the resource.  However, we must not write to
	// the resource while it is in use by the GPU (so we must use synchronization techniques).
}
```

```cpp
// ì´ ViewëŠ” ìœ„ì—ì„œ í• ë‹¹í•œ Tableì„ ì»¨íŠ¸ë¡¤í•˜ê¸° ìœ„í•œ View(í•¸ë“¤)ì´ë‹¤.

void ConstantBuffer::CreateView()
{
	D3D12_DESCRIPTOR_HEAP_DESC cbvDesc = {};
	cbvDesc.NumDescriptors = _elementCount;
	cbvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	cbvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	DEVICE->CreateDescriptorHeap(&cbvDesc, IID_PPV_ARGS(&_cbvHeap));

	// Viewì˜ ì‹œì‘ì£¼ì†Œë¥¼ ê°–ê³ ìˆê³ 
	_cpuHandleBegin = _cbvHeap->GetCPUDescriptorHandleForHeapStart();

	// Viewì˜ ì£¼ì†Œ í¬ê¸°ë¥¼ ì•Œë©´ ëª¨ë“  Viewì— ì ‘ê·¼ì´ ê°€ëŠ¥(ì‹œì‘ì£¼ì†Œ + Viewì£¼ì†Œí¬ê¸° * i)
	// Viewë©´ HANDLEì¸ë° í•­ìƒ ì£¼ì†Œì˜ í¬ê¸°ëŠ” ê°™ì€ê±° ì•„ë‹˜??? 
        // -> Nope! ê·¸ë˜í”½ ì¹´ë“œì— ë”°ë¼ ì£¼ì†Œì˜ í¬ê¸°ê°€ ë‹¬ë¼ì§ˆìˆ˜ ìˆê¸°ì— êµ¬í•´ì˜¤ëŠ”ê²Œ ë§ìŒ.
	_handleIncrementSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

	for (uint32 i = 0; i < _elementCount; ++i)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE cbvHandle = GetCpuHandle(i); // (ì‹œì‘ì£¼ì†Œ + Viewì£¼ì†Œí¬ê¸° * i)

		D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc = {};
		cbvDesc.BufferLocation = _cbvBuffer->GetGPUVirtualAddress() + static_cast<uint64>(_elementSize) * i;
		cbvDesc.SizeInBytes = _elementSize;   // CB size is required to be 256-byte aligned.

		DEVICE->CreateConstantBufferView(&cbvDesc, cbvHandle);
	}
}
```

```cpp
D3D12_CPU_DESCRIPTOR_HANDLE ConstantBuffer::PushData(int32 rootParamIndex, void* buffer, uint32 size)
{
	assert(_currentIndex < _elementSize);

	::memcpy(&_mappedBuffer[_currentIndex * _elementSize], buffer, size);

	D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle = GetCpuHandle(_currentIndex);
	
	_currentIndex++;

	return cpuHandle;
}
```

<Br>

ğŸ˜º ì—¬ê¸°ê¹Œì§€í•˜ë©´ GPUì— ë©”ëª¨ë¦¬ê³µê°„ì„ í• ë‹¹í•œê±°ê¹Œì§€ëŠ” ëë‚œë‹¤. ì´ì œ í• ë‹¹ëœ GPUë©”ëª¨ë¦¬ì— ë°ì´í„°ë¥¼ ë„£ê³ , ë‹¤ì‹œ ë ˆì§€ìŠ¤í„°ë¡œ ë³´ë‚´ëŠ”ê²ƒì„ í™•ì¸í•˜ë©´ ë

---

## TableDesciptorHeap

ğŸ± ë˜ Descriptor??? ìœ„ì—ì„œ GPU Buffer Descriptor(View)ë¥¼ ë§Œë“¤ì—ˆì§€ ì•Šë‚˜?

ğŸ˜º ë§ìŒ ìœ„ì—ì„œ ë§Œë“  DescripotrHeapì€ CPUì—ì„œ ë°”ë¡œ ë³µì‚¬ê°€ ì¼ì–´ë‚˜ëŠ” Bufferì´ê³  TableDescriptorHeapì€ ë ˆì§€ìŠ¤í„°ì— ì˜¬ë¦¬ê¸° ì§ì „ì˜ Bufferì´ë‹¤. ë”°ë¼ì„œ ë©”ëª¨ë¦¬ ê³µê°„ì„ í¬ê²Œ ì¡ê³ ìˆìŒê¸°ì–µ!

```cpp
class TableDescriptorHeap
{
    // ...

private:

    // ì—­ì‹œ Descriptorê°€ í•„ìš”í•˜ê³ 
	ComPtr<ID3D12DescriptorHeap> _descHeap;

    /*
    << TableDescriptor Heap >>
    ---------<group1>--------
    |       < View1 >       |
    |       < View2 >       |
    |       < View3 >       |
    -------------------------
    ---------<group2>--------
    |       < View1 >       | 
    |       < View2 >       | 
    |       < View3 >       | 
    -------------------------
    -> ì´ëŸ°ì‹ìœ¼ë¡œ ì—¬ëŸ¬ Groupì„ êµ¬ì„±
    -> 1, 2 group ì˜¤ê°€ë©° ì‚¬ìš©í•  ì˜ˆì •

    */


    // ê° tableë¼ë¦¬ ì–¼ë§ˆë‚˜ ë–¨ì–´ì ¸ìˆëŠ”ì§€
	uint64					_handleSize = 0;

    // tableí•˜ë‚˜ì˜ ì‚¬ì´ì¦ˆ(ì‚¬ì‹¤ _handleSizeê³¼ ê°™ì€ ê°’ ì„¤ëª…ì„ ìœ„í•´ì„œ ë‚˜ëˆ”.)
	uint64					_groupSize = 0;

    // tableì´ ëª‡ê°œì¸ì§€
	uint64					_groupCount = 0;

    // í˜„ì¬ ì‚¬ìš©ì¤‘ì¸ tableì€?
	uint32					_currentGroupIndex = 0;
};
```

```cpp
void TableDescriptorHeap::Init(uint32 count)
{
        // ê·¸ë£¹ì„ ëª‡ê°œë¡œ ë§Œë“¤ê»€ê°€?
	_groupCount = count;

	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.NumDescriptors = count * REGISTER_COUNT;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE; 
        // ì´ ë¶€ë¶„ì´ ìœ„ì™€ ë‹¤ë¥¸ë°, ëŒ€ëµì ìœ¼ë¡œ ì„¤ëª…í•˜ë©´ D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLEë¥¼ 
        // í‚¤ë©´ ë¬´ì¡°ê±´ GPUë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°€ê²Œ ëœë‹¤.(MSDNì—ì„œ ì´ê±¸ ì¶”ì²œí•˜ê¸°ì— ì‹œí‚¤ëŠ”ë°ë¡œ í•˜ì)
    // D3D12_DESCRIPTOR_HEAP_FLAG_NONE - ê²½ìš°ì— ë”°ë¼ CPUë©”ëª¨ë¦¬ì— ì˜¬ë¼ê°ˆìˆ˜ ìˆìŒ.
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

	DEVICE->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&_descHeap));

	_handleSize = DEVICE->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	_groupSize = _handleSize * REGISTER_COUNT;
}
```

ğŸ˜º GPUë©”ëª¨ë¦¬ì— ë°ì´í„° ë„£ê¸°

```cpp
void TableDescriptorHeap::SetCBV(D3D12_CPU_DESCRIPTOR_HANDLE srcHandle, CBV_REGISTER reg)
{
	D3D12_CPU_DESCRIPTOR_HANDLE destHandle = GetCPUHandle(reg);

	uint32 destRange = 1;
	uint32 srcRange = 1;

    // srcHandleì— ìˆë˜ê±¸ destHandleë¡œ ë³µì‚¬í•´ ì£¼ì„¸ìš”
        // ì¢€ ë” ì •í™•íˆëŠ” Descriptor Heapì— ìˆë˜ê²ƒì„ GPU Descriptor Tableë¡œ ì˜®ê²¨ì£¼ì„¸ìš”!
	DEVICE->CopyDescriptors(1, &destHandle, &destRange, 1, &srcHandle, &srcRange, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}
```

ğŸ˜º ë ˆì§€ìŠ¤í„°ë¡œ ë°ì´í„° ë³´ë‚´ê¸°

```cpp
void TableDescriptorHeap::CommitTable()
{
	D3D12_GPU_DESCRIPTOR_HANDLE handle = _descHeap->GetGPUDescriptorHandleForHeapStart();
	handle.ptr += _currentGroupIndex * _groupSize;
	CMD_LIST->SetGraphicsRootDescriptorTable(0, handle);

	_currentGroupIndex++;
}
```

```cpp
void Mesh::Render()
{
	CMD_LIST->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	CMD_LIST->IASetVertexBuffers(0, 1, &_vertexBufferView); // Slot: (0~15)

	// TODO
	// 1) Bufferì—ë‹¤ê°€ ë°ì´í„° ì„¸íŒ…
	// 2) TableDescHeapì—ë‹¤ê°€ CBV ì „ë‹¬
	// 3) ëª¨ë‘ ì„¸íŒ…ì´ ëë‚¬ìœ¼ë©´ TableDescHeap ì»¤ë°‹
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);
	}
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b1);
	}

	GEngine->GetTableDescHeap()->CommitTable();

        /*

// CommitTableë‚´ì— _currentGroupIndex++ë¥¼ í•˜ëŠ” ë¶€ë¶„ì´ ìˆìœ¼ë‹ˆ
// CommitTable í›„ groupindexë¥¼ ì—…ë°ì´íŠ¸í•˜ë©° ë‹¤ìŒ gpu descriptor groupì„ ì‚¬ìš©í•¨ì„ 
// ì•Œìˆ˜ìˆë‹¤.

void TableDescriptorHeap::CommitTable() 
{ 
	D3D12_GPU_DESCRIPTOR_HANDLE handle = _descHeap->GetGPUDescriptorHandleForHeapStart(); 
	handle.ptr += _currentGroupIndex * _groupSize; 
	CMD_LIST->SetGraphicsRootDescriptorTable(0, handle); 
	_currentGroupIndex++; 
}

        */

	CMD_LIST->DrawInstanced(_vertexCount, 1, 0, 0);
}
```

---

## Update Game ì „ì²´ìˆœì„œ

```cpp
void Game::Update()
{
	GEngine->RenderBegin();

	shader->Update();

	{
		Transform t;
		t.offset = Vec4(0.75f, 0.f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->Render();
	}

	{
		Transform t;
		t.offset = Vec4(0.f, 0.75f, 0.f, 0.f);
		mesh->SetTransform(t);

		mesh->Render();
	}

	GEngine->RenderEnd();
}
```

```cpp
class Mesh
{
    // ...

	void SetTransform(const Transform& t) { _transform = t; }
```

```cpp
void Mesh::Render()
{
	// ...
    
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b0);
	}
	{
		D3D12_CPU_DESCRIPTOR_HANDLE handle = GEngine->GetCB()->PushData(0, &_transform, sizeof(_transform));
		GEngine->GetTableDescHeap()->SetCBV(handle, CBV_REGISTER::b1);
	}
```